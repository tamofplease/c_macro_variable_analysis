<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/operations/worker_split_shard_replication_setup_udf.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * worker_split_shard_replication_setup_udf.c
 *    This file contains functions to setup information about list of shards
 *    that are being split.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distribution_column.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_cleaner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardsplit_shared_memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardsplit_logical_replication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>


<comment type="block">/* declarations for dynamic loading */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_split_shard_replication_setup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ShardInfoHashMap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Function declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParseShardSplitInfoFromDatum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>shardSplitInfoDatum</name></decl></parameter>,
										 <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>sourceShardId</name></decl></parameter>,
										 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>partitionColumnName</name></decl></parameter>,
										 <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>childShardId</name></decl></parameter>,
										 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>minValue</name></decl></parameter>,
										 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>maxValue</name></decl></parameter>,
										 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>nodeId</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ShardSplitInfo</name> <modifier>*</modifier></type> <name>CreateShardSplitInfo</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>sourceShardIdToSplit</name></decl></parameter>,
											 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionColumnName</name></decl></parameter>,
											 <parameter><decl><type><name>uint64</name></type> <name>desSplitChildShardId</name></decl></parameter>,
											 <parameter><decl><type><name>int32</name></type> <name>minValue</name></decl></parameter>,
											 <parameter><decl><type><name>int32</name></type> <name>maxValue</name></decl></parameter>,
											 <parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddShardSplitInfoEntryForNodeInMap</name><parameter_list>(<parameter><decl><type><name>ShardSplitInfo</name> <modifier>*</modifier></type><name>shardSplitInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PopulateShardSplitInfoInSM</name><parameter_list>(<parameter><decl><type><name>ShardSplitInfoSMHeader</name> <modifier>*</modifier></type><name>shardSplitInfoSMHeader</name></decl></parameter>,
									   <parameter><decl><type><name>OperationId</name></type> <name>operationId</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReturnReplicationSlotInfo</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name></decl></parameter>,
									  <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
									  <parameter><decl><type><name>OperationId</name></type> <name>operationId</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * worker_split_shard_replication_setup UDF creates in-memory data structures
 * to store the meta information about the shard undergoing split and new split
 * children along with their placements. This info is required during the catch up
 * phase of logical replication.
 * This meta information is stored in a shared memory segment and accessed
 * by logical decoding plugin.
 *
 * Split information is given by user as an Array of custom data type 'pg_catalog.split_shard_info'.
 * (worker_split_shard_replication_setup(pg_catalog.split_shard_info[]))
 *
 * Fields of custom data type 'pg_catalog.split_shard_info':
 * source_shard_id - id of the shard that is undergoing a split
 *
 * distribution_column - Distribution column name
 *
 * child_shard_id  - id of shard that stores a specific range of values
 *                   belonging to sourceShardId(parent)
 *
 * shard_min_value - Lower bound(inclusive) of hash value which childShard stores
 *
 * shard_max_value - Upper bound(inclusive) of hash value which childShard stores
 *
 * node_id         - Node where the childShardId is located
 *
 * The function parses the data and builds routing map with key for each distinct
 * &lt;nodeId, tableOwner&gt; pair. Multiple shards can be placed on the same destination node.
 * Source and destination nodes can be same too.
 *
 * There is a 1-1 mapping between a (table owner, node) and replication slot. One replication
 * slot takes care of replicating changes for all shards belonging to the same owner on a particular node.
 *
 * During the replication phase, WAL senders will attach to the shared memory
 * populated by current UDF. It routes the tuple from the source shard to the appropriate destination
 * shard for which the respective slot is responsible.
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_split_shard_replication_setup</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"split_shard_info array cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>shardInfoArrayObject</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>array_contains_nulls</name><argument_list>(<argument><expr><name>shardInfoArrayObject</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpectedly shard info array contains a null value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>OperationId</name></type> <name>operationId</name> <init>= <expr><call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* SetupMap */</comment>
	<expr_stmt><expr><name>ShardInfoHashMap</name> <operator>=</operator> <call><name>CreateSimpleHash</name><argument_list>(<argument><expr><name>NodeAndOwner</name></expr></argument>, <argument><expr><name>GroupedShardSplitInfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>shardSplitInfoCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ArrayIterator</name></type> <name>shardInfo_iterator</name> <init>= <expr><call><name>array_create_iterator</name><argument_list>(<argument><expr><name>shardInfoArrayObject</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
															 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>shardInfoDatum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>array_iterate</name><argument_list>(<argument><expr><name>shardInfo_iterator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardInfoDatum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>sourceShardId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionColumnName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>childShardId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>minValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>maxValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>nodeId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ParseShardSplitInfoFromDatum</name><argument_list>(<argument><expr><name>shardInfoDatum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sourceShardId</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>partitionColumnName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>childShardId</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>minValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ShardSplitInfo</name> <modifier>*</modifier></type><name>shardSplitInfo</name> <init>= <expr><call><name>CreateShardSplitInfo</name><argument_list>(
			<argument><expr><name>sourceShardId</name></expr></argument>,
			<argument><expr><name>partitionColumnName</name></expr></argument>,
			<argument><expr><name>childShardId</name></expr></argument>,
			<argument><expr><name>minValue</name></expr></argument>,
			<argument><expr><name>maxValue</name></expr></argument>,
			<argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AddShardSplitInfoEntryForNodeInMap</name><argument_list>(<argument><expr><name>shardSplitInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>shardSplitInfoCount</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<decl_stmt><decl><type><name>dsm_handle</name></type> <name>dsmHandle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardSplitInfoSMHeader</name> <modifier>*</modifier></type><name>splitShardInfoSMHeader</name> <init>=
		<expr><call><name>CreateSharedMemoryForShardSplitInfo</name><argument_list>(<argument><expr><name>shardSplitInfoCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dsmHandle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PopulateShardSplitInfoInSM</name><argument_list>(<argument><expr><name>splitShardInfoSMHeader</name></expr></argument>, <argument><expr><name>operationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* store handle in statically allocated shared memory*/</comment>
	<expr_stmt><expr><call><name>StoreShardSplitSharedMemoryHandle</name><argument_list>(<argument><expr><name>dsmHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReturnReplicationSlotInfo</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>operationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateShardSplitInfo function constructs ShardSplitInfo data structure
 * with appropriate OIs' for source and destination relation.
 *
 * sourceShardIdToSplit - Existing shardId which has a valid entry in cache and catalogue
 * partitionColumnName  - Name of column to use for partitioning
 * desSplitChildShardId - New split child shard which doesn't have an entry in metacache yet
 * minValue				- Minimum hash value for desSplitChildShardId
 * maxValue				- Maximum hash value for desSplitChildShardId
 * nodeId				- NodeId where
 * However we can use shard ID and construct qualified shardName.
 */</comment>
<function><type><name>ShardSplitInfo</name> <modifier>*</modifier></type>
<name>CreateShardSplitInfo</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>sourceShardIdToSplit</name></decl></parameter>,
					 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionColumnName</name></decl></parameter>,
					 <parameter><decl><type><name>uint64</name></type> <name>desSplitChildShardId</name></decl></parameter>,
					 <parameter><decl><type><name>int32</name></type> <name>minValue</name></decl></parameter>,
					 <parameter><decl><type><name>int32</name></type> <name>maxValue</name></decl></parameter>,
					 <parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardIntervalToSplit</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>sourceShardIdToSplit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If metadata is not synced, we cannot proceed further as split work flow assumes
	 * metadata to be synced on worker node hosting source shard to split.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shardIntervalToSplit</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><call><name>errmsg</name><argument_list>(
					<argument><expr><literal type="string">"Could not find metadata corresponding to source shard id: %ld. "</literal>
					<literal type="string">"Split workflow assumes metadata to be synced across "</literal>
					<literal type="string">"worker nodes hosting source shards."</literal></expr></argument>, <argument><expr><name>sourceShardIdToSplit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Oid of distributed table */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTableOid</name> <init>= <expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sourceShardToSplitOid</name> <init>= <expr><call><name>GetTableLocalShardOid</name><argument_list>(<argument><expr><name>citusTableOid</name></expr></argument>,
													  <argument><expr><name>sourceShardIdToSplit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Oid of dummy table at the source */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>destSplitChildShardOid</name> <init>= <expr><call><name>GetTableLocalShardOid</name><argument_list>(<argument><expr><name>citusTableOid</name></expr></argument>,
													   <argument><expr><name>desSplitChildShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>citusTableOid</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator>
		<name>sourceShardToSplitOid</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator>
		<name>destSplitChildShardOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid citusTableOid:%u, "</literal>
							   <literal type="string">"sourceShardToSplitOid:%u, "</literal>
							   <literal type="string">"destSplitChildShardOid:%u "</literal></expr></argument>,
							   <argument><expr><name>citusTableOid</name></expr></argument>,
							   <argument><expr><name>sourceShardToSplitOid</name></expr></argument>,
							   <argument><expr><name>destSplitChildShardOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* determine the partition column in the tuple descriptor */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>BuildDistributionKeyFromColumnName</name><argument_list>(<argument><expr><name>sourceShardToSplitOid</name></expr></argument>,
															  <argument><expr><name>partitionColumnName</name></expr></argument>,
															  <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>partitionColumn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid Partition Column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>partitionColumnIndex</name> <init>= <expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardSplitInfo</name> <modifier>*</modifier></type><name>shardSplitInfo</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardSplitInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>shardSplitInfo</name><operator>-&gt;</operator><name>distributedTableOid</name></name> <operator>=</operator> <name>citusTableOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardSplitInfo</name><operator>-&gt;</operator><name>partitionColumnIndex</name></name> <operator>=</operator> <name>partitionColumnIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardSplitInfo</name><operator>-&gt;</operator><name>sourceShardOid</name></name> <operator>=</operator> <name>sourceShardToSplitOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardSplitInfo</name><operator>-&gt;</operator><name>splitChildShardOid</name></name> <operator>=</operator> <name>destSplitChildShardOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardSplitInfo</name><operator>-&gt;</operator><name>shardMinValue</name></name> <operator>=</operator> <name>minValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardSplitInfo</name><operator>-&gt;</operator><name>shardMaxValue</name></name> <operator>=</operator> <name>maxValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardSplitInfo</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>=</operator> <name>nodeId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardSplitInfo</name><operator>-&gt;</operator><name>sourceShardId</name></name> <operator>=</operator> <name>sourceShardIdToSplit</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardSplitInfo</name><operator>-&gt;</operator><name>splitChildShardId</name></name> <operator>=</operator> <name>desSplitChildShardId</name></expr>;</expr_stmt>

	<return>return <expr><name>shardSplitInfo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddShardSplitInfoEntryForNodeInMap function add's ShardSplitInfo entry
 * to the hash map. The key is nodeId on which the new shard is to be placed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddShardSplitInfoEntryForNodeInMap</name><parameter_list>(<parameter><decl><type><name>ShardSplitInfo</name> <modifier>*</modifier></type><name>shardSplitInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeAndOwner</name></type> <name>key</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>nodeId</name></name> <operator>=</operator> <name><name>shardSplitInfo</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>tableOwnerId</name></name> <operator>=</operator> <call><name>TableOwnerOid</name><argument_list>(<argument><expr><name><name>shardSplitInfo</name><operator>-&gt;</operator><name>distributedTableOid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupedShardSplitInfos</name> <modifier>*</modifier></type><name>groupedInfos</name> <init>=
		<expr><operator>(</operator><name>GroupedShardSplitInfos</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ShardInfoHashMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>groupedInfos</name><operator>-&gt;</operator><name>shardSplitInfoList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>groupedInfos</name><operator>-&gt;</operator><name>shardSplitInfoList</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>groupedInfos</name><operator>-&gt;</operator><name>shardSplitInfoList</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ShardSplitInfo</name> <operator>*</operator><operator>)</operator> <name>shardSplitInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PopulateShardSplitInfoInSM function copies information from the hash map
 * into shared memory segment. This information is consumed by the WAL sender
 * process during logical replication.
 *
 * shardSplitInfoSMHeader - Shared memory header
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PopulateShardSplitInfoInSM</name><parameter_list>(<parameter><decl><type><name>ShardSplitInfoSMHeader</name> <modifier>*</modifier></type><name>shardSplitInfoSMHeader</name></decl></parameter>,
						   <parameter><decl><type><name>OperationId</name></type> <name>operationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>ShardInfoHashMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GroupedShardSplitInfos</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>splitInfoIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>GroupedShardSplitInfos</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>nodeId</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nodeId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>tableOwnerId</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>tableOwnerId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>derivedSlotName</name> <init>=
			<expr><call><name>ReplicationSlotNameForNodeAndOwnerForOperation</name><argument_list>(<argument><expr><name>SHARD_SPLIT</name></expr></argument>,
														   <argument><expr><name>nodeId</name></expr></argument>,
														   <argument><expr><name>tableOwnerId</name></expr></argument>,
														   <argument><expr><name>operationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardSplitInfoList</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>shardSplitInfoList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardSplitInfo</name> <modifier>*</modifier></type><name>splitShardInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>splitShardInfo</argument>, <argument>shardSplitInfoList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>shardSplitInfoSMHeader</name><operator>-&gt;</operator><name>splitInfoArray</name><index>[<expr><name>splitInfoIndex</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>splitShardInfo</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy_s</name><argument_list>(<argument><expr><name><name>shardSplitInfoSMHeader</name><operator>-&gt;</operator><name>splitInfoArray</name><index>[<expr><name>splitInfoIndex</name></expr>]</index></name><operator>.</operator><name>slotName</name></expr></argument>,
					 <argument><expr><name>NAMEDATALEN</name></expr></argument>,
					 <argument><expr><name>derivedSlotName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>splitInfoIndex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * ParseShardSplitInfoFromDatum deserializes individual fields of 'pg_catalog.split_shard_info'
 * datatype.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseShardSplitInfoFromDatum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>shardSplitInfoDatum</name></decl></parameter>,
							 <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>sourceShardId</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>partitionColumnName</name></decl></parameter>,
							 <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>childShardId</name></decl></parameter>,
							 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>minValue</name></decl></parameter>,
							 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>maxValue</name></decl></parameter>,
							 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>nodeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>dataTuple</name> <init>= <expr><call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>shardSplitInfoDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>sourceShardIdDatum</name> <init>= <expr><call><name>GetAttributeByName</name><argument_list>(<argument><expr><name>dataTuple</name></expr></argument>, <argument><expr><literal type="string">"source_shard_id"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"source_shard_id for split_shard_info can't be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>sourceShardId</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>sourceShardIdDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>partitionColumnDatum</name> <init>= <expr><call><name>GetAttributeByName</name><argument_list>(<argument><expr><name>dataTuple</name></expr></argument>, <argument><expr><literal type="string">"distribution_column"</literal></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"distribution_column for split_shard_info can't be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>partitionColumnName</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>partitionColumnDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>childShardIdDatum</name> <init>= <expr><call><name>GetAttributeByName</name><argument_list>(<argument><expr><name>dataTuple</name></expr></argument>, <argument><expr><literal type="string">"child_shard_id"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"child_shard_id for split_shard_info can't be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>childShardId</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name>childShardIdDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>minValueDatum</name> <init>= <expr><call><name>GetAttributeByName</name><argument_list>(<argument><expr><name>dataTuple</name></expr></argument>, <argument><expr><literal type="string">"shard_min_value"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard_min_value for split_shard_info can't be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardMinValueString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>minValueDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>minValue</name> <operator>=</operator> <call><name>SafeStringToInt32</name><argument_list>(<argument><expr><name>shardMinValueString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>maxValueDatum</name> <init>= <expr><call><name>GetAttributeByName</name><argument_list>(<argument><expr><name>dataTuple</name></expr></argument>, <argument><expr><literal type="string">"shard_max_value"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard_max_value for split_shard_info can't be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardMaxValueString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name>maxValueDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>maxValue</name> <operator>=</operator> <call><name>SafeStringToInt32</name><argument_list>(<argument><expr><name>shardMaxValueString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>nodeIdDatum</name> <init>= <expr><call><name>GetAttributeByName</name><argument_list>(<argument><expr><name>dataTuple</name></expr></argument>, <argument><expr><literal type="string">"node_id"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node_id for split_shard_info can't be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>nodeId</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>nodeIdDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReturnReplicationSlotInfo writes 'pg_catalog.replication_slot_info'
 * records to tuplestore.
 * This information is used by the coordinator to create replication slots as a
 * part of non-blocking split workflow.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReturnReplicationSlotInfo</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name></decl></parameter>,
						  <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
						  <parameter><decl><type><name>OperationId</name></type> <name>operationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>ShardInfoHashMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GroupedShardSplitInfos</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>GroupedShardSplitInfos</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwnerName</name> <init>= <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>tableOwnerId</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>tableOwnerName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>slotName</name> <init>=
			<expr><call><name>ReplicationSlotNameForNodeAndOwnerForOperation</name><argument_list>(<argument><expr><name>SHARD_SPLIT</name></expr></argument>,
														   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nodeId</name></name></expr></argument>,
														   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>tableOwnerId</name></name></expr></argument>,
														   <argument><expr><name>operationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>slotName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
</unit>
