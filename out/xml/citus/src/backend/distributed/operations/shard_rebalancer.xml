<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/operations/shard_rebalancer.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * shard_rebalancer.c
 *
 * Function definitions for the shard rebalancer tool.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/argutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/background_jobs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/enterprise.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/lock_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_replication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_rebalance_strategy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_rebalancer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_cleaner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_transfer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/array_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>

<comment type="block">/* RebalanceOptions are the options used to control the rebalance algorithm */</comment>
<typedef>typedef <type><struct>struct <name>RebalanceOptions</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type> <name>threshold</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>maxShardMoves</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>excludedShardArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>drainOnly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type> <name>improvementThreshold</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_dist_rebalance_strategy</name></type> <name>rebalanceStrategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operationName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl>;</decl_stmt>
}</block></struct></type> <name>RebalanceOptions</name>;</typedef>


<comment type="block">/*
 * RebalanceState is used to keep the internal state of the rebalance
 * algorithm in one place.
 */</comment>
<typedef>typedef <type><struct>struct <name>RebalanceState</name>
<block>{
	<comment type="block">/*
	 * placementsHash contains the current state of all shard placements, it
	 * is initialized from pg_dist_placement and is then modified based on the
	 * found shard moves.
	 */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>placementsHash</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * placementUpdateList contains all of the updates that have been done to
	 * reach the current state of placementsHash.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RebalancePlanFunctions</name> <modifier>*</modifier></type><name>functions</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * fillStateListDesc contains all NodeFillStates ordered from full nodes to
	 * empty nodes.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fillStateListDesc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * fillStateListAsc contains all NodeFillStates ordered from empty nodes to
	 * full nodes.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fillStateListAsc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * disallowedPlacementList contains all placements that currently exist,
	 * but are not allowed according to the shardAllowedOnNode function.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>disallowedPlacementList</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * totalCost is the cost of all the shards in the cluster added together.
	 */</comment>
	<decl_stmt><decl><type><name>float4</name></type> <name>totalCost</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * totalCapacity is the capacity of all the nodes in the cluster added
	 * together.
	 */</comment>
	<decl_stmt><decl><type><name>float4</name></type> <name>totalCapacity</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * ignoredMoves is the number of moves that were ignored. This is used to
	 * limit the amount of loglines we send.
	 */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>ignoredMoves</name></decl>;</decl_stmt>
}</block></struct></type> <name>RebalanceState</name>;</typedef>


<comment type="block">/* RebalanceContext stores the context for the function callbacks */</comment>
<typedef>typedef <type><struct>struct <name>RebalanceContext</name>
<block>{
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>shardCostUDF</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>nodeCapacityUDF</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>shardAllowedOnNodeUDF</name></decl>;</decl_stmt>
}</block></struct></type> <name>RebalanceContext</name>;</typedef>

<comment type="block">/* WorkerHashKey contains hostname and port to be used as a key in a hash */</comment>
<typedef>typedef <type><struct>struct <name>WorkerHashKey</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>hostname</name><index>[<expr><name>MAX_NODE_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>;</decl_stmt>
}</block></struct></type> <name>WorkerHashKey</name>;</typedef>

<comment type="block">/* WorkerShardIds represents a set of shardIds grouped by worker */</comment>
<typedef>typedef <type><struct>struct <name>WorkerShardIds</name>
<block>{
	<decl_stmt><decl><type><name>WorkerHashKey</name></type> <name>worker</name></decl>;</decl_stmt>

	<comment type="block">/* This is a uint64 hashset representing the shard ids for a specific worker */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardIds</name></decl>;</decl_stmt>
}</block></struct></type> <name>WorkerShardIds</name>;</typedef>

<comment type="block">/* ShardStatistics contains statistics about a shard */</comment>
<typedef>typedef <type><struct>struct <name>ShardStatistics</name>
<block>{
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name></decl>;</decl_stmt>

	<comment type="block">/* The shard its size in bytes. */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>totalSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>shardLSN</name></decl>;</decl_stmt>
}</block></struct></type> <name>ShardStatistics</name>;</typedef>

<comment type="block">/*
 * WorkerShardStatistics represents a set of statistics about shards,
 * grouped by worker.
 */</comment>
<typedef>typedef <type><struct>struct <name>WorkerShardStatistics</name>
<block>{
	<decl_stmt><decl><type><name>WorkerHashKey</name></type> <name>worker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>workerLSN</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Statistics for each shard on this worker:
	 * key: shardId
	 * value: ShardStatistics
	 */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>statistics</name></decl>;</decl_stmt>
}</block></struct></type> <name>WorkerShardStatistics</name>;</typedef>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>VariablesToBePassedToNewConnections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* static declarations for main logic */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ShardActivePlacementCount</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>activePlacementsHash</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWorkerNodeList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateShardPlacement</name><parameter_list>(<parameter><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>placementUpdateEvent</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>responsiveNodeList</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* static declarations for main logic's utility functions */</comment>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>ShardPlacementsListToHash</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>PlacementsHashFind</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>placementsHash</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
							   <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlacementsHashEnter</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>placementsHash</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
								<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlacementsHashRemove</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>placementsHash</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
								 <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>PlacementsHashCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>lhsKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rhsKey</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keySize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>PlacementsHashHashCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keySize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>WorkerNodeListContains</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>workerName</name></decl></parameter>,
								   <parameter><decl><type><name>uint32</name></type> <name>workerPort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateColocatedShardPlacementProgress</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceName</name></decl></parameter>,
												  <parameter><decl><type><name>int</name></type> <name>sourcePort</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>progress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NodeFillState</name> <modifier>*</modifier></type> <name>FindFillStateForPlacement</name><parameter_list>(<parameter><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
												 <parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RebalanceState</name> <modifier>*</modifier></type> <name>InitRebalanceState</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name></decl></parameter>,
										   <parameter><decl><type><name>RebalancePlanFunctions</name> <modifier>*</modifier></type><name>functions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MoveShardsAwayFromDisallowedNodes</name><parameter_list>(<parameter><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FindAndMoveShardCost</name><parameter_list>(<parameter><decl><type><name>float4</name></type> <name>utilizationLowerBound</name></decl></parameter>,
								 <parameter><decl><type><name>float4</name></type> <name>utilizationUpperBound</name></decl></parameter>,
								 <parameter><decl><type><name>float4</name></type> <name>improvementThreshold</name></decl></parameter>,
								 <parameter><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NodeFillState</name> <modifier>*</modifier></type> <name>FindAllowedTargetFillState</name><parameter_list>(<parameter><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MoveShardCost</name><parameter_list>(<parameter><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>sourceFillState</name></decl></parameter>, <parameter><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>targetFillState</name></decl></parameter>,
						  <parameter><decl><type><name>ShardCost</name> <modifier>*</modifier></type><name>shardCost</name></decl></parameter>, <parameter><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareNodeFillStateAsc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareNodeFillStateDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareShardCostAsc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareShardCostDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareDisallowedPlacementAsc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareDisallowedPlacementDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShardAllowedOnNode</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float4</name></type> <name>NodeCapacity</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ShardCost</name></type> <name>GetShardCost</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>NonColocatedDistRelationIdList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RebalanceTableShards</name><parameter_list>(<parameter><decl><type><name>RebalanceOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>RebalanceTableShardsBackground</name><parameter_list>(<parameter><decl><type><name>RebalanceOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
											<name>shardReplicationModeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AcquireRebalanceColocationLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operationName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecutePlacementUpdates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
									<name>shardReplicationModeOid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>noticeOperation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float4</name></type> <name>CalculateUtilization</name><parameter_list>(<parameter><decl><type><name>float4</name></type> <name>totalCost</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>capacity</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Form_pg_dist_rebalance_strategy</name></type> <name>GetRebalanceStrategy</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureShardCostUDF</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureNodeCapacityUDF</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureShardAllowedOnNodeUDF</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>BuildWorkerShardStatisticsHash</name><parameter_list>(<parameter><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>steps</name></decl></parameter>,
											 <parameter><decl><type><name>int</name></type> <name>stepCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>GetShardStatistics</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardIds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>GetMovedShardIdsByWorker</name><parameter_list>(<parameter><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>steps</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>stepCount</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fromSource</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>WorkerShardSize</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerShardStatistics</name></decl></parameter>,
							  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workerName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workerPort</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>WorkerShardLSN</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerShardStatisticsHash</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workerName</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>workerPort</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>WorkerLSN</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerShardStatisticsHash</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workerName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workerPort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddToWorkerShardIdSet</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardsByWorker</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workerName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workerPort</name></decl></parameter>,
								  <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>BuildShardSizesHash</name><parameter_list>(<parameter><decl><type><name>ProgressMonitorData</name> <modifier>*</modifier></type><name>monitor</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardStatistics</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorOnConcurrentRebalance</name><parameter_list>(<parameter><decl><type><name>RebalanceOptions</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetSetCommandListForNewConnections</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* declarations for dynamic loading */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>rebalance_table_shards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>replicate_table_shards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>get_rebalance_table_shards_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>get_rebalance_progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_drain_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_drain_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_shard_cost_by_disk_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_validate_rebalance_strategy_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>pg_dist_rebalance_strategy_enterprise_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_rebalance_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_rebalance_stop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_rebalance_wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>RunningUnderIsolationTest</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>MaxRebalancerLoggedIgnoredMoves</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PropagateSessionSettingsForLoopbackConnection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>PlacementUpdateTypeNames</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>PLACEMENT_UPDATE_INVALID_FIRST</name></expr>]</index> <operator>=</operator> <literal type="string">"unknown"</literal></expr>,
	<expr><index>[<expr><name>PLACEMENT_UPDATE_MOVE</name></expr>]</index> <operator>=</operator> <literal type="string">"move"</literal></expr>,
	<expr><index>[<expr><name>PLACEMENT_UPDATE_COPY</name></expr>]</index> <operator>=</operator> <literal type="string">"copy"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>PlacementUpdateStatusNames</name><index>[]</index></name> <init>= <expr><block>{
	<expr><index>[<expr><name>PLACEMENT_UPDATE_STATUS_NOT_STARTED_YET</name></expr>]</index> <operator>=</operator> <literal type="string">"Not Started Yet"</literal></expr>,
	<expr><index>[<expr><name>PLACEMENT_UPDATE_STATUS_SETTING_UP</name></expr>]</index> <operator>=</operator> <literal type="string">"Setting Up"</literal></expr>,
	<expr><index>[<expr><name>PLACEMENT_UPDATE_STATUS_COPYING_DATA</name></expr>]</index> <operator>=</operator> <literal type="string">"Copying Data"</literal></expr>,
	<expr><index>[<expr><name>PLACEMENT_UPDATE_STATUS_CATCHING_UP</name></expr>]</index> <operator>=</operator> <literal type="string">"Catching Up"</literal></expr>,
	<expr><index>[<expr><name>PLACEMENT_UPDATE_STATUS_CREATING_CONSTRAINTS</name></expr>]</index> <operator>=</operator> <literal type="string">"Creating Constraints"</literal></expr>,
	<expr><index>[<expr><name>PLACEMENT_UPDATE_STATUS_FINAL_CATCH_UP</name></expr>]</index> <operator>=</operator> <literal type="string">"Final Catchup"</literal></expr>,
	<expr><index>[<expr><name>PLACEMENT_UPDATE_STATUS_CREATING_FOREIGN_KEYS</name></expr>]</index> <operator>=</operator> <literal type="string">"Creating Foreign Keys"</literal></expr>,
	<expr><index>[<expr><name>PLACEMENT_UPDATE_STATUS_COMPLETING</name></expr>]</index> <operator>=</operator> <literal type="string">"Completing"</literal></expr>,
	<expr><index>[<expr><name>PLACEMENT_UPDATE_STATUS_COMPLETED</name></expr>]</index> <operator>=</operator> <literal type="string">"Completed"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>

<comment type="block">/*
 * Check that all the invariants of the state hold.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckRebalanceStateInvariants</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>fillState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>prevFillState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fillStateIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fillStateLength</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListAsc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListAsc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>fillState</argument>, <argument>state-&gt;fillStateListAsc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>float4</name></type> <name>totalCost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardCost</name> <modifier>*</modifier></type><name>shardCost</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardCost</name> <modifier>*</modifier></type><name>prevShardCost</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>prevFillState</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Check that the previous fill state is more empty than this one */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>higherUtilization</name> <init>= <expr><name><name>fillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>&gt;</operator> <name><name>prevFillState</name><operator>-&gt;</operator><name>utilization</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>sameUtilization</name> <init>= <expr><name><name>fillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>==</operator> <name><name>prevFillState</name><operator>-&gt;</operator><name>utilization</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>lowerOrSameCapacity</name> <init>= <expr><name><name>fillState</name><operator>-&gt;</operator><name>capacity</name></name> <operator>&lt;=</operator> <name><name>prevFillState</name><operator>-&gt;</operator><name>capacity</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>higherUtilization</name> <operator>||</operator> <operator>(</operator><name>sameUtilization</name> <operator>&amp;&amp;</operator> <name>lowerOrSameCapacity</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check that fillStateListDesc is the reversed version of fillStateListAsc */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListDesc</name></name></expr></argument>, <argument><expr><name>fillStateLength</name> <operator>-</operator> <name>fillStateIndex</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator>
			   <name>fillState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<macro><name>foreach_ptr</name><argument_list>(<argument>shardCost</argument>, <argument>fillState-&gt;shardCostListDesc</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>prevShardCost</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Check that shard costs are sorted in descending order */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shardCost</name><operator>-&gt;</operator><name>cost</name></name> <operator>&lt;=</operator> <name><name>prevShardCost</name><operator>-&gt;</operator><name>cost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>totalCost</name> <operator>+=</operator> <name><name>shardCost</name><operator>-&gt;</operator><name>cost</name></name></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Check that utilization field is up to date. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>==</operator> <call><name>CalculateUtilization</name><argument_list>(<argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>totalCost</name></name></expr></argument>,
															  <argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* lgtm[cpp/equality-on-floats] */</comment>

		<comment type="block">/*
		 * Check that fillState-&gt;totalCost is within 0.1% difference of
		 * sum(fillState-&gt;shardCostListDesc-&gt;cost)
		 * We cannot compare exactly, because these numbers are floats and
		 * fillState-&gt;totalCost is modified by doing + and - on it. So instead
		 * we check that the numbers are roughly the same.
		 */</comment>
		<decl_stmt><decl><type><name>float4</name></type> <name>absoluteDifferenceBetweenTotalCosts</name> <init>=
			<expr><call><name>fabsf</name><argument_list>(<argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>totalCost</name></name> <operator>-</operator> <name>totalCost</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float4</name></type> <name>maximumAbsoluteValueOfTotalCosts</name> <init>=
			<expr><call><name>fmaxf</name><argument_list>(<argument><expr><call><name>fabsf</name><argument_list>(<argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>totalCost</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>fabsf</name><argument_list>(<argument><expr><name>totalCost</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>absoluteDifferenceBetweenTotalCosts</name> <operator>&lt;=</operator> <name>maximumAbsoluteValueOfTotalCosts</name> <operator>/</operator>
			   <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>prevFillState</name> <operator>=</operator> <name>fillState</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fillStateIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CheckRebalanceStateInvariants</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                          <comment type="block">/* USE_ASSERT_CHECKING */</comment>

<comment type="block">/*
 * BigIntArrayDatumContains checks if the array contains the given number.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>BigIntArrayDatumContains</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arrayLength</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>toFind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arrayLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>toFind</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FullShardPlacementList returns a List containing all the shard placements of
 * a specific table (excluding the excludedShardArray)
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FullShardPlacementList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>excludedShardArray</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>citusTableCacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIntervalArrayLength</name> <init>= <expr><name><name>citusTableCacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>excludedShardIdCount</name> <init>= <expr><call><name>ArrayObjectCount</name><argument_list>(<argument><expr><name>excludedShardArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>excludedShardArrayDatum</name> <init>= <expr><call><name>DeconstructArrayObject</name><argument_list>(<argument><expr><name>excludedShardArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name>shardIntervalArrayLength</name></expr>;</condition> <incr><expr><name>shardIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>=
			<expr><name><name>citusTableCacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>placementArray</name> <init>=
			<expr><name><name>citusTableCacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrays</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>numberOfPlacements</name> <init>=
			<expr><name><name>citusTableCacheEntry</name><operator>-&gt;</operator><name>arrayOfPlacementArrayLengths</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>BigIntArrayDatumContains</name><argument_list>(<argument><expr><name>excludedShardArrayDatum</name></expr></argument>, <argument><expr><name>excludedShardIdCount</name></expr></argument>,
									 <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>placementIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>placementIndex</name> <operator>&lt;</operator> <name>numberOfPlacements</name></expr>;</condition>
			 <incr><expr><name>placementIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupShardPlacement</name> <modifier>*</modifier></type><name>groupPlacement</name> <init>= <expr><operator>&amp;</operator><name><name>placementArray</name><index>[<expr><name>placementIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><call><name>LookupNodeForGroup</name><argument_list>(<argument><expr><name><name>groupPlacement</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>groupPlacement</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>shardLength</name></name> <operator>=</operator> <name><name>groupPlacement</name><operator>-&gt;</operator><name>shardLength</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>shardState</name></name> <operator>=</operator> <name><name>groupPlacement</name><operator>-&gt;</operator><name>shardState</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>=</operator> <name><name>worker</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>nodeName</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>nodePort</name></name> <operator>=</operator> <name><name>worker</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name> <operator>=</operator> <name><name>groupPlacement</name><operator>-&gt;</operator><name>placementId</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>shardPlacementList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>, <argument><expr><name>placement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<return>return <expr><call><name>SortList</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>, <argument><expr><name>CompareShardPlacements</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SortedActiveWorkers returns all the active workers like
 * ActiveReadableNodeList, but sorted.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>SortedActiveWorkers</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWorkerList</name> <init>= <expr><call><name>ActiveReadableNodeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>SortList</name><argument_list>(<argument><expr><name>activeWorkerList</name></expr></argument>, <argument><expr><name>CompareWorkerNodes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRebalanceSteps returns a List of PlacementUpdateEvents that are needed to
 * rebalance a list of tables.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRebalanceSteps</name><parameter_list>(<parameter><decl><type><name>RebalanceOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnsureShardCostUDF</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>rebalanceStrategy</name><operator>-&gt;</operator><name>shardCostFunction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureNodeCapacityUDF</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>rebalanceStrategy</name><operator>-&gt;</operator><name>nodeCapacityFunction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureShardAllowedOnNodeUDF</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>rebalanceStrategy</name><operator>-&gt;</operator><name>shardAllowedOnNodeFunction</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RebalanceContext</name></type> <name>context</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RebalanceContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>rebalanceStrategy</name><operator>-&gt;</operator><name>shardCostFunction</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>shardCostUDF</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>rebalanceStrategy</name><operator>-&gt;</operator><name>nodeCapacityFunction</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>nodeCapacityUDF</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>rebalanceStrategy</name><operator>-&gt;</operator><name>shardAllowedOnNodeFunction</name></name></expr></argument>,
			  <argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>shardAllowedOnNodeUDF</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RebalancePlanFunctions</name></type> <name>rebalancePlanFunctions</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>shardAllowedOnNode</name> <operator>=</operator> <name>ShardAllowedOnNode</name></expr>,
		<expr><operator>.</operator><name>nodeCapacity</name> <operator>=</operator> <name>NodeCapacity</name></expr>,
		<expr><operator>.</operator><name>shardCost</name> <operator>=</operator> <name>GetShardCost</name></expr>,
		<expr><operator>.</operator><name>context</name> <operator>=</operator> <operator>&amp;</operator><name>context</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* sort the lists to make the function more deterministic */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWorkerList</name> <init>= <expr><call><name>SortedActiveWorkers</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeShardPlacementListList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>options-&gt;relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>FullShardPlacementList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
														  <argument><expr><name><name>options</name><operator>-&gt;</operator><name>excludedShardArray</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeShardPlacementListForRelation</name> <init>=
			<expr><call><name>FilterShardPlacementList</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>, <argument><expr><name>IsActiveShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>workerNode</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>activeShardPlacementListForRelation</name> <operator>=</operator> <call><name>FilterActiveShardPlacementListByNode</name><argument_list>(
				<argument><expr><name>shardPlacementList</name></expr></argument>, <argument><expr><name><name>options</name><operator>-&gt;</operator><name>workerNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>activeShardPlacementListList</name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name>activeShardPlacementListList</name></expr></argument>, <argument><expr><name>activeShardPlacementListForRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>threshold</name></name> <operator>&lt;</operator> <name><name>options</name><operator>-&gt;</operator><name>rebalanceStrategy</name><operator>-&gt;</operator><name>minimumThreshold</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							  <argument><expr><literal type="string">"the given threshold is lower than the minimum "</literal>
							  <literal type="string">"threshold allowed by the rebalance strategy, "</literal>
							  <literal type="string">"using the minimum allowed threshold instead"</literal></expr></argument>
							  )</argument_list></call><operator>,</operator>
						  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Using threshold of %.2f"</literal></expr></argument>,
									<argument><expr><name><name>options</name><operator>-&gt;</operator><name>rebalanceStrategy</name><operator>-&gt;</operator><name>minimumThreshold</name></name></expr></argument>
									)</argument_list></call>
						  <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>threshold</name></name> <operator>=</operator> <name><name>options</name><operator>-&gt;</operator><name>rebalanceStrategy</name><operator>-&gt;</operator><name>minimumThreshold</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>RebalancePlacementUpdates</name><argument_list>(<argument><expr><name>activeWorkerList</name></expr></argument>,
									 <argument><expr><name>activeShardPlacementListList</name></expr></argument>,
									 <argument><expr><name><name>options</name><operator>-&gt;</operator><name>threshold</name></name></expr></argument>,
									 <argument><expr><name><name>options</name><operator>-&gt;</operator><name>maxShardMoves</name></name></expr></argument>,
									 <argument><expr><name><name>options</name><operator>-&gt;</operator><name>drainOnly</name></name></expr></argument>,
									 <argument><expr><name><name>options</name><operator>-&gt;</operator><name>improvementThreshold</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>rebalancePlanFunctions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardAllowedOnNode determines if shard is allowed on a specific worker node.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShardAllowedOnNode</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>voidContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>shouldHaveShards</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RebalanceContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><name>voidContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>allowed</name> <init>= <expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>shardAllowedOnNodeUDF</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
								  <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>allowed</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeCapacity returns the relative capacity of a node. A node with capacity 2
 * can contain twice as many shards as a node with capacity 1. The actual
 * capacity can be a number grounded in reality, like the disk size, number of
 * cores, but it doesn't have to be.
 */</comment>
<function><type><specifier>static</specifier> <name>float4</name></type>
<name>NodeCapacity</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>voidContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>shouldHaveShards</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RebalanceContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><name>voidContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>capacity</name> <init>= <expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>nodeCapacityUDF</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>capacity</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetShardCost returns the cost of the given shard. A shard with cost 2 will
 * be weighted as heavily as two shards with cost 1. This cost number can be a
 * number grounded in reality, like the shard size on disk, but it doesn't have
 * to be.
 */</comment>
<function><type><specifier>static</specifier> <name>ShardCost</name></type>
<name>GetShardCost</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>voidContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardCost</name></type> <name>shardCost</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>shardCost</name><operator>.</operator><name>shardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>RebalanceContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><name>voidContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>shardCostDatum</name> <init>= <expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>shardCostUDF</name></name></expr></argument>, <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>shardCost</name><operator>.</operator><name>cost</name></name> <operator>=</operator> <call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>shardCostDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>shardCost</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_shard_cost_by_disk_size gets the cost for a shard based on the disk
 * size of the shard on a worker. The worker to check the disk size is
 * determined by choosing the first active placement for the shard. The disk
 * size is calculated using pg_total_relation_size, so it includes indexes.
 *
 * SQL signature:
 * citus_shard_cost_by_disk_size(shardid bigint) returns float4
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_shard_cost_by_disk_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>shardPlacement</name> <init>= <expr><call><name>ActiveShardPlacement</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"CostByDiscSizeContext"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><call><name>ColocatedNonPartitionShardIntervalList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>colocationSizeInBytes</name> <init>= <expr><call><name>ShardListSizeInBytes</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>,
														<argument><expr><name><name>shardPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
														<argument><expr><name><name>shardPlacement</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>colocationSizeInBytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT4</name><argument_list>(<argument><expr><name>colocationSizeInBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetColocatedRebalanceSteps takes a List of PlacementUpdateEvents and creates
 * a new List of containing those and all the updates for colocated shards.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetColocatedRebalanceSteps</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>placementUpdateCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedUpdateList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>placementUpdateCell</argument>, <argument>placementUpdateList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>placementUpdate</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>placementUpdateCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name><name>placementUpdate</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><call><name>ColocatedShardIntervalList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedShardCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>colocatedShardCell</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>colocatedShard</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>colocatedShardCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>colocatedUpdate</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlacementUpdateEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>colocatedShard</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>sourceNode</name></name> <operator>=</operator> <name><name>placementUpdate</name><operator>-&gt;</operator><name>sourceNode</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>targetNode</name></name> <operator>=</operator> <name><name>placementUpdate</name><operator>-&gt;</operator><name>targetNode</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>updateType</name></name> <operator>=</operator> <name><name>placementUpdate</name><operator>-&gt;</operator><name>updateType</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>colocatedUpdateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colocatedUpdateList</name></expr></argument>, <argument><expr><name>colocatedUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>colocatedUpdateList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AcquireRelationColocationLock tries to acquire a lock for
 * rebalance/replication. If this is it not possible it fails
 * instantly because this means another rebalance/replication
 * is currently happening. This would really mess up planning.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AcquireRebalanceColocationLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operationName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>lockId</name> <init>= <expr><name>relationId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>citusTableCacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>citusTableCacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lockId</name> <operator>=</operator> <name><name>citusTableCacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_REBALANCE_COLOCATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>lockId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>lockAcquired</name> <init>= <expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockAcquired</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not acquire the lock required to %s %s"</literal></expr></argument>,
							   <argument><expr><name>operationName</name></expr></argument>,
							   <argument><expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"It means that either a concurrent shard move "</literal>
								  <literal type="string">"or shard copy is happening."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure that the concurrent operation has "</literal>
								<literal type="string">"finished and re-run the command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AcquirePlacementColocationLock tries to acquire a lock for
 * rebalance/replication while moving/copying the placement. If this
 * is it not possible it fails instantly because this means
 * another move/copy is currently happening. This would really mess up planning.
 */</comment>
<function><type><name>void</name></type>
<name>AcquirePlacementColocationLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lockMode</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operationName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>lockId</name> <init>= <expr><name>relationId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>citusTableCacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>citusTableCacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lockId</name> <operator>=</operator> <name><name>citusTableCacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_REBALANCE_PLACEMENT_COLOCATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name>lockId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>lockAcquired</name> <init>= <expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockAcquired</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not acquire the lock required to %s %s"</literal></expr></argument>,
							   <argument><expr><name>operationName</name></expr></argument>,
							   <argument><expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"It means that either a concurrent shard move "</literal>
								  <literal type="string">"or colocated distributed table creation is "</literal>
								  <literal type="string">"happening."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure that the concurrent operation has "</literal>
								<literal type="string">"finished and re-run the command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetResponsiveWorkerList returns a List of workers that respond to new
 * connection requests.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetResponsiveWorkerList</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWorkerList</name> <init>= <expr><call><name>ActiveReadableNodeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>activeWorkerCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>responsiveWorkerList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>activeWorkerCell</argument>, <argument>activeWorkerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>activeWorkerCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlag</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetNodeConnection</name><argument_list>(<argument><expr><name>connectionFlag</name></expr></argument>,
														<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
														<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>responsiveWorkerList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>responsiveWorkerList</name></expr></argument>, <argument><expr><name>worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>responsiveWorkerList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecutePlacementUpdates copies or moves a shard placement by calling the
 * corresponding functions in Citus in a separate subtransaction for each
 * update.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecutePlacementUpdates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>noticeOperation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>responsiveWorkerList</name> <init>= <expr><call><name>GetResponsiveWorkerList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"ExecutePlacementLoopContext"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>placementUpdateCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DropOrphanedResourcesInSeparateTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>placementUpdateCell</argument>, <argument>placementUpdateList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>placementUpdate</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>placementUpdateCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							 <argument><expr><literal type="string">"%s shard %lu from %s:%u to %s:%u ..."</literal></expr></argument>,
							 <argument><expr><name>noticeOperation</name></expr></argument>,
							 <argument><expr><name><name>placementUpdate</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
							 <argument><expr><name><name>placementUpdate</name><operator>-&gt;</operator><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
							 <argument><expr><name><name>placementUpdate</name><operator>-&gt;</operator><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
							 <argument><expr><name><name>placementUpdate</name><operator>-&gt;</operator><name>targetNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
							 <argument><expr><name><name>placementUpdate</name><operator>-&gt;</operator><name>targetNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>
							 )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UpdateShardPlacement</name><argument_list>(<argument><expr><name>placementUpdate</name></expr></argument>, <argument><expr><name>responsiveWorkerList</name></expr></argument>,
							 <argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SetupRebalanceMonitor initializes the dynamic shared memory required for storing the
 * progress information of a rebalance process. The function takes a List of
 * PlacementUpdateEvents for all shards that will be moved (including colocated
 * ones) and the relation id of the target table. The dynamic shared memory
 * portion consists of a RebalanceMonitorHeader and multiple
 * PlacementUpdateEventProgress, one for each planned shard placement move. The
 * dsm_handle of the created segment is savedin the progress of the current backend so
 * that it can be read by external agents such as get_rebalance_progress function by
 * calling pg_stat_get_progress_info UDF. Since currently only VACUUM commands are
 * officially allowed as the command type, we describe ourselves as a VACUUM command and
 * in order to distinguish a rebalancer progress from regular VACUUM progresses, we put
 * a magic number to the first progress field as an indicator. Finally we return the
 * dsm handle so that it can be used for updating the progress and cleaning things up.
 */</comment>
<function><type><name>void</name></type>
<name>SetupRebalanceMonitor</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>initialProgressState</name></decl></parameter>,
					  <parameter><decl><type><name>PlacementUpdateStatus</name></type> <name>initialStatus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedUpdateList</name> <init>= <expr><call><name>GetColocatedRebalanceSteps</name><argument_list>(<argument><expr><name>placementUpdateList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedUpdateCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>dsm_handle</name></type> <name>dsmHandle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ProgressMonitorData</name> <modifier>*</modifier></type><name>monitor</name> <init>= <expr><call><name>CreateProgressMonitor</name><argument_list>(
		<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>colocatedUpdateList</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlacementUpdateEventProgress</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>dsmHandle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>rebalanceSteps</name> <init>= <expr><call><name>ProgressMonitorSteps</name><argument_list>(<argument><expr><name>monitor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type> <name>eventIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>colocatedUpdateCell</argument>, <argument>colocatedUpdateList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>colocatedUpdate</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>colocatedUpdateCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>event</name> <init>= <expr><name>rebalanceSteps</name> <operator>+</operator> <name>eventIndex</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>sourceName</name></name></expr></argument>, <argument><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>event</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>, <argument><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>targetNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>colocatedUpdate</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>sourcePort</name></name> <operator>=</operator> <name><name>colocatedUpdate</name><operator>-&gt;</operator><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>targetPort</name></name> <operator>=</operator> <name><name>colocatedUpdate</name><operator>-&gt;</operator><name>targetNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>event</name><operator>-&gt;</operator><name>updateType</name></name> <operator>=</operator> <name><name>colocatedUpdate</name><operator>-&gt;</operator><name>updateType</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>event</name><operator>-&gt;</operator><name>updateStatus</name></name></expr></argument>, <argument><expr><name>initialStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>event</name><operator>-&gt;</operator><name>progress</name></name></expr></argument>, <argument><expr><name>initialProgressState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>eventIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>RegisterProgressMonitor</name><argument_list>(<argument><expr><name>REBALANCE_ACTIVITY_MAGIC_NUMBER</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>dsmHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * rebalance_table_shards rebalances the shards across the workers.
 *
 * SQL signature:
 *
 * rebalance_table_shards(
 *     relation regclass,
 *     threshold float4,
 *     max_shard_moves int,
 *     excluded_shard_list bigint[],
 *     shard_transfer_mode citus.shard_transfer_mode,
 *     drain_only boolean,
 *     rebalance_strategy name
 * ) RETURNS VOID
 */</comment>
<function><type><name>Datum</name></type>
<name>rebalance_table_shards</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ErrorIfMoveUnsupportedTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Note that we don't need to do any checks to error out for
		 * citus local tables here as NonColocatedDistRelationIdList
		 * already doesn't return non-distributed tables.
		 */</comment>
		<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>NonColocatedDistRelationIdList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"max_shard_moves"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"excluded_shard_list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"shard_transfer_mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"drain_only"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Form_pg_dist_rebalance_strategy</name></type> <name>strategy</name> <init>= <expr><call><name>GetRebalanceStrategy</name><argument_list>(
		<argument><expr><call><name>PG_GETARG_NAME_OR_NULL</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RebalanceOptions</name></type> <name>options</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>relationIdList</name> <operator>=</operator> <name>relationIdList</name></expr>,
		<expr><operator>.</operator><name>threshold</name> <operator>=</operator> <call><name>PG_GETARG_FLOAT4_OR_DEFAULT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>strategy</name><operator>-&gt;</operator><name>defaultThreshold</name></name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>maxShardMoves</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>excludedShardArray</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>drainOnly</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>rebalanceStrategy</name> <operator>=</operator> <name>strategy</name></expr>,
		<expr><operator>.</operator><name>improvementThreshold</name> <operator>=</operator> <name><name>strategy</name><operator>-&gt;</operator><name>improvementThreshold</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>shardTransferModeOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RebalanceTableShards</name><argument_list>(<argument><expr><operator>&amp;</operator><name>options</name></expr></argument>, <argument><expr><name>shardTransferModeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_rebalance_start rebalances the shards across the workers.
 *
 * SQL signature:
 *
 * citus_rebalance_start(
 *     rebalance_strategy name DEFAULT NULL,
 *     drain_only boolean DEFAULT false,
 *     shard_transfer_mode citus.shard_transfer_mode default 'auto'
 * ) RETURNS VOID
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_rebalance_start</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><call><name>NonColocatedDistRelationIdList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_dist_rebalance_strategy</name></type> <name>strategy</name> <init>=
		<expr><call><name>GetRebalanceStrategy</name><argument_list>(<argument><expr><call><name>PG_GETARG_NAME_OR_NULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"drain_only"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>drainOnly</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"shard_transfer_mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>shardTransferModeOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RebalanceOptions</name></type> <name>options</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>relationIdList</name> <operator>=</operator> <name>relationIdList</name></expr>,
		<expr><operator>.</operator><name>threshold</name> <operator>=</operator> <name><name>strategy</name><operator>-&gt;</operator><name>defaultThreshold</name></name></expr>,
		<expr><operator>.</operator><name>maxShardMoves</name> <operator>=</operator> <literal type="number">10000000</literal></expr>,
		<expr><operator>.</operator><name>excludedShardArray</name> <operator>=</operator> <call><name>construct_empty_array</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>drainOnly</name> <operator>=</operator> <name>drainOnly</name></expr>,
		<expr><operator>.</operator><name>rebalanceStrategy</name> <operator>=</operator> <name>strategy</name></expr>,
		<expr><operator>.</operator><name>improvementThreshold</name> <operator>=</operator> <name><name>strategy</name><operator>-&gt;</operator><name>improvementThreshold</name></name></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>jobId</name> <init>= <expr><call><name>RebalanceTableShardsBackground</name><argument_list>(<argument><expr><operator>&amp;</operator><name>options</name></expr></argument>, <argument><expr><name>shardTransferModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>jobId</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_rebalance_stop stops any ongoing background rebalance that is executing.
 * Raises an error when there is no backgound rebalance ongoing at the moment.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_rebalance_stop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>jobId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HasNonTerminalJobOfType</name><argument_list>(<argument><expr><literal type="string">"rebalance"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>jobId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no ongoing rebalance that can be stopped"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>citus_job_cancel</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_rebalance_wait waits till an ongoing background rebalance has finished execution.
 * A warning will be displayed if no rebalance is ongoing.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_rebalance_wait</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>jobId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HasNonTerminalJobOfType</name><argument_list>(<argument><expr><literal type="string">"rebalance"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>jobId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no ongoing rebalance that can be waited on"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>citus_job_wait_internal</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetRebalanceStrategy returns the rebalance strategy from
 * pg_dist_rebalance_strategy matching the given name. If name is NULL it
 * returns the default rebalance strategy from pg_dist_rebalance_strategy.
 */</comment>
<function><type><specifier>static</specifier> <name>Form_pg_dist_rebalance_strategy</name></type>
<name>GetRebalanceStrategy</name><parameter_list>(<parameter><decl><type><name>Name</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistRebalanceStrategy</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistRebalanceStrategyRelationId</name><argument_list>()</argument_list></call></expr></argument>,
												  <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* WHERE default_strategy=true */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_rebalance_strategy_default_strategy</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_BOOLEQ</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* WHERE name=$name */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_rebalance_strategy_name</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>, <argument><expr><call><name>NameGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistRebalanceStrategy</name></expr></argument>,
													<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"no rebalance_strategy was provided, but there is also no default strategy set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find rebalance strategy with name %s"</literal></expr></argument>,
							   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_dist_rebalance_strategy</name></type> <name>strategy</name> <init>=
		<expr><operator>(</operator><name>Form_pg_dist_rebalance_strategy</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_dist_rebalance_strategy</name></type> <name>strategy_copy</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_dist_rebalance_strategy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Copy data over by dereferencing */</comment>
	<expr_stmt><expr><operator>*</operator><name>strategy_copy</name> <operator>=</operator> <operator>*</operator><name>strategy</name></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistRebalanceStrategy</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>strategy_copy</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_drain_node drains a node by setting shouldhaveshards to false and
 * running the rebalancer after in drain_only mode.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_drain_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"nodename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"nodeport"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"shard_transfer_mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>shardTransferModeOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_dist_rebalance_strategy</name></type> <name>strategy</name> <init>= <expr><call><name>GetRebalanceStrategy</name><argument_list>(
		<argument><expr><call><name>PG_GETARG_NAME_OR_NULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RebalanceOptions</name></type> <name>options</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>relationIdList</name> <operator>=</operator> <call><name>NonColocatedDistRelationIdList</name><argument_list>()</argument_list></call></expr>,
		<expr><operator>.</operator><name>threshold</name> <operator>=</operator> <name><name>strategy</name><operator>-&gt;</operator><name>defaultThreshold</name></name></expr>,
		<expr><operator>.</operator><name>maxShardMoves</name> <operator>=</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name>excludedShardArray</name> <operator>=</operator> <call><name>construct_empty_array</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>drainOnly</name> <operator>=</operator> <name>true</name></expr>,
		<expr><operator>.</operator><name>rebalanceStrategy</name> <operator>=</operator> <name>strategy</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>options</name><operator>.</operator><name>workerNode</name></name> <operator>=</operator> <call><name>FindWorkerNodeOrError</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is done in a separate session. This way it's not undone if the
	 * draining fails midway through.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteRebalancerCommandInSeparateTransaction</name><argument_list>(<argument><expr><call><name>psprintf</name><argument_list>(
													  <argument><expr><literal type="string">"SELECT master_set_node_property(%s, %i, 'shouldhaveshards', false)"</literal></expr></argument>,
													  <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RebalanceTableShards</name><argument_list>(<argument><expr><operator>&amp;</operator><name>options</name></expr></argument>, <argument><expr><name>shardTransferModeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * replicate_table_shards replicates under-replicated shards of the specified
 * table.
 */</comment>
<function><type><name>Datum</name></type>
<name>replicate_table_shards</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>shardReplicationFactor</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>maxShardCopies</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>excludedShardArray</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>transferMode</name> <init>= <expr><call><name>LookupShardTransferMode</name><argument_list>(<argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>EnsureReferenceTablesExistOnAllNodesExtended</name><argument_list>(<argument><expr><name>transferMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AcquireRebalanceColocationLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><literal type="string">"replicate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWorkerList</name> <init>= <expr><call><name>SortedActiveWorkers</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>FullShardPlacementList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>excludedShardArray</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeShardPlacementList</name> <init>= <expr><call><name>FilterShardPlacementList</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>,
															  <argument><expr><name>IsActiveShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name> <init>= <expr><call><name>ReplicationPlacementUpdates</name><argument_list>(<argument><expr><name>activeWorkerList</name></expr></argument>,
															<argument><expr><name>activeShardPlacementList</name></expr></argument>,
															<argument><expr><name>shardReplicationFactor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>placementUpdateList</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name>placementUpdateList</name></expr></argument>, <argument><expr><name>maxShardCopies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecutePlacementUpdates</name><argument_list>(<argument><expr><name>placementUpdateList</name></expr></argument>, <argument><expr><name>shardReplicationModeOid</name></expr></argument>, <argument><expr><literal type="string">"Copying"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_drain_node is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_drain_node</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_drain_node</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_rebalance_table_shards_plan function calculates the shard move steps
 * required for the rebalance operations including the ones for colocated
 * tables.
 *
 * SQL signature:
 *
 * get_rebalance_table_shards_plan(
 *     relation regclass,
 *     threshold float4,
 *     max_shard_moves int,
 *     excluded_shard_list bigint[],
 *     drain_only boolean,
 *     rebalance_strategy name
 * )
 */</comment>
<function><type><name>Datum</name></type>
<name>get_rebalance_table_shards_plan</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ErrorIfMoveUnsupportedTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Note that we don't need to do any checks to error out for
		 * citus local tables here as NonColocatedDistRelationIdList
		 * already doesn't return non-distributed tables.
		 */</comment>
		<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>NonColocatedDistRelationIdList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"max_shard_moves"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"excluded_shard_list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_ENSURE_ARGNOTNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"drain_only"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Form_pg_dist_rebalance_strategy</name></type> <name>strategy</name> <init>= <expr><call><name>GetRebalanceStrategy</name><argument_list>(
		<argument><expr><call><name>PG_GETARG_NAME_OR_NULL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RebalanceOptions</name></type> <name>options</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>relationIdList</name> <operator>=</operator> <name>relationIdList</name></expr>,
		<expr><operator>.</operator><name>threshold</name> <operator>=</operator> <call><name>PG_GETARG_FLOAT4_OR_DEFAULT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>strategy</name><operator>-&gt;</operator><name>defaultThreshold</name></name></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>maxShardMoves</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>excludedShardArray</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>drainOnly</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>rebalanceStrategy</name> <operator>=</operator> <name>strategy</name></expr>,
		<expr><operator>.</operator><name>improvementThreshold</name> <operator>=</operator> <call><name>PG_GETARG_FLOAT4_OR_DEFAULT</name><argument_list>(
			<argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name><name>strategy</name><operator>-&gt;</operator><name>improvementThreshold</name></name></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>


	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name> <init>= <expr><call><name>GetRebalanceSteps</name><argument_list>(<argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedUpdateList</name> <init>= <expr><call><name>GetColocatedRebalanceSteps</name><argument_list>(<argument><expr><name>placementUpdateList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedUpdateCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>colocatedUpdateCell</argument>, <argument>colocatedUpdateList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>colocatedUpdate</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>colocatedUpdateCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><call><name>ShardLength</name><argument_list>(<argument><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(
										<argument><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(
										<argument><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>targetNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>colocatedUpdate</name><operator>-&gt;</operator><name>targetNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_rebalance_progress collects information about the ongoing rebalance operations and
 * returns the concatenated list of steps involved in the operations, along with their
 * progress information. Currently the progress field can take 4 integer values
 * (-1: error, 0: waiting, 1: moving, 2: moved). The progress field is of type bigint
 * because we may implement a more granular, byte-level progress as a future improvement.
 */</comment>
<function><type><name>Datum</name></type>
<name>get_rebalance_progress</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>segmentList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get the addresses of all current rebalance monitors */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rebalanceMonitorList</name> <init>= <expr><call><name>ProgressMonitorList</name><argument_list>(<argument><expr><name>REBALANCE_ACTIVITY_MAGIC_NUMBER</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>segmentList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ProgressMonitorData</name> <modifier>*</modifier></type><name>monitor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>monitor</argument>, <argument>rebalanceMonitorList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>placementUpdateEvents</name> <init>= <expr><call><name>ProgressMonitorSteps</name><argument_list>(
			<argument><expr><name>monitor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardStatistics</name> <init>= <expr><call><name>BuildWorkerShardStatisticsHash</name><argument_list>(<argument><expr><name>placementUpdateEvents</name></expr></argument>,
															   <argument><expr><name><name>monitor</name><operator>-&gt;</operator><name>stepCount</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardSizes</name> <init>= <expr><call><name>BuildShardSizesHash</name><argument_list>(<argument><expr><name>monitor</name></expr></argument>, <argument><expr><name>shardStatistics</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>eventIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>eventIndex</name> <operator>&lt;</operator> <name><name>monitor</name><operator>-&gt;</operator><name>stepCount</name></name></expr>;</condition> <incr><expr><name>eventIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><name>placementUpdateEvents</name> <operator>+</operator> <name>eventIndex</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>step</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>uint64</name></type> <name>sourceSize</name> <init>= <expr><call><name>WorkerShardSize</name><argument_list>(<argument><expr><name>shardStatistics</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourceName</name></name></expr></argument>,
												<argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourcePort</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>targetSize</name> <init>= <expr><call><name>WorkerShardSize</name><argument_list>(<argument><expr><name>shardStatistics</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>,
												<argument><expr><name><name>step</name><operator>-&gt;</operator><name>targetPort</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>sourceLSN</name> <init>= <expr><call><name>WorkerLSN</name><argument_list>(<argument><expr><name>shardStatistics</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourceName</name></name></expr></argument>,
											 <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourcePort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>targetLSN</name> <init>= <expr><call><name>WorkerShardLSN</name><argument_list>(<argument><expr><name>shardStatistics</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>,
												  <argument><expr><name><name>step</name><operator>-&gt;</operator><name>targetPort</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>uint64</name></type> <name>shardSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ShardStatistics</name> <modifier>*</modifier></type><name>shardSizesStat</name> <init>=
				<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>shardSizes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>shardSizesStat</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>shardSize</name> <operator>=</operator> <name><name>shardSizesStat</name><operator>-&gt;</operator><name>totalSize</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>monitor</name><operator>-&gt;</operator><name>processId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>shardSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourceName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourcePort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>targetPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>step</name><operator>-&gt;</operator><name>progress</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>sourceSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>targetSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(
				<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>PlacementUpdateTypeNames</name><index>[<expr><name><name>step</name><operator>-&gt;</operator><name>updateType</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>sourceLSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>LSNGetDatum</name><argument_list>(<argument><expr><name>targetLSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(
											 <argument><expr><name><name>PlacementUpdateStatusNames</name><index>[
												 <expr><call><name>pg_atomic_read_u64</name><argument_list>(
													 <argument><expr><operator>&amp;</operator><name><name>step</name><operator>-&gt;</operator><name>updateStatus</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<expr_stmt><expr><call><name>DetachFromDSMSegments</name><argument_list>(<argument><expr><name>segmentList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildShardSizesHash creates a hash that maps a shardid to its full size
 * within the cluster. It does this by using the rebalance progress monitor
 * state to find the node the shard is currently on. It then looks up the shard
 * size in the shardStatistics hashmap for this node.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>BuildShardSizesHash</name><parameter_list>(<parameter><decl><type><name>ProgressMonitorData</name> <modifier>*</modifier></type><name>monitor</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardStatistics</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ShardStatistics</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardSizes</name> <init>= <expr><call><name>hash_create</name><argument_list>(
		<argument><expr><literal type="string">"ShardSizeHash"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
		<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>placementUpdateEvents</name> <init>= <expr><call><name>ProgressMonitorSteps</name><argument_list>(<argument><expr><name>monitor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>eventIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>eventIndex</name> <operator>&lt;</operator> <name><name>monitor</name><operator>-&gt;</operator><name>stepCount</name></name></expr>;</condition> <incr><expr><name>eventIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><name>placementUpdateEvents</name> <operator>+</operator> <name>eventIndex</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>step</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>backupShardSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>progress</name> <init>= <expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>step</name><operator>-&gt;</operator><name>progress</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>uint64</name></type> <name>sourceSize</name> <init>= <expr><call><name>WorkerShardSize</name><argument_list>(<argument><expr><name>shardStatistics</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourceName</name></name></expr></argument>,
											<argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourcePort</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>targetSize</name> <init>= <expr><call><name>WorkerShardSize</name><argument_list>(<argument><expr><name>shardStatistics</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>,
											<argument><expr><name><name>step</name><operator>-&gt;</operator><name>targetPort</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>==</operator> <name>REBALANCE_PROGRESS_WAITING</name> <operator>||</operator>
			<name>progress</name> <operator>==</operator> <name>REBALANCE_PROGRESS_MOVING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we are not done with the move, the correct shard size is the
			 * size on the source.
			 */</comment>
			<expr_stmt><expr><name>shardSize</name> <operator>=</operator> <name>sourceSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>backupShardSize</name> <operator>=</operator> <name>targetSize</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>progress</name> <operator>==</operator> <name>REBALANCE_PROGRESS_MOVED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we are done with the move, the correct shard size is the size
			 * on the target
			 */</comment>
			<expr_stmt><expr><name>shardSize</name> <operator>=</operator> <name>targetSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>backupShardSize</name> <operator>=</operator> <name>sourceSize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>shardSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>backupShardSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We don't have any useful shard size. This can happen when a
				 * shard is moved multiple times and it is not present on
				 * either of these nodes. Probably the shard is on a worker
				 * related to another event. In the weird case that this shard
				 * is on the nodes and actually is size 0, we will have no
				 * entry in the hashmap. When fetching from it we always
				 * default to 0 if no entry is found, so that's fine.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Because of the way we fetch shard sizes they are from a slightly
			 * earlier moment than the progress state we just read from shared
			 * memory. Usually this is no problem, but there exist some race
			 * conditions where this matters. For example, for very quick moves
			 * it is possible that even though a step is now reported as MOVED,
			 * when we read the shard sizes the move had not even started yet.
			 * This in turn can mean that the target size is 0 while the source
			 * size is not. We try to handle such rare edge cases by falling
			 * back on the other shard size if that one is not 0.
			 */</comment>
			<expr_stmt><expr><name>shardSize</name> <operator>=</operator> <name>backupShardSize</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>


		<decl_stmt><decl><type><name>ShardStatistics</name> <modifier>*</modifier></type><name>currentWorkerStatistics</name> <init>=
			<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>shardSizes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>currentWorkerStatistics</name><operator>-&gt;</operator><name>totalSize</name></name> <operator>=</operator> <name>shardSize</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>shardSizes</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerShardSize returns the size of a shard in bytes on a worker, based on
 * the workerShardStatisticsHash.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>WorkerShardSize</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerShardStatisticsHash</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workerName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workerPort</name></decl></parameter>,
				<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerHashKey</name></type> <name>workerKey</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerKey</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>workerName</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerKey</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>workerPort</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerShardStatistics</name> <modifier>*</modifier></type><name>workerStats</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>workerShardStatisticsHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workerKey</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>workerStats</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardStatistics</name> <modifier>*</modifier></type><name>shardStats</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>workerStats</name><operator>-&gt;</operator><name>statistics</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shardStats</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>shardStats</name><operator>-&gt;</operator><name>totalSize</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerShardLSN returns the LSN of a shard on a worker, based on
 * the workerShardStatisticsHash. If there is no LSN data in the
 * statistics object, returns InvalidXLogRecPtr.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>WorkerShardLSN</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerShardStatisticsHash</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workerName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workerPort</name></decl></parameter>,
			   <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerHashKey</name></type> <name>workerKey</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerKey</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>workerName</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerKey</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>workerPort</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerShardStatistics</name> <modifier>*</modifier></type><name>workerStats</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>workerShardStatisticsHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workerKey</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>workerStats</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardStatistics</name> <modifier>*</modifier></type><name>shardStats</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>workerStats</name><operator>-&gt;</operator><name>statistics</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shardStats</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>shardStats</name><operator>-&gt;</operator><name>shardLSN</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerLSN returns the LSN of a worker, based on the workerShardStatisticsHash.
 * If there is no LSN data in the statistics object, returns InvalidXLogRecPtr.
 */</comment>
<function><type><specifier>static</specifier> <name>XLogRecPtr</name></type>
<name>WorkerLSN</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerShardStatisticsHash</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workerName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workerPort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerHashKey</name></type> <name>workerKey</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerKey</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>workerName</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerKey</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>workerPort</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerShardStatistics</name> <modifier>*</modifier></type><name>workerStats</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>workerShardStatisticsHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workerKey</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>workerStats</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>InvalidXLogRecPtr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>workerStats</name><operator>-&gt;</operator><name>workerLSN</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildWorkerShardStatisticsHash returns a shard id -&gt; shard statistics hash containing
 * sizes of shards on the source node and destination node.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>BuildWorkerShardStatisticsHash</name><parameter_list>(<parameter><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>steps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stepCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardsByWorker</name> <init>= <expr><call><name>GetMovedShardIdsByWorker</name><argument_list>(<argument><expr><name>steps</name></expr></argument>, <argument><expr><name>stepCount</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkerHashKey</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkerShardStatistics</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerShardStatistics</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"WorkerShardStatistics"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
											  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerShardIds</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>shardsByWorker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetNodeConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
														<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>hostname</name></name></expr></argument>,
														<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>statistics</name> <init>=
			<expr><call><name>GetShardStatistics</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>shardIds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>WorkerHashKey</name></type> <name>workerKey</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerKey</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerKey</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>worker</name><operator>.</operator><name>port</name></name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>WorkerShardStatistics</name> <modifier>*</modifier></type><name>moveStat</name> <init>=
			<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>workerShardStatistics</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>worker</name></name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>moveStat</name><operator>-&gt;</operator><name>statistics</name></name> <operator>=</operator> <name>statistics</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>moveStat</name><operator>-&gt;</operator><name>workerLSN</name></name> <operator>=</operator> <call><name>GetRemoteLogPosition</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>workerShardStatistics</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetShardStatistics fetches the statics for the given shard ids over the
 * given connection. It returns a hashmap where the keys are the shard ids and
 * the values are the statistics.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>GetShardStatistics</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardIds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>query</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(
		<argument><expr><name>query</name></expr></argument>,
		<argument><expr><literal type="string">"WITH shard_names (shard_id, schema_name, table_name) AS ((VALUES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isFirst</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name> <modifier>*</modifier></type><name>shardIdPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>shardIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>shardIdPtr</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><operator>*</operator><name>shardIdPtr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFirst</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"("</literal> <name>UINT64_FORMAT</name> <literal type="string">",%s,%s)"</literal></expr></argument>,
						 <argument><expr><name>shardId</name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>shardName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>isFirst</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"))"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(
		<argument><expr><name>query</name></expr></argument>,
		<argument><expr><literal type="string">" SELECT shard_id, coalesce(pg_total_relation_size(tables.relid),0), tables.lsn"</literal>

		<comment type="block">/* for each shard in shardIds */</comment>
		<literal type="string">" FROM shard_names"</literal>

		<comment type="block">/* check if its name can be found in pg_class, if so return size */</comment>
		<literal type="string">" LEFT JOIN"</literal>
		<literal type="string">" (SELECT c.oid AS relid, c.relname, n.nspname, ss.latest_end_lsn AS lsn"</literal>
		<literal type="string">" FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace "</literal>
		<literal type="string">" LEFT JOIN pg_subscription_rel sr ON sr.srrelid = c.oid "</literal>
		<literal type="string">" LEFT JOIN pg_stat_subscription ss ON sr.srsubid = ss.subid) tables"</literal>
		<literal type="string">" ON tables.relname = shard_names.table_name AND"</literal>
		<literal type="string">" tables.nspname = shard_names.schema_name "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>queryResult</name> <init>= <expr><call><name>ExecuteOptionalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>queryResult</name> <operator>!=</operator> <name>RESPONSE_OKAY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot get the size because of a connection error"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>rowCount</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>colCount</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* This is not expected to ever happen, but we check just to be sure */</comment>
	<if_stmt><if>if <condition>(<expr><name>colCount</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected number of columns returned by: %s"</literal></expr></argument>,
							   <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ShardStatistics</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardStatistics</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ShardStatisticsHash"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
										<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>rowIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rowIndex</name> <operator>&lt;</operator> <name>rowCount</name></expr>;</condition> <incr><expr><name>rowIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardIdString</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>strtou64</name><argument_list>(<argument><expr><name>shardIdString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sizeString</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>totalSize</name> <init>= <expr><call><name>strtou64</name><argument_list>(<argument><expr><name>sizeString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardStatistics</name> <modifier>*</modifier></type><name>statistics</name> <init>=
			<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>shardStatistics</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>statistics</name><operator>-&gt;</operator><name>totalSize</name></name> <operator>=</operator> <name>totalSize</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>statistics</name><operator>-&gt;</operator><name>shardLSN</name></name> <operator>=</operator> <name>InvalidXLogRecPtr</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>LSNString</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>LSNDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_lsn_in</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>LSNString</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>statistics</name><operator>-&gt;</operator><name>shardLSN</name></name> <operator>=</operator> <call><name>DatumGetLSN</name><argument_list>(<argument><expr><name>LSNDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shardStatistics</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetMovedShardIdsByWorker groups the shard ids in the provided steps by
 * worker. It returns a hashmap that contains a set of these shard ids.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>GetMovedShardIdsByWorker</name><parameter_list>(<parameter><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>steps</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stepCount</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>fromSource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkerHashKey</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkerShardIds</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardsByWorker</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"GetRebalanceStepsByWorker"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
									   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>stepIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>stepIndex</name> <operator>&lt;</operator> <name>stepCount</name></expr>;</condition> <incr><expr><name>stepIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>steps</name><index>[<expr><name>stepIndex</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AddToWorkerShardIdSet</name><argument_list>(<argument><expr><name>shardsByWorker</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourceName</name></name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourcePort</name></name></expr></argument>,
							  <argument><expr><name><name>step</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>step</name><operator>-&gt;</operator><name>progress</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REBALANCE_PROGRESS_WAITING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * shard move has not started so we don't need target stats for
			 * this shard
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>AddToWorkerShardIdSet</name><argument_list>(<argument><expr><name>shardsByWorker</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>targetName</name></name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>targetPort</name></name></expr></argument>,
							  <argument><expr><name><name>step</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>shardsByWorker</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddToWorkerShardIdSet adds the shard id to the shard id set for the
 * specified worker in the shardsByWorker hashmap.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddToWorkerShardIdSet</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardsByWorker</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workerName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>workerPort</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerHashKey</name></type> <name>workerKey</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>workerKey</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>workerName</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerKey</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>workerPort</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerShardIds</name> <modifier>*</modifier></type><name>workerShardIds</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>shardsByWorker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workerKey</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isFound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFound</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>,
			<expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>,
			<expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>
		}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>workerShardIds</name><operator>-&gt;</operator><name>shardIds</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(
			<argument><expr><literal type="string">"WorkerShardIdsSet"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
			<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>workerShardIds</name><operator>-&gt;</operator><name>shardIds</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * NonColocatedDistRelationIdList returns a list of distributed table oids, one
 * for each existing colocation group.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>NonColocatedDistRelationIdList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allCitusTablesList</name> <init>= <expr><call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>ANY_CITUS_TABLE_TYPE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* allocate sufficient capacity for O(1) expected look-up time */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>capacity</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>allCitusTablesList</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">0.75</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>keysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>entrysize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>,
		<expr><operator>.</operator><name>hcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>alreadySelectedColocationIds</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"RebalanceColocationIdSet"</literal></expr></argument>,
													 <argument><expr><name>capacity</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>tableId</argument>, <argument>allCitusTablesList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>foundInSet</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>citusTableCacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(
			<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>citusTableCacheEntry</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We're only interested in distributed tables, should ignore
			 * reference tables and citus local tables.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>citusTableCacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>alreadySelectedColocationIds</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>citusTableCacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>foundInSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>foundInSet</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>relationIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RebalanceTableShards rebalances the shards for the relations inside the
 * relationIdList across the different workers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RebalanceTableShards</name><parameter_list>(<parameter><decl><type><name>RebalanceOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>transferMode</name> <init>= <expr><call><name>LookupShardTransferMode</name><argument_list>(<argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>EnsureReferenceTablesExistOnAllNodesExtended</name><argument_list>(<argument><expr><name>transferMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>relationIdList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>operationName</name> <init>= <expr><literal type="string">"rebalance"</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>drainOnly</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>operationName</name> <operator>=</operator> <literal type="string">"move"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>operationName</name></name> <operator>=</operator> <name>operationName</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorOnConcurrentRebalance</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name> <init>= <expr><call><name>GetRebalanceSteps</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>placementUpdateList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This uses the first relationId from the list, it's only used for display
	 * purposes so it does not really matter which to show
	 */</comment>
	<expr_stmt><expr><call><name>SetupRebalanceMonitor</name><argument_list>(<argument><expr><name>placementUpdateList</name></expr></argument>, <argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>relationIdList</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>REBALANCE_PROGRESS_WAITING</name></expr></argument>,
						  <argument><expr><name>PLACEMENT_UPDATE_STATUS_NOT_STARTED_YET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecutePlacementUpdates</name><argument_list>(<argument><expr><name>placementUpdateList</name></expr></argument>, <argument><expr><name>shardReplicationModeOid</name></expr></argument>, <argument><expr><literal type="string">"Moving"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FinalizeCurrentProgressMonitor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorOnConcurrentRebalance raises an error with extra information when there is already
 * a rebalance running.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorOnConcurrentRebalance</name><parameter_list>(<parameter><decl><type><name>RebalanceOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>options-&gt;relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* this provides the legacy error when the lock can't be acquired */</comment>
		<expr_stmt><expr><call><name>AcquireRebalanceColocationLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>options</name><operator>-&gt;</operator><name>operationName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>int64</name></type> <name>jobId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HasNonTerminalJobOfType</name><argument_list>(<argument><expr><literal type="string">"rebalance"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>jobId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"A rebalance is already running as job %ld"</literal></expr></argument>, <argument><expr><name>jobId</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A rebalance was already scheduled as background job"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To monitor progress, run: SELECT * FROM "</literal>
							<literal type="string">"pg_dist_background_task WHERE job_id = %ld ORDER BY task_id "</literal>
							<literal type="string">"ASC; or SELECT * FROM get_rebalance_progress();"</literal></expr></argument>,
							<argument><expr><name>jobId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RebalanceTableShardsBackground rebalances the shards for the relations
 * inside the relationIdList across the different workers. It does so using our
 * background job+task infrastructure.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>RebalanceTableShardsBackground</name><parameter_list>(<parameter><decl><type><name>RebalanceOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>relationIdList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"No tables to rebalance"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>operationName</name> <init>= <expr><literal type="string">"rebalance"</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>drainOnly</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>operationName</name> <operator>=</operator> <literal type="string">"move"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>operationName</name></name> <operator>=</operator> <name>operationName</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorOnConcurrentRebalance</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>shardTransferMode</name> <init>= <expr><call><name>LookupShardTransferMode</name><argument_list>(<argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>options-&gt;relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>colocatedTableList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>,
										 <argument><expr><call><name>ColocatedTableList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>colocatedTableId</argument>, <argument>colocatedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>shardTransferMode</name> <operator>==</operator> <name>TRANSFER_MODE_AUTOMATIC</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* make sure that all tables included in the rebalance have a replica identity*/</comment>
		<expr_stmt><expr><call><name>VerifyTablesHaveReplicaIdentity</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name> <init>= <expr><call><name>GetRebalanceSteps</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>placementUpdateList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"No moves available for rebalancing"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DropOrphanedResourcesInSeparateTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* find the name of the shard transfer mode to interpolate in the scheduled command */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>shardTranferModeLabelDatum</name> <init>=
		<expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>enum_out</name></expr></argument>, <argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardTranferModeLabel</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>shardTranferModeLabelDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* schedule planned moves */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>jobId</name> <init>= <expr><call><name>CreateBackgroundJob</name><argument_list>(<argument><expr><literal type="string">"rebalance"</literal></expr></argument>, <argument><expr><literal type="string">"Rebalance all colocation groups"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* buffer used to construct the sql command for the tasks */</comment>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Currently we only have two tasks that any move can depend on:
	 *  - replicating reference tables
	 *  - the previous move
	 *
	 * prevJobIdx tells what slot to write the id of the task into. We only use both slots
	 * if we are actually replicating reference tables.
	 */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name><name>prevJobId</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>prevJobIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referenceTableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HasNodesWithMissingReferenceTables</name><argument_list>(<argument><expr><operator>&amp;</operator><name>referenceTableIdList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>VerifyTablesHaveReplicaIdentity</name><argument_list>(<argument><expr><name>referenceTableIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reference tables need to be copied to (newly-added) nodes, this needs to be the
		 * first task before we can move any other table.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT pg_catalog.replicate_reference_tables(%s)"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>shardTranferModeLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>ScheduleBackgroundTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>,
													  <argument><expr><name>prevJobIdx</name></expr></argument>, <argument><expr><name>prevJobId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>prevJobId</name><index>[<expr><name>prevJobIdx</name></expr>]</index></name> <operator>=</operator> <name><name>task</name><operator>-&gt;</operator><name>taskid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prevJobIdx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>move</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>prevMoveIndex</name> <init>= <expr><name>prevJobIdx</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>move</argument>, <argument>placementUpdateList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT pg_catalog.citus_move_shard_placement(%ld,%s,%u,%s,%u,%s)"</literal></expr></argument>,
						 <argument><expr><name><name>move</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>move</name><operator>-&gt;</operator><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>move</name><operator>-&gt;</operator><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>move</name><operator>-&gt;</operator><name>targetNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>move</name><operator>-&gt;</operator><name>targetNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>shardTranferModeLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>BackgroundTask</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>ScheduleBackgroundTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>,
													  <argument><expr><name>prevJobIdx</name></expr></argument>, <argument><expr><name>prevJobId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>prevJobId</name><index>[<expr><name>prevMoveIndex</name></expr>]</index></name> <operator>=</operator> <name><name>task</name><operator>-&gt;</operator><name>taskid</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>prevJobIdx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Scheduled %d moves as job %ld"</literal></expr></argument>,
					<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>placementUpdateList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>jobId</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Rebalance scheduled as background job"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To monitor progress, run: "</literal>
					 <literal type="string">"SELECT * FROM pg_dist_background_task WHERE job_id = %ld ORDER BY "</literal>
					 <literal type="string">"task_id ASC; or SELECT * FROM get_rebalance_progress();"</literal></expr></argument>,
					 <argument><expr><name>jobId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>jobId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateShardPlacement copies or moves a shard placement by calling
 * the corresponding functions in Citus in a subtransaction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateShardPlacement</name><parameter_list>(<parameter><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>placementUpdateEvent</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>responsiveNodeList</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlacementUpdateType</name></type> <name>updateType</name> <init>= <expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>updateType</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceNode</name> <init>= <expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>sourceNode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name> <init>= <expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>targetNode</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>shardTranferModeLabelDatum</name> <init>=
		<expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>enum_out</name></expr></argument>, <argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardTranferModeLabel</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>shardTranferModeLabelDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>placementUpdateCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if target node is not responsive, don't continue */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>targetResponsive</name> <init>= <expr><call><name>WorkerNodeListContains</name><argument_list>(<argument><expr><name>responsiveNodeList</name></expr></argument>,
												   <argument><expr><name><name>targetNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
												   <argument><expr><name><name>targetNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetResponsive</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"target node %s:%d is not responsive"</literal></expr></argument>,
							   <argument><expr><name><name>targetNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
							   <argument><expr><name><name>targetNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if source node is not responsive, don't continue */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>sourceResponsive</name> <init>= <expr><call><name>WorkerNodeListContains</name><argument_list>(<argument><expr><name>responsiveNodeList</name></expr></argument>,
												   <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
												   <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sourceResponsive</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"source node %s:%d is not responsive"</literal></expr></argument>,
							   <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
							   <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>updateType</name> <operator>==</operator> <name>PLACEMENT_UPDATE_MOVE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>placementUpdateCommand</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT citus_move_shard_placement(%ld,%s,%u,%s,%u,%s)"</literal></expr></argument>,
						 <argument><expr><name>shardId</name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>targetNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>targetNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>shardTranferModeLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>updateType</name> <operator>==</operator> <name>PLACEMENT_UPDATE_COPY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>placementUpdateCommand</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT citus_copy_shard_placement(%ld,%s,%u,%s,%u,%s)"</literal></expr></argument>,
						 <argument><expr><name>shardId</name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>targetNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>targetNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>shardTranferModeLabel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only moving or copying shards is supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>UpdateColocatedShardPlacementProgress</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>,
										  <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
										  <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
										  <argument><expr><name>REBALANCE_PROGRESS_MOVING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In case of failure, we throw an error such that rebalance_table_shards
	 * fails early.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteRebalancerCommandInSeparateTransaction</name><argument_list>(<argument><expr><name><name>placementUpdateCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdateColocatedShardPlacementProgress</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>,
										  <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
										  <argument><expr><name><name>sourceNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
										  <argument><expr><name>REBALANCE_PROGRESS_MOVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteRebalancerCommandInSeparateTransaction runs a command in a separate
 * transaction that is commited right away. This is useful for things that you
 * don't want to rollback when the current transaction is rolled back.
 * Set true to 'useExclusiveTransactionBlock' to initiate a BEGIN and COMMIT statements.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteRebalancerCommandInSeparateTransaction</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlag</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetNodeConnection</name><argument_list>(<argument><expr><name>connectionFlag</name></expr></argument>, <argument><expr><name>LocalHostName</name></expr></argument>,
													<argument><expr><name>PostPortNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><call><name>psprintf</name><argument_list>(
							  <argument><expr><literal type="string">"SET LOCAL application_name TO '%s%ld'"</literal></expr></argument>,
							  <argument><expr><name>CITUS_REBALANCER_APPLICATION_NAME_PREFIX</name></expr></argument>,
							  <argument><expr><call><name>GetGlobalPID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>PropagateSessionSettingsForLoopbackConnection</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>setCommands</name> <init>= <expr><call><name>GetSetCommandListForNewConnections</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>setCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach_ptr</name><argument_list>(<argument>setCommand</argument>, <argument>setCommands</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name>setCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransactionWithConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetSetCommandListForNewConnections returns a list of SET statements to
 * be executed in new connections to worker nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetSetCommandListForNewConnections</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>guc_vars</name> <init>= <expr><call><name>get_guc_variables</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>gucCount</name> <init>= <expr><call><name>GetNumConfigOptions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>gucIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>gucIndex</name> <operator>&lt;</operator> <name>gucCount</name></expr>;</condition> <incr><expr><name>gucIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>)</operator> <name><name>guc_vars</name><index>[<expr><name>gucIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>PGC_S_SESSION</name> <operator>&amp;&amp;</operator> <call><name>IsSettingSafeToPropagate</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>variableValue</name> <init>= <expr><call><name>GetConfigOption</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"SET LOCAL %s TO '%s';"</literal></expr></argument>,
														<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>variableValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RebalancePlacementUpdates returns a list of placement updates which makes the
 * cluster balanced. We move shards to these nodes until all nodes become utilized.
 * We consider a node under-utilized if it has less than floor((1.0 - threshold) *
 * placementCountAverage) shard placements. In each iteration we choose the node
 * with maximum number of shard placements as the source, and we choose the node
 * with minimum number of shard placements as the target. Then we choose a shard
 * which is placed in the source node but not in the target node as the shard to
 * move.
 *
 * The activeShardPlacementListList argument contains a list of lists of active shard
 * placements. Each of these lists are balanced independently. This is used to
 * make sure different colocation groups are balanced separately, so each list
 * contains the placements of a colocation group.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RebalancePlacementUpdates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeShardPlacementListList</name></decl></parameter>,
						  <parameter><decl><type><name>double</name></type> <name>threshold</name></decl></parameter>,
						  <parameter><decl><type><name>int32</name></type> <name>maxShardMoves</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>drainOnly</name></decl></parameter>,
						  <parameter><decl><type><name>float4</name></type> <name>improvementThreshold</name></decl></parameter>,
						  <parameter><decl><type><name>RebalancePlanFunctions</name> <modifier>*</modifier></type><name>functions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rebalanceStates</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>shardPlacementList</argument>, <argument>activeShardPlacementListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>InitRebalanceState</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>shardPlacementList</name></expr></argument>,
								   <argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rebalanceStates</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rebalanceStates</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<macro><name>foreach_ptr</name><argument_list>(<argument>state</argument>, <argument>rebalanceStates</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>placementUpdateList</name></name> <operator>=</operator> <name>placementUpdateList</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MoveShardsAwayFromDisallowedNodes</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>placementUpdateList</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>placementUpdateList</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>drainOnly</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach_ptr</name><argument_list>(<argument>state</argument>, <argument>rebalanceStates</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>placementUpdateList</name></name> <operator>=</operator> <name>placementUpdateList</name></expr>;</expr_stmt>

			<comment type="block">/* calculate lower bound for placement count */</comment>
			<decl_stmt><decl><type><name>float4</name></type> <name>averageUtilization</name> <init>= <expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>totalCost</name></name> <operator>/</operator> <name><name>state</name><operator>-&gt;</operator><name>totalCapacity</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name></type> <name>utilizationLowerBound</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>threshold</name><operator>)</operator> <operator>*</operator> <name>averageUtilization</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>float4</name></type> <name>utilizationUpperBound</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">1.0</literal> <operator>+</operator> <name>threshold</name><operator>)</operator> <operator>*</operator> <name>averageUtilization</name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>moreMovesAvailable</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>placementUpdateList</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>maxShardMoves</name> <operator>&amp;&amp;</operator>
				   <name>moreMovesAvailable</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>moreMovesAvailable</name> <operator>=</operator> <call><name>FindAndMoveShardCost</name><argument_list>(
					<argument><expr><name>utilizationLowerBound</name></expr></argument>,
					<argument><expr><name>utilizationUpperBound</name></expr></argument>,
					<argument><expr><name>improvementThreshold</name></expr></argument>,
					<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><name>placementUpdateList</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>placementUpdateList</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>moreMovesAvailable</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
									 <argument><expr><literal type="string">"Stopped searching before we were out of moves. "</literal>
									 <literal type="string">"Please rerun the rebalancer after it's finished "</literal>
									 <literal type="string">"for a more optimal placement."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>state</argument>, <argument>rebalanceStates</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>placementsHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>int64</name></type> <name>ignoredMoves</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>state</argument>, <argument>rebalanceStates</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>ignoredMoves</name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>ignoredMoves</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>ignoredMoves</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>MaxRebalancerLoggedIgnoredMoves</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
			<name>ignoredMoves</name> <operator>&lt;=</operator> <name>MaxRebalancerLoggedIgnoredMoves</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"Ignored %ld moves, all of which are shown in notices above"</literal></expr></argument>,
							<argument><expr><name>ignoredMoves</name></expr></argument>
							)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(
							<argument><expr><literal type="string">"If you do want these moves to happen, try changing improvement_threshold to a lower value than what it is now (%g)."</literal></expr></argument>,
							<argument><expr><name>improvementThreshold</name></expr></argument>)</argument_list></call>
						<operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"Ignored %ld moves, %d of which are shown in notices above"</literal></expr></argument>,
							<argument><expr><name>ignoredMoves</name></expr></argument>,
							<argument><expr><name>MaxRebalancerLoggedIgnoredMoves</name></expr></argument>
							)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(
							<argument><expr><literal type="string">"If you do want these moves to happen, try changing improvement_threshold to a lower value than what it is now (%g)."</literal></expr></argument>,
							<argument><expr><name>improvementThreshold</name></expr></argument>)</argument_list></call>
						<operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>placementUpdateList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InitRebalanceState sets up a RebalanceState for it's arguments. The
 * RebalanceState contains the information needed to calculate shard moves.
 */</comment>
<function><type><specifier>static</specifier> <name>RebalanceState</name> <modifier>*</modifier></type>
<name>InitRebalanceState</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name></decl></parameter>,
				   <parameter><decl><type><name>RebalancePlanFunctions</name> <modifier>*</modifier></type><name>functions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RebalanceState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <name>functions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>placementsHash</name></name> <operator>=</operator> <call><name>ShardPlacementsListToHash</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create empty fill state for all of the worker nodes */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>fillState</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeFillState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>fillState</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>workerNode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fillState</name><operator>-&gt;</operator><name>capacity</name></name> <operator>=</operator> <call><name><name>functions</name><operator>-&gt;</operator><name>nodeCapacity</name></name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name><name>functions</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set the utilization here although the totalCost is not set yet. This
		 * is needed to set the utilization to INFINITY when the capacity is 0.
		 */</comment>
		<expr_stmt><expr><name><name>fillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>=</operator> <call><name>CalculateUtilization</name><argument_list>(<argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>totalCost</name></name></expr></argument>,
													  <argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListAsc</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListAsc</name></name></expr></argument>, <argument><expr><name>fillState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListDesc</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListDesc</name></name></expr></argument>, <argument><expr><name>fillState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>totalCapacity</name></name> <operator>+=</operator> <name><name>fillState</name><operator>-&gt;</operator><name>capacity</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Fill the fill states for all of the worker nodes based on the placements */</comment>
	<macro><name>foreach_htab</name><argument_list>(<argument>placement</argument>, <argument>&amp;status</argument>, <argument>state-&gt;placementsHash</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardCost</name> <modifier>*</modifier></type><name>shardCost</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardCost</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>fillState</name> <init>= <expr><call><name>FindFillStateForPlacement</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>placement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fillState</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>shardCost</name> <operator>=</operator> <call><name><name>functions</name><operator>-&gt;</operator><name>shardCost</name></name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>, <argument><expr><name><name>functions</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fillState</name><operator>-&gt;</operator><name>totalCost</name></name> <operator>+=</operator> <name><name>shardCost</name><operator>-&gt;</operator><name>cost</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>=</operator> <call><name>CalculateUtilization</name><argument_list>(<argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>totalCost</name></name></expr></argument>,
													  <argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fillState</name><operator>-&gt;</operator><name>shardCostListDesc</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>shardCostListDesc</name></name></expr></argument>,
											   <argument><expr><name>shardCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fillState</name><operator>-&gt;</operator><name>shardCostListDesc</name></name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>shardCostListDesc</name></name></expr></argument>,
												<argument><expr><name>CompareShardCostDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>totalCost</name></name> <operator>+=</operator> <name><name>shardCost</name><operator>-&gt;</operator><name>cost</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>functions</name><operator>-&gt;</operator><name>shardAllowedOnNode</name></name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>, <argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,
										   <argument><expr><name><name>functions</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DisallowedPlacement</name> <modifier>*</modifier></type><name>disallowed</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DisallowedPlacement</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>disallowed</name><operator>-&gt;</operator><name>shardCost</name></name> <operator>=</operator> <name>shardCost</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>disallowed</name><operator>-&gt;</operator><name>fillState</name></name> <operator>=</operator> <name>fillState</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>disallowedPlacementList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>disallowedPlacementList</name></name></expr></argument>,
													 <argument><expr><name>disallowed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>foreach_htab_cleanup</name><argument_list>(<argument><expr><name>placement</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListAsc</name></name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListAsc</name></name></expr></argument>, <argument><expr><name>CompareNodeFillStateAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListDesc</name></name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListDesc</name></name></expr></argument>,
										<argument><expr><name>CompareNodeFillStateDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckRebalanceStateInvariants</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CalculateUtilization returns INFINITY when capacity is 0 and
 * totalCost/capacity otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>float4</name></type>
<name>CalculateUtilization</name><parameter_list>(<parameter><decl><type><name>float4</name></type> <name>totalCost</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>capacity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>capacity</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>INFINITY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>totalCost</name> <operator>/</operator> <name>capacity</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindFillStateForPlacement finds the fillState for the workernode that
 * matches the placement.
 */</comment>
<function><type><specifier>static</specifier> <name>NodeFillState</name> <modifier>*</modifier></type>
<name>FindFillStateForPlacement</name><parameter_list>(<parameter><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>fillState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Find the correct fill state to add the placement to and do that */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>fillState</argument>, <argument>state-&gt;fillStateListAsc</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsPlacementOnWorkerNode</name><argument_list>(<argument><expr><name>placement</name></expr></argument>, <argument><expr><name><name>fillState</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>fillState</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareNodeFillStateAsc can be used to sort fill states from empty to full.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareNodeFillStateAsc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>NodeFillState</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>NodeFillState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>void1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>NodeFillState</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>NodeFillState</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>void2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>utilization</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>utilization</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>utilization</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>utilization</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If utilization prefer nodes with more capacity, since utilization will
	 * grow slower on those
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>capacity</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>capacity</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>capacity</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>capacity</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Finally differentiate by node id */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>nodeId</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareNodeFillStateDesc can be used to sort fill states from full to empty.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareNodeFillStateDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>-</operator><call><name>CompareNodeFillStateAsc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareShardCostAsc can be used to sort shard costs from low cost to high
 * cost.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareShardCostAsc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShardCost</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ShardCost</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>void1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShardCost</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ShardCost</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>void2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>cost</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>cost</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>cost</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>cost</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make compare function (more) stable for tests */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>shardId</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>shardId</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>shardId</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareShardCostDesc can be used to sort shard costs from high cost to low
 * cost.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareShardCostDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>-</operator><call><name>CompareShardCostAsc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MoveShardsAwayFromDisallowedNodes returns a list of placement updates that
 * move any shards that are not allowed on their current node to a node that
 * they are allowed on.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MoveShardsAwayFromDisallowedNodes</name><parameter_list>(<parameter><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DisallowedPlacement</name> <modifier>*</modifier></type><name>disallowedPlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>disallowedPlacementList</name></name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>disallowedPlacementList</name></name></expr></argument>,
											  <argument><expr><name>CompareDisallowedPlacementDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Move shards off of nodes they are not allowed on */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>disallowedPlacement</argument>, <argument>state-&gt;disallowedPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>targetFillState</name> <init>= <expr><call><name>FindAllowedTargetFillState</name><argument_list>(
			<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>disallowedPlacement</name><operator>-&gt;</operator><name>shardCost</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>targetFillState</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								  <argument><expr><literal type="string">"Not allowed to move shard "</literal> <name>UINT64_FORMAT</name>
								  <literal type="string">" anywhere from %s:%d"</literal></expr></argument>,
								  <argument><expr><name><name>disallowedPlacement</name><operator>-&gt;</operator><name>shardCost</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
								  <argument><expr><name><name>disallowedPlacement</name><operator>-&gt;</operator><name>fillState</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
								  <argument><expr><name><name>disallowedPlacement</name><operator>-&gt;</operator><name>fillState</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>
								  )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>MoveShardCost</name><argument_list>(<argument><expr><name><name>disallowedPlacement</name><operator>-&gt;</operator><name>fillState</name></name></expr></argument>,
					  <argument><expr><name>targetFillState</name></expr></argument>,
					  <argument><expr><name><name>disallowedPlacement</name><operator>-&gt;</operator><name>shardCost</name></name></expr></argument>,
					  <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CompareDisallowedPlacementAsc can be used to sort disallowed placements from
 * low cost to high cost.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareDisallowedPlacementAsc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>void2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DisallowedPlacement</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>DisallowedPlacement</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>void1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DisallowedPlacement</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>DisallowedPlacement</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>void2</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>CompareShardCostAsc</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>shardCost</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>shardCost</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareDisallowedPlacementDesc can be used to sort disallowed placements from
 * high cost to low cost.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareDisallowedPlacementDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>-</operator><call><name>CompareDisallowedPlacementAsc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindAllowedTargetFillState finds the first fill state in fillStateListAsc
 * where the shard can be moved to.
 */</comment>
<function><type><specifier>static</specifier> <name>NodeFillState</name> <modifier>*</modifier></type>
<name>FindAllowedTargetFillState</name><parameter_list>(<parameter><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>targetFillState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetFillState</argument>, <argument>state-&gt;fillStateListAsc</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>hasShard</name> <init>= <expr><call><name>PlacementsHashFind</name><argument_list>(
			<argument><expr><name><name>state</name><operator>-&gt;</operator><name>placementsHash</name></name></expr></argument>,
			<argument><expr><name>shardId</name></expr></argument>,
			<argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasShard</name> <operator>&amp;&amp;</operator> <call><name><name>state</name><operator>-&gt;</operator><name>functions</name><operator>-&gt;</operator><name>shardAllowedOnNode</name></name><argument_list>(
				<argument><expr><name>shardId</name></expr></argument>,
				<argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,
				<argument><expr><name><name>state</name><operator>-&gt;</operator><name>functions</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>targetFillState</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MoveShardCost moves a shardcost from the source to the target fill states
 * and updates the RebalanceState accordingly. What it does in detail is:
 * 1. add a placement update to state-&gt;placementUpdateList
 * 2. update state-&gt;placementsHash
 * 3. update totalcost, utilization and shardCostListDesc in source and target
 * 4. resort state-&gt;fillStateListAsc/Desc
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MoveShardCost</name><parameter_list>(<parameter><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>sourceFillState</name></decl></parameter>,
			  <parameter><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>targetFillState</name></decl></parameter>,
			  <parameter><decl><type><name>ShardCost</name> <modifier>*</modifier></type><name>shardCost</name></decl></parameter>,
			  <parameter><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardIdToMove</name> <init>= <expr><name><name>shardCost</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* construct the placement update */</comment>
	<decl_stmt><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>placementUpdateEvent</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlacementUpdateEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>updateType</name></name> <operator>=</operator> <name>PLACEMENT_UPDATE_MOVE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name>shardIdToMove</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>sourceNode</name></name> <operator>=</operator> <name><name>sourceFillState</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>targetNode</name></name> <operator>=</operator> <name><name>targetFillState</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>

	<comment type="block">/* record the placement update */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>placementUpdateList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>placementUpdateList</name></name></expr></argument>,
										 <argument><expr><name>placementUpdateEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update the placements hash and the node shard lists */</comment>
	<expr_stmt><expr><call><name>PlacementsHashRemove</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>placementsHash</name></name></expr></argument>, <argument><expr><name>shardIdToMove</name></expr></argument>, <argument><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PlacementsHashEnter</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>placementsHash</name></name></expr></argument>, <argument><expr><name>shardIdToMove</name></expr></argument>, <argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>totalCost</name></name> <operator>-=</operator> <name><name>shardCost</name><operator>-&gt;</operator><name>cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>=</operator> <call><name>CalculateUtilization</name><argument_list>(<argument><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>totalCost</name></name></expr></argument>,
														<argument><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>shardCostListDesc</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(
		<argument><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>shardCostListDesc</name></name></expr></argument>,
		<argument><expr><name>shardCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>totalCost</name></name> <operator>+=</operator> <name><name>shardCost</name><operator>-&gt;</operator><name>cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>=</operator> <call><name>CalculateUtilization</name><argument_list>(<argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>totalCost</name></name></expr></argument>,
														<argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>shardCostListDesc</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>shardCostListDesc</name></name></expr></argument>,
												 <argument><expr><name>shardCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>shardCostListDesc</name></name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>shardCostListDesc</name></name></expr></argument>,
												  <argument><expr><name>CompareShardCostDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListAsc</name></name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListAsc</name></name></expr></argument>, <argument><expr><name>CompareNodeFillStateAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListDesc</name></name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fillStateListDesc</name></name></expr></argument>,
										<argument><expr><name>CompareNodeFillStateDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckRebalanceStateInvariants</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FindAndMoveShardCost is the main rebalancing algorithm. This takes the
 * current state and returns a list with a new move appended that improves the
 * balance of shards. The algorithm is greedy and will use the first new move
 * that improves the balance. It finds nodes by trying to move a shard from the
 * most utilized node (highest utilization) to the emptiest node (lowest
 * utilization). If no moves are possible it will try the second emptiest node
 * until it tried all of them. Then it wil try the second fullest node. If it
 * was able to find a move it will return true and false if it couldn't.
 *
 * This algorithm won't necessarily result in the best possible balance. Getting
 * the best balance is an NP problem, so it's not feasible to go for the best
 * balance. This algorithm was chosen because of the following reasons:
 * 1. Literature research showed that similar problems would get within 2X of
 *    the optimal balance with a greedy algoritm.
 * 2. Every move will always improve the balance. So if the user stops a
 *    rebalance midway through, they will never be in a worse situation than
 *    before.
 * 3. It's pretty easy to reason about.
 * 4. It's simple to implement.
 *
 * utilizationLowerBound and utilizationUpperBound are used to indicate what
 * the target utilization range of all nodes is. If they are within this range,
 * then balance is good enough. If all nodes are in this range then the cluster
 * is considered balanced and no more moves are done. This is mostly useful for
 * the by_disk_size rebalance strategy. If we wouldn't have this then the
 * rebalancer could become flappy in certain cases.
 *
 * improvementThreshold is a threshold that can be used to ignore moves when
 * they only improve the balance a little relative to the cost of the shard.
 * Again this is mostly useful for the by_disk_size rebalance strategy.
 * Without this threshold the rebalancer would move a shard of 1TB when this
 * move only improves the cluster by 10GB.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FindAndMoveShardCost</name><parameter_list>(<parameter><decl><type><name>float4</name></type> <name>utilizationLowerBound</name></decl></parameter>,
					 <parameter><decl><type><name>float4</name></type> <name>utilizationUpperBound</name></decl></parameter>,
					 <parameter><decl><type><name>float4</name></type> <name>improvementThreshold</name></decl></parameter>,
					 <parameter><decl><type><name>RebalanceState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>sourceFillState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeFillState</name> <modifier>*</modifier></type><name>targetFillState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * find a source node for the move, starting at the node with the highest
	 * utilization
	 */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>sourceFillState</argument>, <argument>state-&gt;fillStateListDesc</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* Don't move shards away from nodes that are already too empty, we're
		 * done searching */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>&lt;=</operator> <name>utilizationLowerBound</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* find a target node for the move, starting at the node with the
		 * lowest utilization */</comment>
		<macro><name>foreach_ptr</name><argument_list>(<argument>targetFillState</argument>, <argument>state-&gt;fillStateListAsc</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardCost</name> <modifier>*</modifier></type><name>shardCost</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Don't add more shards to nodes that are already at the upper
			 * bound. We should try the next source node now because further
			 * target nodes will also be above the upper bound */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>targetFillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>&gt;=</operator> <name>utilizationUpperBound</name></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Don't move a shard between nodes that both have decent
			 * utilization. We should try the next source node now because
			 * further target nodes will also have have decent utilization */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>targetFillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>&gt;=</operator> <name>utilizationLowerBound</name> <operator>&amp;&amp;</operator>
				<name><name>sourceFillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>&lt;=</operator> <name>utilizationUpperBound</name></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* find a shardcost that can be moved between between nodes that
			 * makes the cost distribution more equal */</comment>
			<macro><name>foreach_ptr</name><argument_list>(<argument>shardCost</argument>, <argument>sourceFillState-&gt;shardCostListDesc</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>targetHasShard</name> <init>= <expr><call><name>PlacementsHashFind</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>placementsHash</name></name></expr></argument>,
														 <argument><expr><name><name>shardCost</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
														 <argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>float4</name></type> <name>newTargetTotalCost</name> <init>= <expr><name><name>targetFillState</name><operator>-&gt;</operator><name>totalCost</name></name> <operator>+</operator> <name><name>shardCost</name><operator>-&gt;</operator><name>cost</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>float4</name></type> <name>newTargetUtilization</name> <init>= <expr><call><name>CalculateUtilization</name><argument_list>(
					<argument><expr><name>newTargetTotalCost</name></expr></argument>,
					<argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>float4</name></type> <name>newSourceTotalCost</name> <init>= <expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>totalCost</name></name> <operator>-</operator> <name><name>shardCost</name><operator>-&gt;</operator><name>cost</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>float4</name></type> <name>newSourceUtilization</name> <init>= <expr><call><name>CalculateUtilization</name><argument_list>(
					<argument><expr><name>newSourceTotalCost</name></expr></argument>,
					<argument><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Skip shards that already are on the node */</comment>
				<if_stmt><if>if <condition>(<expr><name>targetHasShard</name></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Skip shards that already are not allowed on the node */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>state</name><operator>-&gt;</operator><name>functions</name><operator>-&gt;</operator><name>shardAllowedOnNode</name></name><argument_list>(<argument><expr><name><name>shardCost</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
														  <argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,
														  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>functions</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * If the target is still less utilized than the source, then
				 * this is clearly a good move. And if they are equally
				 * utilized too.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>newTargetUtilization</name> <operator>&lt;=</operator> <name>newSourceUtilization</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>MoveShardCost</name><argument_list>(<argument><expr><name>sourceFillState</name></expr></argument>, <argument><expr><name>targetFillState</name></expr></argument>,
								  <argument><expr><name>shardCost</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * The target is now more utilized than the source. So we need
				 * to determine if the move is a net positive for the overall
				 * cost distribution. This means that the new highest
				 * utilization of source and target is lower than the previous
				 * highest, or the highest utilization is the same, but the
				 * lowest increased.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>newTargetUtilization</name> <operator>&gt;</operator> <name><name>sourceFillState</name><operator>-&gt;</operator><name>utilization</name></name></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>newTargetUtilization</name> <operator>==</operator> <name><name>sourceFillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>&amp;&amp;</operator>
					<name>newSourceUtilization</name> <operator>&lt;=</operator> <name><name>targetFillState</name><operator>-&gt;</operator><name>utilization</name></name></expr>
					)</condition> <comment type="block">/* lgtm[cpp/equality-on-floats] */</comment>
				<block>{<block_content>
					<comment type="block">/*
					 * this can trigger when capacity of the nodes is not the
					 * same. Example (also a test):
					 * - node with capacity 3
					 * - node with capacity 1
					 * - 3 shards with cost 1
					 * Best distribution would be 2 shards on node with
					 * capacity 3 and one on node with capacity 1
					 */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * fmaxf and fminf here are only needed for cases when nodes
				 * have different capacities. If they are the same, then both
				 * arguments are equal.
				 */</comment>
				<decl_stmt><decl><type><name>float4</name></type> <name>utilizationImprovement</name> <init>= <expr><call><name>fmaxf</name><argument_list>(
					<argument><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>-</operator> <name>newTargetUtilization</name></expr></argument>,
					<argument><expr><name>newSourceUtilization</name> <operator>-</operator> <name><name>targetFillState</name><operator>-&gt;</operator><name>utilization</name></name></expr></argument>
					)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>float4</name></type> <name>utilizationAddedByShard</name> <init>= <expr><call><name>fminf</name><argument_list>(
					<argument><expr><name>newTargetUtilization</name> <operator>-</operator> <name><name>targetFillState</name><operator>-&gt;</operator><name>utilization</name></name></expr></argument>,
					<argument><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>utilization</name></name> <operator>-</operator> <name>newSourceUtilization</name></expr></argument>
					)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the shard causes a lot of utilization, but the
				 * improvement which is gained by moving it is small, then we
				 * ignore the move. Probably there are other shards that are
				 * better candidates, and in any case it's probably not worth
				 * the effort to move the this shard.
				 *
				 * One of the main cases this tries to avoid is the rebalancer
				 * moving a very large shard with the "by_disk_size" strategy
				 * when that only gives a small benefit in data distribution.
				 */</comment>
				<decl_stmt><decl><type><name>float4</name></type> <name>normalizedUtilizationImprovement</name> <init>= <expr><name>utilizationImprovement</name> <operator>/</operator>
														  <name>utilizationAddedByShard</name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>normalizedUtilizationImprovement</name> <operator>&lt;</operator> <name>improvementThreshold</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ignoredMoves</name></name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>MaxRebalancerLoggedIgnoredMoves</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
						<name><name>state</name><operator>-&gt;</operator><name>ignoredMoves</name></name> <operator>&lt;=</operator> <name>MaxRebalancerLoggedIgnoredMoves</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator>
									<call><name>errmsg</name><argument_list>(
										<argument><expr><literal type="string">"Ignoring move of shard %ld from %s:%d to %s:%d, because the move only brings a small improvement relative to the shard its size"</literal></expr></argument>,
										<argument><expr><name><name>shardCost</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
										<argument><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
										<argument><expr><name><name>sourceFillState</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
										<argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
										<argument><expr><name><name>targetFillState</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>
										)</argument_list></call><operator>,</operator>
									<call><name>errdetail</name><argument_list>(
										<argument><expr><literal type="string">"The balance improvement of %g is lower than the improvement_threshold of %g"</literal></expr></argument>,
										<argument><expr><name>normalizedUtilizationImprovement</name></expr></argument>,
										<argument><expr><name>improvementThreshold</name></expr></argument>
										)</argument_list></call>
									<operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>MoveShardCost</name><argument_list>(<argument><expr><name>sourceFillState</name></expr></argument>, <argument><expr><name>targetFillState</name></expr></argument>,
							  <argument><expr><name>shardCost</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>
		</block_content>}</block>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReplicationPlacementUpdates returns a list of placement updates which
 * replicates shard placements that need re-replication. To do this, the
 * function loops over the active shard placements, and for each shard placement
 * which needs to be re-replicated, it chooses an active worker node with
 * smallest number of shards as the target node.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ReplicationPlacementUpdates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeShardPlacementList</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>shardReplicationFactor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementUpdateList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardPlacementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>workerNodeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>placementsHash</name> <init>= <expr><call><name>ShardPlacementsListToHash</name><argument_list>(<argument><expr><name>activeShardPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>workerNodeCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get number of shards per node */</comment>
	<decl_stmt><decl><type><name>uint32</name> <modifier>*</modifier></type><name>shardCountArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>workerNodeCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>shardPlacementCell</argument>, <argument>activeShardPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>shardPlacementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>workerNodeIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>workerNodeIndex</name> <operator>&lt;</operator> <name>workerNodeCount</name></expr>;</condition> <incr><expr><name>workerNodeIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>workerNodeIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>placement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>node</name><operator>-&gt;</operator><name>workerPort</name></name> <operator>==</operator> <name><name>placement</name><operator>-&gt;</operator><name>nodePort</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>shardCountArray</name><index>[<expr><name>workerNodeIndex</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<macro><name>foreach</name><argument_list>(<argument>shardPlacementCell</argument>, <argument>activeShardPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>targetNodeShardCount</name> <init>= <expr><name>UINT_MAX</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>targetNodeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardPlacementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* skip the shard placement if it has enough replications */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>activePlacementCount</name> <init>= <expr><call><name>ShardActivePlacementCount</name><argument_list>(<argument><expr><name>placementsHash</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
															 <argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>activePlacementCount</name> <operator>&gt;=</operator> <name>shardReplicationFactor</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We can copy the shard from any active worker node that contains the
		 * shard.
		 */</comment>
		<for>for <control>(<init><expr><name>workerNodeIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>workerNodeIndex</name> <operator>&lt;</operator> <name>workerNodeCount</name></expr>;</condition> <incr><expr><name>workerNodeIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>workerNodeIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>placementExists</name> <init>= <expr><call><name>PlacementsHashFind</name><argument_list>(<argument><expr><name>placementsHash</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
													  <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>placementExists</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>sourceNode</name> <operator>=</operator> <name>workerNode</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If we couldn't find any worker node which contains the shard, then
		 * all copies of the shard are list and we should error out.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>sourceNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find a source for shard "</literal> <name>UINT64_FORMAT</name></expr></argument>,
								   <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We can copy the shard to any worker node that doesn't contain the shard.
		 * Among such worker nodes, we choose the worker node with minimum shard
		 * count as the target.
		 */</comment>
		<for>for <control>(<init><expr><name>workerNodeIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>workerNodeIndex</name> <operator>&lt;</operator> <name>workerNodeCount</name></expr>;</condition> <incr><expr><name>workerNodeIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>workerNodeIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NodeCanHaveDistTablePlacements</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* never replicate placements to nodes that should not have placements */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* skip this node if it already contains the shard */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>placementExists</name> <init>= <expr><call><name>PlacementsHashFind</name><argument_list>(<argument><expr><name>placementsHash</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
													  <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>placementExists</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* compare and change the target node */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>shardCountArray</name><index>[<expr><name>workerNodeIndex</name></expr>]</index></name> <operator>&lt;</operator> <name>targetNodeShardCount</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>targetNode</name> <operator>=</operator> <name>workerNode</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>targetNodeShardCount</name> <operator>=</operator> <name><name>shardCountArray</name><index>[<expr><name>workerNodeIndex</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>targetNodeIndex</name> <operator>=</operator> <name>workerNodeIndex</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * If there is no worker node which doesn't contain the shard, then the
		 * shard replication factor is greater than number of worker nodes, and
		 * we should error out.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>targetNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find a target for shard "</literal> <name>UINT64_FORMAT</name></expr></argument>,
								   <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* construct the placement update */</comment>
		<decl_stmt><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>placementUpdateEvent</name> <init>= <expr><call><name>palloc0</name><argument_list>(
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlacementUpdateEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>updateType</name></name> <operator>=</operator> <name>PLACEMENT_UPDATE_COPY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>sourceNode</name></name> <operator>=</operator> <name>sourceNode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>targetNode</name></name> <operator>=</operator> <name>targetNode</name></expr>;</expr_stmt>

		<comment type="block">/* record the placement update */</comment>
		<expr_stmt><expr><name>placementUpdateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>placementUpdateList</name></expr></argument>, <argument><expr><name>placementUpdateEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* update the placements hash and the shard count array */</comment>
		<expr_stmt><expr><call><name>PlacementsHashEnter</name><argument_list>(<argument><expr><name>placementsHash</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>targetNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardCountArray</name><index>[<expr><name>targetNodeIndex</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>placementsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>placementUpdateList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardActivePlacementCount returns the number of active placements for the
 * given shard which are placed at the active worker nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ShardActivePlacementCount</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>activePlacementsHash</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWorkerNodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>shardActivePlacementCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>workerNodeCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>workerNodeCell</argument>, <argument>activeWorkerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>workerNodeCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>placementExists</name> <init>= <expr><call><name>PlacementsHashFind</name><argument_list>(<argument><expr><name>activePlacementsHash</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
												  <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>placementExists</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>shardActivePlacementCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>shardActivePlacementCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardPlacementsListToHash creates and returns a hash set from a shard
 * placement list.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>ShardPlacementsListToHash</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardPlacementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardPlacementCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>PlacementsHashHashCode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>PlacementsHashCompare</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name> <operator>|</operator> <name>HASH_CONTEXT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardPlacementsHash</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ActivePlacements Hash"</literal></expr></argument>,
											<argument><expr><name>shardPlacementCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>shardPlacementCell</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>shardPlacement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardPlacementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hashKey</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>shardPlacement</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>shardPlacementsHash</name></expr></argument>, <argument><expr><name>hashKey</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>shardPlacementsHash</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementsHashFind returns true if there exists a shard placement with the
 * given workerNode and shard id in the given placements hash, otherwise it
 * returns false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PlacementsHashFind</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>placementsHash</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>placementFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardPlacement</name></type> <name>shardPlacement</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardPlacement</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>shardPlacement</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>shardPlacement</name><operator>.</operator><name>shardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardPlacement</name><operator>.</operator><name>nodeName</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardPlacement</name><operator>.</operator><name>nodePort</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hashKey</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>shardPlacement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>placementsHash</name></expr></argument>, <argument><expr><name>hashKey</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>placementFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>placementFound</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementsHashEnter enters a shard placement for the given worker node and
 * shard id to the given placements hash.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PlacementsHashEnter</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>placementsHash</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardPlacement</name></type> <name>shardPlacement</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardPlacement</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>shardPlacement</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>shardPlacement</name><operator>.</operator><name>shardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardPlacement</name><operator>.</operator><name>nodeName</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardPlacement</name><operator>.</operator><name>nodePort</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hashKey</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>shardPlacement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>placementsHash</name></expr></argument>, <argument><expr><name>hashKey</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementsHashRemove removes the shard placement for the given worker node and
 * shard id from the given placements hash.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PlacementsHashRemove</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>placementsHash</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardPlacement</name></type> <name>shardPlacement</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardPlacement</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>shardPlacement</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>shardPlacement</name><operator>.</operator><name>shardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardPlacement</name><operator>.</operator><name>nodeName</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardPlacement</name><operator>.</operator><name>nodePort</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hashKey</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>shardPlacement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>placementsHash</name></expr></argument>, <argument><expr><name>hashKey</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementsHashCompare compares two shard placements using shard id, node name,
 * and node port number.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>PlacementsHashCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>lhsKey</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rhsKey</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keySize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type><name>placementLhs</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <name>lhsKey</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type><name>placementRhs</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <name>rhsKey</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>shardIdCompare</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* first, compare by shard id */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>placementLhs</name><operator>-&gt;</operator><name>shardId</name></name> <operator>&lt;</operator> <name><name>placementRhs</name><operator>-&gt;</operator><name>shardId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardIdCompare</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>placementLhs</name><operator>-&gt;</operator><name>shardId</name></name> <operator>&gt;</operator> <name><name>placementRhs</name><operator>-&gt;</operator><name>shardId</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardIdCompare</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shardIdCompare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>shardIdCompare</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* then, compare by node name */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nodeNameCompare</name> <init>= <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>placementLhs</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>, <argument><expr><name><name>placementRhs</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
								  <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>nodeNameCompare</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>nodeNameCompare</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finally, compare by node port */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nodePortCompare</name> <init>= <expr><name><name>placementLhs</name><operator>-&gt;</operator><name>nodePort</name></name> <operator>-</operator> <name><name>placementRhs</name><operator>-&gt;</operator><name>nodePort</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>nodePortCompare</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementsHashHashCode computes the hash code for a shard placement from the
 * placement's shard id, node name, and node port number.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>PlacementsHashHashCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keySize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64</name> <modifier>*</modifier></type><name>shardId</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>placement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint32</name> <modifier>*</modifier></type><name>nodePort</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>placement</name><operator>-&gt;</operator><name>nodePort</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* standard hash function outlined in Effective Java, Item 8 */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>result</name> <init>= <expr><literal type="number">17</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">37</literal> <operator>*</operator> <name>result</name> <operator>+</operator> <call><name>tag_hash</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">37</literal> <operator>*</operator> <name>result</name> <operator>+</operator> <call><name>string_hash</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">37</literal> <operator>*</operator> <name>result</name> <operator>+</operator> <call><name>tag_hash</name><argument_list>(<argument><expr><name>nodePort</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* WorkerNodeListContains checks if the worker node exists in the given list. */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>WorkerNodeListContains</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>workerName</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>workerPort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>workerNodeListContains</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>workerNodeCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>workerNodeCell</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>workerNodeCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name>workerName</name></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name> <operator>==</operator> <name>workerPort</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>workerNodeListContains</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>workerNodeListContains</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateColocatedShardPlacementProgress updates the progress of the given placement,
 * along with its colocated placements, to the given state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateColocatedShardPlacementProgress</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourcePort</name></decl></parameter>,
									  <parameter><decl><type><name>uint64</name></type> <name>progress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ProgressMonitorData</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><call><name>GetCurrentProgressMonitor</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>header</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>steps</name> <init>= <expr><call><name>ProgressMonitorSteps</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedShardIntervalCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardIntervalList</name> <init>= <expr><call><name>ColocatedShardIntervalList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>moveIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>moveIndex</name> <operator>&lt;</operator> <name><name>header</name><operator>-&gt;</operator><name>stepCount</name></name></expr>;</condition> <incr><expr><name>moveIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><name>steps</name> <operator>+</operator> <name>moveIndex</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>currentShardId</name> <init>= <expr><name><name>step</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>colocatedShard</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>colocatedShardIntervalCell</argument>, <argument>colocatedShardIntervalList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>candidateShard</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>colocatedShardIntervalCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>candidateShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>==</operator> <name>currentShardId</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>colocatedShard</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>colocatedShard</name> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourceName</name></name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>step</name><operator>-&gt;</operator><name>sourcePort</name></name> <operator>==</operator> <name>sourcePort</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>step</name><operator>-&gt;</operator><name>progress</name></name></expr></argument>, <argument><expr><name>progress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * pg_dist_rebalance_strategy_enterprise_check is a now removed function, but
 * to avoid issues during upgrades a C stub is kept.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_dist_rebalance_strategy_enterprise_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_validate_rebalance_strategy_functions checks all the functions for
 * their correct signature.
 *
 * SQL signature:
 *
 * citus_validate_rebalance_strategy_functions(
 *     shard_cost_function regproc,
 *     node_capacity_function regproc,
 *     shard_allowed_on_node_function regproc,
 * ) RETURNS VOID
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_validate_rebalance_strategy_functions</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureShardCostUDF</name><argument_list>(<argument><expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureNodeCapacityUDF</name><argument_list>(<argument><expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureShardAllowedOnNodeUDF</name><argument_list>(<argument><expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureShardCostUDF checks that the UDF matching the oid has the correct
 * signature to be used as a ShardCost function. The expected signature is:
 *
 * shard_cost(shardid bigint) returns float4
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureShardCostUDF</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cache lookup failed for shard_cost_function with oid %u"</literal></expr></argument>,
							   <argument><expr><name>functionOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procForm</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procForm</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"signature for shard_cost_function is incorrect"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"number of arguments of %s should be 1, not %i"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>procForm</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>INT8OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"signature for shard_cost_function is incorrect"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"argument type of %s should be bigint"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>FLOAT4OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"signature for shard_cost_function is incorrect"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"return type of %s should be real"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureNodeCapacityUDF checks that the UDF matching the oid has the correct
 * signature to be used as a NodeCapacity function. The expected signature is:
 *
 * node_capacity(nodeid int) returns float4
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureNodeCapacityUDF</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"cache lookup failed for node_capacity_function with oid %u"</literal></expr></argument>,
							<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procForm</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procForm</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"signature for node_capacity_function is incorrect"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"number of arguments of %s should be 1, not %i"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>procForm</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>INT4OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"signature for node_capacity_function is incorrect"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"argument type of %s should be int"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>FLOAT4OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"signature for node_capacity_function is incorrect"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"return type of %s should be real"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureShardAllowedOnNodeUDF checks that the UDF matching the oid has the correct
 * signature to be used as a NodeCapacity function. The expected signature is:
 *
 * shard_allowed_on_node(shardid bigint, nodeid int) returns boolean
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureShardAllowedOnNodeUDF</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"cache lookup failed for shard_allowed_on_node_function with oid %u"</literal></expr></argument>,
							<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procForm</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procForm</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"signature for shard_allowed_on_node_function is incorrect"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"number of arguments of %s should be 2, not %i"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>procForm</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>INT8OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"signature for shard_allowed_on_node_function is incorrect"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"type of first argument of %s should be bigint"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>INT4OID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"signature for shard_allowed_on_node_function is incorrect"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"type of second argument of %s should be int"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>prorettype</name></name> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"signature for shard_allowed_on_node_function is incorrect"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"return type of %s should be boolean"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
