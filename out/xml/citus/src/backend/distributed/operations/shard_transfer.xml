<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/operations/shard_transfer.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * shard_transfer.c
 *
 * This file contains functions to transfer shards between nodes.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/statvfs.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/adaptive_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_cleaner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_replication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_rebalancer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_split.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_transfer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/errcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/* local type declarations */</comment>

<comment type="block">/*
 * ShardInterval along with to be executed
 * DDL command list.
 */</comment>
<typedef>typedef <type><struct>struct <name>ShardCommandList</name>
<block>{
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name></decl>;</decl_stmt>
}</block></struct></type> <name>ShardCommandList</name>;</typedef>

<comment type="block">/* local function forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CanUseLogicalReplication</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>shardReplicationMode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfTableCannotBeReplicated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfTargetNodeIsNotSafeToCopyTo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfSameNode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceNodePort</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetNodePort</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operationName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReplicateColocatedShardPlacement</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
											 <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
											 <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>,
											 <parameter><decl><type><name>char</name></type> <name>shardReplicationMode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyShardTables</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
							<parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
							<parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useLogicalReplication</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyShardTablesViaLogicalReplication</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>,
												 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
												 <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>,
												 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
												 <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyShardTablesViaBlockWrites</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
										  <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>,
										  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureShardCanBeCopied</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
								   <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
								   <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>RecreateTableDDLCommandList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureTableListOwner</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureTableListSuitableForReplication</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MarkForDropColocatedShardPlacement</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>,
											   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>,
											   <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateColocatedShardPlacementMetadataOnWorkers</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>,
														   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
														   <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>,
														   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
														   <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsShardListOnNode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
							  <parameter><decl><type><name>uint32</name></type> <name>targetPort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckSpaceConstraints</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
								  <parameter><decl><type><name>uint64</name></type> <name>colocationSizeInBytes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureEnoughDiskSpaceForShardMove</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name></decl></parameter>,
											  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>sourceNodePort</name></decl></parameter>,
											  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type>
											  <name>targetNodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>RecreateShardDDLCommandList</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
										  <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>PostLoadShardCreationCommandList</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
											   <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ShardCommandList</name> <modifier>*</modifier></type> <name>CreateShardCommandList</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>CreateShardCopyCommand</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shard</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* declarations for dynamic loading */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_copy_shard_placement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_copy_shard_placement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_move_shard_placement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_move_shard_placement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>DesiredPercentFreeAfterMove</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>CheckAvailableSpaceBeforeMove</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * citus_copy_shard_placement implements a user-facing UDF to copy a placement
 * from a source node to a target node, including all co-located placements.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_copy_shard_placement</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>sourceNodeNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>sourceNodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>targetNodeNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>targetNodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>sourceNodeNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>targetNodeNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>shardReplicationMode</name> <init>= <expr><call><name>LookupShardTransferMode</name><argument_list>(<argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReplicateColocatedShardPlacement</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>,
									 <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>,
									 <argument><expr><name>shardReplicationMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_copy_shard_placement is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_copy_shard_placement</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>sourceNodeNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>sourceNodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>targetNodeNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>targetNodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>doRepair</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>sourceNodeNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>targetNodeNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>shardReplicationMode</name> <init>= <expr><call><name>LookupShardTransferMode</name><argument_list>(<argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>doRepair</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"do_repair argument is deprecated"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReplicateColocatedShardPlacement</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>,
									 <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>,
									 <argument><expr><name>shardReplicationMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_move_shard_placement moves given shard (and its co-located shards) from one
 * node to the other node. To accomplish this it entirely recreates the table structure
 * before copying all data.
 *
 * After that, there are two different paths. First one is blocking shard move in the
 * sense that during shard move all modifications are paused to the shard. The second
 * one relies on logical replication meaning that the writes blocked only for a very
 * short duration almost only when the metadata is actually being updated.
 *
 * After successful move operation, shards in the source node gets deleted. If the move
 * fails at any point, this function throws an error, leaving the cluster without doing
 * any changes in source node or target node.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_move_shard_placement</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>sourceNodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>targetNodePort</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedShardCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfSameNode</name><argument_list>(<argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>,
					<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>,
					<argument><expr><literal type="string">"move"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ErrorIfMoveUnsupportedTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorIfTargetNodeIsNotSafeToMove</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AcquirePlacementColocationLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><literal type="string">"move"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><call><name>ColocatedTableList</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><call><name>ColocatedShardIntervalList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>colocatedTableCell</argument>, <argument>colocatedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>colocatedTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* check that user has owner rights in all co-located tables */</comment>
		<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Block concurrent DDL / TRUNCATE commands on the relation. Similarly,
		 * block concurrent citus_move_shard_placement() on any shard of
		 * the same relation. This is OK for now since we're executing shard
		 * moves sequentially anyway.
		 */</comment>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move shard"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table %s is a foreign table. Moving "</literal>
									  <literal type="string">"shards backed by foreign tables is "</literal>
									  <literal type="string">"not supported."</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* we sort colocatedShardList so that lock operations will not cause any deadlocks */</comment>
	<expr_stmt><expr><name>colocatedShardList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>CompareShardIntervalsById</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are no active placements on the source and only active placements on
	 * the target node, we assume the copy to already be done.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsShardListOnNode</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsShardListOnNode</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard is already present on node %s:%d"</literal></expr></argument>,
								 <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Move may have already completed."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>colocatedShardCell</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>colocatedShard</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>colocatedShardCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>colocatedShardId</name> <init>= <expr><name><name>colocatedShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>EnsureShardCanBeCopied</name><argument_list>(<argument><expr><name>colocatedShardId</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>,
							   <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>char</name></type> <name>shardReplicationMode</name> <init>= <expr><call><name>LookupShardTransferMode</name><argument_list>(<argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shardReplicationMode</name> <operator>==</operator> <name>TRANSFER_MODE_AUTOMATIC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>VerifyTablesHaveReplicaIdentity</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureEnoughDiskSpaceForShardMove</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>,
									  <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * We want to be able to track progress of shard moves using
	 * get_rebalancer_progress. If this move is initiated by the rebalancer,
	 * then the rebalancer call has already set up the shared memory that is
	 * used to do that. But if citus_move_shard_placement is called directly by
	 * the user (or through any other mechanism), then the shared memory is not
	 * set up yet. In that case we do it here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsRebalancerInternalBackend</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>placementUpdateEvent</name> <init>= <expr><call><name>palloc0</name><argument_list>(
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlacementUpdateEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>updateType</name></name> <operator>=</operator> <name>PLACEMENT_UPDATE_MOVE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>sourceNode</name></name> <operator>=</operator> <name>sourceNode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>targetNode</name></name> <operator>=</operator> <name>targetNode</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetupRebalanceMonitor</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>placementUpdateEvent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>relationId</name></expr></argument>,
							  <argument><expr><name>REBALANCE_PROGRESS_MOVING</name></expr></argument>,
							  <argument><expr><name>PLACEMENT_UPDATE_STATUS_SETTING_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>colocatedShardList</name></expr></argument>,
		<argument><expr><name>sourceNodeName</name></expr></argument>,
		<argument><expr><name>sourceNodePort</name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_SETTING_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * At this point of the shard moves, we don't need to block the writes to
	 * shards when logical replication is used.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>useLogicalReplication</name> <init>= <expr><call><name>CanUseLogicalReplication</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>,
														  <argument><expr><name>shardReplicationMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>useLogicalReplication</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BlockWritesToShardList</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We prevent multiple shard moves in a transaction that use logical
		 * replication. That's because the first call opens a transaction block
		 * on the worker to drop the old shard placement and replication slot
		 * creation waits for pending transactions to finish, which will not
		 * happen ever. In other words, we prevent a self-deadlock if both
		 * source shard placements are on the same node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>PlacementMovedUsingLogicalReplicationInTX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"moving multiple shard placements via logical "</literal>
								   <literal type="string">"replication in the same transaction is currently "</literal>
								   <literal type="string">"not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If you wish to move multiple shard placements "</literal>
									<literal type="string">"in a single transaction set the shard_transfer_mode "</literal>
									<literal type="string">"to 'block_writes'."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>PlacementMovedUsingLogicalReplicationInTX</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * CopyColocatedShardPlacement function copies given shard with its co-located
	 * shards.
	 */</comment>
	<expr_stmt><expr><call><name>CopyShardTables</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>, <argument><expr><name>targetNodeName</name></expr></argument>,
					<argument><expr><name>targetNodePort</name></expr></argument>, <argument><expr><name>useLogicalReplication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>colocatedShard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>colocatedShard</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>colocatedShardId</name> <init>= <expr><name><name>colocatedShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>groupId</name> <init>= <expr><call><name>GroupForNode</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>placementId</name> <init>= <expr><call><name>GetNextPlacementId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InsertShardPlacementRow</name><argument_list>(<argument><expr><name>colocatedShardId</name></expr></argument>, <argument><expr><name>placementId</name></expr></argument>,
								<argument><expr><name>SHARD_STATE_ACTIVE</name></expr></argument>, <argument><expr><call><name>ShardLength</name><argument_list>(<argument><expr><name>colocatedShardId</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* since this is move operation, we remove shards from source node after copy */</comment>
	<expr_stmt><expr><call><name>MarkForDropColocatedShardPlacement</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdateColocatedShardPlacementMetadataOnWorkers</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>,
												   <argument><expr><name>sourceNodePort</name></expr></argument>, <argument><expr><name>targetNodeName</name></expr></argument>,
												   <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>colocatedShardList</name></expr></argument>,
		<argument><expr><name>sourceNodeName</name></expr></argument>,
		<argument><expr><name>sourceNodePort</name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_COMPLETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FinalizeCurrentProgressMonitor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsShardListOnNode determines whether a co-located shard list has
 * active placements on a given node.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsShardListOnNode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Moving shards to a non-existing node is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We exhaustively search all co-located shards
	 */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>= <expr><call><name>ActiveShardPlacementListOnGroup</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>,
															  <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>placementList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureEnoughDiskSpaceForShardMove checks that there is enough space for
 * shard moves of the given colocated shard list from source node to target node.
 * It tries to clean up old shard placements to ensure there is enough space.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureEnoughDiskSpaceForShardMove</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name></decl></parameter>,
								  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>sourceNodePort</name></decl></parameter>,
								  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CheckAvailableSpaceBeforeMove</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>colocationSizeInBytes</name> <init>= <expr><call><name>ShardListSizeInBytes</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>,
														<argument><expr><name>sourceNodeName</name></expr></argument>,
														<argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>connectionFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetNodeConnection</name><argument_list>(<argument><expr><name>connectionFlag</name></expr></argument>, <argument><expr><name>targetNodeName</name></expr></argument>,
													<argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CheckSpaceConstraints</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>colocationSizeInBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShardListSizeInBytes returns the size in bytes of a set of shard tables.
 */</comment>
<function><type><name>uint64</name></type>
<name>ShardListSizeInBytes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workerNodeName</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type>
					 <name>workerNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>connectionFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we skip child tables of a partitioned table if this boolean variable is true */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>optimizePartitionCalculations</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>tableSizeQuery</name> <init>= <expr><call><name>GenerateSizeQueryOnMultiplePlacements</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>,
																	  <argument><expr><name>TOTAL_RELATION_SIZE</name></expr></argument>,
																	  <argument><expr><name>optimizePartitionCalculations</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetNodeConnection</name><argument_list>(<argument><expr><name>connectionFlag</name></expr></argument>, <argument><expr><name>workerNodeName</name></expr></argument>,
													<argument><expr><name>workerNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>queryResult</name> <init>= <expr><call><name>ExecuteOptionalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>tableSizeQuery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>queryResult</name> <operator>!=</operator> <name>RESPONSE_OKAY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot get the size because of a connection error"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sizeList</name> <init>= <expr><call><name>ReadFirstColumnAsText</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>sizeList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"received wrong number of rows from worker, expected 1 received %d"</literal></expr></argument>,
							<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>sizeList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>totalSizeStringInfo</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>sizeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>totalSizeString</name> <init>= <expr><name><name>totalSizeStringInfo</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>totalSize</name> <init>= <expr><call><name>SafeStringToUint64</name><argument_list>(<argument><expr><name>totalSizeString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>totalSize</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckSpaceConstraints checks there is enough space to place the colocation
 * on the node that the connection is connected to.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckSpaceConstraints</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>colocationSizeInBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>diskAvailableInBytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>diskSizeInBytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>=
		<expr><call><name>GetNodeDiskSpaceStatsForConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>diskAvailableInBytes</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>diskSizeInBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not fetch disk stats for node: %s-%d"</literal></expr></argument>,
							   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>diskAvailableInBytesAfterShardMove</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>diskAvailableInBytes</name> <operator>&lt;</operator> <name>colocationSizeInBytes</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * even though the space will be less than "0", we set it to 0 for convenience.
		 */</comment>
		<expr_stmt><expr><name>diskAvailableInBytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>diskAvailableInBytesAfterShardMove</name> <operator>=</operator> <name>diskAvailableInBytes</name> <operator>-</operator> <name>colocationSizeInBytes</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>desiredNewDiskAvailableInBytes</name> <init>= <expr><name>diskSizeInBytes</name> <operator>*</operator>
											<operator>(</operator><name>DesiredPercentFreeAfterMove</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>diskAvailableInBytesAfterShardMove</name> <operator>&lt;</operator> <name>desiredNewDiskAvailableInBytes</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough empty space on node if the shard is moved, "</literal>
							   <literal type="string">"actual available space after move will be %ld bytes, "</literal>
							   <literal type="string">"desired available space after move is %ld bytes, "</literal>
							   <literal type="string">"estimated size increase on node after move is %ld bytes."</literal></expr></argument>,
							   <argument><expr><name>diskAvailableInBytesAfterShardMove</name></expr></argument>,
							   <argument><expr><name>desiredNewDiskAvailableInBytes</name></expr></argument>, <argument><expr><name>colocationSizeInBytes</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(
							<argument><expr><literal type="string">"consider lowering citus.desired_percent_disk_available_after_move."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfTargetNodeIsNotSafeToMove throws error if the target node is not
 * eligible for moving shards.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfTargetNodeIsNotSafeToMove</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Moving shards to a non-existing node is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(
							<argument><expr><literal type="string">"Add the target node via SELECT citus_add_node('%s', %d);"</literal></expr></argument>,
							<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>isActive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Moving shards to a non-active node is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(
							<argument><expr><literal type="string">"Activate the target node via SELECT citus_activate_node('%s', %d);"</literal></expr></argument>,
							<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>shouldHaveShards</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Moving shards to a node that shouldn't have a shard is "</literal>
							   <literal type="string">"not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Allow shards on the target node via "</literal>
								<literal type="string">"SELECT * FROM citus_set_node_property('%s', %d, 'shouldhaveshards', true);"</literal></expr></argument>,
								<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Moving shards to a secondary (e.g., replica) node is "</literal>
							   <literal type="string">"not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfSameNode throws an error if the two host:port combinations
 * are the same.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfSameNode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceNodePort</name></decl></parameter>,
				<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetNodePort</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operationName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>sourceNodePort</name> <operator>==</operator> <name>targetNodePort</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot %s shard to the same node"</literal></expr></argument>,
							   <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_move_shard_placement is a wrapper around citus_move_shard_placement.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_move_shard_placement</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_move_shard_placement</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfMoveUnsupportedTableType is a helper function for rebalance_table_shards
 * and citus_move_shard_placement udf's to error out if relation with relationId
 * is not a distributed table.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfMoveUnsupportedTableType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table %s is a regular postgres table, you can "</literal>
							   <literal type="string">"only move shards of a citus table"</literal></expr></argument>,
							   <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table %s is a local table, moving shard of "</literal>
							   <literal type="string">"a local table added to metadata is currently "</literal>
							   <literal type="string">"not supported"</literal></expr></argument>, <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table %s is a reference table, moving shard of "</literal>
							   <literal type="string">"a reference table is not supported"</literal></expr></argument>,
							   <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * VerifyTablesHaveReplicaIdentity throws an error if any of the tables
 * do not have a replica identity, which is required for logical replication
 * to replicate UPDATE and DELETE commands.
 */</comment>
<function><type><name>void</name></type>
<name>VerifyTablesHaveReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>colocatedTableCell</argument>, <argument>colocatedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>colocatedTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationCanPublishAllModifications</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colocatedRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use logical replication to transfer shards of "</literal>
								   <literal type="string">"the relation %s since it doesn't have a REPLICA "</literal>
								   <literal type="string">"IDENTITY or PRIMARY KEY"</literal></expr></argument>, <argument><expr><name>colocatedRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"UPDATE and DELETE commands on the shard will "</literal>
									  <literal type="string">"error out during logical replication unless "</literal>
									  <literal type="string">"there is a REPLICA IDENTITY or PRIMARY KEY."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If you wish to continue without a replica "</literal>
									<literal type="string">"identity set the shard_transfer_mode to "</literal>
									<literal type="string">"'force_logical' or 'block_writes'."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * RelationCanPublishAllModifications returns true if the relation is safe to publish
 * all modification while being replicated via logical replication.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationCanPublishAllModifications</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>canPublish</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if relation has replica identity we are always good */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name> <operator>==</operator> <name>REPLICA_IDENTITY_FULL</name> <operator>||</operator>
		<call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>RelationGetReplicaIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>canPublish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* partitioned tables do not contain any data themselves, can always replicate */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>canPublish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>canPublish</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BlockWritesToShardList blocks writes to all shards in the given shard
 * list. The function assumes that all the shards in the list are colocated.
 */</comment>
<function><type><name>void</name></type>
<name>BlockWritesToShardList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shard</argument>, <argument>shardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * We need to lock the referenced reference table metadata to avoid
		 * asynchronous shard copy in case of cascading DML operations.
		 */</comment>
		<expr_stmt><expr><call><name>LockReferencedReferenceShardDistributionMetadata</name><argument_list>(<argument><expr><name><name>shard</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
														 <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LockShardDistributionMetadata</name><argument_list>(<argument><expr><name><name>shard</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* following code relies on the list to have at least one shard */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since the function assumes that the input shards are colocated,
	 * calculating shouldSyncMetadata for a single table is sufficient.
	 */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>firstShardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>firstDistributedTableId</name> <init>= <expr><name><name>firstShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>shouldSyncMetadata</name> <init>= <expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>firstDistributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shouldSyncMetadata</name> <operator>||</operator> <operator>!</operator><call><name>IsCoordinator</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Even if users disable metadata sync, we cannot allow them not to
		 * acquire the remote locks. Hence, we have !IsCoordinator() check.
		 */</comment>
		<expr_stmt><expr><call><name>LockShardListMetadataOnWorkers</name><argument_list>(<argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>shardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CanUseLogicalReplication returns true if the given table can be logically replicated.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CanUseLogicalReplication</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>shardReplicationMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>shardReplicationMode</name> <operator>==</operator> <name>TRANSFER_MODE_BLOCK_WRITES</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* user explicitly chose not to use logical replication */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Logical replication doesn't support replicating foreign tables and views.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RegularTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot use logical replication for "</literal>
							 <literal type="string">"shard move since the relation %s is not "</literal>
							 <literal type="string">"a regular relation"</literal></expr></argument>,
							 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Logical replication doesn't support inherited tables */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsParentTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot use logical replication for "</literal>
							 <literal type="string">"shard move since the relation %s is an "</literal>
							 <literal type="string">"inherited relation"</literal></expr></argument>,
							 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfTableCannotBeReplicated function errors out if the given table is not suitable
 * for its shard being replicated. There are 2 cases in which shard replication is not
 * allowed:
 *
 * 1) MX tables, since RF=1 is a must MX tables
 * 2) Reference tables, since the shard should already exist in all workers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfTableCannotBeReplicated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Note that ShouldSyncTableMetadata() returns true for both MX tables
	 * and reference tables.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>shouldSyncMetadata</name> <init>= <expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shouldSyncMetadata</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>tableEntry</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Table %s is a local table. Replicating "</literal>
								<literal type="string">"shard of a local table added to metadata "</literal>
								<literal type="string">"currently is not supported"</literal></expr></argument>,
								<argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * ShouldSyncTableMetadata() returns true also for reference table,
	 * we don't want to error in that case since reference tables aren't
	 * automatically replicated to active nodes with no shards, and
	 * master_copy_shard_placement() can be used to create placements in
	 * such nodes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tableEntry</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>==</operator> <name>REPLICATION_MODEL_STREAMING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Table %s is streaming replicated. Shards "</literal>
								<literal type="string">"of streaming replicated tables cannot "</literal>
								<literal type="string">"be copied"</literal></expr></argument>, <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfTargetNodeIsNotSafeToCopyTo throws an error if the target node is not
 * eligible for copying shards.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfTargetNodeIsNotSafeToCopyTo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Copying shards to a non-existing node is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(
							<argument><expr><literal type="string">"Add the target node via SELECT citus_add_node('%s', %d);"</literal></expr></argument>,
							<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>isActive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Copying shards to a non-active node is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(
							<argument><expr><literal type="string">"Activate the target node via SELECT citus_activate_node('%s', %d);"</literal></expr></argument>,
							<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NodeIsPrimary</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Copying shards to a secondary (e.g., replica) node is "</literal>
							   <literal type="string">"not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LookupShardTransferMode maps the oids of citus.shard_transfer_mode enum
 * values to a char.
 */</comment>
<function><type><name>char</name></type>
<name>LookupShardTransferMode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardReplicationModeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>shardReplicationMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>enumLabelDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>enum_out</name></expr></argument>, <argument><expr><name>shardReplicationModeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>enumLabel</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>enumLabelDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>enumLabel</name></expr></argument>, <argument><expr><literal type="string">"auto"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardReplicationMode</name> <operator>=</operator> <name>TRANSFER_MODE_AUTOMATIC</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>enumLabel</name></expr></argument>, <argument><expr><literal type="string">"force_logical"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardReplicationMode</name> <operator>=</operator> <name>TRANSFER_MODE_FORCE_LOGICAL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>enumLabel</name></expr></argument>, <argument><expr><literal type="string">"block_writes"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardReplicationMode</name> <operator>=</operator> <name>TRANSFER_MODE_BLOCK_WRITES</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid label for enum: %s"</literal></expr></argument>, <argument><expr><name>enumLabel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>shardReplicationMode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReplicateColocatedShardPlacement replicates the given shard and its
 * colocated shards from a source node to target node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReplicateColocatedShardPlacement</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
								 <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
								 <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>shardReplicationMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfSameNode</name><argument_list>(<argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>,
					<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>,
					<argument><expr><literal type="string">"copy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ErrorIfTableCannotBeReplicated</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorIfTargetNodeIsNotSafeToCopyTo</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureNoModificationsHaveBeenDone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AcquirePlacementColocationLock</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><literal type="string">"copy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><call><name>ColocatedTableList</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><call><name>ColocatedShardIntervalList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureTableListOwner</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableListSuitableForReplication</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We sort shardIntervalList so that lock operations will not cause any
	 * deadlocks.
	 */</comment>
	<expr_stmt><expr><name>colocatedShardList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>CompareShardIntervalsById</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are active placements on both nodes, we assume the copy to already
	 * be done.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsShardListOnNode</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsShardListOnNode</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard is already present on node %s:%d"</literal></expr></argument>,
								 <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Copy may have already completed."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlacementUpdateEvent</name> <modifier>*</modifier></type><name>placementUpdateEvent</name> <init>= <expr><call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlacementUpdateEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>updateType</name></name> <operator>=</operator> <name>PLACEMENT_UPDATE_COPY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>sourceNode</name></name> <operator>=</operator> <name>sourceNode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>placementUpdateEvent</name><operator>-&gt;</operator><name>targetNode</name></name> <operator>=</operator> <name>targetNode</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetupRebalanceMonitor</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>placementUpdateEvent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>relationId</name></expr></argument>,
						  <argument><expr><name>REBALANCE_PROGRESS_MOVING</name></expr></argument>,
						  <argument><expr><name>PLACEMENT_UPDATE_STATUS_SETTING_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>colocatedShardList</name></expr></argument>,
		<argument><expr><name>sourceNodeName</name></expr></argument>,
		<argument><expr><name>sourceNodePort</name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_SETTING_UP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * At this point of the shard replication, we don't need to block the writes to
	 * shards when logical replication is used.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>useLogicalReplication</name> <init>= <expr><call><name>CanUseLogicalReplication</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>,
														  <argument><expr><name>shardReplicationMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>useLogicalReplication</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BlockWritesToShardList</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>colocatedShard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>colocatedShard</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>colocatedShardId</name> <init>= <expr><name><name>colocatedShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For shard copy, there should be healthy placement in source node and no
		 * placement in the target node.
		 */</comment>
		<expr_stmt><expr><call><name>EnsureShardCanBeCopied</name><argument_list>(<argument><expr><name>colocatedShardId</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>,
							   <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>shardReplicationMode</name> <operator>==</operator> <name>TRANSFER_MODE_AUTOMATIC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>VerifyTablesHaveReplicaIdentity</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When copying a shard to a new node, we should first ensure that reference
		 * tables are present such that joins work immediately after copying the shard.
		 * When copying a reference table, we are probably trying to achieve just that.
		 *
		 * Since this a long-running operation we do this after the error checks, but
		 * before taking metadata locks.
		 */</comment>
		<expr_stmt><expr><call><name>EnsureReferenceTablesExistOnAllNodesExtended</name><argument_list>(<argument><expr><name>shardReplicationMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CopyShardTables</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>,
					<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>, <argument><expr><name>useLogicalReplication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally insert the placements to pg_dist_placement and sync it to the
	 * metadata workers.
	 */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>colocatedShard</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>colocatedShardId</name> <init>= <expr><name><name>colocatedShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>groupId</name> <init>= <expr><call><name>GroupForNode</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>placementId</name> <init>= <expr><call><name>GetNextPlacementId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InsertShardPlacementRow</name><argument_list>(<argument><expr><name>colocatedShardId</name></expr></argument>, <argument><expr><name>placementId</name></expr></argument>,
								<argument><expr><name>SHARD_STATE_ACTIVE</name></expr></argument>, <argument><expr><call><name>ShardLength</name><argument_list>(<argument><expr><name>colocatedShardId</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name><name>colocatedShard</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>placementCommand</name> <init>= <expr><call><name>PlacementUpsertCommand</name><argument_list>(<argument><expr><name>colocatedShardId</name></expr></argument>, <argument><expr><name>placementId</name></expr></argument>,
															<argument><expr><name>SHARD_STATE_ACTIVE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
															<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>placementCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>colocatedShardList</name></expr></argument>,
		<argument><expr><name>sourceNodeName</name></expr></argument>,
		<argument><expr><name>sourceNodePort</name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_COMPLETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FinalizeCurrentProgressMonitor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureTableListOwner ensures current user owns given tables. Superusers
 * are regarded as owners.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureTableListOwner</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>tableId</argument>, <argument>tableIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureTableListSuitableForReplication errors out if given tables are not
 * suitable for replication.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureTableListSuitableForReplication</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>tableId</argument>, <argument>tableIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot replicate shard"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table %s is a foreign table. Replicating "</literal>
									  <literal type="string">"shards backed by foreign tables is "</literal>
									  <literal type="string">"not supported."</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignConstraintCommandList</name> <init>=
			<expr><call><name>GetReferencingForeignConstaintCommands</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>foreignConstraintCommandList</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
			<call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot replicate shards with foreign keys"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CopyShardTables copies a shard along with its co-located shards from a source
 * node to target node. It does not make any checks about state of the shards.
 * It is caller's responsibility to make those checks if they are necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyShardTables</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>,
				<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useLogicalReplication</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DropOrphanedResourcesInSeparateTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>useLogicalReplication</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopyShardTablesViaLogicalReplication</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>,
											 <argument><expr><name>sourceNodePort</name></expr></argument>, <argument><expr><name>targetNodeName</name></expr></argument>,
											 <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopyShardTablesViaBlockWrites</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>,
									  <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CopyShardTablesViaLogicalReplication copies a shard along with its co-located shards
 * from a source node to target node via logical replication.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyShardTablesViaLogicalReplication</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
									 <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
									 <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"CopyShardTablesViaLogicalReplication"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate through the colocated shards and create them on the
	 * target node. We do not create the indexes yet.
	 */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableRecreationCommandList</name> <init>= <expr><call><name>RecreateTableDDLCommandList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>tableRecreationCommandList</name> <operator>=</operator>
			<call><name>WorkerApplyShardDDLCommandList</name><argument_list>(<argument><expr><name>tableRecreationCommandList</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwner</name> <init>= <expr><call><name>TableOwner</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransaction</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>,
												  <argument><expr><name>tableOwner</name></expr></argument>,
												  <argument><expr><name>tableRecreationCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Start operation to prepare for generating cleanup records */</comment>
	<expr_stmt><expr><call><name>RegisterOperationNeedingCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* data copy is done seperately when logical replication is used */</comment>
	<expr_stmt><expr><call><name>LogicallyReplicateShards</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>,
							 <argument><expr><name>sourceNodePort</name></expr></argument>, <argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Drop temporary objects that were marked as CLEANUP_ALWAYS.
	 */</comment>
	<expr_stmt><expr><call><name>FinalizeOperationNeedingCleanupOnSuccess</name><argument_list>(<argument><expr><literal type="string">"citus_[move/copy]_shard_placement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateShardCommandList creates a struct for shard interval
 * along with DDL commands to be executed.
 */</comment>
<function><type><specifier>static</specifier> <name>ShardCommandList</name> <modifier>*</modifier></type>
<name>CreateShardCommandList</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardCommandList</name> <modifier>*</modifier></type><name>shardCommandList</name> <init>= <expr><call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardCommandList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>shardCommandList</name><operator>-&gt;</operator><name>shardInterval</name></name> <operator>=</operator> <name>shardInterval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardCommandList</name><operator>-&gt;</operator><name>ddlCommandList</name></name> <operator>=</operator> <name>ddlCommandList</name></expr>;</expr_stmt>

	<return>return <expr><name>shardCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyShardTablesViaBlockWrites copies a shard along with its co-located shards
 * from a source node to target node via COPY command. While the command is in
 * progress, the modifications on the source node is blocked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyShardTablesViaBlockWrites</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
							  <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>,
							  <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"CopyShardTablesViaBlockWrites"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate through the colocated shards and copy each */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * For each shard we first create the shard table in a separate
		 * transaction and then we copy the data and create the indexes in a
		 * second separate transaction. The reason we don't do both in a single
		 * transaction is so we can see the size of the new shard growing
		 * during the copy when we run get_rebalance_progress in another
		 * session. If we wouldn't split these two phases up, then the table
		 * wouldn't be visible in the session that get_rebalance_progress uses.
		 * So get_rebalance_progress would always report its size as 0.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name> <init>= <expr><call><name>RecreateShardDDLCommandList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>,
														   <argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwner</name> <init>= <expr><call><name>TableOwner</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransaction</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>,
												  <argument><expr><name>tableOwner</name></expr></argument>, <argument><expr><name>ddlCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>shardIntervalList</name></expr></argument>,
		<argument><expr><name>sourceNodeName</name></expr></argument>,
		<argument><expr><name>sourceNodePort</name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_COPYING_DATA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ConflictWithIsolationTestingBeforeCopy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CopyShardsToNode</name><argument_list>(<argument><expr><name>sourceNode</name></expr></argument>, <argument><expr><name>targetNode</name></expr></argument>, <argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ConflictWithIsolationTestingAfterCopy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>shardIntervalList</name></expr></argument>,
		<argument><expr><name>sourceNodeName</name></expr></argument>,
		<argument><expr><name>sourceNodePort</name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_CREATING_CONSTRAINTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name> <init>=
			<expr><call><name>PostLoadShardCreationCommandList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>, <argument><expr><name>sourceNodeName</name></expr></argument>,
											 <argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwner</name> <init>= <expr><call><name>TableOwner</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransaction</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>,
												  <argument><expr><name>tableOwner</name></expr></argument>, <argument><expr><name>ddlCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Once all shards are copied, we can recreate relationships between shards.
	 * Create DDL commands to Attach child tables to their parents in a partitioning hierarchy.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalWithDDCommandsList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attachPartitionCommand</name> <init>=
				<expr><call><name>GenerateAttachShardPartitionCommand</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>ShardCommandList</name> <modifier>*</modifier></type><name>shardCommandList</name> <init>= <expr><call><name>CreateShardCommandList</name><argument_list>(
				<argument><expr><name>shardInterval</name></expr></argument>,
				<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>attachPartitionCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>shardIntervalWithDDCommandsList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shardIntervalWithDDCommandsList</name></expr></argument>,
													  <argument><expr><name>shardCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>shardIntervalList</name></expr></argument>,
		<argument><expr><name>sourceNodeName</name></expr></argument>,
		<argument><expr><name>sourceNodePort</name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_CREATING_FOREIGN_KEYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Iterate through the colocated shards and create DDL commamnds
	 * to create the foreign constraints.
	 */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardForeignConstraintCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referenceTableForeignConstraintList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CopyShardForeignConstraintCommandListGrouped</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>shardForeignConstraintCommandList</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>referenceTableForeignConstraintList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ShardCommandList</name> <modifier>*</modifier></type><name>shardCommandList</name> <init>= <expr><call><name>CreateShardCommandList</name><argument_list>(
			<argument><expr><name>shardInterval</name></expr></argument>,
			<argument><expr><call><name>list_concat</name><argument_list>(<argument><expr><name>shardForeignConstraintCommandList</name></expr></argument>,
						<argument><expr><name>referenceTableForeignConstraintList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>shardIntervalWithDDCommandsList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shardIntervalWithDDCommandsList</name></expr></argument>,
												  <argument><expr><name>shardCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Now execute the Partitioning &amp; Foreign constraints creation commads. */</comment>
	<decl_stmt><decl><type><name>ShardCommandList</name> <modifier>*</modifier></type><name>shardCommandList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardCommandList</argument>, <argument>shardIntervalWithDDCommandsList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwner</name> <init>= <expr><call><name>TableOwner</name><argument_list>(<argument><expr><name><name>shardCommandList</name><operator>-&gt;</operator><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransaction</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>,
												  <argument><expr><name>tableOwner</name></expr></argument>,
												  <argument><expr><name><name>shardCommandList</name><operator>-&gt;</operator><name>ddlCommandList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>UpdatePlacementUpdateStatusForShardIntervalList</name><argument_list>(
		<argument><expr><name>shardIntervalList</name></expr></argument>,
		<argument><expr><name>sourceNodeName</name></expr></argument>,
		<argument><expr><name>sourceNodePort</name></expr></argument>,
		<argument><expr><name>PLACEMENT_UPDATE_STATUS_COMPLETING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CopyShardsToNode copies the list of shards from the source to the target.
 * When snapshotName is not NULL it will do the COPY using this snapshot name.
 */</comment>
<function><type><name>void</name></type>
<name>CopyShardsToNode</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceNode</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>snapshotName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>copyTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Skip copying data for partitioned tables, because they contain no
		 * data themselves. Their partitions do contain data, but those are
		 * different colocated shards that will be copied seperately.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * This uses repeatable read because we want to read the table in
		 * the state exactly as it was when the snapshot was created. This
		 * is needed when using this code for the initial data copy when
		 * using logical replication. The logical replication catchup might
		 * fail otherwise, because some of the updates that it needs to do
		 * have already been applied on the target.
		 */</comment>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>beginTransaction</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>beginTransaction</name></expr></argument>,
						 <argument><expr><literal type="string">"BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ddlCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommandList</name></expr></argument>, <argument><expr><name><name>beginTransaction</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set snapshot for non-blocking shard split. */</comment>
		<if_stmt><if>if <condition>(<expr><name>snapshotName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>snapShotString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>snapShotString</name></expr></argument>, <argument><expr><literal type="string">"SET TRANSACTION SNAPSHOT %s;"</literal></expr></argument>,
							 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(
								 <argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ddlCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommandList</name></expr></argument>, <argument><expr><name><name>snapShotString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>copyCommand</name> <init>= <expr><call><name>CreateShardCopyCommand</name><argument_list>(
			<argument><expr><name>shardInterval</name></expr></argument>, <argument><expr><name>targetNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>ddlCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommandList</name></expr></argument>, <argument><expr><name>copyCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>commitCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>commitCommand</name></expr></argument>, <argument><expr><literal type="string">"COMMIT;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ddlCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommandList</name></expr></argument>, <argument><expr><name><name>commitCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>READ_TASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryStringList</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>ddlCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SetPlacementNodeMetadata</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>, <argument><expr><name>sourceNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>copyTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>copyTaskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>taskId</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExecuteTaskListOutsideTransaction</name><argument_list>(<argument><expr><name>ROW_MODIFY_NONE</name></expr></argument>, <argument><expr><name>copyTaskList</name></expr></argument>,
									  <argument><expr><name>MaxAdaptiveExecutorPoolSize</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* jobIdList (ignored by API implementation) */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateShardCopyCommand constructs the command to copy a shard to another
 * worker node. This command needs to be run on the node wher you want to copy
 * the shard from.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateShardCopyCommand</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shard</name></decl></parameter>,
					   <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>targetNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardName</name> <init>= <expr><call><name>ConstructQualifiedShardName</name><argument_list>(<argument><expr><name>shard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>query</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT pg_catalog.worker_copy_table_to_node(%s::regclass, %u);"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>shardName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>targetNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureShardCanBeCopied checks if the given shard has a healthy placement in the source
 * node and no placements in the target node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureShardCanBeCopied</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>ShardPlacementListIncludingOrphanedPlacements</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>sourcePlacement</name> <init>= <expr><call><name>SearchShardPlacementInListOrError</name><argument_list>(
		<argument><expr><name>shardPlacementList</name></expr></argument>,
		<argument><expr><name>sourceNodeName</name></expr></argument>,
		<argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sourcePlacement</name><operator>-&gt;</operator><name>shardState</name></name> <operator>!=</operator> <name>SHARD_STATE_ACTIVE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"source placement must be in active state"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>targetPlacement</name> <init>= <expr><call><name>SearchShardPlacementInList</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>,
																 <argument><expr><name>targetNodeName</name></expr></argument>,
																 <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetPlacement</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>targetPlacement</name><operator>-&gt;</operator><name>shardState</name></name> <operator>==</operator> <name>SHARD_STATE_TO_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Trigger deletion of orphaned resources and hope that this removes
			 * the shard.
			 */</comment>
			<expr_stmt><expr><call><name>DropOrphanedResourcesInSeparateTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>shardPlacementList</name> <operator>=</operator> <call><name>ShardPlacementListIncludingOrphanedPlacements</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>targetPlacement</name> <operator>=</operator> <call><name>SearchShardPlacementInList</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>,
														 <argument><expr><name>targetNodeName</name></expr></argument>,
														 <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If it still doesn't remove the shard, then we error.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>targetPlacement</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(
									<argument><expr><literal type="string">"shard "</literal> <name>INT64_FORMAT</name>
									<literal type="string">" still exists on the target node as an orphaned shard"</literal></expr></argument>,
									<argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errdetail</name><argument_list>(
									<argument><expr><literal type="string">"The existing shard is orphaned, but could not be deleted because there are still active queries on it"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"shard "</literal> <name>INT64_FORMAT</name> <literal type="string">" already exists in the target node"</literal></expr></argument>,
								<argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SearchShardPlacementInList searches a provided list for a shard placement with the
 * specified node name and port. This function returns NULL if no such
 * placement exists in the provided list.
 */</comment>
<function><type><name>ShardPlacement</name> <modifier>*</modifier></type>
<name>SearchShardPlacementInList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>,
						   <parameter><decl><type><name>uint32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>shardPlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardPlacement</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name><name>shardPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name>nodePort</name> <operator>==</operator> <name><name>shardPlacement</name><operator>-&gt;</operator><name>nodePort</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>shardPlacement</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SearchShardPlacementInListOrError searches a provided list for a shard
 * placement with the specified node name and port. This function throws an
 * error if no such placement exists in the provided list.
 *
 * This is a separate function (instead of using missingOk), so static analysis
 * reasons about NULL returns correctly.
 */</comment>
<function><type><name>ShardPlacement</name> <modifier>*</modifier></type>
<name>SearchShardPlacementInListOrError</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>,
								  <parameter><decl><type><name>uint32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><call><name>SearchShardPlacementInList</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>,
														   <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>placement</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find placement matching \"%s:%d\""</literal></expr></argument>,
							   <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Confirm the placement still exists and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>placement</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecreateShardDDLCommandList generates a command list to recreate a shard,
 * but without any data init and without the post-load table creation commands.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>RecreateShardDDLCommandList</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
							<parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableRecreationCommandList</name> <init>= <expr><call><name>RecreateTableDDLCommandList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>WorkerApplyShardDDLCommandList</name><argument_list>(<argument><expr><name>tableRecreationCommandList</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostLoadShardCreationCommandList generates a command list to finalize the
 * creation of a shard after the data has been loaded. This creates stuff like
 * the indexes on the table.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>PostLoadShardCreationCommandList</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>,
								 <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>includeReplicaIdentity</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexCommandList</name> <init>=
		<expr><call><name>GetPostLoadTableCreationCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>includeReplicaIdentity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>WorkerApplyShardDDLCommandList</name><argument_list>(<argument><expr><name>indexCommandList</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyShardForeignConstraintCommandList generates command list to create foreign
 * constraints existing in source shard after copying it to the other node.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CopyShardForeignConstraintCommandList</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardForeignConstraintCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referenceTableForeignConstraintList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CopyShardForeignConstraintCommandListGrouped</name><argument_list>(
		<argument><expr><name>shardInterval</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>colocatedShardForeignConstraintCommandList</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>referenceTableForeignConstraintList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>colocatedShardForeignConstraintCommandList</name></expr></argument>,
					   <argument><expr><name>referenceTableForeignConstraintList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyShardForeignConstraintCommandListGrouped generates command lists
 * to create foreign constraints existing in source shard after copying it to other
 * node in separate groups for foreign constraints in between hash distributed tables
 * and from a hash distributed to reference tables.
 */</comment>
<function><type><name>void</name></type>
<name>CopyShardForeignConstraintCommandListGrouped</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>,
											 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type>
											 <name>colocatedShardForeignConstraintCommandList</name></decl></parameter>,
											 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>referenceTableForeignConstraintList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedSchemaName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>GetReferencingForeignConstaintCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we will only use shardIndex if there is a foreign constraint */</comment>
	<if_stmt><if>if <condition>(<expr><name>commandList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardIndex</name> <operator>=</operator> <call><name>ShardIndex</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>colocatedShardForeignConstraintCommandList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>referenceTableForeignConstraintList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedCommand</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>uint64</name></type> <name>referencedShardId</name> <init>= <expr><name>INVALID_SHARD_ID</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>colocatedForeignKey</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>applyForeignConstraintCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we need to parse the foreign constraint command to get referenced table id */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>referencedRelationId</name> <init>= <expr><call><name>ForeignConstraintGetReferencedTableId</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>referencedRelationId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign key constraint"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Referenced relation cannot be found."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>referencedSchemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>referencedRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>referencedSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>referencedSchemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedReferencedSchemaName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>referencedSchemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>referencedRelationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>referencedShardId</name> <operator>=</operator> <call><name>GetFirstShardId</name><argument_list>(<argument><expr><name>referencedRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>referencedRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Only reference tables and citus local tables can have foreign
			 * keys to citus local tables but we already do not allow copying
			 * citus local table shards and we don't try to replicate citus
			 * local table shards. So, the referencing table must be a reference
			 * table in this context.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We don't set foreign keys from reference tables to citus local
			 * tables in worker shard placements of reference tables because
			 * we don't have the shard placement for citus local table in worker
			 * nodes.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>referencedShardId</name> <operator>=</operator> <call><name>ColocatedShardIdInRelation</name><argument_list>(<argument><expr><name>referencedRelationId</name></expr></argument>,
														   <argument><expr><name>shardIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>colocatedForeignKey</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>applyForeignConstraintCommand</name></expr></argument>,
						 <argument><expr><name>WORKER_APPLY_INTER_SHARD_DDL_COMMAND</name></expr></argument>, <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
						 <argument><expr><name>escapedSchemaName</name></expr></argument>, <argument><expr><name>referencedShardId</name></expr></argument>,
						 <argument><expr><name>escapedReferencedSchemaName</name></expr></argument>, <argument><expr><name>escapedCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>colocatedForeignKey</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>colocatedShardForeignConstraintCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(
				<argument><expr><operator>*</operator><name>colocatedShardForeignConstraintCommandList</name></expr></argument>,
				<argument><expr><name><name>applyForeignConstraintCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>referenceTableForeignConstraintList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(
				<argument><expr><operator>*</operator><name>referenceTableForeignConstraintList</name></expr></argument>,
				<argument><expr><name><name>applyForeignConstraintCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetFirstShardId is a helper function which returns the first
 * shardId of the given distributed relation. The function doesn't
 * sort the shardIds, so it is mostly useful for reference tables.
 */</comment>
<function><type><name>uint64</name></type>
<name>GetFirstShardId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name> <init>= <expr><call><name>LoadShardList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name> <modifier>*</modifier></type><name>shardIdPointer</name> <init>= <expr><operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><operator>*</operator><name>shardIdPointer</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConstuctQualifiedShardName creates the fully qualified name string of the
 * given shard in &lt;schema&gt;.&lt;table_name&gt;_&lt;shard_id&gt; format.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>ConstructQualifiedShardName</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardName</name></expr></argument>, <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>shardName</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shardName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecreateTableDDLCommandList returns a list of DDL statements similar to that
 * returned by GetTableCreationCommands except that the list begins with a "DROP TABLE"
 * or "DROP FOREIGN TABLE" statement to facilitate idempotent recreation of a placement.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>RecreateTableDDLCommandList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationSchemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>relationSchemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>,
																   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>dropCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>IncludeSequenceDefaults</name></type> <name>includeSequenceDefaults</name> <init>= <expr><name>NO_SEQUENCE_DEFAULTS</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build appropriate DROP command based on relation kind */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RegularTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dropCommand</name></expr></argument>, <argument><expr><name>DROP_REGULAR_TABLE_COMMAND</name></expr></argument>,
						 <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dropCommand</name></expr></argument>, <argument><expr><name>DROP_FOREIGN_TABLE_COMMAND</name></expr></argument>,
						 <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"target is not a regular, foreign or partitioned "</literal>
							   <literal type="string">"table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dropCommandList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(<argument><expr><name><name>dropCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>createCommandList</name> <init>= <expr><call><name>GetPreLoadTableCreationCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
															  <argument><expr><name>includeSequenceDefaults</name></expr></argument>,
															  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>recreateCommandList</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>dropCommandList</name></expr></argument>, <argument><expr><name>createCommandList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>recreateCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MarkForDropColocatedShardPlacement marks the shard placement metadata for
 * the given shard placement to be deleted in pg_dist_placement. The function
 * does this for all colocated placements.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MarkForDropColocatedShardPlacement</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>,
								   <parameter><decl><type><name>int32</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><call><name>ColocatedShardIntervalList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedShardCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>colocatedShardCell</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>colocatedShard</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>colocatedShardCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>colocatedShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>=
			<expr><call><name>ShardPlacementListIncludingOrphanedPlacements</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>=
			<expr><call><name>SearchShardPlacementInListOrError</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>UpdateShardPlacementState</name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>, <argument><expr><name>SHARD_STATE_TO_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateColocatedShardPlacementMetadataOnWorkers updates the metadata about the
 * placements of the given shard and its colocated shards by changing the nodename and
 * nodeport of the shards from the source nodename/port to target nodename/port.
 *
 * Note that the function does nothing if the given shard belongs to a non-mx table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateColocatedShardPlacementMetadataOnWorkers</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>,
											   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceNodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>sourceNodePort</name></decl></parameter>,
											   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetNodeName</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>targetNodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedShardCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>shouldSyncMetadata</name> <init>= <expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shouldSyncMetadata</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>sourceGroupId</name> <init>= <expr><call><name>GroupForNode</name><argument_list>(<argument><expr><name>sourceNodeName</name></expr></argument>, <argument><expr><name>sourceNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>targetGroupId</name> <init>= <expr><call><name>GroupForNode</name><argument_list>(<argument><expr><name>targetNodeName</name></expr></argument>, <argument><expr><name>targetNodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><call><name>ColocatedShardIntervalList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate through the colocated shards and copy each */</comment>
	<macro><name>foreach</name><argument_list>(<argument>colocatedShardCell</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>colocatedShard</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>colocatedShardCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>updateCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>updateCommand</name></expr></argument>,
						 <argument><expr><literal type="string">"SELECT citus_internal_update_placement_metadata(%ld, %d, %d)"</literal></expr></argument>,
						 <argument><expr><name><name>colocatedShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
						 <argument><expr><name>sourceGroupId</name></expr></argument>, <argument><expr><name>targetGroupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name><name>updateCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerApplyShardDDLCommandList wraps all DDL commands in ddlCommandList
 * in a call to worker_apply_shard_ddl_command to apply the DDL command to
 * the shard specified by shardId.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>WorkerApplyShardDDLCommandList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>applyDDLCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>ddlCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>ddlCommand</argument>, <argument>ddlCommandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>ddlCommand</name></expr></argument>, <argument><expr><name>TableDDLCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>applyDDLCommand</name> <init>= <expr><call><name>GetShardedTableDDLCommand</name><argument_list>(<argument><expr><name>ddlCommand</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>applyDDLCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>applyDDLCommandList</name></expr></argument>, <argument><expr><name>applyDDLCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>applyDDLCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UpdatePlacementUpdateStatusForShardIntervalList updates the status field for shards
 * in the given shardInterval list.
 */</comment>
<function><type><name>void</name></type>
<name>UpdatePlacementUpdateStatusForShardIntervalList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>,
												<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourcePort</name></decl></parameter>,
												<parameter><decl><type><name>PlacementUpdateStatus</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>segmentList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rebalanceMonitorList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HasProgressMonitor</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rebalanceMonitorList</name> <operator>=</operator> <call><name>ProgressMonitorList</name><argument_list>(<argument><expr><name>REBALANCE_ACTIVITY_MAGIC_NUMBER</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>segmentList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rebalanceMonitorList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>GetCurrentProgressMonitor</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>ProgressMonitorData</name> <modifier>*</modifier></type><name>monitor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>monitor</argument>, <argument>rebalanceMonitorList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>steps</name> <init>= <expr><call><name>ProgressMonitorSteps</name><argument_list>(<argument><expr><name>monitor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>moveIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>moveIndex</name> <operator>&lt;</operator> <name><name>monitor</name><operator>-&gt;</operator><name>stepCount</name></name></expr>;</condition> <incr><expr><name>moveIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlacementUpdateEventProgress</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><name>steps</name> <operator>+</operator> <name>moveIndex</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>currentShardId</name> <init>= <expr><name><name>step</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>foundInList</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>candidateShard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>candidateShard</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>candidateShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>==</operator> <name>currentShardId</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>foundInList</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>foundInList</name> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>sourceName</name></name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>step</name><operator>-&gt;</operator><name>sourcePort</name></name> <operator>==</operator> <name>sourcePort</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_atomic_write_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>step</name><operator>-&gt;</operator><name>updateStatus</name></name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<expr_stmt><expr><call><name>DetachFromDSMSegments</name><argument_list>(<argument><expr><name>segmentList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
