<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/operations/citus_tools.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * citus_tools.c
 *	  UDF to run multi shard/worker queries
 *
 * This file contains functions to run commands on other worker/shards.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/array_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/function.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_run_on_worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ParseCommandParameters</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodeNameArray</name></decl></parameter>,
								  <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodePortsArray</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>commandStringArray</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>parallel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteCommandsInParallelAndStoreResults</name><parameter_list>(<parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>nodeNameArray</name></decl></parameter>,
													 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nodePortArray</name></decl></parameter>,
													 <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>commandStringArray</name></decl></parameter>,
													 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>statusArray</name></decl></parameter>,
													 <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>resultStringArray</name></decl></parameter>,
													 <parameter><decl><type><name>int</name></type> <name>commandCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>GetConnectionStatusAndResult</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resultStatus</name></decl></parameter>,
										 <parameter><decl><type><name>StringInfo</name></type> <name>queryResultString</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteCommandsAndStoreResults</name><parameter_list>(<parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>nodeNameArray</name></decl></parameter>,
										   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nodePortArray</name></decl></parameter>,
										   <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>commandStringArray</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>statusArray</name></decl></parameter>,
										   <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>resultStringArray</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>commandCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecuteOptionalSingleResultCommand</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
											   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type>
											   <name>queryResultString</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Tuplestorestate</name> <modifier>*</modifier></type> <name>CreateTupleStore</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
										  <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>nodeNameArray</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nodePortArray</name></decl></parameter>,
										  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>statusArray</name></decl></parameter>,
										  <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>resultArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>commandCount</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * master_run_on_worker executes queries/commands to run on specified worker and
 * returns success status and query/command result. Expected input is 3 arrays
 * containing node names, node ports, and query strings, and boolean flag to specify
 * parallel execution. The function then returns node_name, node_port, success,
 * result tuples upon completion of the query. The same user credentials are used
 * to connect to remote nodes.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_run_on_worker</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>parallelExecution</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>nodeNameArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>nodePortArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>commandStringArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsinfo</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal>
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>commandCount</name> <init>= <expr><call><name>ParseCommandParameters</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeNameArray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodePortArray</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>commandStringArray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parallelExecution</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name> <init>= <expr><name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get the requested return tuple description */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check to make sure we have correct tuple descriptor
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">4</literal> <operator>||</operator>
		<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name>TEXTOID</name> <operator>||</operator>
		<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name>INT4OID</name> <operator>||</operator>
		<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name>BOOLOID</name> <operator>||</operator>
		<call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name> <operator>!=</operator> <name>TEXTOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query-specified return tuple and "</literal>
						<literal type="string">"function return type are not compatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * prepare storage for status and result values.
	 * commandCount is based on user input however, it is the length of list
	 * instead of a user given integer, hence this should be safe here in terms
	 * of memory allocation.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>statusArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>commandCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>resultArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>commandCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StringInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>commandIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>commandIndex</name> <operator>&lt;</operator> <name>commandCount</name></expr>;</condition> <incr><expr><name>commandIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>resultArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>parallelExecution</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteCommandsInParallelAndStoreResults</name><argument_list>(<argument><expr><name>nodeNameArray</name></expr></argument>, <argument><expr><name>nodePortArray</name></expr></argument>,
												 <argument><expr><name>commandStringArray</name></expr></argument>,
												 <argument><expr><name>statusArray</name></expr></argument>, <argument><expr><name>resultArray</name></expr></argument>, <argument><expr><name>commandCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteCommandsAndStoreResults</name><argument_list>(<argument><expr><name>nodeNameArray</name></expr></argument>, <argument><expr><name>nodePortArray</name></expr></argument>, <argument><expr><name>commandStringArray</name></expr></argument>,
									   <argument><expr><name>statusArray</name></expr></argument>, <argument><expr><name>resultArray</name></expr></argument>, <argument><expr><name>commandCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* let the caller know we're sending back a tuplestore */</comment>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>CreateTupleStore</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
												   <argument><expr><name>nodeNameArray</name></expr></argument>, <argument><expr><name>nodePortArray</name></expr></argument>,
												   <argument><expr><name>statusArray</name></expr></argument>,
												   <argument><expr><name>resultArray</name></expr></argument>, <argument><expr><name>commandCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupleStore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupleDescriptor</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ParseCommandParameters reads call parameters and fills in data structures */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ParseCommandParameters</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodeNameArray</name></decl></parameter>,
					   <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodePortsArray</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>commandStringArray</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>parallel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>nodeNameArrayObject</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>nodePortArrayObject</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>commandStringArrayObject</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>parallelExecution</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nodeNameCount</name> <init>= <expr><call><name>ArrayObjectCount</name><argument_list>(<argument><expr><name>nodeNameArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nodePortCount</name> <init>= <expr><call><name>ArrayObjectCount</name><argument_list>(<argument><expr><name>nodePortArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>commandStringCount</name> <init>= <expr><call><name>ArrayObjectCount</name><argument_list>(<argument><expr><name>commandStringArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>nodeNameDatumArray</name> <init>= <expr><call><name>DeconstructArrayObject</name><argument_list>(<argument><expr><name>nodeNameArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>nodePortDatumArray</name> <init>= <expr><call><name>DeconstructArrayObject</name><argument_list>(<argument><expr><name>nodePortArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>commandStringDatumArray</name> <init>= <expr><call><name>DeconstructArrayObject</name><argument_list>(<argument><expr><name>commandStringArrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nodeNameCount</name> <operator>!=</operator> <name>nodePortCount</name> <operator>||</operator> <name>nodeNameCount</name> <operator>!=</operator> <name>commandStringCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected same number of node name, port, and query string"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>nodeNames</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>nodeNameCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StringInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>nodePorts</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>nodeNameCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>commandStrings</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>nodeNameCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StringInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>nodeNameCount</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeNameText</name> <init>= <expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name><name>nodeNameDatumArray</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>nodeNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>nodePortDatumArray</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>commandText</name> <init>= <expr><call><name>DatumGetTextP</name><argument_list>(<argument><expr><name><name>commandStringDatumArray</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>commandString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>commandText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>nodeNames</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>commandStrings</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>nodeNames</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nodePorts</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>nodePort</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>commandStrings</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>nodeNameArray</name> <operator>=</operator> <name>nodeNames</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nodePortsArray</name> <operator>=</operator> <name>nodePorts</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>commandStringArray</name> <operator>=</operator> <name>commandStrings</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>parallel</name> <operator>=</operator> <name>parallelExecution</name></expr>;</expr_stmt>

	<return>return <expr><name>nodeNameCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteCommandsInParallelAndStoreResults connects to each node specified in
 * nodeNameArray and nodePortArray, and executes command in commandStringArray
 * in parallel fashion. Execution success status and result is reported for
 * each command in statusArray and resultStringArray. Each array contains
 * commandCount items.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteCommandsInParallelAndStoreResults</name><parameter_list>(<parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>nodeNameArray</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nodePortArray</name></decl></parameter>,
										 <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>commandStringArray</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>statusArray</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>resultStringArray</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>commandCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier><modifier>*</modifier></type><name>connectionArray</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><name>commandCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiConnection</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>finishedCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* start connections asynchronously */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>commandIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>commandIndex</name> <operator>&lt;</operator> <name>commandCount</name></expr>;</condition> <incr><expr><name>commandIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>nodeNameArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>nodePortArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>connectionArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator>
			<call><name>StartNodeConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* establish connections */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>commandIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>commandIndex</name> <operator>&lt;</operator> <name>commandCount</name></expr>;</condition> <incr><expr><name>commandIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>connectionArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryResultString</name> <init>= <expr><name><name>resultStringArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>nodeNameArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>nodePortArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FinishConnectionEstablishment</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check whether connection attempt was successful */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>, <argument><expr><literal type="string">"failed to connect to %s:%d"</literal></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>,
							 <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>statusArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>connectionArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>finishedCount</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* set the application_name to avoid nested execution checks */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><call><name>psprintf</name><argument_list>(
											  <argument><expr><literal type="string">"SET application_name TO '%s%ld'"</literal></expr></argument>,
											  <argument><expr><name>CITUS_RUN_COMMAND_APPLICATION_NAME_PREFIX</name></expr></argument>,
											  <argument><expr><call><name>GetGlobalPID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>StoreErrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>statusArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>connectionArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>finishedCount</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>statusArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* send queries at once */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>commandIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>commandIndex</name> <operator>&lt;</operator> <name>commandCount</name></expr>;</condition> <incr><expr><name>commandIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>connectionArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>queryResult</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* write the result value or error message to queryResultString */</comment>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryResultString</name> <init>= <expr><name><name>resultStringArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><call><name>EvaluateSingleQueryResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryResult</name></expr></argument>,
												 <argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>statusArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>connectionArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>finishedCount</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* clear results for the next command */</comment>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we only care about the SET application_name result on failure */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* send queries at once */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>commandIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>commandIndex</name> <operator>&lt;</operator> <name>commandCount</name></expr>;</condition> <incr><expr><name>commandIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>connectionArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name> <init>= <expr><name><name>commandStringArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryResultString</name> <init>= <expr><name><name>resultStringArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If we don't have a connection, nothing to send, error string should already
		 * been filled.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>StoreErrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>statusArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>connectionArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>finishedCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* check for query results */</comment>
	<while>while <condition>(<expr><name>finishedCount</name> <operator>&lt;</operator> <name>commandCount</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>commandIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>commandIndex</name> <operator>&lt;</operator> <name>commandCount</name></expr>;</condition> <incr><expr><name>commandIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>connectionArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryResultString</name> <init>= <expr><name><name>resultStringArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>queryFinished</name> <init>= <expr><call><name>GetConnectionStatusAndResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>success</name></expr></argument>,
															  <argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>queryFinished</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>finishedCount</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>statusArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>success</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>connectionArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>finishedCount</name> <operator>&lt;</operator> <name>commandCount</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>long</name></type> <name>sleepIntervalPerCycle</name> <init>= <expr><name>RemoteTaskCheckInterval</name> <operator>*</operator> <literal type="number">1000L</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>sleepIntervalPerCycle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connectionArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetConnectionStatusAndResult checks the active connection and returns true if
 * query execution is finished (either success or fail).
 * Query success/fail in resultStatus, and query result in queryResultString are
 * reported upon completion of the query.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>GetConnectionStatusAndResult</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resultStatus</name></decl></parameter>,
							 <parameter><decl><type><name>StringInfo</name></type> <name>queryResultString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>finished</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnStatusType</name></type> <name>connectionStatus</name> <init>= <expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>resultStatus</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>connectionStatus</name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>, <argument><expr><literal type="string">"connection lost"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>finished</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>consumeInput</name> <init>= <expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>consumeInput</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>, <argument><expr><literal type="string">"query result unavailable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>finished</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check later if busy */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>finished</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>finished</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* query result is available at this point */</comment>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>queryResult</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><call><name>EvaluateSingleQueryResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryResult</name></expr></argument>, <argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>resultStatus</name> <operator>=</operator> <name>success</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>finished</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteCommandsAndStoreResults connects to each node specified in
 * nodeNameArray and nodePortArray, and executes command in commandStringArray
 * in sequential order. Execution success status and result is reported for
 * each command in statusArray and resultStringArray. Each array contains
 * commandCount items.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteCommandsAndStoreResults</name><parameter_list>(<parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>nodeNameArray</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nodePortArray</name></decl></parameter>,
							   <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>commandStringArray</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>statusArray</name></decl></parameter>,
							   <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>resultStringArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>commandCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>commandIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>commandIndex</name> <operator>&lt;</operator> <name>commandCount</name></expr>;</condition> <incr><expr><name>commandIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>nodeNameArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>nodePort</name> <init>= <expr><name><name>nodePortArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name> <init>= <expr><name><name>commandStringArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryResultString</name> <init>= <expr><name><name>resultStringArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
			<expr><call><name>GetNodeConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* set the application_name to avoid nested execution checks */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><call><name>ExecuteOptionalSingleResultCommand</name><argument_list>(
			<argument><expr><name>connection</name></expr></argument>,
			<argument><expr><call><name>psprintf</name><argument_list>(
				<argument><expr><literal type="string">"SET application_name TO '%s%ld'"</literal></expr></argument>,
				<argument><expr><name>CITUS_RUN_COMMAND_APPLICATION_NAME_PREFIX</name></expr></argument>,
				<argument><expr><call><name>GetGlobalPID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>queryResultString</name></expr></argument>
			)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>statusArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we only care about the SET application_name result on failure */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* send the actual query string */</comment>
		<expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>ExecuteOptionalSingleResultCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
													 <argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>statusArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name> <operator>=</operator> <name>success</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteOptionalSingleResultCommand executes a query at specified remote node using
 * the calling user's credentials. The function returns the query status
 * (success/failure), and query result. The query is expected to return a single
 * target containing zero or one rows.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExecuteOptionalSingleResultCommand</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
								   <parameter><decl><type><name>StringInfo</name></type> <name>queryResultString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>, <argument><expr><literal type="string">"failed to connect to %s:%d"</literal></expr></argument>,
						 <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>, <argument><expr><literal type="string">"failed to send query to %s:%d"</literal></expr></argument>,
						 <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>queryResult</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* write the result value or error message to queryResultString */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><call><name>EvaluateSingleQueryResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryResult</name></expr></argument>, <argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* clear result and close the connection */</comment>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* CreateTupleStore prepares result tuples from individual query results */</comment>
<function><type><specifier>static</specifier> <name>Tuplestorestate</name> <modifier>*</modifier></type>
<name>CreateTupleStore</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
				 <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>nodeNameArray</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nodePortArray</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>statusArray</name></decl></parameter>,
				 <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>resultArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>commandCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>commandIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>commandIndex</name> <operator>&lt;</operator> <name>commandCount</name></expr>;</condition> <incr><expr><name>commandIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>nodeNameString</name> <init>= <expr><name><name>nodeNameArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>resultString</name> <init>= <expr><name><name>resultArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>nodeNameText</name> <init>= <expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>nodeNameString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
													  <argument><expr><name><name>nodeNameString</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>resultText</name> <init>= <expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>resultString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
													<argument><expr><name><name>resultString</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>nodeNameText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>nodePortArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>statusArray</name><index>[<expr><name>commandIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>resultText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodeNameText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>resultText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>tupleStore</name></expr>;</return>
</block_content>}</block></function>
</unit>
