<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/operations/shard_split.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * shard_split.c
 *
 * Function definitions for the shard split.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/array_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_library_init.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/adaptive_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_split.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_transfer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_cleaner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_library_init.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_shard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/distribution_column_map.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardsplit_logical_replication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_rebalancer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Entry for map that tracks ShardInterval -&gt; Placement Node
 * created by split workflow.
 */</comment>
<typedef>typedef <type><struct>struct <name>ShardCreatedByWorkflowEntry</name>
<block>{
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardIntervalKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNodeValue</name></decl>;</decl_stmt>
}</block></struct></type> <name>ShardCreatedByWorkflowEntry</name>;</typedef>

<comment type="block">/*
 * Entry for map that trackes dummy shards.
 * Key: node + owner
 * Value: List of dummy shards for that node + owner
 */</comment>
<typedef>typedef <type><struct>struct <name>GroupedDummyShards</name>
<block>{
	<decl_stmt><decl><type><name>NodeAndOwner</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervals</name></decl>;</decl_stmt>
}</block></struct></type> <name>GroupedDummyShards</name>;</typedef>

<comment type="block">/* Function declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfCannotSplitShard</name><parameter_list>(<parameter><decl><type><name>SplitOperation</name></type> <name>splitOperation</name></decl></parameter>,
									<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>sourceShard</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfCannotSplitShardExtended</name><parameter_list>(<parameter><decl><type><name>SplitOperation</name></type> <name>splitOperation</name></decl></parameter>,
											<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardIntervalToSplit</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardSplitPointsList</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeIdsForPlacementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckIfRelationWithSameNameExists</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>,
											  <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfModificationAndSplitInTheSameTransaction</name><parameter_list>(<parameter><decl><type><name>SplitOperation</name></type>
															<name>splitOperation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateSplitShardsForShardGroup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateDummyShardsForShardGroup</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>mapOfPlacementToDummyShardList</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
										   <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceWorkerNode</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>CreateWorkerForPlacementSet</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateAuxiliaryStructuresForShardGroup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
												   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>,
												   <parameter><decl><type><name>bool</name></type> <name>includeReplicaIdentity</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateReplicaIdentitiesForDummyShards</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>mapOfPlacementToDummyShardList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateObjectOnPlacement</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>objectCreationCommandList</name></decl></parameter>,
									<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>    <name>CreateSplitIntervalsForShardGroup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardList</name></decl></parameter>,
												   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>splitPointsForShard</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateSplitIntervalsForShard</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>sourceShard</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>splitPointsForShard</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardSplitChildrenIntervalList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BlockingShardSplit</name><parameter_list>(<parameter><decl><type><name>SplitOperation</name></type> <name>splitOperation</name></decl></parameter>,
							   <parameter><decl><type><name>uint64</name></type> <name>splitWorkflowId</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardSplitPointsList</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>,
							   <parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnOverrides</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>NonBlockingShardSplit</name><parameter_list>(<parameter><decl><type><name>SplitOperation</name></type> <name>splitOperation</name></decl></parameter>,
								  <parameter><decl><type><name>uint64</name></type> <name>splitWorkflowId</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardSplitPointsList</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>,
								  <parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnOverrides</name></decl></parameter>,
								  <parameter><decl><type><name>uint32</name></type> <name>targetColocationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DoSplitCopy</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceShardNode</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>snapShotName</name></decl></parameter>,
						<parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnOverrides</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>CreateSplitCopyCommand</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>sourceShardSplitInterval</name></decl></parameter>,
										 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>splitChildrenShardIntervalList</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type> <name>CreateSplitCopyTask</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>splitCopyUdfCommand</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>snapshotName</name></decl></parameter>, <parameter><decl><type><name>int</name></type>
								  <name>taskId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateDistributionColumnsForShardGroup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name></decl></parameter>,
												   <parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distCols</name></decl></parameter>,
												   <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>,
												   <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>,
												   <parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InsertSplitChildrenShardMetadata</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
											 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreatePartitioningHierarchyForBlockingSplit</name><parameter_list>(
	<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
	<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateForeignKeyConstraints</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type> <name>CreateTaskForDDLCommandList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>CreateSplitShardReplicationSetupUDF</name><parameter_list>(
	<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
	<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>destinationWorkerNodesList</name></decl></parameter>,
	<parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type>
	<name>distributionColumnOverrides</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ParseReplicationSlotInfoFromResult</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ExecuteSplitShardReplicationSetupUDF</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceWorkerNode</name></decl></parameter>,
												   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
												   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
												   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>destinationWorkerNodesList</name></decl></parameter>,
												   <parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type>
												   <name>distributionColumnOverrides</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteSplitShardReleaseSharedMemory</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceConnection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddDummyShardEntryInMap</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>mapOfPlacementToDummyShardList</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type>
									<name>targetNodeId</name></decl></parameter>,
									<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>GetNextShardIdForSplitChild</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AcquireNonblockingSplitLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetWorkerNodesFromWorkerIds</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeIdsForPlacementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropShardListMetadata</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InsertDeferredDropCleanupRecordsForShards</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Customize error message strings based on operation type */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>SplitOperationName</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><index>[<expr><name>SHARD_SPLIT_API</name></expr>]</index> <operator>=</operator> <literal type="string">"split"</literal></expr>,
	<expr><index>[<expr><name>ISOLATE_TENANT_TO_NEW_SHARD</name></expr>]</index> <operator>=</operator> <literal type="string">"isolate"</literal></expr>,
	<expr><index>[<expr><name>CREATE_DISTRIBUTED_TABLE</name></expr>]</index> <operator>=</operator> <literal type="string">"create"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>SplitOperationAPIName</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><index>[<expr><name>SHARD_SPLIT_API</name></expr>]</index> <operator>=</operator> <literal type="string">"citus_split_shard_by_split_points"</literal></expr>,
	<expr><index>[<expr><name>ISOLATE_TENANT_TO_NEW_SHARD</name></expr>]</index> <operator>=</operator> <literal type="string">"isolate_tenant_to_new_shard"</literal></expr>,
	<expr><index>[<expr><name>CREATE_DISTRIBUTED_TABLE</name></expr>]</index> <operator>=</operator> <literal type="string">"create_distributed_table_concurrently"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>SplitTargetName</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><index>[<expr><name>SHARD_SPLIT_API</name></expr>]</index> <operator>=</operator> <literal type="string">"shard"</literal></expr>,
	<expr><index>[<expr><name>ISOLATE_TENANT_TO_NEW_SHARD</name></expr>]</index> <operator>=</operator> <literal type="string">"tenant"</literal></expr>,
	<expr><index>[<expr><name>CREATE_DISTRIBUTED_TABLE</name></expr>]</index> <operator>=</operator> <literal type="string">"distributed table"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Function definitions */</comment>

<comment type="block">/*
 * ErrorIfCannotSplitShard checks relation kind and invalid shards. It errors
 * out if we are not able to split the given shard.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfCannotSplitShard</name><parameter_list>(<parameter><decl><type><name>SplitOperation</name></type> <name>splitOperation</name></decl></parameter>, <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>sourceShard</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>sourceShard</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>colocatedShardCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* checks for table ownership and foreign tables */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><call><name>ColocatedTableList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>colocatedTableCell</argument>, <argument>colocatedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>colocatedTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* check that user has owner rights in all co-located tables */</comment>
		<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name></type> <name>relationKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>relationKind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot %s %s because \"%s\" is a "</literal>
								   <literal type="string">"foreign table"</literal></expr></argument>,
								   <argument><expr><name><name>SplitOperationName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name><name>SplitTargetName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Splitting shards backed by foreign tables "</literal>
									  <literal type="string">"is not supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* check shards with inactive placements */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><call><name>ColocatedShardIntervalList</name><argument_list>(<argument><expr><name>sourceShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>colocatedShardCell</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>colocatedShardCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardPlacementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>ShardPlacementListWithoutOrphanedPlacements</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>shardPlacementCell</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardPlacementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>shardState</name></name> <operator>!=</operator> <name>SHARD_STATE_ACTIVE</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot %s %s because relation "</literal>
									   <literal type="string">"\"%s\" has an inactive shard placement "</literal>
									   <literal type="string">"for the shard %lu"</literal></expr></argument>,
									   <argument><expr><name><name>SplitOperationName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>SplitTargetName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * Exteded checks before we decide to split the shard.
 * When all consumers (Example : ISOLATE_TENANT_TO_NEW_SHARD) directly call 'SplitShard' API,
 * this method will be merged with 'ErrorIfCannotSplitShard' above.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfCannotSplitShardExtended</name><parameter_list>(<parameter><decl><type><name>SplitOperation</name></type> <name>splitOperation</name></decl></parameter>,
								<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardIntervalToSplit</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardSplitPointsList</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeIdsForPlacementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* we should not perform checks for create distributed table operation */</comment>
	<if_stmt><if>if <condition>(<expr><name>splitOperation</name> <operator>==</operator> <name>CREATE_DISTRIBUTED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cachedTableEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(
		<argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Perform checks common to both blocking and non-blocking Split API here. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cachedTableEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot %s %s as operation "</literal>
							   <literal type="string">"is only supported for hash distributed tables."</literal></expr></argument>,
							   <argument><expr><name><name>SplitOperationName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name><name>SplitTargetName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>relationReplicationFactor</name> <init>= <expr><call><name>TableShardReplicationFactor</name><argument_list>(
		<argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relationReplicationFactor</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"Operation %s not supported for %s as replication factor '%u' "</literal>
							<literal type="string">"is greater than 1."</literal></expr></argument>,
							<argument><expr><name><name>SplitOperationName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></argument>,
							<argument><expr><name><name>SplitTargetName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>relationReplicationFactor</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>splitPointsCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardSplitPointsList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nodeIdsCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>nodeIdsForPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardsCount</name> <init>= <expr><name>splitPointsCount</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>nodeIdsCount</name> <operator>!=</operator> <name>shardsCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(
					 <argument><expr><literal type="string">"Number of worker node ids should be one greater split points. "</literal>
					 <literal type="string">"NodeId count is '%d' and SplitPoint count is '%d'."</literal></expr></argument>,
					 <argument><expr><name>nodeIdsCount</name></expr></argument>,
					 <argument><expr><name>splitPointsCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>shardsCount</name> <operator>&gt;</operator> <name>MAX_SHARD_COUNT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"Resulting shard count '%d' with split is greater than max shard count '%d' limit."</literal></expr></argument>,
							<argument><expr><name>shardsCount</name></expr></argument>, <argument><expr><name>MAX_SHARD_COUNT</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>minValueExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We already verified table is Hash Distributed. We know (minValue, maxValue) are integers. */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>minValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>maxValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Fail if Shard Interval cannot be split anymore i.e (min, max) range overlap. */</comment>
	<if_stmt><if>if <condition>(<expr><name>minValue</name> <operator>==</operator> <name>maxValue</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(
					 <argument><expr><literal type="string">"Cannot split shard id \"%lu\" as min/max range are equal: ('%d', '%d')."</literal></expr></argument>,
					 <argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
					 <argument><expr><name>minValue</name></expr></argument>,
					 <argument><expr><name>maxValue</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>NullableDatum</name></type> <name>lastShardSplitPoint</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>true</name></expr> <comment type="block">/*isnull*/</comment> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>shardSplitPoint</name></decl>;</decl_stmt>
	<macro><name>foreach_int</name><argument_list>(<argument>shardSplitPoint</argument>, <argument>shardSplitPointsList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardSplitPointValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>shardSplitPoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * 1) All Split points should lie within the shard interval range.
		 * 2) Given our split points inclusive, you cannot specify the max value in a range as a split point.
		 * Example: Shard 81060002 range is from (0,1073741823). '1073741823' as split point is invalid.
		 * '1073741822' is correct and will split shard to: (0, 1073741822) and (1073741823, 1073741823).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shardSplitPointValue</name> <argument_list type="generic">&lt; <argument><expr><name>minValue</name> <operator>||</operator> <name>shardSplitPointValue</name></expr></argument> &gt;</argument_list></name> <name>maxValue</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(
						 <argument><expr><literal type="string">"Split point %d is outside the min/max range(%d, %d) for shard id %lu."</literal></expr></argument>,
						 <argument><expr><name>shardSplitPointValue</name></expr></argument>,
						 <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>maxValue</name> <operator>==</operator> <name>shardSplitPointValue</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type> <name>validSplitPoint</name> <init>= <expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>maxValue</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(
						 <argument><expr><literal type="string">"Invalid split point %d, as split points should be inclusive. Please use %d instead."</literal></expr></argument>,
						 <argument><expr><name>maxValue</name></expr></argument>,
						 <argument><expr><name>validSplitPoint</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Split points should be in strictly increasing order */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>lastShardSplitPointValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>lastShardSplitPoint</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lastShardSplitPoint</name><operator>.</operator><name>isnull</name></name> <operator>&amp;&amp;</operator> <name>shardSplitPointValue</name> <operator>&lt;=</operator>
			<name>lastShardSplitPointValue</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(
						 <argument><expr><literal type="string">"Invalid Split Points '%d' followed by '%d'. "</literal>
						 <literal type="string">"All split points should be strictly increasing."</literal></expr></argument>,
						 <argument><expr><name>lastShardSplitPointValue</name></expr></argument>,
						 <argument><expr><name>shardSplitPointValue</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>lastShardSplitPoint</name> <operator>=</operator> <operator>(</operator><name>NullableDatum</name><operator>)</operator> <block>{
			<expr><name>shardSplitPoint</name></expr>, <expr><name>false</name></expr>
		}</block></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfModificationAndSplitInTheSameTransaction will error if we detect split operation
 * in the same transaction which has modification before.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfModificationAndSplitInTheSameTransaction</name><parameter_list>(<parameter><decl><type><name>SplitOperation</name></type> <name>splitOperation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>XactModificationLevel</name> <operator>&gt;</operator> <name>XACT_MODIFICATION_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot %s %s after other modifications "</literal>
							   <literal type="string">"in the same transaction."</literal></expr></argument>,
							   <argument><expr><name><name>SplitOperationName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></argument>,
							   <argument><expr><name><name>SplitTargetName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfMultipleNonblockingMoveSplitInTheSameTransaction will error if we detect multiple
 * nonblocking shard movements/splits in the same transaction.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfMultipleNonblockingMoveSplitInTheSameTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>PlacementMovedUsingLogicalReplicationInTX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple shard movements/splits via logical "</literal>
							   <literal type="string">"replication in the same transaction is currently "</literal>
							   <literal type="string">"not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetWorkerNodesFromWorkerIds returns list of worker nodes given a list
 * of worker ids. It will error if any node id is invalid.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetWorkerNodesFromWorkerIds</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeIdsForPlacementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>nodeId</name></decl>;</decl_stmt>
	<macro><name>foreach_int</name><argument_list>(<argument>nodeId</argument>, <argument>nodeIdsForPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>nodeIdValue</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>nodeId</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>LookupNodeByNodeId</name><argument_list>(<argument><expr><name>nodeIdValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* NodeId in Citus are unsigned and range from [1, 4294967296]. */</comment>
		<if_stmt><if>if <condition>(<expr><name>nodeIdValue</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>workerNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid Node Id '%u'."</literal></expr></argument>, <argument><expr><name>nodeIdValue</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>workersForPlacementList</name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name>workersForPlacementList</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>workersForPlacementList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SplitShard API to split a given shard (or shard group) based on specified split points
 * to a set of destination nodes.
 * 'splitMode'					: Mode of split operation.
 * 'splitOperation'             : Customer operation that triggered split.
 * 'shardInterval'              : Source shard interval to be split.
 * 'shardSplitPointsList'		: Split Points list for the source 'shardInterval'.
 * 'nodeIdsForPlacementList'	: Placement list corresponding to split children.
 * 'distributionColumnList'     : Maps relation IDs to distribution columns.
 *                                If not specified, the distribution column is read
 *                                from the metadata.
 * 'colocatedShardIntervalList' : Shard interval list for colocation group. (only used for
 *                                create_distributed_table_concurrently).
 * 'targetColocationId'         : Specifies the colocation ID (only used for
 *                                create_distributed_table_concurrently).
 */</comment>
<function><type><name>void</name></type>
<name>SplitShard</name><parameter_list>(<parameter><decl><type><name>SplitMode</name></type> <name>splitMode</name></decl></parameter>,
		   <parameter><decl><type><name>SplitOperation</name></type> <name>splitOperation</name></decl></parameter>,
		   <parameter><decl><type><name>uint64</name></type> <name>shardIdToSplit</name></decl></parameter>,
		   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardSplitPointsList</name></decl></parameter>,
		   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeIdsForPlacementList</name></decl></parameter>,
		   <parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnOverrides</name></decl></parameter>,
		   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardIntervalList</name></decl></parameter>,
		   <parameter><decl><type><name>uint32</name></type> <name>targetColocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operationName</name> <init>= <expr><name><name>SplitOperationAPIName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfModificationAndSplitInTheSameTransaction</name><argument_list>(<argument><expr><name>splitOperation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardIntervalToSplit</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>shardIdToSplit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><call><name>ColocatedTableList</name><argument_list>(<argument><expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>splitMode</name> <operator>==</operator> <name>AUTO_SPLIT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>VerifyTablesHaveReplicaIdentity</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Acquire global lock to prevent concurrent split on the same colocation group or relation */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name>shardIdToSplit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AcquirePlacementColocationLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><literal type="string">"split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sort the tables to avoid deadlocks */</comment>
	<expr_stmt><expr><name>colocatedTableList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>colocatedTableList</name></expr></argument>, <argument><expr><name>CompareOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>colocatedTableId</argument>, <argument>colocatedTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Block concurrent DDL / TRUNCATE commands on the relation. Similarly,
		 * block concurrent citus_move_shard_placement() / isolate_tenant_to_new_shard()
		 * on any shard of the same relation.
		 */</comment>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ErrorIfCannotSplitShard</name><argument_list>(<argument><expr><name>splitOperation</name></expr></argument>, <argument><expr><name>shardIntervalToSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorIfCannotSplitShardExtended</name><argument_list>(
		<argument><expr><name>splitOperation</name></expr></argument>,
		<argument><expr><name>shardIntervalToSplit</name></expr></argument>,
		<argument><expr><name>shardSplitPointsList</name></expr></argument>,
		<argument><expr><name>nodeIdsForPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name> <init>= <expr><call><name>GetWorkerNodesFromWorkerIds</name><argument_list>(<argument><expr><name>nodeIdsForPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfNotAllNodesHaveReferenceTableReplicas</name><argument_list>(<argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>colocatedShardIntervalList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sourceColocatedShardIntervalList</name> <operator>=</operator> <call><name>ColocatedShardIntervalList</name><argument_list>(
			<argument><expr><name>shardIntervalToSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>sourceColocatedShardIntervalList</name> <operator>=</operator> <name>colocatedShardIntervalList</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>DropOrphanedResourcesInSeparateTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* use the user-specified shard ID as the split workflow ID */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>splitWorkflowId</name> <init>= <expr><name><name>shardIntervalToSplit</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Start operation to prepare for generating cleanup records */</comment>
	<expr_stmt><expr><call><name>RegisterOperationNeedingCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>splitMode</name> <operator>==</operator> <name>BLOCKING_SPLIT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"performing blocking %s "</literal></expr></argument>, <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>BlockingShardSplit</name><argument_list>(
			<argument><expr><name>splitOperation</name></expr></argument>,
			<argument><expr><name>splitWorkflowId</name></expr></argument>,
			<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
			<argument><expr><name>shardSplitPointsList</name></expr></argument>,
			<argument><expr><name>workersForPlacementList</name></expr></argument>,
			<argument><expr><name>distributionColumnOverrides</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"performing non-blocking %s "</literal></expr></argument>, <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>NonBlockingShardSplit</name><argument_list>(
			<argument><expr><name>splitOperation</name></expr></argument>,
			<argument><expr><name>splitWorkflowId</name></expr></argument>,
			<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
			<argument><expr><name>shardSplitPointsList</name></expr></argument>,
			<argument><expr><name>workersForPlacementList</name></expr></argument>,
			<argument><expr><name>distributionColumnOverrides</name></expr></argument>,
			<argument><expr><name>targetColocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>PlacementMovedUsingLogicalReplicationInTX</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Drop temporary objects that were marked as CLEANUP_ALWAYS.
	 */</comment>
	<expr_stmt><expr><call><name>FinalizeOperationNeedingCleanupOnSuccess</name><argument_list>(<argument><expr><name>operationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SplitShard API to split a given shard (or shard group) in blocking fashion
 * based on specified split points to a set of destination nodes.
 * splitOperation                   : Customer operation that triggered split.
 * splitWorkflowId                  : Number used to identify split workflow in names.
 * sourceColocatedShardIntervalList : Source shard group to be split.
 * shardSplitPointsList             : Split Points list for the source 'shardInterval'.
 * workersForPlacementList          : Placement list corresponding to split children.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BlockingShardSplit</name><parameter_list>(<parameter><decl><type><name>SplitOperation</name></type> <name>splitOperation</name></decl></parameter>,
				   <parameter><decl><type><name>uint64</name></type> <name>splitWorkflowId</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardSplitPointsList</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>,
				   <parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnOverrides</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operationName</name> <init>= <expr><name><name>SplitOperationAPIName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>BlockWritesToShardList</name><argument_list>(<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First create shard interval metadata for split children */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name> <init>= <expr><call><name>CreateSplitIntervalsForShardGroup</name><argument_list>(
		<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
		<argument><expr><name>shardSplitPointsList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Only single placement allowed (already validated RelationReplicationFactor = 1) */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>firstShard</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceShardNode</name> <init>=
		<expr><call><name>ActiveShardPlacementWorkerNode</name><argument_list>(<argument><expr><name><name>firstShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating child shards for %s"</literal></expr></argument>, <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Physically create split children. */</comment>
		<expr_stmt><expr><call><name>CreateSplitShardsForShardGroup</name><argument_list>(<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
									   <argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"performing copy for %s"</literal></expr></argument>, <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* For Blocking split, copy isn't snapshotted */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>snapshotName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ConflictWithIsolationTestingBeforeCopy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DoSplitCopy</name><argument_list>(<argument><expr><name>sourceShardNode</name></expr></argument>, <argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
					<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>, <argument><expr><name>workersForPlacementList</name></expr></argument>,
					<argument><expr><name>snapshotName</name></expr></argument>, <argument><expr><name>distributionColumnOverrides</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ConflictWithIsolationTestingAfterCopy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
						  <argument><expr><literal type="string">"creating auxillary structures (indexes, stats, replicaindentities, triggers) for %s"</literal></expr></argument>,
						  <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create auxiliary structures (indexes, stats, replicaindentities, triggers) */</comment>
		<expr_stmt><expr><call><name>CreateAuxiliaryStructuresForShardGroup</name><argument_list>(<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
											   <argument><expr><name>workersForPlacementList</name></expr></argument>,
											   <argument><expr><name>true</name></expr></argument> <comment type="block">/* includeReplicaIdentity*/</comment>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Up to this point, we performed various subtransactions that may
		 * require additional clean-up in case of failure. The remaining operations
		 * going forward are part of the same distributed transaction.
		 */</comment>


		<comment type="block">/*
		 * Delete old shards metadata and mark the shards as to be deferred drop.
		 * Have to do that before creating the new shard metadata,
		 * because there's cross-checks preventing inconsistent metadata
		 * (like overlapping shards).
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"marking deferred cleanup of source shard(s) for %s"</literal></expr></argument>,
							 <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InsertDeferredDropCleanupRecordsForShards</name><argument_list>(<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DropShardListMetadata</name><argument_list>(<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Insert new shard and placement metdata */</comment>
		<expr_stmt><expr><call><name>InsertSplitChildrenShardMetadata</name><argument_list>(<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
										 <argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* create partitioning hierarchy, if any */</comment>
		<expr_stmt><expr><call><name>CreatePartitioningHierarchyForBlockingSplit</name><argument_list>(
			<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
			<argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating foreign key constraints (if any) for %s"</literal></expr></argument>,
							 <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create foreign keys if exists after the metadata changes happening in
		 * InsertSplitChildrenShardMetadata() because the foreign
		 * key creation depends on the new metadata.
		 */</comment>
		<expr_stmt><expr><call><name>CreateForeignKeyConstraints</name><argument_list>(<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
									<argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* end ongoing transactions to enable us to clean up */</comment>
		<expr_stmt><expr><call><name>ShutdownAllConnections</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Do a best effort cleanup of shards created on workers in the above block */</comment>
		<expr_stmt><expr><call><name>FinalizeOperationNeedingCleanupOnFailure</name><argument_list>(<argument><expr><name>operationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistShardRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Check if a relation with given name already exists on the worker node */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckIfRelationWithSameNameExists</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(
		<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardName</name></expr></argument>, <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>checkShardExistsQuery</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We pass schemaName and shardName without quote_identifier, since
	 * they are used as strings here.
	 */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>checkShardExistsQuery</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT EXISTS (SELECT FROM pg_catalog.pg_tables WHERE schemaname = %s AND tablename = %s);"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>shardName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
																<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
																<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
																<argument><expr><call><name>CitusExtensionOwnerName</name><argument_list>()</argument_list></call></expr></argument>,
																<argument><expr><call><name>get_database_name</name><argument_list>(
																	<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>queryResult</name> <init>= <expr><call><name>ExecuteOptionalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>,
												   <argument><expr><name><name>checkShardExistsQuery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>queryResult</name> <operator>!=</operator> <name>RESPONSE_OKAY</name> <operator>||</operator> <operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>existsString</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>tableExists</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>existsString</name></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tableExists</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Create ShardGroup split children on a list of corresponding workers. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateSplitShardsForShardGroup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Iterate over all the shards in the shard group.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardIntervalList</argument>, <argument>shardGroupSplitIntervalListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerPlacementNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Iterate on split shards DDL command list for a given shard
		 * and create them on corresponding workerPlacementNode.
		 */</comment>
		<macro><name>forboth_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>, <argument>workerPlacementNode</argument>,
					<argument>workersForPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* Populate list of commands necessary to create shard interval on destination */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>splitShardCreationCommandList</name> <init>= <expr><call><name>GetPreLoadTableCreationCommands</name><argument_list>(
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
				<argument><expr><name>false</name></expr></argument>, <comment type="block">/* includeSequenceDefaults */</comment>
				<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* auto add columnar options for cstore tables */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>splitShardCreationCommandList</name> <operator>=</operator> <call><name>WorkerApplyShardDDLCommandList</name><argument_list>(
				<argument><expr><name>splitShardCreationCommandList</name></expr></argument>,
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Log resource for cleanup in case of failure only.
			 * Before we log a record, do a best effort check to see if a shard with same name exists.
			 * This is because, it will cause shard creation to fail and we will end up cleaning the
			 * old shard. We don't want that.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>relationExists</name> <init>= <expr><call><name>CheckIfRelationWithSameNameExists</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>,
																	<argument><expr><name>workerPlacementNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>relationExists</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation %s already exists on worker %s:%d"</literal></expr></argument>,
									   <argument><expr><call><name>ConstructQualifiedShardName</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
									   <argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>InsertCleanupRecordInSubtransaction</name><argument_list>(<argument><expr><name>CLEANUP_OBJECT_SHARD_PLACEMENT</name></expr></argument>,
												<argument><expr><call><name>ConstructQualifiedShardName</name><argument_list>(
													<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
												<argument><expr><name>CLEANUP_ON_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create new split child shard on the specified placement list */</comment>
			<expr_stmt><expr><call><name>CreateObjectOnPlacement</name><argument_list>(<argument><expr><name>splitShardCreationCommandList</name></expr></argument>,
									<argument><expr><name>workerPlacementNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/* Create a DDL task with corresponding task list on given worker node */</comment>
<function><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type>
<name>CreateTaskForDDLCommandList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>ddlTask</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ddlTask</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>DDL_TASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlTask</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetTaskQueryStringList</name><argument_list>(<argument><expr><name>ddlTask</name></expr></argument>, <argument><expr><name>ddlCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetPlacementNodeMetadata</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ddlTask</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Create ShardGroup auxiliary structures (indexes, stats, replicaindentities, triggers)
 * on a list of corresponding workers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateAuxiliaryStructuresForShardGroup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
									   <name>includeReplicaIdentity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlTaskExecList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate over all the shards in the shard group.
	 */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardIntervalList</argument>, <argument>shardGroupSplitIntervalListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerPlacementNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Iterate on split shard interval list for given shard and create tasks
		 * for every single split shard in a shard group.
		 */</comment>
		<macro><name>forboth_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>, <argument>workerPlacementNode</argument>,
					<argument>workersForPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name> <init>= <expr><call><name>GetPostLoadTableCreationCommands</name><argument_list>(
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
				<argument><expr><name>true</name></expr></argument> <comment type="block">/* includeIndexes */</comment>,
				<argument><expr><name>includeReplicaIdentity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>ddlCommandList</name> <operator>=</operator> <call><name>WorkerApplyShardDDLCommandList</name><argument_list>(
				<argument><expr><name>ddlCommandList</name></expr></argument>,
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * A task is expected to be instantiated with a non-null 'ddlCommandList'.
			 * The list can be empty, if no auxiliary structures are present.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ddlCommandList</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>ddlTask</name> <init>= <expr><call><name>CreateTaskForDDLCommandList</name><argument_list>(<argument><expr><name>ddlCommandList</name></expr></argument>,
															<argument><expr><name>workerPlacementNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>ddlTaskExecList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlTaskExecList</name></expr></argument>, <argument><expr><name>ddlTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExecuteTaskListOutsideTransaction</name><argument_list>(
		<argument><expr><name>ROW_MODIFY_NONE</name></expr></argument>,
		<argument><expr><name>ddlTaskExecList</name></expr></argument>,
		<argument><expr><name>MaxAdaptiveExecutorPoolSize</name></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* jobIdList (ignored by API implementation) */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Perform Split Copy from source shard(s) to split children.
 * 'sourceShardNode'					: Source shard worker node.
 * 'sourceColocatedShardIntervalList'	: List of source shard intervals from shard group.
 * 'shardGroupSplitIntervalListList'	: List of shard intervals for split children.
 * 'workersForPlacementList'			: List of workers for split children placement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DoSplitCopy</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceShardNode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
			<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>destinationWorkerNodesList</name></decl></parameter>,
			<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>snapShotName</name></decl></parameter>, <parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnOverrides</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>sourceShardIntervalToCopy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>splitShardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>splitCopyTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth_ptr</name><argument_list>(<argument>sourceShardIntervalToCopy</argument>, <argument>sourceColocatedShardIntervalList</argument>,
				<argument>splitShardIntervalList</argument>, <argument>shardGroupSplitIntervalListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Skip copying data for partitioned tables, because they contain no
		 * data themselves. Their partitions do contain data, but those are
		 * different colocated shards that will be copied seperately.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name><name>sourceShardIntervalToCopy</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>sourceShardIntervalToCopy</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name> <init>=
			<expr><call><name>GetDistributionColumnWithOverrides</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
											   <argument><expr><name>distributionColumnOverrides</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distributionColumn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>missingOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name> <init>= <expr><call><name>get_attname</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
												   <argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>,
												   <argument><expr><name>missingOK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>splitCopyUdfCommand</name> <init>= <expr><call><name>CreateSplitCopyCommand</name><argument_list>(
			<argument><expr><name>sourceShardIntervalToCopy</name></expr></argument>,
			<argument><expr><name>distributionColumnName</name></expr></argument>,
			<argument><expr><name>splitShardIntervalList</name></expr></argument>,
			<argument><expr><name>destinationWorkerNodesList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Create copy task. Snapshot name is required for nonblocking splits */</comment>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>splitCopyTask</name> <init>= <expr><call><name>CreateSplitCopyTask</name><argument_list>(<argument><expr><name>splitCopyUdfCommand</name></expr></argument>, <argument><expr><name>snapShotName</name></expr></argument>,
												  <argument><expr><name>taskId</name></expr></argument>,
												  <argument><expr><name><name>sourceShardIntervalToCopy</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SetPlacementNodeMetadata</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>, <argument><expr><name>sourceShardNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splitCopyTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>splitCopyTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>splitCopyTaskList</name></expr></argument>, <argument><expr><name>splitCopyTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>taskId</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExecuteTaskListOutsideTransaction</name><argument_list>(<argument><expr><name>ROW_MODIFY_NONE</name></expr></argument>, <argument><expr><name>splitCopyTaskList</name></expr></argument>,
									  <argument><expr><name>MaxAdaptiveExecutorPoolSize</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* jobIdList (ignored by API implementation) */</comment>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Create Copy command for a given shard source shard to be copied to corresponding split children.
 * 'sourceShardSplitInterval' : Source shard interval to be copied.
 * 'splitChildrenShardINnerIntervalList' : List of shard intervals for split children.
 * 'destinationWorkerNodesList' : List of workers for split children placement.
 * Here is an example of a 2 way split copy :
 * SELECT * from worker_split_copy(
 *  81060000, -- source shard id to split copy
 *  ARRAY[
 *       -- split copy info for split children 1
 *      ROW(81060015, -- destination shard id
 *           -2147483648, -- split range begin
 *          1073741823, --split range end
 *          10 -- worker node id)::pg_catalog.split_copy_info,
 *      -- split copy info for split children 2
 *      ROW(81060016,  --destination shard id
 *          1073741824, --split range begin
 *          2147483647, --split range end
 *          11 -- workef node id)::pg_catalog.split_copy_info
 *      ]
 *  );
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>CreateSplitCopyCommand</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>sourceShardSplitInterval</name></decl></parameter>,
					   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>splitChildrenShardIntervalList</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>destinationWorkerNodesList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>splitCopyInfoArray</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>splitCopyInfoArray</name></expr></argument>, <argument><expr><literal type="string">"ARRAY["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>splitChildShardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>addComma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>destinationWorkerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth_ptr</name><argument_list>(<argument>splitChildShardInterval</argument>, <argument>splitChildrenShardIntervalList</argument>,
				<argument>destinationWorkerNode</argument>, <argument>destinationWorkerNodesList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>addComma</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>splitCopyInfoArray</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>splitCopyInfoRow</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>splitCopyInfoRow</name></expr></argument>,
						 <argument><expr><literal type="string">"ROW(%lu, %d, %d, %u)::pg_catalog.split_copy_info"</literal></expr></argument>,
						 <argument><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
						 <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>destinationWorkerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>splitCopyInfoArray</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>splitCopyInfoRow</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>addComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>splitCopyInfoArray</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>splitCopyUdf</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>splitCopyUdf</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.worker_split_copy(%lu, %s, %s);"</literal></expr></argument>,
					 <argument><expr><name><name>sourceShardSplitInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>distributionColumnName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>splitCopyInfoArray</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>splitCopyUdf</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateSplitCopyTask creates a task for copying data.
 * In the case of Non-blocking split, snapshotted copy task is created with given 'snapshotName'.
 * 'snapshotName' is NULL for Blocking split.
 */</comment>
<function><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type>
<name>CreateSplitCopyTask</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>splitCopyUdfCommand</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>snapshotName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>taskId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type>
					<name>jobId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>beginTransaction</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>beginTransaction</name></expr></argument>,
					 <argument><expr><literal type="string">"BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ddlCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommandList</name></expr></argument>, <argument><expr><name><name>beginTransaction</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set snapshot for non-blocking shard split. */</comment>
	<if_stmt><if>if <condition>(<expr><name>snapshotName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>snapShotString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>snapShotString</name></expr></argument>, <argument><expr><literal type="string">"SET TRANSACTION SNAPSHOT %s;"</literal></expr></argument>,
						 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(
							 <argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ddlCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommandList</name></expr></argument>, <argument><expr><name><name>snapShotString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>ddlCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommandList</name></expr></argument>, <argument><expr><name><name>splitCopyUdfCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>commitCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>commitCommand</name></expr></argument>, <argument><expr><literal type="string">"COMMIT;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ddlCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommandList</name></expr></argument>, <argument><expr><name><name>commitCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>splitCopyTask</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>splitCopyTask</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitCopyTask</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitCopyTask</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>READ_TASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitCopyTask</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetTaskQueryStringList</name><argument_list>(<argument><expr><name>splitCopyTask</name></expr></argument>, <argument><expr><name>ddlCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>splitCopyTask</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Create an object on a worker node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateObjectOnPlacement</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>objectCreationCommandList</name></decl></parameter>,
						<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerPlacementNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
		<expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>OUTSIDE_TRANSACTION</name></expr></argument>,
									  <argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
									  <argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransactionWithConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>,
															<argument><expr><name>objectCreationCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Create split children intervals for a shardgroup given list of split points.
 * Example:
 * 'sourceColocatedShardIntervalList': Colocated shard S1[-2147483648, 2147483647] &amp; S2[-2147483648, 2147483647]
 * 'splitPointsForShard': [0] (2 way split)
 * 'shardGroupSplitIntervalListList':
 *  [
 *      [ S1_1(-2147483648, 0), S1_2(1, 2147483647) ], // Split Interval List for S1.
 *      [ S2_1(-2147483648, 0), S2_2(1, 2147483647) ]  // Split Interval List for S2.
 *  ]
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CreateSplitIntervalsForShardGroup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>splitPointsForShard</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardToSplitInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardToSplitInterval</argument>, <argument>sourceColocatedShardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardSplitIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>CreateSplitIntervalsForShard</name><argument_list>(<argument><expr><name>shardToSplitInterval</name></expr></argument>, <argument><expr><name>splitPointsForShard</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name>shardSplitIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>shardGroupSplitIntervalListList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
												  <argument><expr><name>shardSplitIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>shardGroupSplitIntervalListList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Create split children intervals given a sourceshard and a list of split points.
 * Example: SourceShard is range [0, 100] and SplitPoints are (15, 30) will give us:
 *  [(0, 15) (16, 30) (31, 100)]
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateSplitIntervalsForShard</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>sourceShard</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>splitPointsForShard</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardSplitChildrenIntervalList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* For 'N' split points, we will have N+1 shard intervals created. */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>shardIntervalCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>splitPointsForShard</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>splitPointCell</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>splitPointsForShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>splitParentMaxValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>sourceShard</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>currentSplitChildMinValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>sourceShard</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if we are splitting a Citus local table, assume whole shard range */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sourceShard</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>splitParentMaxValue</name> <operator>=</operator> <name>PG_INT32_MAX</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sourceShard</name><operator>-&gt;</operator><name>minValueExists</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>currentSplitChildMinValue</name> <operator>=</operator> <name>PG_INT32_MIN</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>shardIntervalCount</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>splitChildShardInterval</name> <init>= <expr><call><name>CopyShardInterval</name><argument_list>(<argument><expr><name>sourceShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>shardIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <call><name>GetNextShardIdForSplitChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>minValue</name></name> <operator>=</operator> <name>currentSplitChildMinValue</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* Length of splitPointsForShard is one less than 'shardIntervalCount' and we need to account */</comment>
		<comment type="block">/* for 'splitPointCell' being NULL for last iteration. */</comment>
		<if_stmt><if>if <condition>(<expr><name>splitPointCell</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>maxValue</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <call><name>lfirst</name><argument_list>(
																  <argument><expr><name>splitPointCell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>splitPointCell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>splitPointsForShard</name></expr></argument>, <argument><expr><name>splitPointCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>maxValue</name></name> <operator>=</operator> <name>splitParentMaxValue</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>currentSplitChildMinValue</name> <operator>=</operator> <name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>maxValue</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>shardSplitChildrenIntervalList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>shardSplitChildrenIntervalList</name></expr></argument>,
												  <argument><expr><name>splitChildShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateDistributionColumnsForShardGroup globally updates the pg_dist_partition metadata
 * for each relation that has a shard in colocatedShardList.
 *
 * This is used primarily for Citus local -&gt; distributed table conversion
 * in create_distributed_table_concurrently.
 *
 * It would be nicer to keep this separate from shard split, but we need to do the
 * update at exactly the right point in the shard split process, namely after
 * replication slot creation and before inserting shard metadata, which itself
 * needs to happen before foreign key creation (mainly because the foreign key
 * functions depend on metadata).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateDistributionColumnsForShardGroup</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name></decl></parameter>,
									   <parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnMap</name></decl></parameter>,
									   <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>,
									   <parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>colocatedShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name> <init>= <expr><call><name>GetDistributionColumnFromMap</name><argument_list>(<argument><expr><name>distributionColumnMap</name></expr></argument>,
															   <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we should have an entry for every relation ID in the colocation group */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distributionColumn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Getting here with an invalid co-location ID means that no
			 * appropriate co-location group exists yet.
			 */</comment>
			<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <call><name>CreateColocationGroup</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>,
												 <argument><expr><name>ShardReplicationFactor</name></expr></argument>,
												 <argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
												 <argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>UpdateDistributionColumnGlobally</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>,
										 <argument><expr><name>distributionColumn</name></expr></argument>, <argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * Insert new shard and placement metadata.
 * Sync the Metadata with all nodes if enabled.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InsertSplitChildrenShardMetadata</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>syncedShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate over all the shards in the shard group.
	 */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardIntervalList</argument>, <argument>shardGroupSplitIntervalListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Iterate on split shards list for a given shard and insert metadata.
		 */</comment>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerPlacementNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>forboth_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>, <argument>workerPlacementNode</argument>,
					<argument>workersForPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>InsertShardRow</name><argument_list>(
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>storageType</name></name></expr></argument>,
				<argument><expr><call><name>IntegerToText</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>IntegerToText</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>InsertShardPlacementRow</name><argument_list>(
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
				<argument><expr><name>INVALID_PLACEMENT_ID</name></expr></argument>, <comment type="block">/* triggers generation of new id */</comment>
				<argument><expr><name>SHARD_STATE_ACTIVE</name></expr></argument>,
				<argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* shard length (zero for HashDistributed Table) */</comment>
				<argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>syncedShardList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>syncedShardList</name></expr></argument>, <argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/* send commands to synced nodes one by one */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>splitOffShardMetadataCommandList</name> <init>= <expr><call><name>ShardListInsertCommand</name><argument_list>(<argument><expr><name>syncedShardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>splitOffShardMetadataCommandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CreatePartitioningHierarchy creates the partitioning
 * hierarchy between the shardList, if any.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreatePartitioningHierarchyForBlockingSplit</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Create partition heirarchy between shards */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate over all the shards in the shard group.
	 */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardIntervalList</argument>, <argument>shardGroupSplitIntervalListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerPlacementNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Iterate on split shards list for a given shard and create constraints.
		 */</comment>
		<macro><name>forboth_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>, <argument>workerPlacementNode</argument>,
					<argument>workersForPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attachPartitionCommand</name> <init>=
					<expr><call><name>GenerateAttachShardPartitionCommand</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>SendCommandToWorker</name><argument_list>(
					<argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
					<argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
					<argument><expr><name>attachPartitionCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * Create foreign key constraints on the split children shards.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateForeignKeyConstraints</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Create constraints between shards */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Iterate over all the shards in the shard group.
	 */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardIntervalList</argument>, <argument>shardGroupSplitIntervalListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerPlacementNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Iterate on split shards list for a given shard and create constraints.
		 */</comment>
		<macro><name>forboth_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>,
					<argument>workerPlacementNode</argument>, <argument>workersForPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardForeignConstraintCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referenceTableForeignConstraintList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CopyShardForeignConstraintCommandListGrouped</name><argument_list>(
				<argument><expr><name>shardInterval</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>shardForeignConstraintCommandList</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>referenceTableForeignConstraintList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>constraintCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>constraintCommandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>constraintCommandList</name></expr></argument>,
												<argument><expr><name>shardForeignConstraintCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>constraintCommandList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>constraintCommandList</name></expr></argument>,
												<argument><expr><name>referenceTableForeignConstraintList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>constraintCommand</argument>, <argument>constraintCommandList</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SendCommandToWorker</name><argument_list>(
					<argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
					<argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
					<argument><expr><name>constraintCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * DropShardListMetadata drops shard metadata from both the coordinator and
 * mx nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropShardListMetadata</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardIntervalCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>shardIntervalCell</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardIntervalCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardPlacementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>oldShardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* delete metadata from synced nodes */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>commandCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* send the commands one by one (calls citus_internal_delete_shard_metadata internally) */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardMetadataDeleteCommandList</name> <init>= <expr><call><name>ShardDeleteCommandList</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>foreach</name><argument_list>(<argument>commandCell</argument>, <argument>shardMetadataDeleteCommandList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>commandCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* delete shard placements */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>oldShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>shardPlacementCell</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardPlacementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>DeleteShardPlacementRow</name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* delete shard row */</comment>
		<expr_stmt><expr><call><name>DeleteShardRow</name><argument_list>(<argument><expr><name>oldShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * Insert deferred cleanup records.
 * The shards will be dropped by background cleaner later.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InsertDeferredDropCleanupRecordsForShards</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardIntervalCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>shardIntervalCell</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardIntervalCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardPlacementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>oldShardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* mark for deferred drop */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>oldShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>shardPlacementCell</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardPlacementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* get shard name */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedShardName</name> <init>= <expr><call><name>ConstructQualifiedShardName</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Log shard in pg_dist_cleanup.
			 * Parent shards are to be dropped only on sucess after split workflow is complete,
			 * so mark the policy as 'CLEANUP_DEFERRED_ON_SUCCESS'.
			 * We also log cleanup record in the current transaction. If the current transaction rolls back,
			 * we do not generate a record at all.
			 */</comment>
			<expr_stmt><expr><call><name>InsertCleanupRecordInCurrentTransaction</name><argument_list>(<argument><expr><name>CLEANUP_OBJECT_SHARD_PLACEMENT</name></expr></argument>,
													<argument><expr><name>qualifiedShardName</name></expr></argument>,
													<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
													<argument><expr><name>CLEANUP_DEFERRED_ON_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * AcquireNonblockingSplitLock does not allow concurrent nonblocking splits, because we share memory and
 * replication slots.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AcquireNonblockingSplitLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_CITUS_OPERATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>CITUS_NONBLOCKING_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>lockAcquired</name> <init>= <expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>,
												 <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockAcquired</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not acquire the lock required to split "</literal>
							   <literal type="string">"concurrently %s."</literal></expr></argument>, <argument><expr><call><name>generate_qualified_relation_name</name><argument_list>(
								   <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"It means that either a concurrent shard move "</literal>
								  <literal type="string">"or distributed table creation is happening."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure that the concurrent operation has "</literal>
								<literal type="string">"finished and re-run the command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SplitShard API to split a given shard (or shard group) in non-blocking fashion
 * based on specified split points to a set of destination nodes.
 * splitOperation                   : Customer operation that triggered split.
 * splitWorkflowId                  : Number used to identify split workflow in names.
 * sourceColocatedShardIntervalList : Source shard group to be split.
 * shardSplitPointsList             : Split Points list for the source 'shardInterval'.
 * workersForPlacementList          : Placement list corresponding to split children.
 * distributionColumnList           : Maps relation IDs to distribution columns.
 *                                    If not specified, the distribution column is read
 *                                    from the metadata.
 * targetColocationId               : Specifies the colocation ID (only used for
 *                                    create_distributed_table_concurrently).
 */</comment>
<function><type><name>void</name></type>
<name>NonBlockingShardSplit</name><parameter_list>(<parameter><decl><type><name>SplitOperation</name></type> <name>splitOperation</name></decl></parameter>,
					  <parameter><decl><type><name>uint64</name></type> <name>splitWorkflowId</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardSplitPointsList</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>,
					  <parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnOverrides</name></decl></parameter>,
					  <parameter><decl><type><name>uint32</name></type> <name>targetColocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operationName</name> <init>= <expr><name><name>SplitOperationAPIName</name><index>[<expr><name>splitOperation</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfMultipleNonblockingMoveSplitInTheSameTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>superUser</name> <init>= <expr><call><name>CitusExtensionOwnerName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* First create shard interval metadata for split children */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name> <init>= <expr><call><name>CreateSplitIntervalsForShardGroup</name><argument_list>(
		<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
		<argument><expr><name>shardSplitPointsList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>firstShard</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Acquire global lock to prevent concurrent nonblocking splits */</comment>
	<expr_stmt><expr><call><name>AcquireNonblockingSplitLock</name><argument_list>(<argument><expr><name><name>firstShard</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceShardToCopyNode</name> <init>=
		<expr><call><name>ActiveShardPlacementWorkerNode</name><argument_list>(<argument><expr><name><name>firstShard</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Create hashmap to group shards for publication-subscription management */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>publicationInfoHash</name> <init>= <expr><call><name>CreateShardSplitInfoMapForPublication</name><argument_list>(
		<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
		<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
		<argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><name>FORCE_NEW_CONNECTION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceConnection</name> <init>= <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(
		<argument><expr><name>connectionFlags</name></expr></argument>,
		<argument><expr><name><name>sourceShardToCopyNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
		<argument><expr><name><name>sourceShardToCopyNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
		<argument><expr><name>superUser</name></expr></argument>,
		<argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ClaimConnectionExclusively</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceReplicationConnection</name> <init>=
		<expr><call><name>GetReplicationConnection</name><argument_list>(<argument><expr><name><name>sourceShardToCopyNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
								 <argument><expr><name><name>sourceShardToCopyNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Non-Blocking shard split workflow starts here */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating child shards for %s"</literal></expr></argument>,
							 <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 1) Physically create split children. */</comment>
		<expr_stmt><expr><call><name>CreateSplitShardsForShardGroup</name><argument_list>(<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
									   <argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * 2) Create dummy shards due to PG logical replication constraints.
		 *    Refer to the comment section of 'CreateDummyShardsForShardGroup' for indepth
		 *    information.
		 */</comment>
		<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>mapOfPlacementToDummyShardList</name> <init>= <expr><call><name>CreateSimpleHash</name><argument_list>(<argument><expr><name>NodeAndOwner</name></expr></argument>,
																<argument><expr><name>GroupedShardSplitInfos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>CreateDummyShardsForShardGroup</name><argument_list>(
			<argument><expr><name>mapOfPlacementToDummyShardList</name></expr></argument>,
			<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
			<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
			<argument><expr><name>sourceShardToCopyNode</name></expr></argument>,
			<argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * 3) Create replica identities on dummy shards. This needs to be done
		 * before the subscriptions are created. Otherwise the subscription
		 * creation will get stuck waiting for the publication to send a
		 * replica identity. Since we never actually write data into these
		 * dummy shards there's no point in creating these indexes after the
		 * initial COPY phase, like we do for the replica identities on the
		 * target shards.
		 */</comment>
		<expr_stmt><expr><call><name>CreateReplicaIdentitiesForDummyShards</name><argument_list>(<argument><expr><name>mapOfPlacementToDummyShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
						  <argument><expr><literal type="string">"creating replication artifacts (publications, replication slots, subscriptions for %s"</literal></expr></argument>,
						  <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 4) Create Publications. */</comment>
		<expr_stmt><expr><call><name>CreatePublications</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>, <argument><expr><name>publicationInfoHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 5) Execute 'worker_split_shard_replication_setup UDF */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicationSlotInfoList</name> <init>= <expr><call><name>ExecuteSplitShardReplicationSetupUDF</name><argument_list>(
			<argument><expr><name>sourceShardToCopyNode</name></expr></argument>,
			<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
			<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
			<argument><expr><name>workersForPlacementList</name></expr></argument>,
			<argument><expr><name>distributionColumnOverrides</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Subscriber flow starts from here.
		 * Populate 'ShardSplitSubscriberMetadata' for subscription management.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>logicalRepTargetList</name> <init>=
			<expr><call><name>PopulateShardSplitSubscriptionsMetadataList</name><argument_list>(
				<argument><expr><name>publicationInfoHash</name></expr></argument>, <argument><expr><name>replicationSlotInfoList</name></expr></argument>,
				<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>, <argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>groupedLogicalRepTargetsHash</name> <init>= <expr><call><name>CreateGroupedLogicalRepTargetsHash</name><argument_list>(
			<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Create connections to the target nodes */</comment>
		<expr_stmt><expr><call><name>CreateGroupedLogicalRepTargetsConnections</name><argument_list>(
			<argument><expr><name>groupedLogicalRepTargetsHash</name></expr></argument>,
			<argument><expr><name>superUser</name></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>logicalRepDecoderPlugin</name> <init>= <expr><literal type="string">"citus"</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * 6) Create replication slots and keep track of their snapshot.
		 */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>snapshot</name> <init>= <expr><call><name>CreateReplicationSlots</name><argument_list>(
			<argument><expr><name>sourceConnection</name></expr></argument>,
			<argument><expr><name>sourceReplicationConnection</name></expr></argument>,
			<argument><expr><name>logicalRepTargetList</name></expr></argument>,
			<argument><expr><name>logicalRepDecoderPlugin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * 7) Create subscriptions. This isn't strictly needed yet at this
		 * stage, but this way we error out quickly if it fails.
		 */</comment>
		<expr_stmt><expr><call><name>CreateSubscriptions</name><argument_list>(
			<argument><expr><name>sourceConnection</name></expr></argument>,
			<argument><expr><name>databaseName</name></expr></argument>,
			<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We have to create the primary key (or any other replica identity)
		 * before the update/delete operations that are queued will be
		 * replicated. Because if the replica identity does not exist on the
		 * target, the replication would fail.
		 *
		 * So the latest possible moment we could do this is right after the
		 * initial data COPY, but before enabling the susbcriptions. It might
		 * seem like a good idea to it after the initial data COPY, since
		 * it's generally the rule that it's cheaper to build an index at once
		 * than to create it incrementally. This general rule, is why we create
		 * all the regular indexes as late during the move as possible.
		 *
		 * But as it turns out in practice it's not as clear cut, and we saw a
		 * speed degradation in the time it takes to move shards when doing the
		 * replica identity creation after the initial COPY. So, instead we
		 * keep it before the COPY.
		 */</comment>
		<expr_stmt><expr><call><name>CreateReplicaIdentities</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"performing copy for %s"</literal></expr></argument>, <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 8) Do snapshotted Copy */</comment>
		<expr_stmt><expr><call><name>DoSplitCopy</name><argument_list>(<argument><expr><name>sourceShardToCopyNode</name></expr></argument>, <argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
					<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>, <argument><expr><name>workersForPlacementList</name></expr></argument>,
					<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>distributionColumnOverrides</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replicating changes for %s"</literal></expr></argument>, <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * 9) Logically replicate all the changes and do most of the table DDL,
		 * like index and foreign key creation.
		 */</comment>
		<expr_stmt><expr><call><name>CompleteNonBlockingShardTransfer</name><argument_list>(<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
										 <argument><expr><name>sourceConnection</name></expr></argument>,
										 <argument><expr><name>publicationInfoHash</name></expr></argument>,
										 <argument><expr><name>logicalRepTargetList</name></expr></argument>,
										 <argument><expr><name>groupedLogicalRepTargetsHash</name></expr></argument>,
										 <argument><expr><name>SHARD_SPLIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * 10) Delete old shards metadata and mark the shards as to be deferred drop.
		 * Have to do that before creating the new shard metadata,
		 * because there's cross-checks preventing inconsistent metadata
		 * (like overlapping shards).
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"marking deferred cleanup of source shard(s) for %s"</literal></expr></argument>,
							 <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InsertDeferredDropCleanupRecordsForShards</name><argument_list>(<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DropShardListMetadata</name><argument_list>(<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * 11) In case of create_distributed_table_concurrently, which converts
		 * a Citus local table to a distributed table, update the distributed
		 * table metadata now.
		 *
		 * We would rather have this be outside of the scope of NonBlockingShardSplit,
		 * but we cannot make metadata changes before replication slot creation, and
		 * we cannot create the replication slot before creating new shards and
		 * corresponding publications, because the decoder uses a catalog snapshot
		 * from the time of the slot creation, which means it would not be able to see
		 * the shards or publications when replication starts if it was created before.
		 *
		 * We also cannot easily move metadata changes to be after this function,
		 * because CreateForeignKeyConstraints relies on accurate metadata and
		 * we also want to perform the clean-up logic in PG_CATCH in case of
		 * failure.
		 *
		 * Hence, this appears to be the only suitable spot for updating
		 * pg_dist_partition and pg_dist_colocation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>splitOperation</name> <operator>==</operator> <name>CREATE_DISTRIBUTED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we currently only use split for hash-distributed tables */</comment>
			<decl_stmt><decl><type><name>char</name></type> <name>distributionMethod</name> <init>= <expr><name>DISTRIBUTE_BY_HASH</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardSplitPointsList</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>UpdateDistributionColumnsForShardGroup</name><argument_list>(<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
												   <argument><expr><name>distributionColumnOverrides</name></expr></argument>,
												   <argument><expr><name>distributionMethod</name></expr></argument>,
												   <argument><expr><name>shardCount</name></expr></argument>,
												   <argument><expr><name>targetColocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* 12) Insert new shard and placement metdata */</comment>
		<expr_stmt><expr><call><name>InsertSplitChildrenShardMetadata</name><argument_list>(<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
										 <argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 13) create partitioning hierarchy, if any, this needs to be done
		 * after the metadata is correct, because it fails for some
		 * uninvestigated reason otherwise.
		 */</comment>
		<expr_stmt><expr><call><name>CreatePartitioningHierarchy</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating foreign key constraints (if any) for %s"</literal></expr></argument>,
							 <argument><expr><name>operationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * 14) Create foreign keys if exists after the metadata changes happening in
		 * InsertSplitChildrenShardMetadata() because the foreign
		 * key creation depends on the new metadata.
		 */</comment>
		<expr_stmt><expr><call><name>CreateUncheckedForeignKeyConstraints</name><argument_list>(<argument><expr><name>logicalRepTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * 15) Release shared memory allocated by worker_split_shard_replication_setup udf
		 * at source node.
		 */</comment>
		<expr_stmt><expr><call><name>ExecuteSplitShardReleaseSharedMemory</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 16) Close source connection */</comment>
		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 17) Close all subscriber connections */</comment>
		<expr_stmt><expr><call><name>CloseGroupedLogicalRepTargetsConnections</name><argument_list>(<argument><expr><name>groupedLogicalRepTargetsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* 18) Close connection of template replication slot */</comment>
		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>sourceReplicationConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* end ongoing transactions to enable us to clean up */</comment>
		<expr_stmt><expr><call><name>ShutdownAllConnections</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Drop temporary objects that were marked as CLEANUP_ON_FAILURE
		 * or CLEANUP_ALWAYS.
		 */</comment>
		<expr_stmt><expr><call><name>FinalizeOperationNeedingCleanupOnFailure</name><argument_list>(<argument><expr><name>operationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Given we are using PG logical replication infrastructure there are some constraints
 * that need to met around matching table names in source and target nodes:
 * The restrictions in context of split are:
 * Constraint 1: Dummy source shard(s) from shard group must exist on all destination nodes.
 * Constraint 2: Dummy target shards from shard group must exist on source node.
 * Example :
 * Shard1[1-200] is co-located with Shard2[1-200] in Worker0.
 * We are splitting 2-way to worker0 (same node) and worker1 (different node).
 *
 * Non-Dummy shards (expected from Split):
 * In Worker0 --&gt; Shard1_1 and Shard2_1.
 * In Worker1 --&gt; Shard1_2 and Shard2_2.
 *
 * Dummy shards:
 * From constraint 1, we need to create: Dummy Shard1 and Shard2 in Worker0. Dummy Shard1 and Shard2 in Worker1
 * Note 1 : Given there is an overlap of source and destination in Worker0, Shard1 and Shard2 need not be created.
 * Be very careful here, dropping Shard1, Shard2 with customer data to create dummy Shard1, Shard2 on worker0 is catastrophic.
 *
 * From constraint 2, we need to create: Dummy Shard1_1, Shard2_1, Shard1_2 and Shard2_2 in Worker0.
 * Note 2 : Given there is an overlap of source and destination in Worker0, Shard1_1 and Shard2_1 need not be created.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateDummyShardsForShardGroup</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>mapOfPlacementToDummyShardList</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
							   <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceWorkerNode</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Statisfy Constraint 1: Create dummy source shard(s) on all destination nodes.
	 * If source node is also in desintation, skip dummy shard creation(see Note 1 from function description).
	 * We are guarenteed to have a single active placement for source shard. This is enforced earlier by ErrorIfCannotSplitShardExtended.
	 */</comment>

	<comment type="block">/* List 'workersForPlacementList' can have duplicates. We need all unique destination nodes. */</comment>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workersForPlacementSet</name> <init>= <expr><call><name>CreateWorkerForPlacementSet</name><argument_list>(<argument><expr><name>workersForPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>workersForPlacementSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerPlacementNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>workerPlacementNode</name> <operator>=</operator> <operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name><name>sourceWorkerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>sourceColocatedShardIntervalList</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/* Populate list of commands necessary to create shard interval on destination */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>splitShardCreationCommandList</name> <init>= <expr><call><name>GetPreLoadTableCreationCommands</name><argument_list>(
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
				<argument><expr><name>false</name></expr></argument>, <comment type="block">/* includeSequenceDefaults */</comment>
				<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* auto add columnar options for cstore tables */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>splitShardCreationCommandList</name> <operator>=</operator> <call><name>WorkerApplyShardDDLCommandList</name><argument_list>(
				<argument><expr><name>splitShardCreationCommandList</name></expr></argument>,
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Log resource for cleanup in case of failure only.
			 * Before we log a record, do a best effort check to see if a shard with same name exists.
			 * This is because, it will cause shard creation to fail and we will end up cleaning the
			 * old shard. We don't want that.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>relationExists</name> <init>= <expr><call><name>CheckIfRelationWithSameNameExists</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>,
																	<argument><expr><name>workerPlacementNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>relationExists</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation %s already exists on worker %s:%d"</literal></expr></argument>,
									   <argument><expr><call><name>ConstructQualifiedShardName</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
									   <argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Log shard in pg_dist_cleanup. Given dummy shards are transient resources,
			 * we want to cleanup irrespective of operation success or failure.
			 */</comment>
			<expr_stmt><expr><call><name>InsertCleanupRecordInSubtransaction</name><argument_list>(<argument><expr><name>CLEANUP_OBJECT_SHARD_PLACEMENT</name></expr></argument>,
												<argument><expr><call><name>ConstructQualifiedShardName</name><argument_list>(
													<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
												<argument><expr><name>CLEANUP_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create dummy source shard on the specified placement list */</comment>
			<expr_stmt><expr><call><name>CreateObjectOnPlacement</name><argument_list>(<argument><expr><name>splitShardCreationCommandList</name></expr></argument>,
									<argument><expr><name>workerPlacementNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add dummy source shard entry created for placement node in map */</comment>
			<expr_stmt><expr><call><name>AddDummyShardEntryInMap</name><argument_list>(<argument><expr><name>mapOfPlacementToDummyShardList</name></expr></argument>,
									<argument><expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>,
									<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Statisfy Constraint 2: Create dummy target shards from shard group on source node.
	 * If the target shard was created on source node as placement, skip it (See Note 2 from function description).
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardIntervalList</argument>, <argument>shardGroupSplitIntervalListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>workerPlacementNode</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<macro><name>forboth_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>, <argument>workerPlacementNode</argument>,
					<argument>workersForPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>workerPlacementNode</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>==</operator> <name><name>sourceWorkerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>splitShardCreationCommandList</name> <init>= <expr><call><name>GetPreLoadTableCreationCommands</name><argument_list>(
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
				<argument><expr><name>false</name></expr></argument>, <comment type="block">/* includeSequenceDefaults */</comment>
				<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* auto add columnar options for cstore tables */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>splitShardCreationCommandList</name> <operator>=</operator> <call><name>WorkerApplyShardDDLCommandList</name><argument_list>(
				<argument><expr><name>splitShardCreationCommandList</name></expr></argument>,
				<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Log resource for cleanup in case of failure only.
			 * Before we log a record, do a best effort check to see if a shard with same name exists.
			 * This is because, it will cause shard creation to fail and we will end up cleaning the
			 * old shard. We don't want that.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>relationExists</name> <init>= <expr><call><name>CheckIfRelationWithSameNameExists</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>,
																	<argument><expr><name>sourceWorkerNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>relationExists</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation %s already exists on worker %s:%d"</literal></expr></argument>,
									   <argument><expr><call><name>ConstructQualifiedShardName</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>sourceWorkerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
									   <argument><expr><name><name>sourceWorkerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Log shard in pg_dist_cleanup. Given dummy shards are transient resources,
			 * we want to cleanup irrespective of operation success or failure.
			 */</comment>
			<expr_stmt><expr><call><name>InsertCleanupRecordInSubtransaction</name><argument_list>(<argument><expr><name>CLEANUP_OBJECT_SHARD_PLACEMENT</name></expr></argument>,
												<argument><expr><call><name>ConstructQualifiedShardName</name><argument_list>(
													<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name><name>sourceWorkerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
												<argument><expr><name>CLEANUP_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Create dummy split child shard on source worker node */</comment>
			<expr_stmt><expr><call><name>CreateObjectOnPlacement</name><argument_list>(<argument><expr><name>splitShardCreationCommandList</name></expr></argument>, <argument><expr><name>sourceWorkerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add dummy split child shard entry created on source node */</comment>
			<expr_stmt><expr><call><name>AddDummyShardEntryInMap</name><argument_list>(<argument><expr><name>mapOfPlacementToDummyShardList</name></expr></argument>,
									<argument><expr><name><name>sourceWorkerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>,
									<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CreateWorkerForPlacementSet returns a set with unique worker nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>CreateWorkerForPlacementSet</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkerNode</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>WorkerNodeHashCode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>WorkerNodeCompare</name></expr>;</expr_stmt>

	<comment type="block">/* we don't have value field as it's a set */</comment>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>keysize</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_CONTEXT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>workerForPlacementSet</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"worker placement set"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
											  <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerForPlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerForPlacement</argument>, <argument>workersForPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>hashKey</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>workerForPlacement</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>workerForPlacementSet</name></expr></argument>, <argument><expr><name>hashKey</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>workerForPlacementSet</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteSplitShardReplicationSetupUDF executes
 * 'worker_split_shard_replication_setup' UDF on source shard node
 * and returns list of ReplicationSlotInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExecuteSplitShardReplicationSetupUDF</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>sourceWorkerNode</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>destinationWorkerNodesList</name></decl></parameter>,
									 <parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnOverrides</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>splitShardReplicationUDF</name> <init>= <expr><call><name>CreateSplitShardReplicationSetupUDF</name><argument_list>(
		<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
		<argument><expr><name>shardGroupSplitIntervalListList</name></expr></argument>,
		<argument><expr><name>destinationWorkerNodesList</name></expr></argument>,
		<argument><expr><name>distributionColumnOverrides</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Force a new connection to execute the UDF */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceConnection</name> <init>= <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
																	  <argument><expr><name><name>sourceWorkerNode</name><operator>-&gt;</operator>
																	  <name>workerName</name></name></expr></argument>,
																	  <argument><expr><name><name>sourceWorkerNode</name><operator>-&gt;</operator>
																	  <name>workerPort</name></name></expr></argument>,
																	  <argument><expr><call><name>CitusExtensionOwnerName</name><argument_list>()</argument_list></call></expr></argument>,
																	  <argument><expr><call><name>get_database_name</name><argument_list>(
																		  <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ClaimConnectionExclusively</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>queryResult</name> <init>= <expr><call><name>ExecuteOptionalRemoteCommand</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>,
												   <argument><expr><name><name>splitShardReplicationUDF</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Result should contain atleast one tuple. The information returned is
	 * set of tuples where each tuple is formatted as:
	 * &lt;targetNodeId, tableOwnerName, replication_slot_name&gt;.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>queryResult</name> <operator>!=</operator> <name>RESPONSE_OKAY</name> <operator>||</operator> <operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"Failed to run worker_split_shard_replication_setup UDF. It should successfully execute "</literal>
							<literal type="string">" for splitting a shard in a non-blocking way. Please retry."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get replication slot information */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicationSlotInfoList</name> <init>= <expr><call><name>ParseReplicationSlotInfoFromResult</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>replicationSlotInfoList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteSplitShardReleaseSharedMemory releases dynamic shared memory
 * at source node.
 * As a part of non-blocking split workflow, worker_split_shard_replication_setup allocates
 * shared memory to store split information. This has to be released after split completes(or fails).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteSplitShardReleaseSharedMemory</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>sourceConnection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>splitShardReleaseMemoryUDF</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>splitShardReleaseMemoryUDF</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT pg_catalog.worker_split_shard_release_dsm();"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>sourceConnection</name></expr></argument>, <argument><expr><name><name>splitShardReleaseMemoryUDF</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateSplitShardReplicationSetupUDF creates and returns
 * parameterized 'worker_split_shard_replication_setup' UDF command.
 *
 * 'sourceShardSplitIntervalList'    : Source shard interval to split.
 * 'shardGroupSplitIntervalListList' : List of shard intervals for split children..
 * 'destinationWorkerNodesList'      : List of workers for split children placement.
 *
 * For example consider below input values:
 * sourceColocatedShardIntervalList : [sourceShardInterval]
 * shardGroupSplitIntervalListList  : [&lt;childFirstShardInterval, childSecondShardInterval&gt;]
 * destinationWorkerNodesList       : [worker1, worker2]
 *
 * SELECT * FROM worker_split_shard_replication_setup(
 *  Array[
 *      ROW(sourceShardId, childFirstShardId, childFirstMinRange, childFirstMaxRange, worker1)::citus.split_shard_info,
 *      ROW(sourceShardId, childSecondShardId, childSecondMinRange, childSecondMaxRange, worker2)::citus.split_shard_info
 *  ], CurrentOperationId);
 */</comment>
<function><type><name>StringInfo</name></type>
<name>CreateSplitShardReplicationSetupUDF</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardGroupSplitIntervalListList</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>destinationWorkerNodesList</name></decl></parameter>,
									<parameter><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnOverrides</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>splitChildrenRows</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>sourceShardIntervalToCopy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>splitChildShardIntervalList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>addComma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth_ptr</name><argument_list>(<argument>sourceShardIntervalToCopy</argument>, <argument>sourceColocatedShardIntervalList</argument>,
				<argument>splitChildShardIntervalList</argument>, <argument>shardGroupSplitIntervalListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>sourceShardId</name> <init>= <expr><name><name>sourceShardIntervalToCopy</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>sourceShardIntervalToCopy</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name> <init>=
			<expr><call><name>GetDistributionColumnWithOverrides</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
											   <argument><expr><name>distributionColumnOverrides</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>missingOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name> <init>=
			<expr><call><name>get_attname</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>,
						<argument><expr><name>missingOK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>splitChildShardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>destinationWorkerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>forboth_ptr</name><argument_list>(<argument>splitChildShardInterval</argument>, <argument>splitChildShardIntervalList</argument>,
					<argument>destinationWorkerNode</argument>, <argument>destinationWorkerNodesList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>addComma</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>splitChildrenRows</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>StringInfo</name></type> <name>minValueString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>minValueString</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>DatumGetInt32</name><argument_list>(
								 <argument><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>StringInfo</name></type> <name>maxValueString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>maxValueString</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>DatumGetInt32</name><argument_list>(
								 <argument><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>splitChildrenRows</name></expr></argument>,
							 <argument><expr><literal type="string">"ROW(%lu, %s, %lu, %s, %s, %u)::pg_catalog.split_shard_info"</literal></expr></argument>,
							 <argument><expr><name>sourceShardId</name></expr></argument>,
							 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>distributionColumnName</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>splitChildShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
							 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>minValueString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>maxValueString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>destinationWorkerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>addComma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>splitShardReplicationUDF</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>splitShardReplicationUDF</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT * FROM pg_catalog.worker_split_shard_replication_setup("</literal>
					 <literal type="string">"ARRAY[%s], %lu);"</literal></expr></argument>,
					 <argument><expr><name><name>splitChildrenRows</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><name>CurrentOperationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>splitShardReplicationUDF</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ParseReplicationSlotInfoFromResult parses custom datatype 'replication_slot_info'.
 * 'replication_slot_info' is a tuple with below format:
 * &lt;targetNodeId, tableOwnerName, replicationSlotName&gt;
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ParseReplicationSlotInfoFromResult</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>rowCount</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicationSlotInfoList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int64</name></type> <name>rowIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rowIndex</name> <operator>&lt;</operator> <name>rowCount</name></expr>;</condition> <incr><expr><name>rowIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ReplicationSlotInfo</name> <modifier>*</modifier></type><name>replicationSlot</name> <init>= <expr><operator>(</operator><name>ReplicationSlotInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReplicationSlotInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>targeNodeIdString</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* nodeId column*/</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>replicationSlot</name><operator>-&gt;</operator><name>targetNodeId</name></name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>targeNodeIdString</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>replicationSlot</name><operator>-&gt;</operator><name>tableOwnerId</name></name> <operator>=</operator> <call><name>get_role_oid</name><argument_list>(
			<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument> <comment type="block">/* table owner name column */</comment>)</argument_list></call></expr></argument>,
			<argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Replication slot name */</comment>
		<expr_stmt><expr><name><name>replicationSlot</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>,
												   <argument><expr><literal type="number">2</literal></expr></argument> <comment type="block">/* slot name column */</comment>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>replicationSlotInfoList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>replicationSlotInfoList</name></expr></argument>, <argument><expr><name>replicationSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>replicationSlotInfoList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddDummyShardEntryInMap adds shard entry into hash map to keep track
 * of dummy shards that are created. These shards are cleanedup after split completes.
 *
 * This is a cautious measure to keep track of dummy shards created for constraints
 * of logical replication. We cautiously delete only the dummy shards added in the DummyShardHashMap.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddDummyShardEntryInMap</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>mapOfPlacementToDummyShardList</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>targetNodeId</name></decl></parameter>,
						<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeAndOwner</name></type> <name>key</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>nodeId</name></name> <operator>=</operator> <name>targetNodeId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>tableOwnerId</name></name> <operator>=</operator> <call><name>TableOwnerOid</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupedDummyShards</name> <modifier>*</modifier></type><name>nodeMappingEntry</name> <init>=
		<expr><operator>(</operator><name>GroupedDummyShards</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>mapOfPlacementToDummyShardList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
										   <argument><expr><name>HASH_ENTER</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nodeMappingEntry</name><operator>-&gt;</operator><name>shardIntervals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>nodeMappingEntry</name><operator>-&gt;</operator><name>shardIntervals</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>nodeMappingEntry</name><operator>-&gt;</operator><name>shardIntervals</name></name></expr></argument>, <argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateReplicaIdentitiesForDummyShards creates replica indentities for split
 * dummy shards.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateReplicaIdentitiesForDummyShards</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>mapOfDummyShardToPlacement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Create Replica Identities for dummy shards */</comment>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>mapOfDummyShardToPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GroupedDummyShards</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>GroupedDummyShards</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>nodeId</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>nodeId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>shardToBeDroppedNode</name> <init>= <expr><call><name>FindNodeWithNodeId</name><argument_list>(<argument><expr><name>nodeId</name></expr></argument>,
															  <argument><expr><name>false</name></expr></argument> <comment type="block">/* missingOk */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dummyShardIntervalList</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>shardIntervals</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>CreateReplicaIdentitiesOnNode</name><argument_list>(<argument><expr><name>dummyShardIntervalList</name></expr></argument>,
									  <argument><expr><name><name>shardToBeDroppedNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
									  <argument><expr><name><name>shardToBeDroppedNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * GetNextShardIdForSplitChild returns shard id to be used for split child.
 * The function connects to the local node through a new connection and gets the next
 * sequence. This prevents self deadlock when 'CREATE_REPLICATION_SLOT' is executed
 * as a part of nonblocking split workflow.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>GetNextShardIdForSplitChild</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In regression tests, we would like to generate shard IDs consistently
	 * even if the tests run in parallel. Instead of the sequence, we can use
	 * the next_shard_id GUC to specify which shard ID the current session should
	 * generate next. The GUC is automatically increased by 1 every time a new
	 * shard ID is generated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NextShardId</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardId</name> <operator>=</operator> <name>NextShardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>NextShardId</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><name>shardId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>nextValueCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>nextValueCommand</name></expr></argument>, <argument><expr><literal type="string">"SELECT nextval(%s);"</literal></expr></argument>, <argument><expr><call><name>quote_literal_cstr</name><argument_list>(
						 <argument><expr><literal type="string">"pg_catalog.pg_dist_shardid_seq"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetConnectionForLocalQueriesOutsideTransaction</name><argument_list>(
		<argument><expr><call><name>CitusExtensionOwnerName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>queryResult</name> <init>= <expr><call><name>ExecuteOptionalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>nextValueCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>queryResult</name> <operator>!=</operator> <name>RESPONSE_OKAY</name> <operator>||</operator> <operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>PQnfields</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CloseConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"Could not generate next shard id while executing shard splits."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>shardId</name> <operator>=</operator> <call><name>SafeStringToUint64</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* nodeId column*/</comment>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shardId</name></expr>;</return>
</block_content>}</block></function>
</unit>
