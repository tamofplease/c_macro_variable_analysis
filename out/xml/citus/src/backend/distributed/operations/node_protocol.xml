<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/operations/node_protocol.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * node_protocol.c
 *	  Routines for requesting information from the master node for creating or
 *	  updating shards.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/attnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/namespace_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_shard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_library_init.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<comment type="block">/* Shard related configuration */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>ShardCount</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ShardReplicationFactor</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* desired replication factor for shards */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>NextShardId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>NextPlacementId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GatherIndexAndConstraintDefinitionListExcludingReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Form_pg_index</name></type>
																		   <name>indexForm</name></decl></parameter>,
																		   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type>
																		   <name>indexDDLEventList</name></decl></parameter>,
																		   <parameter><decl><type><name>int</name></type> <name>indexFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>WorkerNodeGetDatum</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>CitusCreateAlterColumnarTableSet</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>ColumnarOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetTableDDLCommandColumnar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableDDLCommand</name> <modifier>*</modifier></type> <name>ColumnarGetTableOptionsDDL</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_get_table_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_get_table_ddl_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_get_new_shardid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_get_new_placementid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_get_active_worker_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_get_active_worker_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_get_round_robin_candidate_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_stage_shard_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_stage_shard_placement_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * master_get_table_metadata is a deprecated UDF.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_get_table_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"master_get_table_metadata is deprecated"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_get_table_ddl_events takes in a relation name, and returns the set of
 * DDL commands needed to reconstruct the relation. The returned DDL commands
 * are similar in flavor to schema definitions that pgdump returns. The function
 * errors if given relation does not exist.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_get_table_ddl_events</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>functionContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tableDDLEventCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * On the very first call to this function, we first use the given relation
	 * name to get to the relation. We then recreate the list of DDL statements
	 * issued for this relation, and save the first statement's position in the
	 * function context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IncludeSequenceDefaults</name></type> <name>includeSequenceDefaults</name> <init>= <expr><name>NEXTVAL_SEQUENCE_DEFAULTS</name></expr></init></decl>;</decl_stmt>


		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>functionContext</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* switch to memory context appropriate for multiple function calls */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(
			<argument><expr><name><name>functionContext</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* allocate DDL statements, and then save position in DDL statements */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>creatingShellTableOnRemoteNode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableDDLEventList</name> <init>= <expr><call><name>GetFullTableCreationCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
															   <argument><expr><name>includeSequenceDefaults</name></expr></argument>,
															   <argument><expr><name>creatingShellTableOnRemoteNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>tableDDLEventCell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>ListCellAndListWrapper</name> <modifier>*</modifier></type><name>wrapper</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListCellAndListWrapper</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <name>tableDDLEventList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>listCell</name></name> <operator>=</operator> <name>tableDDLEventCell</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>functionContext</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>wrapper</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * On every call to this function, we get the current position in the
	 * statement list. We then iterate to the next position in the list and
	 * return the current statement, if we have not yet reached the end of
	 * list.
	 */</comment>
	<expr_stmt><expr><name>functionContext</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ListCellAndListWrapper</name> <modifier>*</modifier></type><name>wrapper</name> <init>=
		<expr><operator>(</operator><name>ListCellAndListWrapper</name> <operator>*</operator><operator>)</operator> <name><name>functionContext</name><operator>-&gt;</operator><name>user_fctx</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>wrapper</name><operator>-&gt;</operator><name>listCell</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>ddlStatement</name> <init>= <expr><operator>(</operator><name>TableDDLCommand</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name><name>wrapper</name><operator>-&gt;</operator><name>listCell</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>ddlStatement</name></expr></argument>, <argument><expr><name>TableDDLCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>ddlStatementText</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>GetTableDDLCommand</name><argument_list>(<argument><expr><name>ddlStatement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>listCell</name></name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>wrapper</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name><name>wrapper</name><operator>-&gt;</operator><name>listCell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>functionContext</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>ddlStatementText</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>functionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_get_new_shardid is a user facing wrapper function around GetNextShardId()
 * which allocates and returns a unique shardId for the shard to be created.
 *
 * NB: This can be called by any user; for now we have decided that that's
 * ok. We might want to restrict this to users part of a specific role or such
 * at some later point.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_get_new_shardid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>GetNextShardId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>shardIdDatum</name> <init>= <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>shardIdDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetNextShardId allocates and returns a unique shardId for the shard to be
 * created. This allocation occurs both in shared memory and in write ahead
 * logs; writing to logs avoids the risk of having shardId collisions.
 *
 * Please note that the caller is still responsible for finalizing shard data
 * and the shardId with the master node.
 */</comment>
<function><type><name>uint64</name></type>
<name>GetNextShardId</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>savedUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>savedSecurityContext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In regression tests, we would like to generate shard IDs consistently
	 * even if the tests run in parallel. Instead of the sequence, we can use
	 * the next_shard_id GUC to specify which shard ID the current session should
	 * generate next. The GUC is automatically increased by 1 every time a new
	 * shard ID is generated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NextShardId</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardId</name> <operator>=</operator> <name>NextShardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>NextShardId</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><name>shardId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>SHARDID_SEQUENCE_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>sequenceName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>sequenceIdDatum</name> <init>= <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>savedUserId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedSecurityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><call><name>CitusExtensionOwner</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* generate new and unique shardId from sequence */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>shardIdDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>nextval_oid</name></expr></argument>, <argument><expr><name>sequenceIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>savedUserId</name></expr></argument>, <argument><expr><name>savedSecurityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>shardId</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>shardIdDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shardId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * master_get_new_placementid is a user facing wrapper function around
 * GetNextPlacementId() which allocates and returns a unique placement id for the
 * placement to be created.
 *
 * NB: This can be called by any user; for now we have decided that that's
 * ok. We might want to restrict this to users part of a specific role or such
 * at some later point.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_get_new_placementid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>placementId</name> <init>= <expr><call><name>GetNextPlacementId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>placementIdDatum</name> <init>= <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>placementId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>placementIdDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetNextPlacementId allocates and returns a unique placementId for
 * the placement to be created. This allocation occurs both in shared memory
 * and in write ahead logs; writing to logs avoids the risk of having shardId
 * collisions.
 *
 * NB: This can be called by any user; for now we have decided that that's
 * ok. We might want to restrict this to users part of a specific role or such
 * at some later point.
 */</comment>
<function><type><name>uint64</name></type>
<name>GetNextPlacementId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>savedUserId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>savedSecurityContext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>placementId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In regression tests, we would like to generate placement IDs consistently
	 * even if the tests run in parallel. Instead of the sequence, we can use
	 * the next_placement_id GUC to specify which shard ID the current session
	 * should generate next. The GUC is automatically increased by 1 every time
	 * a new placement ID is generated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NextPlacementId</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>placementId</name> <operator>=</operator> <name>NextPlacementId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>NextPlacementId</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><name>placementId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>PLACEMENTID_SEQUENCE_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>sequenceName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>sequenceIdDatum</name> <init>= <expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>savedUserId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>savedSecurityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><call><name>CitusExtensionOwner</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SECURITY_LOCAL_USERID_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* generate new and unique placement id from sequence */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>placementIdDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>nextval_oid</name></expr></argument>, <argument><expr><name>sequenceIdDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>savedUserId</name></expr></argument>, <argument><expr><name>savedSecurityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>placementId</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>placementIdDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>placementId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * master_get_round_robin_candidate_nodes is a stub UDF to make pg_upgrade
 * work flawlessly while upgrading servers from 6.1. This implementation
 * will be removed after the UDF dropped on the sql side properly.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_get_round_robin_candidate_nodes</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"this function is deprecated and no longer is used"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_stage_shard_row is a stub UDF to make pg_upgrade
 * work flawlessly while upgrading servers from 6.1. This implementation
 * will be removed after the UDF dropped on the sql side properly.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_stage_shard_row</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"this function is deprecated and no longer is used"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_stage_shard_placement_row is a stub UDF to make pg_upgrade
 * work flawlessly while upgrading servers from 6.1. This implementation
 * will be removed after the UDF dropped on the sql side properly.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_stage_shard_placement_row</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"this function is deprecated and no longer is used"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_get_active_worker_nodes returns a set of active worker host names and
 * port numbers in deterministic order. Currently we assume that all worker
 * nodes in pg_dist_node are active.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_get_active_worker_nodes</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>functionContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>workerNodeCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>functionContext</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* switch to memory context appropriate for multiple function calls */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(
			<argument><expr><name><name>functionContext</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActiveReadableNonCoordinatorNodeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>workerNodeCount</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>functionContext</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>workerNodeList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>functionContext</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <name>workerNodeCount</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * This tuple descriptor must match the output parameters declared for
		 * the function in pg_proc.
		 */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>WORKER_NODE_FIELDS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"node_name"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"node_port"</literal></expr></argument>,
						   <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>functionContext</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>functionContext</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>workerNodeIndex</name> <init>= <expr><name><name>functionContext</name><operator>-&gt;</operator><name>call_cntr</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>workerNodeCount</name> <operator>=</operator> <name><name>functionContext</name><operator>-&gt;</operator><name>max_calls</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>workerNodeIndex</name> <operator>&lt;</operator> <name>workerNodeCount</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><name><name>functionContext</name><operator>-&gt;</operator><name>user_fctx</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>workerNodeIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>workerNodeDatum</name> <init>= <expr><call><name>WorkerNodeGetDatum</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>,
												   <argument><expr><name><name>functionContext</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>functionContext</name></expr></argument>, <argument><expr><name>workerNodeDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>functionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * master_get_active_worker_nodes is a wrapper function for old UDF name.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_get_active_worker_nodes</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>citus_get_active_worker_nodes</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Finds the relationId from a potentially qualified relation name. */</comment>
<function><type><name>Oid</name></type>
<name>ResolveRelationId</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* resolve relationId from passed in schema and relation name */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationNameList</name> <init>= <expr><call><name>textToQualifiedNameList</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>relationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetFullTableCreationCommands takes in a relationId, includeSequenceDefaults,
 * and returns the list of DDL commands needed to reconstruct the relation.
 * When includeSequenceDefaults is NEXTVAL_SEQUENCE_DEFAULTS, the function also creates
 * DEFAULT clauses for columns getting their default values from a sequence.
 * When it's WORKER_NEXTVAL_SEQUENCE_DEFAULTS, the function creates the DEFAULT
 * clause using worker_nextval('sequence') and not nextval('sequence')
 * These DDL commands are all palloced; and include the table's schema
 * definition, optional column storage and statistics definitions, and index
 * constraint and trigger definitions.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetFullTableCreationCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
							 <parameter><decl><type><name>IncludeSequenceDefaults</name></type> <name>includeSequenceDefaults</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>creatingShellTableOnRemoteNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableDDLEventList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>preLoadCreationCommandList</name> <init>=
		<expr><call><name>GetPreLoadTableCreationCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>includeSequenceDefaults</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>preLoadCreationCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>postLoadCreationCommandList</name> <init>=
		<expr><call><name>GetPostLoadTableCreationCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>creatingShellTableOnRemoteNode</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * While creating shell tables, we need to associate dependencies between
		 * sequences and the relation. We also need to add truncate trigger for it
		 * if it is not the foreign table.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sequenceDependencyCommandList</name> <init>= <expr><call><name>SequenceDependencyCommandList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>sequenceDependencyCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>truncateTriggerCommand</name> <init>= <expr><call><name>TruncateTriggerCreateCommand</name><argument_list>(
				<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>,
										<argument><expr><name>truncateTriggerCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>postLoadCreationCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tableDDLEventList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetPostLoadTableCreationCommands takes in a relationId and returns the list
 * of DDL commands that should be applied after loading the data.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetPostLoadTableCreationCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>includeIndexes</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>includeReplicaIdentity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableDDLEventList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Include all the commands (e.g., create index, set index clustered
	 * and set index statistics) regarding the indexes. Note that
	 * running all these commands in parallel might fail as the
	 * latter two depends on the first one. So, the caller should
	 * execute the commands sequentially.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>indexFlags</name> <init>= <expr><name>INCLUDE_INDEX_ALL_STATEMENTS</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>includeIndexes</name> <operator>&amp;&amp;</operator> <name>includeReplicaIdentity</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexAndConstraintCommandList</name> <init>=
			<expr><call><name>GetTableIndexAndConstraintCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>indexFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>indexAndConstraintCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>includeIndexes</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>includeReplicaIdentity</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do not include the indexes/constraints that backs
		 * replica identity, if any.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexAndConstraintCommandList</name> <init>=
			<expr><call><name>GetTableIndexAndConstraintCommandsExcludingReplicaIdentity</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																	   <argument><expr><name>indexFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>indexAndConstraintCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>includeReplicaIdentity</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicaIdentityEvents</name> <init>= <expr><call><name>GetTableReplicaIdentityCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>replicaIdentityEvents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggerCommands</name> <init>= <expr><call><name>GetExplicitTriggerCommandList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>triggerCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>statisticsCommands</name> <init>= <expr><call><name>GetExplicitStatisticsCommandList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>statisticsCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tableDDLEventList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTableReplicaIdentityCommand returns the list of DDL commands to
 * (re)define the replica identity choice for a given table.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetTableReplicaIdentityCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>replicaIdentityCreateCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We skip non-relations because postgres does not support
	 * ALTER TABLE .. REPLICA IDENTITY on non-relations.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>relationKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relationKind</name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>replicaIdentityCreateCommand</name> <init>= <expr><call><name>pg_get_replica_identity_command</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>replicaIdentityCreateCommand</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>replicaIdentityCreateCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(
			<argument><expr><name>replicaIdentityCreateCommandList</name></expr></argument>,
			<argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(<argument><expr><name>replicaIdentityCreateCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>replicaIdentityCreateCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetPreLoadTableCreationCommands takes in a relationId, and returns the list of DDL
 * commands needed to reconstruct the relation, excluding indexes and constraints,
 * to facilitate faster data load.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetPreLoadTableCreationCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
								<parameter><decl><type><name>IncludeSequenceDefaults</name></type> <name>includeSequenceDefaults</name></decl></parameter>,
								<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>accessMethod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableDDLEventList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PushOverrideEmptySearchPath</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fetch table schema and column option definitions */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableSchemaDef</name> <init>= <expr><call><name>pg_get_tableschemadef_string</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
														<argument><expr><name>includeSequenceDefaults</name></expr></argument>,
														<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableColumnOptionsDef</name> <init>= <expr><call><name>pg_get_tablecolumnoptionsdef_string</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(
									<argument><expr><name>tableSchemaDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tableColumnOptionsDef</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(
										<argument><expr><name>tableColumnOptionsDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* add columnar options for cstore tables */</comment>
	<if_stmt><if>if <condition>(<expr><name>accessMethod</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>extern_IsColumnarTableAmTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>cstoreOptionsDDL</name> <init>= <expr><call><name>ColumnarGetTableOptionsDDL</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>cstoreOptionsDDL</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>cstoreOptionsDDL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableACLList</name> <init>= <expr><call><name>pg_get_table_grants</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>tableACLList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableACLCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>tableACLCommand</argument>, <argument>tableACLList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>,
										<argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(<argument><expr><name>tableACLCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableOwnerDef</name> <init>= <expr><call><name>TableOwnerResetCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>tableOwnerDef</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(
										<argument><expr><name>tableOwnerDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableRowLevelSecurityCommands</name> <init>= <expr><call><name>GetTableRowLevelSecurityCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>tableRowLevelSecurityCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>policyCommands</name> <init>= <expr><call><name>CreatePolicyCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>tableDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>tableDDLEventList</name></expr></argument>, <argument><expr><name>policyCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* revert back to original search_path */</comment>
	<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tableDDLEventList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTableIndexAndConstraintCommands returns the list of DDL commands to
 * (re)create indexes and constraints for a given table.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetTableIndexAndConstraintCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ExecuteFunctionOnEachTableIndex</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
										   <argument><expr><name>GatherIndexAndConstraintDefinitionList</name></expr></argument>,
										   <argument><expr><name>indexFlags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTableIndexAndConstraintCommands returns the list of DDL commands to
 * (re)create indexes and constraints for a given table.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetTableIndexAndConstraintCommandsExcludingReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ExecuteFunctionOnEachTableIndex</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
										   <argument><expr><name>GatherIndexAndConstraintDefinitionListExcludingReplicaIdentity</name></expr></argument>,
										   <argument><expr><name>indexFlags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GatherIndexAndConstraintDefinitionListExcludingReplicaIdentity is a wrapper around
 * GatherIndexAndConstraintDefinitionList(), which only excludes the indexes or
 * constraints that back the replica identity.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GatherIndexAndConstraintDefinitionListExcludingReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl></parameter>,
															   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexDDLEventList</name></decl></parameter>,
															   <parameter><decl><type><name>int</name></type> <name>indexFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>indexForm</name><operator>-&gt;</operator><name>indrelid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>replicaIdentityIndex</name> <init>= <expr><call><name>GetRelationIdentityOrPK</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>replicaIdentityIndex</name> <operator>==</operator> <name><name>indexForm</name><operator>-&gt;</operator><name>indexrelid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this index is backing the replica identity, so skip */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>GatherIndexAndConstraintDefinitionList</name><argument_list>(<argument><expr><name>indexForm</name></expr></argument>, <argument><expr><name>indexDDLEventList</name></expr></argument>, <argument><expr><name>indexFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Get replica identity index or if it is not defined a primary key.
 *
 * If neither is defined, returns InvalidOid.
 *
 * Inspired from postgres/src/backend/replication/logical/worker.c
 */</comment>
<function><type><name>Oid</name></type>
<name>GetRelationIdentityOrPK</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>idxoid</name> <init>= <expr><call><name>RelationGetReplicaIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>idxoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>idxoid</name> <operator>=</operator> <call><name>RelationGetPrimaryKeyIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>idxoid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GatherIndexAndConstraintDefinitionList adds the DDL command for the given index.
 */</comment>
<function><type><name>void</name></type>
<name>GatherIndexAndConstraintDefinitionList</name><parameter_list>(<parameter><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexDDLEventList</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>indexFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* generate fully-qualified names */</comment>
	<expr_stmt><expr><call><name>PushOverrideEmptySearchPath</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>indexId</name> <init>= <expr><name><name>indexForm</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>indexImpliedByConstraint</name> <init>= <expr><call><name>IndexImpliedByAConstraint</name><argument_list>(<argument><expr><name>indexForm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get the corresponding constraint or index statement */</comment>
	<if_stmt><if>if <condition>(<expr><name>indexImpliedByConstraint</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>indexFlags</name> <operator>&amp;</operator> <name>INCLUDE_CREATE_CONSTRAINT_STATEMENTS</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>constraintId</name> <init>= <expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>constraintId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* include constraints backed by indexes only when explicitly asked */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>statementDef</name> <init>= <expr><call><name>pg_get_constraintdef_command</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>*</operator><name>indexDDLEventList</name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>indexDDLEventList</name></expr></argument>,
						<argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(<argument><expr><name>statementDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>indexFlags</name> <operator>&amp;</operator> <name>INCLUDE_CREATE_INDEX_STATEMENTS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Include indexes that are not backing constraints only when
		 * explicitly asked.
		 */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>statementDef</name> <init>= <expr><call><name>pg_get_indexdef_string</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>indexDDLEventList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>indexDDLEventList</name></expr></argument>,
									 <argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(<argument><expr><name>statementDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if table is clustered on this index, append definition to the list */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>indexFlags</name> <operator>&amp;</operator> <name>INCLUDE_INDEX_CLUSTERED_STATEMENTS</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>clusteredDef</name> <init>= <expr><call><name>pg_get_indexclusterdef_string</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clusteredDef</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>indexDDLEventList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>indexDDLEventList</name></expr></argument>, <argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(
										 <argument><expr><name>clusteredDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we need alter index commands for altered targets on expression indexes */</comment>
	<if_stmt><if>if <condition>(<expr><name>indexFlags</name> <operator>&amp;</operator> <name>INCLUDE_INDEX_STATISTICS_STATEMENTTS</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>alterIndexStatisticsCommands</name> <init>= <expr><call><name>GetAlterIndexStatisticsCommands</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>indexDDLEventList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>indexDDLEventList</name></expr></argument>,
										 <argument><expr><name>alterIndexStatisticsCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* revert back to original search_path */</comment>
	<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetTableRowLevelSecurityCommands takes in a relationId, and returns the list of
 * commands needed to reconstruct the row level security policy.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetTableRowLevelSecurityCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rowLevelSecurityCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rowLevelSecurityEnableCommands</name> <init>= <expr><call><name>pg_get_row_level_security_commands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rowLevelSecurityCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>rowLevelSecurityCommand</argument>, <argument>rowLevelSecurityEnableCommands</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rowLevelSecurityCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(
			<argument><expr><name>rowLevelSecurityCommandList</name></expr></argument>,
			<argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(<argument><expr><name>rowLevelSecurityCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>rowLevelSecurityCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IndexImpliedByAConstraint is a helper function to be used while scanning
 * pg_index. It returns true if the index identified by the given indexForm is
 * implied by a constraint. Note that caller is responsible for passing a valid
 * indexFrom, which means an alive heap tuple which is of form Form_pg_index.
 */</comment>
<function><type><name>bool</name></type>
<name>IndexImpliedByAConstraint</name><parameter_list>(<parameter><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indexForm</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>indexImpliedByConstraint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * A primary key index is always created by a constraint statement.
	 * A unique key index or exclusion index is created by a constraint
	 * if and only if the index has a corresponding constraint entry in
	 * pg_depend. Any other index form is never associated with a constraint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>indexImpliedByConstraint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisunique</name></name> <operator>||</operator> <name><name>indexForm</name><operator>-&gt;</operator><name>indisexclusion</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>constraintId</name> <init>= <expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexImpliedByConstraint</name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>indexImpliedByConstraint</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardStorageType returns the shard storage type according to relation type.
 */</comment>
<function><type><name>char</name></type>
<name>ShardStorageType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>shardStorageType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>relationType</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>RegularTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardStorageType</name> <operator>=</operator> <name>SHARD_STORAGE_TABLE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>relationType</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardStorageType</name> <operator>=</operator> <name>SHARD_STORAGE_FOREIGN</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected relation type: %c"</literal></expr></argument>, <argument><expr><name>relationType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>shardStorageType</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCoordinator function returns true if this node is identified as the
 * schema/coordinator/master node of the cluster.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCoordinator</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call> <operator>==</operator> <name>COORDINATOR_GROUP_ID</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerNodeGetDatum converts the worker node passed to it into its datum
 * representation. To do this, the function first creates the heap tuple from
 * the worker node name and port. Then, the function converts the heap tuple
 * into a datum and returns it.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>WorkerNodeGetDatum</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>WORKER_NODE_FIELDS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNulls</name><index>[<expr><name>WORKER_NODE_FIELDS</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>workerNodeTuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isNulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>workerNodeDatum</name> <init>= <expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>workerNodeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>workerNodeDatum</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistributedTableReplicationIsEnabled returns true if distributed table shards
 * are replicated according to ShardReplicationFactor.
 */</comment>
<function><type><name>bool</name></type>
<name>DistributedTableReplicationIsEnabled</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>ShardReplicationFactor</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * makeTableDDLCommandString creates a TableDDLCommand based on a constant string. If the
 * TableDDLCommand is turned into a sharded table command the constant will be wrapped in
 * worker_apply_shard_ddl_command with the target shardId. If the command applies to an
 * un-sharded table (eg. mx) the command is applied as is.
 */</comment>
<function><type><name>TableDDLCommand</name> <modifier>*</modifier></type>
<name>makeTableDDLCommandString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>commandStr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>TableDDLCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TABLE_DDL_COMMAND_STRING</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>commandStr</name></name> <operator>=</operator> <name>commandStr</name></expr>;</expr_stmt>

	<return>return <expr><name>command</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * makeTableDDLCommandString creates an implementation of TableDDLCommand that creates the
 * final sql command based on function pointers being passed.
 */</comment>
<function><type><name>TableDDLCommand</name> <modifier>*</modifier></type>
<name>makeTableDDLCommandFunction</name><parameter_list>(<parameter><decl><type><name>TableDDLFunction</name></type> <name>function</name></decl></parameter>,
							<parameter><decl><type><name>TableDDLShardedFunction</name></type> <name>shardedFunction</name></decl></parameter>,
							<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>TableDDLCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Function pointers are called later without verifying them not being NULL. Guard
	 * developers from making a mistake with them directly when they could be made.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>function</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shardedFunction</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TABLE_DDL_COMMAND_FUNCTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>function</name></name> <operator>=</operator> <name>function</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>shardedFunction</name></name> <operator>=</operator> <name>shardedFunction</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>command</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>context</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>

	<return>return <expr><name>command</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetShardedTableDDLCommandString is the internal function for TableDDLCommand objects
 * created with makeTableDDLCommandString.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetShardedTableDDLCommandString</name><parameter_list>(<parameter><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
								<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TABLE_DDL_COMMAND_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedDDLCommand</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>commandStr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaName</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><literal type="string">"public"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedSchemaName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>WORKER_APPLY_SHARD_DDL_COMMAND</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>escapedSchemaName</name></expr></argument>,
						 <argument><expr><name>escapedDDLCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>WORKER_APPLY_SHARD_DDL_COMMAND_WITHOUT_SCHEMA</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
						 <argument><expr><name>escapedDDLCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTableDDLCommandString is the internal function for TableDDLCommand objects created
 * with makeTableDDLCommandString to return the non-sharded version of the ddl command.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetTableDDLCommandString</name><parameter_list>(<parameter><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TABLE_DDL_COMMAND_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>command</name><operator>-&gt;</operator><name>commandStr</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetShardedTableDDLCommand returns the ddl command expressed by this TableDDLCommand
 * where all applicable names are transformed into the names for a shard identified by
 * shardId
 *
 * schemaName is deprecated but used for TableDDLCommandString. All other implementations
 * will need to rely solely on the shardId.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetShardedTableDDLCommand</name><parameter_list>(<parameter><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TABLE_DDL_COMMAND_STRING</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><call><name>GetShardedTableDDLCommandString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>TABLE_DDL_COMMAND_FUNCTION</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><call><name><name>command</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>shardedFunction</name></name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>

	<comment type="block">/* unreachable: compiler should warn/error when not all cases are covered above */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported TableDDLCommand: %d"</literal></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetTableDDLCommand returns the ddl command expressed by this TableDDLCommand where all
 * table names are targeting the base table, not any shards.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetTableDDLCommand</name><parameter_list>(<parameter><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TABLE_DDL_COMMAND_STRING</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><call><name>GetTableDDLCommandString</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>TABLE_DDL_COMMAND_FUNCTION</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><call><name><name>command</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>function</name></name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>function</name><operator>.</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>

	<comment type="block">/* unreachable: compiler should warn/error when not all cases are covered above */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported TableDDLCommand: %d"</literal></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusCreateAlterColumnarTableSet generates a portable
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CitusCreateAlterColumnarTableSet</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>ColumnarOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
					 <argument><expr><literal type="string">"ALTER TABLE %s SET ("</literal>
					 <literal type="string">"columnar.chunk_group_row_limit = %d, "</literal>
					 <literal type="string">"columnar.stripe_row_limit = %lu, "</literal>
					 <literal type="string">"columnar.compression_level = %d, "</literal>
					 <literal type="string">"columnar.compression = %s);"</literal></expr></argument>,
					 <argument><expr><name>qualifiedRelationName</name></expr></argument>,
					 <argument><expr><name><name>options</name><operator>-&gt;</operator><name>chunkRowCount</name></name></expr></argument>,
					 <argument><expr><name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name></expr></argument>,
					 <argument><expr><name><name>options</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>extern_CompressionTypeStr</name><argument_list>(
											<argument><expr><name><name>options</name><operator>-&gt;</operator><name>compressionType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTableDDLCommandColumnar is an internal function used to turn a
 * ColumnarTableDDLContext stored on the context of a TableDDLCommandFunction into a sql
 * command that will be executed against a table. The resulting command will set the
 * options of the table to the same options as the relation on the coordinator.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetTableDDLCommandColumnar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarTableDDLContext</name> <modifier>*</modifier></type><name>tableDDLContext</name> <init>= <expr><operator>(</operator><name>ColumnarTableDDLContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedShardName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>tableDDLContext</name><operator>-&gt;</operator><name>schemaName</name></name></expr></argument>,
														  <argument><expr><name><name>tableDDLContext</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>CitusCreateAlterColumnarTableSet</name><argument_list>(<argument><expr><name>qualifiedShardName</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>tableDDLContext</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetShardedTableDDLCommandColumnar is an internal function used to turn a
 * ColumnarTableDDLContext stored on the context of a TableDDLCommandFunction into a sql
 * command that will be executed against a shard. The resulting command will set the
 * options of the shard to the same options as the relation the shard is based on.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetShardedTableDDLCommandColumnar</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarTableDDLContext</name> <modifier>*</modifier></type><name>tableDDLContext</name> <init>= <expr><operator>(</operator><name>ColumnarTableDDLContext</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * AppendShardId is destructive of the original cahr *, given we want to serialize
	 * more than once we copy it before appending the shard id.
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>tableDDLContext</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedShardName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>tableDDLContext</name><operator>-&gt;</operator><name>schemaName</name></name></expr></argument>,
														  <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>CitusCreateAlterColumnarTableSet</name><argument_list>(<argument><expr><name>qualifiedShardName</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>tableDDLContext</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarGetCustomTableOptionsDDL returns a TableDDLCommand representing a command that
 * will apply the passed columnar options to the relation identified by relationId on a
 * new table or shard.
 */</comment>
<function><type><name>TableDDLCommand</name> <modifier>*</modifier></type>
<name>ColumnarGetCustomTableOptionsDDL</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>,
								 <parameter><decl><type><name>ColumnarOptions</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarTableDDLContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>(</operator><name>ColumnarTableDDLContext</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnarTableDDLContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build the context */</comment>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>schemaName</name></name> <operator>=</operator> <name>schemaName</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>relationName</name></name> <operator>=</operator> <name>relationName</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>

	<comment type="block">/* create TableDDLCommand based on the context build above */</comment>
	<return>return <expr><call><name>makeTableDDLCommandFunction</name><argument_list>(
		<argument><expr><name>GetTableDDLCommandColumnar</name></expr></argument>,
		<argument><expr><name>GetShardedTableDDLCommandColumnar</name></expr></argument>,
		<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarGetTableOptionsDDL returns a TableDDLCommand representing a command that will
 * apply the columnar options currently applicable to the relation identified by
 * relationId on a new table or shard.
 */</comment>
<function><type><specifier>static</specifier> <name>TableDDLCommand</name> <modifier>*</modifier></type>
<name>ColumnarGetTableOptionsDDL</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ColumnarOptions</name></type> <name>options</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>extern_ReadColumnarOptions</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>ColumnarGetCustomTableOptionsDDL</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
