<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/operations/create_shards.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * create_shards.c
 *
 * This file contains functions to distribute a table by creating shards for it
 * across a set of worker nodes.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_shard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/errcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>


<comment type="block">/* declarations for dynamic loading */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_create_worker_shards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * master_create_worker_shards is a deprecated UDF that was used to
 * create shards for a hash-distributed table.
 */</comment>
<function><type><name>Datum</name></type>
<name>master_create_worker_shards</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"master_create_worker_shards has been deprecated"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateShardsWithRoundRobinPolicy creates empty shards for the given table
 * based on the specified number of initial shards. The function first updates
 * metadata on the coordinator node to make this shard (and its placements)
 * visible. Note that the function assumes the table is hash partitioned and
 * calculates the min/max hash token ranges for each shard, giving them an equal
 * split of the hash space. Finally, function creates empty shard placements on
 * worker nodes.
 */</comment>
<function><type><name>void</name></type>
<name>CreateShardsWithRoundRobinPolicy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>distributedTableId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>shardCount</name></decl></parameter>,
								 <parameter><decl><type><name>int32</name></type> <name>replicationFactor</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useExclusiveConnections</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>colocatedShard</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertedShardPlacements</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* make sure table is hash partitioned */</comment>
	<expr_stmt><expr><call><name>CheckHashPartitionedTable</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In contrast to append/range partitioned tables it makes more sense to
	 * require ownership privileges - shards for hash-partitioned tables are
	 * only created once, not continually during ingest as for the other
	 * partitioning types.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we plan to add shards: get an exclusive lock on relation oid */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* validate that shards haven't already been created for this table */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>existingShardList</name> <init>= <expr><call><name>LoadShardList</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>existingShardList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has already had shards created for it"</literal></expr></argument>,
							   <argument><expr><name>tableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make sure that at least one shard is specified */</comment>
	<if_stmt><if>if <condition>(<expr><name>shardCount</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard_count must be positive"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make sure that at least one replica is specified */</comment>
	<if_stmt><if>if <condition>(<expr><name>replicationFactor</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replication_factor must be positive"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make sure that RF=1 if the table is streaming replicated */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>==</operator> <name>REPLICATION_MODEL_STREAMING</name> <operator>&amp;&amp;</operator>
		<name>replicationFactor</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"using replication factor %d with the streaming "</literal>
							   <literal type="string">"replication model is not supported"</literal></expr></argument>,
							   <argument><expr><name>replicationFactor</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The table %s is marked as streaming replicated and "</literal>
								  <literal type="string">"the shard replication factor of streaming replicated "</literal>
								  <literal type="string">"tables must be 1."</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use replication factor 1."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* calculate the split of the hash space */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>hashTokenIncrement</name> <init>= <expr><name>HASH_TOKEN_COUNT</name> <operator>/</operator> <name>shardCount</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* don't allow concurrent node list changes that require an exclusive lock */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* load and sort the worker node list for deterministic placement */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>DistributedTablePlacementNodeList</name><argument_list>(<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>workerNodeList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>CompareWorkerNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int32</name></type> <name>workerNodeCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>replicationFactor</name> <operator>&gt;</operator> <name>workerNodeCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replication_factor (%d) exceeds number of worker nodes "</literal>
							   <literal type="string">"(%d)"</literal></expr></argument>, <argument><expr><name>replicationFactor</name></expr></argument>, <argument><expr><name>workerNodeCount</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Add more worker nodes or try again with a lower "</literal>
								<literal type="string">"replication factor."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if we have enough nodes, add an extra placement attempt for backup */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>placementAttemptCount</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>replicationFactor</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNodeCount</name> <operator>&gt;</operator> <name>replicationFactor</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>placementAttemptCount</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set shard storage type according to relation type */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>shardStorageType</name> <init>= <expr><call><name>ShardStorageType</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int64</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name>shardCount</name></expr>;</condition> <incr><expr><name>shardIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>roundRobinNodeIndex</name> <init>= <expr><name>shardIndex</name> <operator>%</operator> <name>workerNodeCount</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* initialize the hash token space for this shard */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMinHashToken</name> <init>= <expr><name>PG_INT32_MIN</name> <operator>+</operator> <operator>(</operator><name>shardIndex</name> <operator>*</operator> <name>hashTokenIncrement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMaxHashToken</name> <init>= <expr><name>shardMinHashToken</name> <operator>+</operator> <operator>(</operator><name>hashTokenIncrement</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>GetNextShardId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if we are at the last shard, make sure the max token value is INT_MAX */</comment>
		<if_stmt><if>if <condition>(<expr><name>shardIndex</name> <operator>==</operator> <operator>(</operator><name>shardCount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>shardMaxHashToken</name> <operator>=</operator> <name>PG_INT32_MAX</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* insert the shard metadata row along with its min/max values */</comment>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>minHashTokenText</name> <init>= <expr><call><name>IntegerToText</name><argument_list>(<argument><expr><name>shardMinHashToken</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>maxHashTokenText</name> <init>= <expr><call><name>IntegerToText</name><argument_list>(<argument><expr><name>shardMaxHashToken</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InsertShardRow</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>shardStorageType</name></expr></argument>,
					   <argument><expr><name>minHashTokenText</name></expr></argument>, <argument><expr><name>maxHashTokenText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>currentInsertedShardPlacements</name> <init>= <expr><call><name>InsertShardPlacementRows</name><argument_list>(
			<argument><expr><name>distributedTableId</name></expr></argument>,
			<argument><expr><name>shardId</name></expr></argument>,
			<argument><expr><name>workerNodeList</name></expr></argument>,
			<argument><expr><name>roundRobinNodeIndex</name></expr></argument>,
			<argument><expr><name>replicationFactor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>insertedShardPlacements</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>insertedShardPlacements</name></expr></argument>,
											  <argument><expr><name>currentInsertedShardPlacements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>CreateShardsOnWorkers</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>insertedShardPlacements</name></expr></argument>,
						  <argument><expr><name>useExclusiveConnections</name></expr></argument>, <argument><expr><name>colocatedShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateColocatedShards creates shards for the target relation colocated with
 * the source relation.
 */</comment>
<function><type><name>void</name></type>
<name>CreateColocatedShards</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
					  <name>useExclusiveConnections</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>colocatedShard</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertedShardPlacements</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* make sure that tables are hash partitioned */</comment>
	<expr_stmt><expr><call><name>CheckHashPartitionedTable</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CheckHashPartitionedTable</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In contrast to append/range partitioned tables it makes more sense to
	 * require ownership privileges - shards for hash-partitioned tables are
	 * only created once, not continually during ingest as for the other
	 * partitioning types.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we plan to add shards: get an exclusive lock on target relation oid */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we don't want source table to get dropped before we colocate with it */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prevent placement changes of the source relation until we colocate with them */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceShardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>sourceShardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* validate that shards haven't already been created for this table */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>existingShardList</name> <init>= <expr><call><name>LoadShardList</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>existingShardList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>targetRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has already had shards created for it"</literal></expr></argument>,
							   <argument><expr><name>targetRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>targetShardStorageType</name> <init>= <expr><call><name>ShardStorageType</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>sourceShardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>sourceShardInterval</argument>, <argument>sourceShardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>sourceShardId</name> <init>= <expr><name><name>sourceShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>newShardId</name> <init>= <expr><call><name>GetNextShardId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int32</name></type> <name>shardMinValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>sourceShardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMaxValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>sourceShardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMinValueText</name> <init>= <expr><call><name>IntegerToText</name><argument_list>(<argument><expr><name>shardMinValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMaxValueText</name> <init>= <expr><call><name>IntegerToText</name><argument_list>(<argument><expr><name>shardMaxValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceShardPlacementList</name> <init>= <expr><call><name>ShardPlacementListWithoutOrphanedPlacements</name><argument_list>(
			<argument><expr><name>sourceShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InsertShardRow</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>newShardId</name></expr></argument>, <argument><expr><name>targetShardStorageType</name></expr></argument>,
					   <argument><expr><name>shardMinValueText</name></expr></argument>, <argument><expr><name>shardMaxValueText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>sourcePlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>sourcePlacement</argument>, <argument>sourceShardPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type> <name>groupId</name> <init>= <expr><name><name>sourcePlacement</name><operator>-&gt;</operator><name>groupId</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>ShardState</name></type> <name>shardState</name> <init>= <expr><name>SHARD_STATE_ACTIVE</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>uint64</name></type> <name>shardSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Optimistically add shard placement row the pg_dist_shard_placement, in case
			 * of any error it will be roll-backed.
			 */</comment>
			<decl_stmt><decl><type><name>uint64</name></type> <name>shardPlacementId</name> <init>= <expr><call><name>InsertShardPlacementRow</name><argument_list>(<argument><expr><name>newShardId</name></expr></argument>,
															  <argument><expr><name>INVALID_PLACEMENT_ID</name></expr></argument>,
															  <argument><expr><name>shardState</name></expr></argument>, <argument><expr><name>shardSize</name></expr></argument>,
															  <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>shardPlacement</name> <init>= <expr><call><name>LoadShardPlacement</name><argument_list>(<argument><expr><name>newShardId</name></expr></argument>,
																<argument><expr><name>shardPlacementId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>insertedShardPlacements</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>insertedShardPlacements</name></expr></argument>, <argument><expr><name>shardPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<expr_stmt><expr><call><name>CreateShardsOnWorkers</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>insertedShardPlacements</name></expr></argument>,
						  <argument><expr><name>useExclusiveConnections</name></expr></argument>, <argument><expr><name>colocatedShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateReferenceTableShard creates a single shard for the given
 * distributedTableId. The created shard does not have min/max values.
 * Also, the shard is replicated to the all active nodes in the cluster.
 */</comment>
<function><type><name>void</name></type>
<name>CreateReferenceTableShard</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>distributedTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>workerStartIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMinValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMaxValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>useExclusiveConnection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>colocatedShard</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In contrast to append/range partitioned tables it makes more sense to
	 * require ownership privileges - shards for reference tables are
	 * only created once, not continually during ingest as for the other
	 * partitioning types such as append and range.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we plan to add shards: get an exclusive lock on relation oid */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set shard storage type according to relation type */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>shardStorageType</name> <init>= <expr><call><name>ShardStorageType</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* validate that shards haven't already been created for this table */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>existingShardList</name> <init>= <expr><call><name>LoadShardList</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>existingShardList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has already had shards created for it"</literal></expr></argument>,
							   <argument><expr><name>tableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * load and sort the worker node list for deterministic placements
	 * create_reference_table has already acquired pg_dist_node lock
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><call><name>ReferenceTablePlacementNodeList</name><argument_list>(<argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>nodeList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>CompareWorkerNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>replicationFactor</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get the next shard id */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>GetNextShardId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InsertShardRow</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>shardStorageType</name></expr></argument>, <argument><expr><name>shardMinValue</name></expr></argument>,
				   <argument><expr><name>shardMaxValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertedShardPlacements</name> <init>= <expr><call><name>InsertShardPlacementRows</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
															 <argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>workerStartIndex</name></expr></argument>,
															 <argument><expr><name>replicationFactor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CreateShardsOnWorkers</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>insertedShardPlacements</name></expr></argument>,
						  <argument><expr><name>useExclusiveConnection</name></expr></argument>, <argument><expr><name>colocatedShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CheckHashPartitionedTable looks up the partition information for the given
 * tableId and checks if the table is hash partitioned. If not, the function
 * throws an error.
 */</comment>
<function><type><name>void</name></type>
<name>CheckHashPartitionedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>distributedTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>partitionType</name> <init>= <expr><call><name>PartitionMethod</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>partitionType</name> <operator>!=</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported table partition type: %c"</literal></expr></argument>, <argument><expr><name>partitionType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Helper function to convert an integer value to a text type */</comment>
<function><type><name>text</name> <modifier>*</modifier></type>
<name>IntegerToText</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>valueString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>valueString</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>valueText</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>valueString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>valueText</name></expr>;</return>
</block_content>}</block></function>
</unit>
