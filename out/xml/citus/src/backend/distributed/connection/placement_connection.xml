<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/connection/placement_connection.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * placement_connection.c
 *   Per placement connection handling.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/placement_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * A connection reference is used to register that a connection has been used
 * to read or modify either a) a shard placement as a particular user b) a
 * group of colocated placements (which depend on whether the reference is
 * from ConnectionPlacementHashEntry or ColocatedPlacementHashEntry).
 */</comment>
<typedef>typedef <type><struct>struct <name>ConnectionReference</name>
<block>{
	<comment type="block">/*
	 * The user used to read/modify the placement. We cannot reuse connections
	 * that were performed using a different role, since it would not have the
	 * right permissions.
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name></decl>;</decl_stmt>

	<comment type="block">/* the connection */</comment>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Information about what the connection is used for. There can only be
	 * one connection executing DDL/DML for a placement to avoid deadlock
	 * issues/read-your-own-writes violations.  The difference between DDL/DML
	 * currently is only used to emit more precise error messages.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hadDML</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hadDDL</name></decl>;</decl_stmt>

	<comment type="block">/* colocation group of the placement, if any */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationGroupId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>representativeValue</name></decl>;</decl_stmt>

	<comment type="block">/* placementId of the placement, used only for append distributed tables */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>placementId</name></decl>;</decl_stmt>

	<comment type="block">/* membership in MultiConnection-&gt;referencedPlacements */</comment>
	<decl_stmt><decl><type><name>dlist_node</name></type> <name>connectionNode</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConnectionReference</name>;</typedef>


<struct_decl>struct <name>ColocatedPlacementsHashEntry</name>;</struct_decl>


<comment type="block">/*
 * Hash table mapping placements to a list of connections.
 *
 * This stores a list of connections for each placement, because multiple
 * connections to the same placement may exist at the same time. E.g. an
 * adaptive executor query may reference the same placement in several
 * sub-tasks.
 *
 * We keep track about a connection having executed DML or DDL, since we can
 * only ever allow a single transaction to do either to prevent deadlocks and
 * consistency violations (e.g. read-your-own-writes).
 */</comment>

<comment type="block">/* hash key */</comment>
<typedef>typedef <type><struct>struct <name>ConnectionPlacementHashKey</name>
<block>{
	<decl_stmt><decl><type><name>uint64</name></type> <name>placementId</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConnectionPlacementHashKey</name>;</typedef>

<comment type="block">/* hash entry */</comment>
<typedef>typedef <type><struct>struct <name>ConnectionPlacementHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>ConnectionPlacementHashKey</name></type> <name>key</name></decl>;</decl_stmt>

	<comment type="block">/* did any remote transactions fail? */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>failed</name></decl>;</decl_stmt>

	<comment type="block">/* primary connection used to access the placement */</comment>
	<decl_stmt><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>primaryConnection</name></decl>;</decl_stmt>

	<comment type="block">/* are any other connections reading from the placements? */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasSecondaryConnections</name></decl>;</decl_stmt>

	<comment type="block">/* entry for the set of co-located placements */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>ColocatedPlacementsHashEntry</name></name> <modifier>*</modifier></type><name>colocatedEntry</name></decl>;</decl_stmt>

	<comment type="block">/* membership in ConnectionShardHashEntry-&gt;placementConnections */</comment>
	<decl_stmt><decl><type><name>dlist_node</name></type> <name>shardNode</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConnectionPlacementHashEntry</name>;</typedef>

<comment type="block">/* hash table */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ConnectionPlacementHash</name></decl>;</decl_stmt>


<comment type="block">/*
 * A hash-table mapping colocated placements to connections. Colocated
 * placements being the set of placements on a single node that represent the
 * same value range. This is needed because connections for colocated
 * placements (i.e. the corresponding placements for different colocated
 * distributed tables) need to share connections.  Otherwise things like
 * foreign keys can very easily lead to unprincipled deadlocks.  This means
 * that there can only be one DML/DDL connection for a set of colocated
 * placements.
 *
 * A set of colocated placements is identified, besides node identifying
 * information, by the associated colocation group id and the placement's
 * 'representativeValue' which currently is the lower boundary of it's
 * hash-range.
 *
 * Note that this hash-table only contains entries for hash-partitioned
 * tables, because others so far don't support colocation.
 */</comment>

<comment type="block">/* hash key */</comment>
<typedef>typedef <type><struct>struct <name>ColocatedPlacementsHashKey</name>
<block>{
	<comment type="block">/* to identify host - database can't differ */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>nodeId</name></decl>;</decl_stmt>

	<comment type="block">/* colocation group, or invalid */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationGroupId</name></decl>;</decl_stmt>

	<comment type="block">/* to represent the value range */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>representativeValue</name></decl>;</decl_stmt>
}</block></struct></type> <name>ColocatedPlacementsHashKey</name>;</typedef>

<comment type="block">/* hash entry */</comment>
<typedef>typedef <type><struct>struct <name>ColocatedPlacementsHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>ColocatedPlacementsHashKey</name></type> <name>key</name></decl>;</decl_stmt>

	<comment type="block">/* primary connection used to access the co-located placements */</comment>
	<decl_stmt><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>primaryConnection</name></decl>;</decl_stmt>

	<comment type="block">/* are any other connections reading from the placements? */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasSecondaryConnections</name></decl>;</decl_stmt>
}</block></struct></type>  <name>ColocatedPlacementsHashEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ColocatedPlacementsHash</name></decl>;</decl_stmt>


<comment type="block">/*
 * Hash table mapping shard ids to placements.
 *
 * This is used to track whether placements of a shard have to be marked
 * invalid after a failure, or whether a coordinated transaction has to be
 * aborted, to avoid all placements of a shard to be marked invalid.
 */</comment>

<comment type="block">/* hash key */</comment>
<typedef>typedef <type><struct>struct <name>ConnectionShardHashKey</name>
<block>{
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConnectionShardHashKey</name>;</typedef>

<comment type="block">/* hash entry */</comment>
<typedef>typedef <type><struct>struct <name>ConnectionShardHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>ConnectionShardHashKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_head</name></type> <name>placementConnections</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConnectionShardHashEntry</name>;</typedef>

<comment type="block">/* hash table */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ConnectionShardHash</name></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>MultiConnection</name> <modifier>*</modifier></type> <name>FindPlacementListConnection</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementAccessList</name></decl></parameter>,
													 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ConnectionPlacementHashEntry</name> <modifier>*</modifier></type> <name>FindOrCreatePlacementEntry</name><parameter_list>(
	<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CanUseExistingConnection</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name></decl></parameter>,
									 <parameter><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>placementConnection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ConnectionAccessedDifferentPlacement</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
												 <parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AssociatePlacementWithShard</name><parameter_list>(<parameter><decl><type><name>ConnectionPlacementHashEntry</name> <modifier>*</modifier></type><name>placementEntry</name></decl></parameter>,
										<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasModificationFailedForShard</name><parameter_list>(<parameter><decl><type><name>ConnectionShardHashEntry</name> <modifier>*</modifier></type><name>shardEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>ColocatedPlacementsHashHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ColocatedPlacementsHashCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * GetPlacementConnection establishes a connection for a placement.
 *
 * See StartPlacementConnection for details.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>GetPlacementConnection</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>StartPlacementConnection</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>placement</name></expr></argument>, <argument><expr><name>userName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection can only be NULL for optional connections */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>OPTIONAL_CONNECTION</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>FinishConnectionEstablishment</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StartPlacementConnection initiates a connection to a remote node,
 * associated with the placement and transaction.
 *
 * The connection is established for the current database. If userName is NULL
 * the current user is used, otherwise the provided one.
 *
 * See StartNodeUserDatabaseConnection for details.
 *
 * Flags have the corresponding meaning from StartNodeUserDatabaseConnection,
 * except that two additional flags have an effect:
 * - FOR_DML - signal that connection is going to be used for DML (modifications)
 * - FOR_DDL - signal that connection is going to be used for DDL
 *
 * Only one connection associated with the placement may have FOR_DML or
 * FOR_DDL set. For hash-partitioned tables only one connection for a set of
 * colocated placements may have FOR_DML/DDL set.  This restriction prevents
 * deadlocks and wrong results due to in-progress transactions.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>StartPlacementConnection</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardPlacementAccess</name> <modifier>*</modifier></type><name>placementAccess</name> <init>=
		<expr><operator>(</operator><name>ShardPlacementAccess</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardPlacementAccess</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>placementAccess</name><operator>-&gt;</operator><name>placement</name></name> <operator>=</operator> <name>placement</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FOR_DDL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>placementAccess</name><operator>-&gt;</operator><name>accessType</name></name> <operator>=</operator> <name>PLACEMENT_ACCESS_DDL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FOR_DML</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>placementAccess</name><operator>-&gt;</operator><name>accessType</name></name> <operator>=</operator> <name>PLACEMENT_ACCESS_DML</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>placementAccess</name><operator>-&gt;</operator><name>accessType</name></name> <operator>=</operator> <name>PLACEMENT_ACCESS_SELECT</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>StartPlacementListConnection</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>placementAccess</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>userName</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StartPlacementListConnection returns a connection to a remote node suitable for
 * a placement accesses (SELECT, DML, DDL) or throws an error if no suitable
 * connection can be established if would cause a self-deadlock or consistency
 * violation.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>StartPlacementListConnection</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementAccessList</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>freeUserName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>userName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>userName</name> <operator>=</operator> <name>freeUserName</name> <operator>=</operator> <call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>chosenConnection</name> <init>= <expr><call><name>FindPlacementListConnection</name><argument_list>(<argument><expr><name>flags</name></expr></argument>,
																	<argument><expr><name>placementAccessList</name></expr></argument>,
																	<argument><expr><name>userName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>chosenConnection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use the first placement from the list to extract nodename and nodeport */</comment>
		<decl_stmt><decl><type><name>ShardPlacementAccess</name> <modifier>*</modifier></type><name>placementAccess</name> <init>=
			<expr><operator>(</operator><name>ShardPlacementAccess</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>placementAccessList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name><name>placementAccess</name><operator>-&gt;</operator><name>placement</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>placement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>placement</name><operator>-&gt;</operator><name>nodePort</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * No suitable connection in the placement-&gt;connection mapping, get one from
		 * the node-&gt;connection pool.
		 */</comment>
		<expr_stmt><expr><name>chosenConnection</name> <operator>=</operator> <call><name>StartNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>,
														   <argument><expr><name>userName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>chosenConnection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connection can only be NULL for optional connections */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>OPTIONAL_CONNECTION</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REQUIRE_CLEAN_CONNECTION</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<call><name>ConnectionAccessedDifferentPlacement</name><argument_list>(<argument><expr><name>chosenConnection</name></expr></argument>, <argument><expr><name>placement</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Cached connection accessed a non-co-located placement in the same
			 * table or co-location group, while the caller asked for a clean
			 * connection. Open a new connection instead.
			 *
			 * We use this for situations in which we want to use a different
			 * connection for every placement, such as COPY. If we blindly returned
			 * a cached connection that already modified a different, non-co-located
			 * placement B in the same table or in a table with the same co-location
			 * ID as the current placement, then we'd no longer able to write to
			 * placement B later in the COPY.
			 */</comment>
			<expr_stmt><expr><name>chosenConnection</name> <operator>=</operator> <call><name>StartNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>flags</name> <operator>|</operator>
															   <name>FORCE_NEW_CONNECTION</name></expr></argument>,
															   <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>,
															   <argument><expr><name>userName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>chosenConnection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* connection can only be NULL for optional connections */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>OPTIONAL_CONNECTION</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ConnectionAccessedDifferentPlacement</name><argument_list>(<argument><expr><name>chosenConnection</name></expr></argument>, <argument><expr><name>placement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* remember which connection we're going to use to access the placements */</comment>
	<expr_stmt><expr><call><name>AssignPlacementListToConnection</name><argument_list>(<argument><expr><name>placementAccessList</name></expr></argument>, <argument><expr><name>chosenConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>freeUserName</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>freeUserName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>chosenConnection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssignPlacementListToConnection assigns a set of shard placement accesses to a
 * given connection, meaning that connection must be used for all (conflicting)
 * accesses of the same shard placements to make sure reads see writes and to
 * make sure we don't take conflicting locks.
 */</comment>
<function><type><name>void</name></type>
<name>AssignPlacementListToConnection</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementAccessList</name></decl></parameter>, <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>user</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardPlacementAccess</name> <modifier>*</modifier></type><name>placementAccess</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>placementAccess</argument>, <argument>placementAccessList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name><name>placementAccess</name><operator>-&gt;</operator><name>placement</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name> <init>= <expr><name><name>placementAccess</name><operator>-&gt;</operator><name>accessType</name></name></expr></init></decl>;</decl_stmt>


		<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name> <operator>==</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When a SELECT prunes down to 0 shard, we use a dummy placement
			 * which is only used to route the query to a worker node, but
			 * the SELECT doesn't actually access any shard placement.
			 *
			 * FIXME: this can be removed if we evaluate empty SELECTs locally.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ConnectionPlacementHashEntry</name> <modifier>*</modifier></type><name>placementEntry</name> <init>= <expr><call><name>FindOrCreatePlacementEntry</name><argument_list>(
			<argument><expr><name>placement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>placementConnection</name> <init>= <expr><name><name>placementEntry</name><operator>-&gt;</operator><name>primaryConnection</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>placementConnection</name><operator>-&gt;</operator><name>connection</name></name> <operator>==</operator> <name>connection</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* using the connection that was already assigned to the placement */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>placementConnection</name><operator>-&gt;</operator><name>connection</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* placement does not have a connection assigned yet */</comment>
			<expr_stmt><expr><name><name>placementConnection</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>connection</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDDL</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDML</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placementConnection</name><operator>-&gt;</operator><name>userName</name></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
																<argument><expr><name>userName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placementConnection</name><operator>-&gt;</operator><name>placementId</name></name> <operator>=</operator> <name><name>placementAccess</name><operator>-&gt;</operator><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr>;</expr_stmt>

			<comment type="block">/* record association with connection */</comment>
			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>referencedPlacements</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>placementConnection</name><operator>-&gt;</operator><name>connectionNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* using a different connection than the one assigned to the placement */</comment>

			<if_stmt><if>if <condition>(<expr><name>accessType</name> <operator>!=</operator> <name>PLACEMENT_ACCESS_SELECT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We previously read from the placement, but now we're writing to
				 * it (if we had written to the placement, we would have either chosen
				 * the same connection, or errored out). Update the connection reference
				 * to point to the connection used for writing. We don't need to remember
				 * the existing connection since we won't be able to reuse it for
				 * accessing the placement. However, we do register that it exists in
				 * hasSecondaryConnections.
				 */</comment>
				<expr_stmt><expr><name><name>placementConnection</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>connection</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>placementConnection</name><operator>-&gt;</operator><name>userName</name></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
																	<argument><expr><name>userName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDDL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDML</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* record association with connection */</comment>
				<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>referencedPlacements</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>placementConnection</name><operator>-&gt;</operator><name>connectionNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * There are now multiple connections that read from the placement
			 * and DDL commands are forbidden.
			 */</comment>
			<expr_stmt><expr><name><name>placementEntry</name><operator>-&gt;</operator><name>hasSecondaryConnections</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>placementEntry</name><operator>-&gt;</operator><name>colocatedEntry</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we also remember this for co-located placements */</comment>
				<expr_stmt><expr><name><name>placementEntry</name><operator>-&gt;</operator><name>colocatedEntry</name><operator>-&gt;</operator><name>hasSecondaryConnections</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Remember that we used the current connection for writes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>accessType</name> <operator>==</operator> <name>PLACEMENT_ACCESS_DDL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDDL</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>accessType</name> <operator>==</operator> <name>PLACEMENT_ACCESS_DML</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDML</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* record the relation access */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationIdForShard</name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>RecordRelationAccessIfNonDistTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetConnectionIfPlacementAccessedInXact returns the connection over which
 * the placement has been access in the transaction. If not found, returns
 * NULL.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>GetConnectionIfPlacementAccessedInXact</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementAccessList</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>freeUserName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>userName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>userName</name> <operator>=</operator> <name>freeUserName</name> <operator>=</operator> <call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>FindPlacementListConnection</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>placementAccessList</name></expr></argument>,
															  <argument><expr><name>userName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>freeUserName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>freeUserName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindPlacementListConnection determines whether there is a connection that must
 * be used to perform the given placement accesses.
 *
 * If a placement was only read in this transaction, then the same connection must
 * be used for DDL to prevent self-deadlock. If a placement was modified in this
 * transaction, then the same connection must be used for all subsequent accesses
 * to ensure read-your-writes consistency and prevent self-deadlock. If those
 * conditions cannot be met, because a connection is in use or the placements in
 * the placement access list were modified over multiple connections, then this
 * function throws an error.
 *
 * The function returns the connection that needs to be used, if such a connection
 * exists.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiConnection</name> <modifier>*</modifier></type>
<name>FindPlacementListConnection</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementAccessList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundModifyingConnection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>chosenConnection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Go through all placement accesses to find a suitable connection.
	 *
	 * If none of the placements have been accessed in this transaction, connection
	 * remains NULL.
	 *
	 * If one or more of the placements have been modified in this transaction, then
	 * use the connection that performed the write. If placements have been written
	 * over multiple connections or the connection is not available, error out.
	 *
	 * If placements have only been read in this transaction, then use the last
	 * suitable connection found for a placement in the placementAccessList.
	 */</comment>
	<decl_stmt><decl><type><name>ShardPlacementAccess</name> <modifier>*</modifier></type><name>placementAccess</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>placementAccess</argument>, <argument>placementAccessList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><name><name>placementAccess</name><operator>-&gt;</operator><name>placement</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardPlacementAccessType</name></type> <name>accessType</name> <init>= <expr><name><name>placementAccess</name><operator>-&gt;</operator><name>accessType</name></name></expr></init></decl>;</decl_stmt>


		<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name> <operator>==</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When a SELECT prunes down to 0 shard, we use a dummy placement.
			 * In that case, we can fall back to the default connection.
			 *
			 * FIXME: this can be removed if we evaluate empty SELECTs locally.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ConnectionPlacementHashEntry</name> <modifier>*</modifier></type><name>placementEntry</name> <init>= <expr><call><name>FindOrCreatePlacementEntry</name><argument_list>(
			<argument><expr><name>placement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColocatedPlacementsHashEntry</name> <modifier>*</modifier></type><name>colocatedEntry</name> <init>= <expr><name><name>placementEntry</name><operator>-&gt;</operator><name>colocatedEntry</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>placementConnection</name> <init>= <expr><name><name>placementEntry</name><operator>-&gt;</operator><name>primaryConnection</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* note: the Asserts below are primarily for clarifying the conditions */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>placementConnection</name><operator>-&gt;</operator><name>connection</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no connection has been chosen for the placement */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>accessType</name> <operator>==</operator> <name>PLACEMENT_ACCESS_DDL</name> <operator>&amp;&amp;</operator>
				 <name><name>placementEntry</name><operator>-&gt;</operator><name>hasSecondaryConnections</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If a placement has been read over multiple connections (typically as
			 * a result of a reference table join) then a DDL command on the placement
			 * would create a self-deadlock.
			 */</comment>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>placementConnection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform DDL on placement "</literal> <name>UINT64_FORMAT</name>
							<literal type="string">", which has been read over multiple connections"</literal></expr></argument>,
							<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>accessType</name> <operator>==</operator> <name>PLACEMENT_ACCESS_DDL</name> <operator>&amp;&amp;</operator> <name>colocatedEntry</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				 <name><name>colocatedEntry</name><operator>-&gt;</operator><name>hasSecondaryConnections</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If a placement has been read over multiple (uncommitted) connections
			 * then a DDL command on a co-located placement may create a self-deadlock
			 * if there exist some relationship between the co-located placements
			 * (e.g. foreign key, partitioning).
			 */</comment>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>placementConnection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform DDL on placement "</literal> <name>UINT64_FORMAT</name>
							<literal type="string">" since a co-located placement has been read over multiple connections"</literal></expr></argument>,
							<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>foundModifyingConnection</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We already found a connection that performed writes on of the placements
			 * and must use it.
			 */</comment>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDDL</name></name> <operator>||</operator> <name><name>placementConnection</name><operator>-&gt;</operator><name>hadDML</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
				<name><name>placementConnection</name><operator>-&gt;</operator><name>connection</name></name> <operator>!=</operator> <name>chosenConnection</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The current placement may have been modified over a different
				 * connection. Neither connection is guaranteed to see all uncomitted
				 * writes and therefore we cannot proceed.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform query with placements that were "</literal>
								<literal type="string">"modified over multiple connections"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>accessType</name> <operator>==</operator> <name>PLACEMENT_ACCESS_SELECT</name> <operator>&amp;&amp;</operator>
				 <name><name>placementEntry</name><operator>-&gt;</operator><name>hasSecondaryConnections</name></name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDDL</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDML</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Two separate connections have already selected from this placement
			 * and it was not modified. There is no benefit to using this connection.
			 */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>CanUseExistingConnection</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>userName</name></expr></argument>, <argument><expr><name>placementConnection</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * There is an existing connection for the placement and we can use it.
			 */</comment>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>placementConnection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>chosenConnection</name> <operator>=</operator> <name><name>placementConnection</name><operator>-&gt;</operator><name>connection</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDDL</name></name> <operator>||</operator> <name><name>placementConnection</name><operator>-&gt;</operator><name>hadDML</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* this connection performed writes, we must use it */</comment>
				<expr_stmt><expr><name>foundModifyingConnection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>placementConnection</name><operator>-&gt;</operator><name>hadDDL</name></name> <operator>||</operator> <name><name>placementConnection</name><operator>-&gt;</operator><name>hadDML</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>placementConnection</name><operator>-&gt;</operator><name>userName</name></name></expr></argument>, <argument><expr><name>userName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform query on placements that were "</literal>
								<literal type="string">"modified in this transaction by a different "</literal>
								<literal type="string">"user"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform query, because modifications were "</literal>
							<literal type="string">"made over a connection that cannot be used at "</literal>
							<literal type="string">"this time. This is most likely a Citus bug so "</literal>
							<literal type="string">"please report it"</literal></expr></argument>
							)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>chosenConnection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindOrCreatePlacementEntry finds a placement entry in either the
 * placement-&gt;connection hash or the co-located placements-&gt;connection hash,
 * or adds a new entry if the placement has not yet been accessed in the
 * current transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>ConnectionPlacementHashEntry</name> <modifier>*</modifier></type>
<name>FindOrCreatePlacementEntry</name><parameter_list>(<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnectionPlacementHashKey</name></type> <name>connKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>connKey</name><operator>.</operator><name>placementId</name></name> <operator>=</operator> <name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ConnectionPlacementHashEntry</name> <modifier>*</modifier></type><name>placementEntry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ConnectionPlacementHash</name></expr></argument>,
															   <argument><expr><operator>&amp;</operator><name>connKey</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
															   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no connection has been chosen for this placement */</comment>
		<expr_stmt><expr><name><name>placementEntry</name><operator>-&gt;</operator><name>failed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementEntry</name><operator>-&gt;</operator><name>primaryConnection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementEntry</name><operator>-&gt;</operator><name>hasSecondaryConnections</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementEntry</name><operator>-&gt;</operator><name>colocatedEntry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>||</operator>
			<name><name>placement</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColocatedPlacementsHashKey</name></type> <name>coloKey</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>coloKey</name><operator>.</operator><name>nodeId</name></name> <operator>=</operator> <name><name>placement</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coloKey</name><operator>.</operator><name>colocationGroupId</name></name> <operator>=</operator> <name><name>placement</name><operator>-&gt;</operator><name>colocationGroupId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coloKey</name><operator>.</operator><name>representativeValue</name></name> <operator>=</operator> <name><name>placement</name><operator>-&gt;</operator><name>representativeValue</name></name></expr>;</expr_stmt>

			<comment type="block">/* look for a connection assigned to co-located placements */</comment>
			<decl_stmt><decl><type><name>ColocatedPlacementsHashEntry</name> <modifier>*</modifier></type><name>colocatedEntry</name> <init>= <expr><call><name>hash_search</name><argument_list>(
				<argument><expr><name>ColocatedPlacementsHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coloKey</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>,
				<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>conRef</name> <init>= <expr><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
													  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionReference</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>connectionReference</name> <init>= <expr><operator>(</operator><name>ConnectionReference</name> <operator>*</operator><operator>)</operator> <name>conRef</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Store the co-location group information such that we can later
				 * determine whether a connection accessed different placements
				 * of the same co-location group.
				 */</comment>
				<expr_stmt><expr><name><name>connectionReference</name><operator>-&gt;</operator><name>colocationGroupId</name></name> <operator>=</operator> <name><name>placement</name><operator>-&gt;</operator><name>colocationGroupId</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>connectionReference</name><operator>-&gt;</operator><name>representativeValue</name></name> <operator>=</operator> <name><name>placement</name><operator>-&gt;</operator><name>representativeValue</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Create a connection reference that can be used for the entire
				 * set of co-located placements.
				 */</comment>
				<expr_stmt><expr><name><name>colocatedEntry</name><operator>-&gt;</operator><name>primaryConnection</name></name> <operator>=</operator> <name>connectionReference</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>colocatedEntry</name><operator>-&gt;</operator><name>hasSecondaryConnections</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Assign the connection reference for the set of co-located placements
			 * to the current placement.
			 */</comment>
			<expr_stmt><expr><name><name>placementEntry</name><operator>-&gt;</operator><name>primaryConnection</name></name> <operator>=</operator> <name><name>colocatedEntry</name><operator>-&gt;</operator><name>primaryConnection</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>placementEntry</name><operator>-&gt;</operator><name>colocatedEntry</name></name> <operator>=</operator> <name>colocatedEntry</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>conRef</name> <init>= <expr><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
												  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionReference</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>placementEntry</name><operator>-&gt;</operator><name>primaryConnection</name></name> <operator>=</operator> <operator>(</operator><name>ConnectionReference</name> <operator>*</operator><operator>)</operator> <name>conRef</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* record association with shard, for invalidation */</comment>
	<expr_stmt><expr><call><name>AssociatePlacementWithShard</name><argument_list>(<argument><expr><name>placementEntry</name></expr></argument>, <argument><expr><name>placement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>placementEntry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CanUseExistingConnection is a helper function for CheckExistingConnections()
 * that checks whether an existing connection can be reused.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CanUseExistingConnection</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name></decl></parameter>,
						 <parameter><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>connectionReference</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>connectionReference</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>connection</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if already closed connection obviously not usable */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>claimedExclusively</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* already used */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FORCE_NEW_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no connection reuse desired */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>connectionReference</name><operator>-&gt;</operator><name>userName</name></name></expr></argument>, <argument><expr><name>userName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection for different user, check for conflict */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ConnectionAccessedDifferentPlacement returns true if the connection accessed another
 * placement in the same colocation group with a different representative value,
 * meaning it's not strictly colocated.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ConnectionAccessedDifferentPlacement</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
									 <parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>placementIter</name></decl>;</decl_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>placementIter</argument>, <argument>&amp;connection-&gt;referencedPlacements</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>connectionReference</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ConnectionReference</name></expr></argument>, <argument><expr><name>connectionNode</name></expr></argument>, <argument><expr><name><name>placementIter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* handle append and range distributed tables */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>!=</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>&amp;&amp;</operator>
			<name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name> <operator>!=</operator> <name><name>connectionReference</name><operator>-&gt;</operator><name>placementId</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* handle hash distributed tables */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>colocationGroupId</name></name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name> <operator>&amp;&amp;</operator>
			<name><name>placement</name><operator>-&gt;</operator><name>colocationGroupId</name></name> <operator>==</operator> <name><name>connectionReference</name><operator>-&gt;</operator><name>colocationGroupId</name></name> <operator>&amp;&amp;</operator>
			<name><name>placement</name><operator>-&gt;</operator><name>representativeValue</name></name> <operator>!=</operator> <name><name>connectionReference</name><operator>-&gt;</operator><name>representativeValue</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* non-co-located placements from the same co-location group */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConnectionModifiedPlacement returns true if any DML or DDL is executed over
 * the connection on any placement/table.
 */</comment>
<function><type><name>bool</name></type>
<name>ConnectionModifiedPlacement</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>placementIter</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name><operator>.</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When StartPlacementListConnection() is called, we set the
		 * hadDDL/hadDML even before the actual command is sent to
		 * remote nodes. And, if this function is called at that
		 * point, we should not assume that the connection has already
		 * done any modifications.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>referencedPlacements</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When referencesPlacements are empty, it means that we come here
		 * from an API that uses a node connection (e.g., not placement connection),
		 * which doesn't set placements.
		 * In that case, the command sent could be either write or read, so we assume
		 * it is write to be on the safe side.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>placementIter</argument>, <argument>&amp;connection-&gt;referencedPlacements</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>connectionReference</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ConnectionReference</name></expr></argument>, <argument><expr><name>connectionNode</name></expr></argument>, <argument><expr><name><name>placementIter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connectionReference</name><operator>-&gt;</operator><name>hadDDL</name></name> <operator>||</operator> <name><name>connectionReference</name><operator>-&gt;</operator><name>hadDML</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssociatePlacementWithShard records shard-&gt;placement relation in
 * ConnectionShardHash.
 *
 * That association is later used, in CheckForFailedPlacements, to invalidate
 * shard placements if necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AssociatePlacementWithShard</name><parameter_list>(<parameter><decl><type><name>ConnectionPlacementHashEntry</name> <modifier>*</modifier></type><name>placementEntry</name></decl></parameter>,
							<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnectionShardHashKey</name></type> <name>shardKey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>placementIter</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>shardKey</name><operator>.</operator><name>shardId</name></name> <operator>=</operator> <name><name>placement</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ConnectionShardHashEntry</name> <modifier>*</modifier></type><name>shardEntry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ConnectionShardHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardKey</name></expr></argument>,
													   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardEntry</name><operator>-&gt;</operator><name>placementConnections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if placement is already associated with shard (happens if there's
	 * multiple connections for a placement).  There'll usually only be few
	 * placement per shard, so the price of iterating isn't large.
	 */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>placementIter</argument>, <argument>&amp;shardEntry-&gt;placementConnections</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConnectionPlacementHashEntry</name> <modifier>*</modifier></type><name>currPlacementEntry</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ConnectionPlacementHashEntry</name></expr></argument>, <argument><expr><name>shardNode</name></expr></argument>, <argument><expr><name><name>placementIter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currPlacementEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>placementId</name></name> <operator>==</operator> <name><name>placement</name><operator>-&gt;</operator><name>placementId</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* otherwise add */</comment>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardEntry</name><operator>-&gt;</operator><name>placementConnections</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>placementEntry</name><operator>-&gt;</operator><name>shardNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CloseShardPlacementAssociation handles a connection being closed before
 * transaction end.
 *
 * This should only be called by connection_management.c.
 */</comment>
<function><type><name>void</name></type>
<name>CloseShardPlacementAssociation</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>MultiConnection</name></name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>placementIter</name></decl>;</decl_stmt>

	<comment type="block">/* set connection to NULL for all references to the connection */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>placementIter</argument>, <argument>&amp;connection-&gt;referencedPlacements</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>reference</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ConnectionReference</name></expr></argument>, <argument><expr><name>connectionNode</name></expr></argument>, <argument><expr><name><name>placementIter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>reference</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that we don't reset ConnectionPlacementHashEntry's
		 * primaryConnection here, that'd be more complicated than it seems
		 * worth.  That means we'll error out spuriously if a DML/DDL
		 * executing connection is closed earlier in a transaction.
		 */</comment>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ResetShardPlacementAssociation resets the association of connections to
 * shard placements at the end of a transaction.
 *
 * This should only be called by connection_management.c.
 */</comment>
<function><type><name>void</name></type>
<name>ResetShardPlacementAssociation</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>MultiConnection</name></name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>referencedPlacements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ResetPlacementConnectionManagement() disassociates connections from
 * placements and shards. This will be called at the end of XACT_EVENT_COMMIT
 * and XACT_EVENT_ABORT.
 */</comment>
<function><type><name>void</name></type>
<name>ResetPlacementConnectionManagement</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Simply delete all entries */</comment>
	<expr_stmt><expr><call><name>hash_delete_all</name><argument_list>(<argument><expr><name>ConnectionPlacementHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_delete_all</name><argument_list>(<argument><expr><name>ConnectionShardHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_delete_all</name><argument_list>(<argument><expr><name>ColocatedPlacementsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * NB: memory for ConnectionReference structs and subordinate data is
	 * deleted by virtue of being allocated in TopTransactionContext.
	 */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfPostCommitFailedShardPlacements throws an error if any of the placements
 * that modified the database and involved in the transaction has failed.
 *
 * Note that Citus already fails queries/commands in case of any failures during query
 * processing. However, there are certain failures that can only be detected on the
 * COMMIT time. And, this check mainly ensures to catch errors that happens on the
 * COMMIT time on the placements.
 *
 * The most common example for this case is the deferred errors that are thrown by
 * triggers or constraints at the COMMIT time.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfPostCommitFailedShardPlacements</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionShardHashEntry</name> <modifier>*</modifier></type><name>shardEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>ConnectionShardHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>shardEntry</name> <operator>=</operator> <operator>(</operator><name>ConnectionShardHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>HasModificationFailedForShard</name><argument_list>(<argument><expr><name>shardEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not commit transaction for shard "</literal> <name>INT64_FORMAT</name>
							<literal type="string">" on at least one active node"</literal></expr></argument>, <argument><expr><name><name>shardEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>shardId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * HasModificationFailedForShard is a helper function for
 * ErrorIfPostCommitFailedShardPlacements that performs the per-shard work.
 *
 * The function returns true if any placement of the input shard is modified
 * and any failures has happened (either connection failures or transaction
 * failures).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasModificationFailedForShard</name><parameter_list>(<parameter><decl><type><name>ConnectionShardHashEntry</name> <modifier>*</modifier></type><name>shardEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>placementIter</name></decl>;</decl_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>placementIter</argument>, <argument>&amp;shardEntry-&gt;placementConnections</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConnectionPlacementHashEntry</name> <modifier>*</modifier></type><name>placementEntry</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>ConnectionPlacementHashEntry</name></expr></argument>, <argument><expr><name>shardNode</name></expr></argument>, <argument><expr><name><name>placementIter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ConnectionReference</name> <modifier>*</modifier></type><name>primaryConnection</name> <init>= <expr><name><name>placementEntry</name><operator>-&gt;</operator><name>primaryConnection</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we only consider shards that are modified */</comment>
		<if_stmt><if>if <condition>(<expr><name>primaryConnection</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<operator>!</operator><operator>(</operator><name><name>primaryConnection</name><operator>-&gt;</operator><name>hadDDL</name></name> <operator>||</operator> <name><name>primaryConnection</name><operator>-&gt;</operator><name>hadDML</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>primaryConnection</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>connection</name> <operator>||</operator> <name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name><operator>.</operator><name>transactionFailed</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InitPlacementConnectionManagement performs initialization of the
 * infrastructure in this file at server start.
 */</comment>
<function><type><name>void</name></type>
<name>InitPlacementConnectionManagement</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>

	<comment type="block">/* create (placementId) -&gt; [ConnectionReference] hash */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionPlacementHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionPlacementHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>ConnectionContext</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ConnectionPlacementHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"citus connection cache (placementid)"</literal></expr></argument>,
										  <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create (colocated placement identity) -&gt; [ConnectionReference] hash */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColocatedPlacementsHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColocatedPlacementsHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>ColocatedPlacementsHashHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>ColocatedPlacementsHashCompare</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>ConnectionContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashFlags</name> <operator>=</operator> <operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_COMPARE</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>ColocatedPlacementsHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"citus connection cache (colocated placements)"</literal></expr></argument>,
										  <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create (shardId) -&gt; [ConnectionShardHashEntry] hash */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionShardHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionShardHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>ConnectionContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashFlags</name> <operator>=</operator> <operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>ConnectionShardHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"citus connection cache (shardid)"</literal></expr></argument>,
									  <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UseConnectionPerPlacement returns whether we should use as separate connection
 * per placement even if another connection is idle. We mostly use this in testing
 * scenarios.
 */</comment>
<function><type><name>bool</name></type>
<name>UseConnectionPerPlacement</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>ForceMaxQueryParallelization</name> <operator>&amp;&amp;</operator>
		   <name>MultiShardConnectionType</name> <operator>!=</operator> <name>SEQUENTIAL_CONNECTION</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>ColocatedPlacementsHashHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColocatedPlacementsHashKey</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>ColocatedPlacementsHashKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>hash</name> <init>= <expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>colocationGroupId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>representativeValue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>ColocatedPlacementsHashCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColocatedPlacementsHashKey</name> <modifier>*</modifier></type><name>ca</name> <init>= <expr><operator>(</operator><name>ColocatedPlacementsHashKey</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColocatedPlacementsHashKey</name> <modifier>*</modifier></type><name>cb</name> <init>= <expr><operator>(</operator><name>ColocatedPlacementsHashKey</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ca</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>!=</operator> <name><name>cb</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>||</operator>
		<name><name>ca</name><operator>-&gt;</operator><name>colocationGroupId</name></name> <operator>!=</operator> <name><name>cb</name><operator>-&gt;</operator><name>colocationGroupId</name></name> <operator>||</operator>
		<name><name>ca</name><operator>-&gt;</operator><name>representativeValue</name></name> <operator>!=</operator> <name><name>cb</name><operator>-&gt;</operator><name>representativeValue</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
