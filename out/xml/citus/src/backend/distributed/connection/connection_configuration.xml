<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/connection/connection_configuration.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * connection_configuration.c
 *   Functions for controlling configuration of Citus connections
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_result_pruning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<comment type="block">/* stores the string representation of our node connection GUC */</comment>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>NodeConninfo</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>LocalHostName</name> <init>= <expr><literal type="string">"localhost"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* represents a list of libpq parameter settings */</comment>
<typedef>typedef <type><struct>struct <name>ConnParamsInfo</name>
<block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl>;</decl_stmt> <comment type="block">/* libpq keywords */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt> <comment type="block">/* desired values for above */</comment>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name></decl>;</decl_stmt> <comment type="block">/* current used size of arrays */</comment>
	<decl_stmt><decl><type><name>Size</name></type> <name>maxSize</name></decl>;</decl_stmt> <comment type="block">/* maximum allocated size of arrays (similar to e.g. StringInfo) */</comment>
}</block></struct></type> <name>ConnParamsInfo</name>;</typedef>

<comment type="block">/*
 * Stores parsed global libpq parameter settings. static because all access
 * is encapsulated in the other public functions in this file.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ConnParamsInfo</name></type> <name>ConnParams</name></decl>;</decl_stmt>

<comment type="block">/* helper functions for processing connection info */</comment>
<function_decl><type><specifier>static</specifier> <name>ConnectionHashKey</name> <modifier>*</modifier></type> <name>GetEffectiveConnKey</name><parameter_list>(<parameter><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>CalculateMaxSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>uri_prefix_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * InitConnParams initializes the ConnParams field to point to enough memory to
 * store settings for every valid libpq value, though these regions are set to
 * zeros from the outset and the size appropriately also set to zero.
 *
 * This function must be called before others in this file, though calling it
 * after use of the initialized ConnParams structure will result in any
 * populated parameter settings being lost.
 */</comment>
<function><type><name>void</name></type>
<name>InitConnParams</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>maxSize</name> <init>= <expr><call><name>CalculateMaxSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnParamsInfo</name></type> <name>connParams</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>keywords</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>maxSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>values</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>maxSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>,
		<expr><operator>.</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>,
		<expr><operator>.</operator><name>maxSize</name> <operator>=</operator> <name>maxSize</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>connParams</name><operator>.</operator><name>keywords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>maxSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>connParams</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>maxSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ConnParams</name> <operator>=</operator> <name>connParams</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ResetConnParams frees all strings in the keywords and parameters arrays,
 * sets their elements to null, and resets the ConnParamsSize to zero before
 * adding back any hardcoded global connection settings (at present, there
 * are no).
 */</comment>
<function><type><name>void</name></type>
<name>ResetConnParams</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>Size</name></type> <name>paramIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>paramIdx</name> <operator>&lt;</operator> <name><name>ConnParams</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>paramIdx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>ConnParams</name><operator>.</operator><name>keywords</name><index>[<expr><name>paramIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>ConnParams</name><operator>.</operator><name>values</name><index>[<expr><name>paramIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ConnParams</name><operator>.</operator><name>keywords</name><index>[<expr><name>paramIdx</name></expr>]</index></name> <operator>=</operator> <name><name>ConnParams</name><operator>.</operator><name>values</name><index>[<expr><name>paramIdx</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InvalidateConnParamsHashEntries</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AddConnParam adds a parameter setting to the global libpq settings according
 * to the provided keyword and value.
 */</comment>
<function><type><name>void</name></type>
<name>AddConnParam</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>ConnParams</name><operator>.</operator><name>maxSize</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* hopefully this error is only seen by developers */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ConnParams arrays bound check failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ConnParams</name><operator>.</operator><name>keywords</name><index>[<expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConnParams</name><operator>.</operator><name>values</name><index>[<expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ConnParams</name><operator>.</operator><name>keywords</name><index>[<expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name></expr>]</index></name> <operator>=</operator> <name><name>ConnParams</name><operator>.</operator><name>values</name><index>[<expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CheckConninfo is a building block to help implement check constraints and
 * other check hooks against libpq-like conninfo strings. In particular, the
 * provided conninfo must:
 *
 *   - Not use a uri-prefix such as postgres:// (it must be only keys and values)
 *   - Parse using PQconninfoParse
 *   - Only set keywords contained in the provided allowedConninfoKeywords
 *
 * This function returns true if all of the above are satisfied, otherwise it
 * returns false. If the provided errmsg pointer is not NULL, it will be set
 * to an appropriate message if the check fails.
 *
 * The provided allowedConninfoKeywords must be sorted in a manner usable by bsearch,
 * though this is only validated during assert-enabled builds.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckConninfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conninfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>allowedConninfoKeywords</name></decl></parameter>,
			  <parameter><decl><type><name>Size</name></type> <name>allowedConninfoKeywordsLength</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errorMsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errorMsgString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the user doesn't need a message, just overwrite errmsg with a stack
	 * variable so we can always safely write to it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>errorMsg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errorMsg</name> <operator>=</operator> <operator>&amp;</operator><name>errorMsgString</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* sure, it can be null */</comment>
	<if_stmt><if>if <condition>(<expr><name>conninfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* the libpq prefix form is more complex than we need; ban it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>uri_prefix_length</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>errorMsg</name> <operator>=</operator> <literal type="string">"Citus connection info strings must be in "</literal>
					<literal type="string">"'k1=v1 k2=v2 [...] kn=vn' format"</literal></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* this should at least parse */</comment>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>optionArray</name> <init>= <expr><call><name>PQconninfoParse</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>optionArray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>errorMsg</name> <operator>=</operator> <literal type="string">"Provided string is not a valid libpq connection info string"</literal></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>

	<comment type="block">/* verify that the allowedConninfoKeywords is in ascending order */</comment>
	<for>for <control>(<init><decl><type><name>Size</name></type> <name>keywordIdx</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>keywordIdx</name> <operator>&lt;</operator> <name>allowedConninfoKeywordsLength</name></expr>;</condition> <incr><expr><name>keywordIdx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>allowedConninfoKeywords</name><index>[<expr><name>keywordIdx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curr</name> <init>= <expr><name><name>allowedConninfoKeywords</name><index>[<expr><name>keywordIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<for>for <control>(<init><expr><name>option</name> <operator>=</operator> <name>optionArray</name></expr>;</init> <condition><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>option</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>option</name><operator>-&gt;</operator><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>matchingKeyword</name> <init>= <expr><call><name>SafeBsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><name>allowedConninfoKeywords</name></expr></argument>,
											<argument><expr><name>allowedConninfoKeywordsLength</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
											<argument><expr><name>pg_qsort_strcmp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>matchingKeyword</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* the allowedConninfoKeywords lacks this keyword; error out! */</comment>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>msgString</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgString</name></expr></argument>, <argument><expr><literal type="string">"Prohibited conninfo keyword detected: %s"</literal></expr></argument>,
							 <argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>errorMsg</name> <operator>=</operator> <name><name>msgString</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>optionArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if error message is set we found an invalid keyword */</comment>
	<return>return <expr><operator>(</operator><operator>*</operator><name>errorMsg</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetConnParams uses the provided key to determine libpq parameters needed to
 * establish a connection using that key. The keywords and values are placed in
 * the like-named out parameters. All parameter strings are allocated in the
 * context provided by the caller, to save the caller needing to copy strings
 * into an appropriate context later.
 */</comment>
<function><type><name>void</name></type>
<name>GetConnParams</name><parameter_list>(<parameter><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>keywords</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>,
			  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>runtimeParamStart</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * make space for the port as a string: sign, 10 digits, NUL. We keep it on the stack
	 * till we can later copy it to the right context. By having the declaration here
	 * already we can add a pointer to the runtimeValues.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>nodePortString</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>effectiveKey</name> <init>= <expr><call><name>GetEffectiveConnKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>applicationName</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>applicationName</name></expr></argument>, <argument><expr><literal type="string">"%s%ld"</literal></expr></argument>, <argument><expr><name>CITUS_APPLICATION_NAME_PREFIX</name></expr></argument>,
					 <argument><expr><call><name>GetGlobalPID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This function has three sections:
	 *   - Initialize the keywords and values (to be copied later) of global parameters
	 *   - Append user/host-specific parameters calculated from the given key
	 *   - (Enterprise-only) append user/host-specific authentication params
	 *
	 * The global parameters have already been assigned from a GUC, so begin by
	 * calculating the key-specific parameters (basically just the fields of
	 * the key and the active database encoding).
	 *
	 * We allocate everything in the provided context so as to facilitate using
	 * pfree on all runtime parameters when connections using these entries are
	 * invalidated during config reloads.
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>runtimeKeywords</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"host"</literal></expr>,
		<expr><literal type="string">"port"</literal></expr>,
		<expr><literal type="string">"dbname"</literal></expr>,
		<expr><literal type="string">"user"</literal></expr>,
		<expr><literal type="string">"client_encoding"</literal></expr>,
		<expr><literal type="string">"application_name"</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>runtimeValues</name><index>[]</index></name> <init>= <expr><block>{
		<expr><name><name>effectiveKey</name><operator>-&gt;</operator><name>hostname</name></name></expr>,
		<expr><name>nodePortString</name></expr>,
		<expr><name><name>effectiveKey</name><operator>-&gt;</operator><name>database</name></name></expr>,
		<expr><name><name>effectiveKey</name><operator>-&gt;</operator><name>user</name></name></expr>,
		<expr><call><name>GetDatabaseEncodingName</name><argument_list>()</argument_list></call></expr>,
		<expr><name><name>applicationName</name><operator>-&gt;</operator><name>data</name></name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * remember where global/GUC params end and runtime ones start, all entries after this
	 * point should be allocated in context and will be freed upon
	 * FreeConnParamsHashEntryFields
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>runtimeParamStart</name> <operator>=</operator> <name><name>ConnParams</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Declare local params for readability;
	 *
	 * assignment is done directly to not lose the pointers if any of the later
	 * allocations cause an error. FreeConnParamsHashEntryFields knows about the
	 * possibility of half initialized keywords or values and correctly reclaims them when
	 * the cache is reused.
	 *
	 * Need to zero enough space for all possible libpq parameters.
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>connKeywords</name> <init>= <expr><operator>*</operator><name>keywords</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>ConnParams</name><operator>.</operator><name>maxSize</name></name> <operator>*</operator>
															 <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>connValues</name> <init>= <expr><operator>*</operator><name>values</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>ConnParams</name><operator>.</operator><name>maxSize</name></name> <operator>*</operator>
														 <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* auth keywords will begin after global and runtime ones are appended */</comment>
	<decl_stmt><decl><type><name>Index</name></type> <name>authParamsIdx</name> <init>= <expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name> <operator>+</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>runtimeKeywords</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name> <operator>+</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>runtimeKeywords</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>ConnParams</name><operator>.</operator><name>maxSize</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* hopefully this error is only seen by developers */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many connParams entries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pg_ltoa</name><argument_list>(<argument><expr><name><name>effectiveKey</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>nodePortString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* populate node port string with port */</comment>

	<comment type="block">/* first step: copy global parameters to beginning of array */</comment>
	<for>for <control>(<init><decl><type><name>Size</name></type> <name>paramIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>paramIndex</name> <operator>&lt;</operator> <name><name>ConnParams</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>paramIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* copy the keyword&amp;value pointers to the new array */</comment>
		<expr_stmt><expr><name><name>connKeywords</name><index>[<expr><name>paramIndex</name></expr>]</index></name> <operator>=</operator> <name><name>ConnParams</name><operator>.</operator><name>keywords</name><index>[<expr><name>paramIndex</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>connValues</name><index>[<expr><name>paramIndex</name></expr>]</index></name> <operator>=</operator> <name><name>ConnParams</name><operator>.</operator><name>values</name><index>[<expr><name>paramIndex</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* second step: begin after global params and copy runtime params into our context */</comment>
	<for>for <control>(<init><decl><type><name>Index</name></type> <name>runtimeParamIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init>
		 <condition><expr><name>runtimeParamIndex</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>runtimeKeywords</name></expr></argument>)</argument_list></call></expr>;</condition>
		 <incr><expr><name>runtimeParamIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* copy the keyword &amp; value into our context and append to the new array */</comment>
		<expr_stmt><expr><name><name>connKeywords</name><index>[<expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name> <operator>+</operator> <name>runtimeParamIndex</name></expr>]</index></name> <operator>=</operator>
			<call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>runtimeKeywords</name><index>[<expr><name>runtimeParamIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>connValues</name><index>[<expr><name><name>ConnParams</name><operator>.</operator><name>size</name></name> <operator>+</operator> <name>runtimeParamIndex</name></expr>]</index></name> <operator>=</operator>
			<call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>runtimeValues</name><index>[<expr><name>runtimeParamIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* we look up authinfo by original key, not effective one */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>authinfo</name> <init>= <expr><call><name>GetAuthinfo</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>user</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pqerr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>optionArray</name> <init>= <expr><call><name>PQconninfoParse</name><argument_list>(<argument><expr><name>authinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pqerr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>optionArray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* PQconninfoParse failed, it's unsafe to continue as this has caused segfaults in production */</comment>
		<if_stmt><if>if <condition>(<expr><name>pqerr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* parse failed without an error message, treat as OOM error  */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed to parse authentication information via libpq"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Parse error, should not be possible as the validity is checked upon insert into pg_dist_authinfo,
			 * however, better safe than sorry
			 */</comment>

			<comment type="block">/*
			 * errmsg is populated by PQconninfoParse which requires us to free the message. Since we want to
			 * incorporate the parse error into the detail of our message we need to copy the error message before
			 * freeing it. Not freeing the message will leak memory.
			 */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pqerrcopy</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>pqerr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>pqerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"failed to parse node authentication information for %s@%s:%d"</literal></expr></argument>,
								<argument><expr><name><name>key</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>pqerrcopy</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><name>optionArray</name></expr></init></decl>;</init> <condition><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>option</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>option</name><operator>-&gt;</operator><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>connKeywords</name><index>[<expr><name>authParamsIdx</name></expr>]</index></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>connValues</name><index>[<expr><name>authParamsIdx</name></expr>]</index></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>authParamsIdx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>replicationConnParam</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connKeywords</name><index>[<expr><name>authParamsIdx</name></expr>]</index></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"replication"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>connValues</name><index>[<expr><name>authParamsIdx</name></expr>]</index></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"database"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>authParamsIdx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>optionArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* final step: add terminal NULL, required by libpq */</comment>
	<expr_stmt><expr><name><name>connKeywords</name><index>[<expr><name>authParamsIdx</name></expr>]</index></name> <operator>=</operator> <name><name>connValues</name><index>[<expr><name>authParamsIdx</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetConnParam finds the keyword in the configured connection parameters and returns its
 * value.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetConnParam</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keyword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>Size</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ConnParams</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name><name>ConnParams</name><operator>.</operator><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name><name>ConnParams</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetEffectiveConnKey checks whether there is any pooler configuration for the
 * provided key (host/port combination). The one case where this logic is not
 * applied is for loopback connections originating within the task tracker. If
 * a corresponding row is found in the poolinfo table, a modified (effective)
 * key is returned with the node, port, and dbname overridden, as applicable,
 * otherwise, the original key is returned unmodified.
 */</comment>
<function><type><name>ConnectionHashKey</name> <modifier>*</modifier></type>
<name>GetEffectiveConnKey</name><parameter_list>(<parameter><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>optionArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we're in the task tracker, so should only see loopback */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name>LOCAL_HOST_NAME</name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			   <name>PostPortNumber</name> <operator>==</operator> <name><name>key</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>key</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>worker</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this can be hit when the key references an unknown node */</comment>
		<return>return <expr><name>key</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>poolinfo</name> <init>= <expr><call><name>GetPoolinfoViaCatalog</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>poolinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>key</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy the key to provide defaults for all fields */</comment>
	<decl_stmt><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>effectiveKey</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionHashKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>effectiveKey</name> <operator>=</operator> <operator>*</operator><name>key</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>optionArray</name> <operator>=</operator> <call><name>PQconninfoParse</name><argument_list>(<argument><expr><name>poolinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>option</name> <operator>=</operator> <name>optionArray</name></expr>;</init> <condition><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>option</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>option</name><operator>-&gt;</operator><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"host"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>effectiveKey</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"port"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>effectiveKey</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>pg_strtoint32</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name></expr></argument>, <argument><expr><literal type="string">"dbname"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* permit dbname for poolers which can key pools based on dbname */</comment>
			<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>effectiveKey</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name><name>option</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized poolinfo keyword"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>optionArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>effectiveKey</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAuthinfo simply returns the string representation of authentication info
 * for a specified hostname/port/user combination. If the current transaction
 * is valid, then we use the catalog, otherwise a shared memory hash is used,
 * a mode that is currently only useful for getting authentication information
 * to the Task Tracker, which lacks a database connection and transaction.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetAuthinfo</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>authinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isLoopback</name> <init>= <expr><operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>LOCAL_HOST_NAME</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					   <name>PostPortNumber</name> <operator>==</operator> <name>port</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>nodeId</name> <init>= <expr><name>WILDCARD_NODE_ID</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* -1 is a special value for loopback connections (task tracker) */</comment>
		<if_stmt><if>if <condition>(<expr><name>isLoopback</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nodeId</name> <operator>=</operator> <name>LOCALHOST_NODE_ID</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>worker</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>worker</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nodeId</name> <operator>=</operator> <name><name>worker</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>authinfo</name> <operator>=</operator> <call><name>GetAuthinfoViaCatalog</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name>authinfo</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>authinfo</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CalculateMaxSize simply counts the number of elements returned by
 * PQconnDefaults, including the final NULL. This helps us know how space would
 * be used if a connection utilizes every known libpq parameter.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>CalculateMaxSize</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>defaults</name> <init>= <expr><call><name>PQconndefaults</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>maxSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>PQconninfoOption</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><name>defaults</name></expr></init></decl>;</init>
		 <condition><expr><name><name>option</name><operator>-&gt;</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>option</name><operator>++</operator></expr><operator>,</operator> <expr><name>maxSize</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* do nothing, we're just counting the elements */</comment>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PQconninfoFree</name><argument_list>(<argument><expr><name>defaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we've counted elements but libpq needs a final NULL, so add one */</comment>
	<expr_stmt><expr><name>maxSize</name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>maxSize</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* *INDENT-OFF* */</comment>

<comment type="block">/*
 * Checks if connection string starts with either of the valid URI prefix
 * designators.
 *
 * Returns the URI prefix length, 0 if the string doesn't contain a URI prefix.
 *
 * This implementation (mostly) taken from libpq/fe-connect.c.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>uri_prefix_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>uri_designator</name><index>[]</index></name> <init>= <expr><literal type="string">"postgresql://"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>short_uri_designator</name><index>[]</index></name> <init>= <expr><literal type="string">"postgres://"</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><name>uri_designator</name></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><name>short_uri_designator</name></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>short_uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>short_uri_designator</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* *INDENT-ON* */</comment>
</unit>
