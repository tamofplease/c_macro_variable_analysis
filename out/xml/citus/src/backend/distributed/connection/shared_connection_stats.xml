<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/connection/shared_connection_stats.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * shared_connection_stats.c
 *   Keeps track of the number of connections to remote nodes across
 *   backends. The primary goal is to prevent excessive number of
 *   connections (typically &gt; max_connections) to any worker node.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/cancel_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/locally_reserved_shared_connections.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/placement_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_connection_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/time_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMOTE_CONNECTION_STATS_COLUMNS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>


<comment type="block">/*
 * The data structure used to store data in shared memory. This data structure is only
 * used for storing the lock. The actual statistics about the connections are stored
 * in the hashmap, which is allocated separately, as Postgres provides different APIs
 * for allocating hashmaps in the shared memory.
 */</comment>
<typedef>typedef <type><struct>struct <name>ConnectionStatsSharedData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>sharedConnectionHashTrancheId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sharedConnectionHashTrancheName</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LWLock</name></type> <name>sharedConnectionHashLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConditionVariable</name></type> <name>waitersConditionVariable</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConnectionStatsSharedData</name>;</typedef>


<typedef>typedef <type><struct>struct <name>SharedConnStatsHashKey</name>
<block>{
	<comment type="block">/*
	 * We keep the entries in the shared memory even after master_update_node()
	 * as there might be some cached connections to the old node.
	 * That's why, we prefer to use "hostname/port" over nodeId.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>hostname</name><index>[<expr><name>MAX_NODE_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>port</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Given that citus.shared_max_pool_size can be defined per database, we
	 * should keep track of shared connections per database.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>databaseOid</name></decl>;</decl_stmt>
}</block></struct></type> <name>SharedConnStatsHashKey</name>;</typedef>

<comment type="block">/* hash entry for per worker stats */</comment>
<typedef>typedef <type><struct>struct <name>SharedConnStatsHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>SharedConnStatsHashKey</name></type> <name>key</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>connectionCount</name></decl>;</decl_stmt>
}</block></struct></type> <name>SharedConnStatsHashEntry</name>;</typedef>


<comment type="block">/*
 * Controlled via a GUC, never access directly, use GetMaxSharedPoolSize().
 *  "0" means adjust MaxSharedPoolSize automatically by using MaxConnections.
 * "-1" means do not apply connection throttling
 * Anything else means use that number
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>MaxSharedPoolSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Controlled via a GUC, never access directly, use GetLocalSharedPoolSize().
 *  "0" means adjust LocalSharedPoolSize automatically by using MaxConnections.
 * "-1" means do not use any remote connections for local tasks
 * Anything else means use that number
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>LocalSharedPoolSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* number of connections reserved for Citus */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>MaxClientConnections</name> <init>= <expr><name>ALLOW_ALL_EXTERNAL_CONNECTIONS</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* the following two structs are used for accessing shared memory */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>SharedConnStatsHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ConnectionStatsSharedData</name> <modifier>*</modifier></type><name>ConnectionStatsSharedState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>shmem_startup_hook_type</name></type> <name>prev_shmem_startup_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* local function declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreAllRemoteConnectionStats</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type>
										  <name>tupleDescriptor</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LockConnectionSharedMemory</name><parameter_list>(<parameter><decl><type><name>LWLockMode</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UnLockConnectionSharedMemory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldWaitForConnection</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>currentConnectionCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>SharedConnectionHashHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>SharedConnectionHashCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_remote_connection_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * citus_remote_connection_stats returns all the avaliable information about all
 * the remote connections (a.k.a., connections to remote nodes).
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_remote_connection_stats</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StoreAllRemoteConnectionStats</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StoreAllRemoteConnectionStats gets connections established from the current node
 * and inserts them into the given tuplestore.
 *
 * We don't need to enforce any access privileges as the number of backends
 * on any node is already visible on pg_stat_activity to all users.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreAllRemoteConnectionStats</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>REMOTE_CONNECTION_STATS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNulls</name><index>[<expr><name>REMOTE_CONNECTION_STATS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* we're reading all shared connections, prevent any changes */</comment>
	<expr_stmt><expr><call><name>LockConnectionSharedMemory</name><argument_list>(<argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedConnStatsHashEntry</name> <modifier>*</modifier></type><name>connectionEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SharedConnStatsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>connectionEntry</name> <operator>=</operator> <operator>(</operator><name>SharedConnStatsHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* get ready for the next tuple */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>databaseOid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>databaseName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* database might have been dropped */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>UnLockConnectionSharedMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetMaxClientConnections returns the value of citus.max_client_connections,
 * or max_connections when it is -1 or when connecting as superuser.
 *
 * The latter is done because citus.max_client_connections does not apply to
 * superuser.
 */</comment>
<function><type><name>int</name></type>
<name>GetMaxClientConnections</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MaxClientConnections</name> <operator>==</operator> <name>ALLOW_ALL_EXTERNAL_CONNECTIONS</name> <operator>||</operator> <call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>MaxConnections</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>MaxClientConnections</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetMaxSharedPoolSize is a wrapper around MaxSharedPoolSize which is controlled
 * via a GUC.
 *  "0" means adjust MaxSharedPoolSize automatically by using MaxConnections
 * "-1" means do not apply connection throttling
 * Anything else means use that number
 */</comment>
<function><type><name>int</name></type>
<name>GetMaxSharedPoolSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MaxSharedPoolSize</name> <operator>==</operator> <name>ADJUST_POOLSIZE_AUTOMATICALLY</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>GetMaxClientConnections</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>MaxSharedPoolSize</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetLocalSharedPoolSize is a wrapper around LocalSharedPoolSize which is
 * controlled via a GUC.
 *  "0" means adjust MaxSharedPoolSize automatically by using MaxConnections
 * "-1" means do not use any remote connections for local tasks
 * Anything else means use that number
 */</comment>
<function><type><name>int</name></type>
<name>GetLocalSharedPoolSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>LocalSharedPoolSize</name> <operator>==</operator> <name>ADJUST_POOLSIZE_AUTOMATICALLY</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>GetMaxClientConnections</name><argument_list>()</argument_list></call> <operator>*</operator> <literal type="number">0.5</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>LocalSharedPoolSize</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WaitLoopForSharedConnection tries to increment the shared connection
 * counter for the given hostname/port and the current database in
 * SharedConnStatsHash.
 *
 * The function implements a retry mechanism via a condition variable.
 */</comment>
<function><type><name>void</name></type>
<name>WaitLoopForSharedConnection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><operator>!</operator><call><name>TryToIncrementSharedConnectionCounter</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>WaitForSharedConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TryToIncrementSharedConnectionCounter tries to increment the shared
 * connection counter for the given nodeId and the current database in
 * SharedConnStatsHash.
 *
 * If the function returns true, the caller is allowed (and expected)
 * to establish a new connection to the given node. Else, the caller
 * is not allowed to establish a new connection.
 */</comment>
<function><type><name>bool</name></type>
<name>TryToIncrementSharedConnectionCounter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>GetMaxSharedPoolSize</name><argument_list>()</argument_list></call> <operator>==</operator> <name>DISABLE_CONNECTION_THROTTLING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection throttling disabled */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>counterIncremented</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedConnStatsHashKey</name></type> <name>connKey</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>connKey</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAX_NODE_LENGTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hostname exceeds the maximum length of %d"</literal></expr></argument>,
							   <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The local session might already have some reserved connections to the given
	 * node. In that case, we don't need to go through the shared memory.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>userId</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CanUseReservedConnection</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>userId</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkReservedConnectionUsed</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>userId</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>connKey</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connKey</name><operator>.</operator><name>databaseOid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Handle adaptive connection management for the local node slightly different
	 * as local node can failover to local execution.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>connectionToLocalNode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>activeBackendCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>FindWorkerNode</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>connectionToLocalNode</name> <operator>=</operator> <operator>(</operator><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <call><name>GetLocalGroupId</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>connectionToLocalNode</name> <operator>&amp;&amp;</operator>
			<call><name>GetLocalSharedPoolSize</name><argument_list>()</argument_list></call> <operator>==</operator> <name>DISABLE_REMOTE_CONNECTIONS_FOR_LOCAL_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This early return is required as LocalNodeParallelExecutionFactor
			 * is ignored for the first connection below. This check makes the
			 * user experience is more accurate and also makes it easy for
			 * having regression tests which emulates the local node adaptive
			 * connection management.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>activeBackendCount</name> <operator>=</operator> <call><name>GetExternalClientBackendCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LockConnectionSharedMemory</name><argument_list>(<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * As the hash map is  allocated in shared memory, it doesn't rely on palloc for
	 * memory allocation, so we could get NULL via HASH_ENTER_NULL when there is no
	 * space in the shared memory. That's why we prefer continuing the execution
	 * instead of throwing an error.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>entryFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedConnStatsHashEntry</name> <modifier>*</modifier></type><name>connectionEntry</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SharedConnStatsHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>connKey</name></expr></argument>, <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entryFound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * It is possible to throw an error at this point, but that doesn't help us in anyway.
	 * Instead, we try our best, let the connection establishment continue by-passing the
	 * connection throttling.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>connectionEntry</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnLockConnectionSharedMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entryFound</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we successfully allocated the entry for the first time, so initialize it */</comment>
		<expr_stmt><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>counterIncremented</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>connectionToLocalNode</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For local nodes, solely relying on citus.max_shared_pool_size or
		 * max_connections might not be sufficient. The former gives us
		 * a preview of the future (e.g., we let the new connections to establish,
		 * but they are not established yet). The latter gives us the close to
		 * precise view of the past (e.g., the active number of client backends).
		 *
		 * Overall, we want to limit both of the metrics. The former limit typically
		 * kicks in under regular loads, where the load of the database increases in
		 * a reasonable pace. The latter limit typically kicks in when the database
		 * is issued lots of concurrent sessions at the same time, such as benchmarks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>activeBackendCount</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <call><name>GetLocalSharedPoolSize</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>counterIncremented</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <call><name>GetLocalSharedPoolSize</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>counterIncremented</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>counterIncremented</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <call><name>GetMaxSharedPoolSize</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there is no space left for this connection */</comment>
		<expr_stmt><expr><name>counterIncremented</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>counterIncremented</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>UnLockConnectionSharedMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>counterIncremented</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IncrementSharedConnectionCounter increments the shared counter
 * for the given hostname and port.
 */</comment>
<function><type><name>void</name></type>
<name>IncrementSharedConnectionCounter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedConnStatsHashKey</name></type> <name>connKey</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>MaxSharedPoolSize</name> <operator>==</operator> <name>DISABLE_CONNECTION_THROTTLING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection throttling disabled */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>connKey</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAX_NODE_LENGTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hostname exceeds the maximum length of %d"</literal></expr></argument>,
							   <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>connKey</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connKey</name><operator>.</operator><name>databaseOid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockConnectionSharedMemory</name><argument_list>(<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * As the hash map is  allocated in shared memory, it doesn't rely on palloc for
	 * memory allocation, so we could get NULL via HASH_ENTER_NULL. That's why we prefer
	 * continuing the execution instead of throwing an error.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>entryFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedConnStatsHashEntry</name> <modifier>*</modifier></type><name>connectionEntry</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SharedConnStatsHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>connKey</name></expr></argument>, <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entryFound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * It is possible to throw an error at this point, but that doesn't help us in anyway.
	 * Instead, we try our best, let the connection establishment continue by-passing the
	 * connection throttling.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>connectionEntry</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnLockConnectionSharedMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"No entry found for node %s:%d while incrementing "</literal>
								<literal type="string">"connection counter"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entryFound</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we successfully allocated the entry for the first time, so initialize it */</comment>
		<expr_stmt><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnLockConnectionSharedMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DecrementSharedConnectionCounter decrements the shared counter
 * for the given hostname and port for the given count.
 */</comment>
<function><type><name>void</name></type>
<name>DecrementSharedConnectionCounter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedConnStatsHashKey</name></type> <name>connKey</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do not call GetMaxSharedPoolSize() here, since it may read from
	 * the catalog and we may be in the process exit handler.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MaxSharedPoolSize</name> <operator>==</operator> <name>DISABLE_CONNECTION_THROTTLING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection throttling disabled */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>connKey</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAX_NODE_LENGTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hostname exceeds the maximum length of %d"</literal></expr></argument>,
							   <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>connKey</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connKey</name><operator>.</operator><name>databaseOid</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockConnectionSharedMemory</name><argument_list>(<argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>entryFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedConnStatsHashEntry</name> <modifier>*</modifier></type><name>connectionEntry</name> <init>=
		<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SharedConnStatsHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>connKey</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entryFound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this worker node is removed or updated, no need to care */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entryFound</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnLockConnectionSharedMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* wake up any waiters in case any backend is waiting for this node */</comment>
		<expr_stmt><expr><call><name>WakeupWaiterBackendsForSharedConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"No entry found for node %s:%d while decrementing "</literal>
								<literal type="string">"connection counter"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we should never go below 0 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>connectionCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't have to remove at this point as the node might be still active
		 * and will have new connections open to it. Still, this seems like a convenient
		 * place to remove the entry, as connectionCount == 0 implies that the server is
		 * not busy, and given the default value of MaxCachedConnectionsPerWorker = 1,
		 * we're unlikely to trigger this often.
		 */</comment>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SharedConnStatsHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>connKey</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entryFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>UnLockConnectionSharedMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WakeupWaiterBackendsForSharedConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LockConnectionSharedMemory is a utility function that should be used when
 * accessing to the SharedConnStatsHash, which is in the shared memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LockConnectionSharedMemory</name><parameter_list>(<parameter><decl><type><name>LWLockMode</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>sharedConnectionHashLock</name></name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UnLockConnectionSharedMemory is a utility function that should be used after
 * LockConnectionSharedMemory().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnLockConnectionSharedMemory</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>sharedConnectionHashLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WakeupWaiterBackendsForSharedConnection is a wrapper around the condition variable
 * broadcast operation.
 *
 * We use a single condition variable, for all worker nodes, to implement the connection
 * throttling mechanism. Combination of all the backends are allowed to establish
 * MaxSharedPoolSize number of connections per worker node. If a backend requires a
 * non-optional connection (see WAIT_FOR_CONNECTION for details), it is not allowed
 * to establish it immediately if the total connections are equal to MaxSharedPoolSize.
 * Instead, the backend waits on the condition variable. When any other backend
 * terminates an existing connection to any remote node, this function is called.
 * The main goal is to trigger all waiting backends to try getting a connection slot
 * in MaxSharedPoolSize. The ones which can get connection slot are allowed to continue
 * with the connection establishments. Others should wait another backend to call
 * this function.
 */</comment>
<function><type><name>void</name></type>
<name>WakeupWaiterBackendsForSharedConnection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>waitersConditionVariable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WaitForSharedConnection is a wrapper around the condition variable sleep operation.
 *
 * For the details of the use of the condition variable, see
 * WakeupWaiterBackendsForSharedConnection().
 */</comment>
<function><type><name>void</name></type>
<name>WaitForSharedConnection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>waitersConditionVariable</name></name></expr></argument>,
						   <argument><expr><name>PG_WAIT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InitializeSharedConnectionStats requests the necessary shared memory
 * from Postgres and sets up the shared memory startup hook.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeSharedConnectionStats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* on PG 15, we use shmem_request_hook_type */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_15</name></expr></cpp:if>

	<comment type="block">/* allocate shared memory */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RequestAddinShmemSpace</name><argument_list>(<argument><expr><call><name>SharedConnectionStatsShmemSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>prev_shmem_startup_hook</name> <operator>=</operator> <name>shmem_startup_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmem_startup_hook</name> <operator>=</operator> <name>SharedConnectionStatsShmemInit</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SharedConnectionStatsShmemSize returns the size that should be allocated
 * on the shared memory for shared connection stats.
 */</comment>
<function><type><name>size_t</name></type>
<name>SharedConnectionStatsShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionStatsSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Size</name></type> <name>hashSize</name> <init>= <expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>MaxWorkerNodesTracked</name></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedConnStatsHashEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>hashSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SharedConnectionStatsShmemInit initializes the shared memory used
 * for keeping track of connection stats across backends.
 */</comment>
<function><type><name>void</name></type>
<name>SharedConnectionStatsShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>alreadyInitialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>

	<comment type="block">/* create (hostname, port, database) -&gt; [counter] */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SharedConnStatsHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SharedConnStatsHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>SharedConnectionHashHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>SharedConnectionHashCompare</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_COMPARE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Currently the lock isn't required because allocation only happens at
	 * startup in postmaster, but it doesn't hurt, and makes things more
	 * consistent with other extensions.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ConnectionStatsSharedState</name> <operator>=</operator>
		<operator>(</operator><name>ConnectionStatsSharedData</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(
			<argument><expr><literal type="string">"Shared Connection Stats Data"</literal></expr></argument>,
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionStatsSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>alreadyInitialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alreadyInitialized</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>sharedConnectionHashTrancheId</name></name> <operator>=</operator> <call><name>LWLockNewTrancheId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>sharedConnectionHashTrancheName</name></name> <operator>=</operator>
			<literal type="string">"Shared Connection Tracking Hash Tranche"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>sharedConnectionHashTrancheId</name></name></expr></argument>,
							  <argument><expr><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>sharedConnectionHashTrancheName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>sharedConnectionHashLock</name></name></expr></argument>,
						 <argument><expr><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>sharedConnectionHashTrancheId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ConditionVariableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>waitersConditionVariable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*  allocate hash table */</comment>
	<expr_stmt><expr><name>SharedConnStatsHash</name> <operator>=</operator>
		<call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"Shared Conn. Stats Hash"</literal></expr></argument>, <argument><expr><name>MaxWorkerNodesTracked</name></expr></argument>,
					  <argument><expr><name>MaxWorkerNodesTracked</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AddinShmemInitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SharedConnStatsHash</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ConnectionStatsSharedState</name><operator>-&gt;</operator><name>sharedConnectionHashTrancheId</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prev_shmem_startup_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>prev_shmem_startup_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AdaptiveConnectionManagementFlag returns the appropriate connection flag,
 * regarding the adaptive connection management, based on the given
 * activeConnectionCount to remote nodes.
 *
 * This function should only be called if the code-path is capable of handling
 * optional connections.
 */</comment>
<function><type><name>int</name></type>
<name>AdaptiveConnectionManagementFlag</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>connectToLocalNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>activeConnectionCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>UseConnectionPerPlacement</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * User wants one connection per placement, so no throttling is desired
		 * and we do not set any flags.
		 *
		 * The primary reason for this is that allowing multiple backends to use
		 * connection per placement could lead to unresolved self deadlocks. In other
		 * words, each backend may stuck waiting for other backends to get a slot
		 * in the shared connection counters.
		 */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>connectToLocalNode</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Connection to local node is always optional because the executor is capable
		 * of falling back to local execution.
		 */</comment>
		<return>return <expr><name>OPTIONAL_CONNECTION</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>ShouldWaitForConnection</name><argument_list>(<argument><expr><name>activeConnectionCount</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need this connection to finish the execution. If it is not
		 * available based on the current number of connections to the worker
		 * then wait for it.
		 */</comment>
		<return>return <expr><name>WAIT_FOR_CONNECTION</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The execution can be finished the execution with a single connection,
		 * remaining are optional. If the execution can get more connections,
		 * it can increase the parallelism.
		 */</comment>
		<return>return <expr><name>OPTIONAL_CONNECTION</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldWaitForConnection returns true if the workerPool should wait to
 * get the next connection until one slot is empty within
 * citus.max_shared_pool_size on the worker. Note that, if there is an
 * empty slot, the connection will not wait anyway.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldWaitForConnection</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>currentConnectionCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>currentConnectionCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We definitely need at least 1 connection to finish the execution.
		 * All single shard queries hit here with the default settings.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>currentConnectionCount</name> <operator>&lt;</operator> <name>MaxCachedConnectionsPerWorker</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Until this session caches MaxCachedConnectionsPerWorker connections,
		 * this might lead some optional connections to be considered as non-optional
		 * when MaxCachedConnectionsPerWorker &gt; 1.
		 *
		 * However, once the session caches MaxCachedConnectionsPerWorker (which is
		 * the second transaction executed in the session), Citus would utilize the
		 * cached connections as much as possible.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>SharedConnectionHashHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedConnStatsHashKey</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>SharedConnStatsHashKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>hash</name> <init>= <expr><call><name>string_hash</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>databaseOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>SharedConnectionHashCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedConnStatsHashKey</name> <modifier>*</modifier></type><name>ca</name> <init>= <expr><operator>(</operator><name>SharedConnStatsHashKey</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedConnStatsHashKey</name> <modifier>*</modifier></type><name>cb</name> <init>= <expr><operator>(</operator><name>SharedConnStatsHashKey</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>ca</name><operator>-&gt;</operator><name>port</name></name> <operator>!=</operator> <name><name>cb</name><operator>-&gt;</operator><name>port</name></name> <operator>||</operator>
		<name><name>ca</name><operator>-&gt;</operator><name>databaseOid</name></name> <operator>!=</operator> <name><name>cb</name><operator>-&gt;</operator><name>databaseOid</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
