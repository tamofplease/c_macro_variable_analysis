<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/connection/connection_management.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * connection_management.c
 *   Central management of connections and their life-cycle
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/error_codes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/placement_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/run_from_same_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_connection_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/cancel_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/time_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_log_messages.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><name>int</name></type> <name>NodeConnectionTimeout</name> <init>= <expr><literal type="number">30000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>MaxCachedConnectionsPerWorker</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>MaxCachedConnectionLifetime</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <name>MS_PER_MINUTE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>ConnectionHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>ConnParamsHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ConnectionContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>ConnectionHashHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ConnectionHashCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartConnectionEstablishment</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connectionn</name></decl></parameter>,
										 <parameter><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiConnection</name> <modifier>*</modifier></type> <name>FindAvailableConnection</name><parameter_list>(<parameter><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>connections</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfMultipleMetadataConnectionExists</name><parameter_list>(<parameter><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>connections</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreeConnParamsHashEntryFields</name><parameter_list>(<parameter><decl><type><name>ConnParamsHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AfterXactHostConnectionHandling</name><parameter_list>(<parameter><decl><type><name>ConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldShutdownConnection</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type>
									 <name>cachedConnectionCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RemoteTransactionIdle</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>EventSetSizeForConnectionList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connections</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* types for async connection management */</comment>
<enum>enum <name>MultiConnectionPhase</name>
<block>{
	<decl><name>MULTI_CONNECTION_PHASE_CONNECTING</name></decl>,
	<decl><name>MULTI_CONNECTION_PHASE_CONNECTED</name></decl>,
	<decl><name>MULTI_CONNECTION_PHASE_ERROR</name></decl>,
}</block>;</enum>
<typedef>typedef <type><struct>struct <name>MultiConnectionPollState</name>
<block>{
	<decl_stmt><decl><type><name><name>enum</name> <name>MultiConnectionPhase</name></name></type> <name>phase</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>pollmode</name></decl>;</decl_stmt>
}</block></struct></type> <name>MultiConnectionPollState</name>;</typedef>


<comment type="block">/* helper functions for async connection management */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MultiConnectionStatePoll</name><parameter_list>(<parameter><decl><type><name>MultiConnectionPollState</name> <modifier>*</modifier></type><name>connectionState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WaitEventSet</name> <modifier>*</modifier></type> <name>WaitEventSetFromMultiConnectionStates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connections</name></decl></parameter>,
															<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>waitCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CloseNotReadyMultiConnectionStates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStates</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>MultiConnectionStateEventMask</name><parameter_list>(<parameter><decl><type><name>MultiConnectionPollState</name> <modifier>*</modifier></type><name>connectionState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusPQFinish</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ConnParamsHashEntry</name> <modifier>*</modifier></type> <name>FindOrCreateConnParamsEntry</name><parameter_list>(<parameter><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Initialize per-backend connection management infrastructure.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeConnectionManagement</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>, <decl><type ref="prev"/><name>connParamsInfo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create a single context for connection and transaction related memory
	 * management. Doing so, instead of allocating in TopMemoryContext, makes
	 * it easier to associate used memory.
	 */</comment>
	<expr_stmt><expr><name>ConnectionContext</name> <operator>=</operator> <call><name>AllocSetContextCreateInternal</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
													  <argument><expr><literal type="string">"Connection Context"</literal></expr></argument>,
													  <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
													  <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
													  <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create (host,port,user,database) -&gt; [connection] hash */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>ConnectionHashHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>ConnectionHashCompare</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>ConnectionContext</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_COMPARE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* connParamsInfo is same as info, except for entrysize */</comment>
	<expr_stmt><expr><name>connParamsInfo</name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connParamsInfo</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnParamsHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>ConnectionHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"citus connection cache (host,port,user,database)"</literal></expr></argument>,
								 <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ConnParamsHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"citus connparams cache (host,port,user,database)"</literal></expr></argument>,
								 <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>connParamsInfo</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateConnParamsHashEntries sets every hash entry's isValid flag to false.
 */</comment>
<function><type><name>void</name></type>
<name>InvalidateConnParamsHashEntries</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ConnParamsHash</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConnParamsHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>ConnParamsHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>ConnParamsHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AfterXactConnectionHandling performs connection management activity after the end of a transaction. Both
 * COMMIT and ABORT paths are handled here.
 *
 * This is called by Citus' global transaction callback.
 */</comment>
<function><type><name>void</name></type>
<name>AfterXactConnectionHandling</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>ConnectionHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>ConnectionHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip invalid connection hash entries */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>AfterXactHostConnectionHandling</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * NB: We leave the hash entry in place, even if there's no individual
		 * connections in it anymore. There seems no benefit in deleting it,
		 * and it'll save a bit of work in the next transaction.
		 */</comment>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * GetNodeConnection() establishes a connection to remote node, using default
 * user and database.
 *
 * See StartNodeUserDatabaseConnection for details.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>GetNodeConnection</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StartNodeConnection initiates a connection to remote node, using default
 * user and database.
 *
 * See StartNodeUserDatabaseConnection for details.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>StartNodeConnection</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>StartNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>,
																  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * connection can only be NULL for optional connections, which we don't
	 * support in this codepath.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>OPTIONAL_CONNECTION</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>connection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetNodeUserDatabaseConnection establishes connection to remote node.
 *
 * See StartNodeUserDatabaseConnection for details.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>GetNodeUserDatabaseConnection</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>port</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>database</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>StartNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>,
																  <argument><expr><name>user</name></expr></argument>, <argument><expr><name>database</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * connection can only be NULL for optional connections, which we don't
	 * support in this codepath.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>OPTIONAL_CONNECTION</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>connection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FinishConnectionEstablishment</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetConnectionForLocalQueriesOutsideTransaction returns a localhost connection for
 * subtransaction. To avoid creating excessive connections, we reuse an
 * existing connection.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>GetConnectionForLocalQueriesOutsideTransaction</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>userName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionFlag</name> <init>= <expr><name>OUTSIDE_TRANSACTION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
		<expr><call><name>GetNodeUserDatabaseConnection</name><argument_list>(<argument><expr><name>connectionFlag</name></expr></argument>, <argument><expr><name>LocalHostName</name></expr></argument>, <argument><expr><name>PostPortNumber</name></expr></argument>,
									  <argument><expr><name>userName</name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StartNodeUserDatabaseConnection() initiates a connection to a remote node.
 *
 * If user or database are NULL, the current session's defaults are used. The
 * following flags influence connection establishment behaviour:
 * - FORCE_NEW_CONNECTION - a new connection is required
 *
 * The returned connection has only been initiated, not fully
 * established. That's useful to allow parallel connection establishment. If
 * that's not desired use the Get* variant.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>StartNodeUserDatabaseConnection</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>port</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>database</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnectionHashKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

	<comment type="block">/* do some minimal input checks */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAX_NODE_LENGTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hostname exceeds the maximum length of %d"</literal></expr></argument>,
							   <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>user</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>database</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>database</name></name></expr></argument>, <argument><expr><name>database</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>database</name></name></expr></argument>, <argument><expr><call><name>CurrentDatabaseName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REQUIRE_REPLICATION_CONNECTION_PARAM</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>replicationConnParam</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>replicationConnParam</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>CurrentCoordinatedTransactionState</name> <operator>==</operator> <name>COORD_TRANS_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>CurrentCoordinatedTransactionState</name> <operator>=</operator> <name>COORD_TRANS_IDLE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Lookup relevant hash entry. We always enter. If only a cached
	 * connection is desired, and there's none, we'll simply leave the
	 * connection list empty.
	 */</comment>

	<decl_stmt><decl><type><name>ConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ConnectionHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We are just building hash entry or previously it was left in an
		 * invalid state as we couldn't allocate memory for it.
		 * So initialize entry-&gt;connections list here.
		 */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>connections</name></name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>ConnectionContext</name></expr></argument>,
												<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dlist_head</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If MemoryContextAlloc errors out -e.g. during an OOM-, entry-&gt;connections
		 * stays as NULL. So entry-&gt;isValid should be set to true right after we
		 * initialize entry-&gt;connections properly.
		 */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if desired, check whether there's a usable connection */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FORCE_NEW_CONNECTION</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check connection cache for a connection that's not already in use */</comment>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>FindAvailableConnection</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>connection</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>connection</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REQUIRE_METADATA_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* FORCE_NEW_CONNECTION and REQUIRE_METADATA_CONNECTION are incompatible */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"metadata connections cannot be forced to open "</literal>
							   <literal type="string">"a new connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * Either no caching desired, or no pre-established, non-claimed,
	 * connection present. Initiate connection establishment.
	 */</comment>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>ConnectionContext</name></expr></argument>,
														 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>initilizationState</name></name> <operator>=</operator> <name>POOL_STATE_NOT_INITIALIZED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>connectionNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* these two flags are by nature cannot happen at the same time */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WAIT_FOR_CONNECTION</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>OPTIONAL_CONNECTION</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WAIT_FOR_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WaitLoopForSharedConnection</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>OPTIONAL_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can afford to skip establishing an optional connection. For
		 * non-optional connections, we first retry for some time. If we still
		 * cannot reserve the right to establish a connection, we prefer to
		 * error out.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TryToIncrementSharedConnectionCounter</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* do not track the connection anymore */</comment>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>connectionNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The caller doesn't want the connection manager to wait
		 * until a connection slot is available on the remote node.
		 * In the end, we might fail to establish connection to the
		 * remote node as it might not have any space in
		 * max_connections for this connection establishment.
		 *
		 * Still, we keep track of the connection counter.
		 */</comment>
		<expr_stmt><expr><call><name>IncrementSharedConnectionCounter</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>


	<comment type="block">/*
	 * We've already incremented the counter above, so we should decrement
	 * when we're done with the connection.
	 */</comment>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>initilizationState</name></name> <operator>=</operator> <name>POOL_STATE_COUNTER_INCREMENTED</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartConnectionEstablishment</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResetShardPlacementAssociation</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REQUIRE_METADATA_CONNECTION</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>useForMetadataOperations</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fully initialized the connection, record it */</comment>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>initilizationState</name></name> <operator>=</operator> <name>POOL_STATE_INITIALIZED</name></expr>;</expr_stmt>

	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindAvailableConnection searches the given list of connections for one that
 * is not claimed exclusively.
 *
 * If no connection is available, FindAvailableConnection returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiConnection</name> <modifier>*</modifier></type>
<name>FindAvailableConnection</name><parameter_list>(<parameter><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>connections</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>metadataConnectionCandidateList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>connections</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>connectionNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>OUTSIDE_TRANSACTION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* don't return connections that are used in transactions */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name><operator>.</operator><name>transactionState</name></name> <operator>!=</operator>
				<name>REMOTE_TRANS_NOT_STARTED</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* don't return claimed connections */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>claimedExclusively</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connection is in use for an ongoing operation */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>forceCloseAtTransactionEnd</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name><operator>.</operator><name>beginSent</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This is a connection that should be closed, probably because
			 * of old connection options or removing a node. This will
			 * automatically be closed at the end of the transaction. But, if we are still
			 * inside a transaction, we should keep using this connection as long as a remote
			 * transaction is in progress over the connection. The main use for this case
			 * is having some commands inside a transaction block after removing nodes. And, we
			 * currently allow very limited operations after removing a node inside a
			 * transaction block (e.g., no placement access can happen).
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>initilizationState</name></name> <operator>!=</operator> <name>POOL_STATE_INITIALIZED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the connection has not been initialized, it should not be
			 * considered as available.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REQUIRE_METADATA_CONNECTION</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>connection</name><operator>-&gt;</operator><name>useForMetadataOperations</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The caller requested a metadata connection, and this is not the
			 * metadata connection. Still, this is a candidate for becoming a
			 * metadata connection.
			 */</comment>
			<expr_stmt><expr><name>metadataConnectionCandidateList</name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name>metadataConnectionCandidateList</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>connection</name></expr>;</return>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REQUIRE_METADATA_CONNECTION</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name>metadataConnectionCandidateList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Caller asked a metadata connection, and we couldn't find a connection
		 * that has already been used for metadata operations.
		 *
		 * So, we pick the first connection as the metadata connection.
		 */</comment>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>metadataConnection</name> <init>=
			<expr><call><name>linitial</name><argument_list>(<argument><expr><name>metadataConnectionCandidateList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>metadataConnection</name><operator>-&gt;</operator><name>claimedExclusively</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* remember that we use this connection for metadata operations */</comment>
		<expr_stmt><expr><name><name>metadataConnection</name><operator>-&gt;</operator><name>useForMetadataOperations</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We cannot have multiple metadata connections. If we see
		 * this error, it is likely that there is a bug in connection
		 * management.
		 */</comment>
		<expr_stmt><expr><call><name>ErrorIfMultipleMetadataConnectionExists</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>metadataConnection</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfMultipleMetadataConnectionExists throws an error if the
 * input connection dlist contains more than one metadata connections.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfMultipleMetadataConnectionExists</name><parameter_list>(<parameter><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>connections</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundMetadataConnection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>connections</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>connectionNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>useForMetadataOperations</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>foundMetadataConnection</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have multiple metadata connections"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>foundMetadataConnection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CloseAllConnectionsAfterTransaction sets the forceClose flag of all the
 * connections. This is mainly done when citus.node_conninfo changes.
 */</comment>
<function><type><name>void</name></type>
<name>CloseAllConnectionsAfterTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ConnectionHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>ConnectionHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>ConnectionHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip invalid connection hash entries */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>connections</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>connections</name></name></expr></init></decl>;</decl_stmt>
		<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>connections</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
				<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>connectionNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>forceCloseAtTransactionEnd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * ConnectionAvailableToNode returns a MultiConnection if the session has at least
 * one connection established and avaliable to use to the give node. Else, returns
 * false.
 */</comment>
<function><type><name>MultiConnection</name> <modifier>*</modifier></type>
<name>ConnectionAvailableToNode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hostName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userName</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>database</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnectionHashKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>hostName</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>nodePort</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><name>userName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>database</name></name></expr></argument>, <argument><expr><name>database</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>replicationConnParam</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>=
		<expr><operator>(</operator><name>ConnectionHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ConnectionHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>FindAvailableConnection</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CloseNodeConnectionsAfterTransaction sets the forceClose flag of the connections
 * to a particular node as true such that the connections are no longer cached. This
 * is mainly used when a worker leaves the cluster.
 */</comment>
<function><type><name>void</name></type>
<name>CloseNodeConnectionsAfterTransaction</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>ConnectionHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>ConnectionHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip invalid connection hash entries */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>port</name></name> <operator>!=</operator> <name>nodePort</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>dlist_head</name> <modifier>*</modifier></type><name>connections</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>connections</name></name></expr></init></decl>;</decl_stmt>
		<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>connections</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
				<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>connectionNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>forceCloseAtTransactionEnd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Close a previously established connection.
 */</comment>
<function><type><name>void</name></type>
<name>CloseConnection</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnectionHashKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

	<comment type="block">/* close connection */</comment>
	<expr_stmt><expr><call><name>CitusPQFinish</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>replicationConnParam</name></name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>requiresReplication</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>database</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ConnectionHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* unlink from list of open connections */</comment>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>connectionNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* same for transaction state and shard/placement machinery */</comment>
		<expr_stmt><expr><call><name>CloseShardPlacementAssociation</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetRemoteTransaction</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we leave the per-host entry alive */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"closing untracked connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShutdownAllConnections shutdowns all the MultiConnections in the
 * ConnectionHash.
 *
 * This function is intended to be called atexit() of the backend, so
 * that the cached connections are closed properly. Calling this function
 * at another point in the code could be dangerous, so think twice if you
 * need to call this function.
 */</comment>
<function><type><name>void</name></type>
<name>ShutdownAllConnections</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>ConnectionHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>ConnectionHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip invalid connection hash entries */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>

		<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>entry-&gt;connections</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
				<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>connectionNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ShutdownConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * ShutdownConnection, if necessary cancels the currently running statement,
 * and then closes the underlying libpq connection.  The MultiConnection
 * itself is left intact.
 *
 * NB: Cancelling a statement requires network IO, and currently is not
 * interruptible. Unfortunately libpq does not provide a non-blocking
 * implementation of PQcancel(), so we don't have much choice for now.
 */</comment>
<function><type><name>void</name></type>
<name>ShutdownConnection</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Only cancel statement if there's currently one running, and the
	 * connection is in an OK state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_OK</name> <operator>&amp;&amp;</operator>
		<call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PQTRANS_ACTIVE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendCancelationRequest</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>CitusPQFinish</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MultiConnectionStatePoll executes a PQconnectPoll on the connection to progres the
 * connection establishment. The return value of this function indicates if the
 * MultiConnectionPollState has been changed, which could require a change to the WaitEventSet
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MultiConnectionStatePoll</name><parameter_list>(<parameter><decl><type><name>MultiConnectionPollState</name> <modifier>*</modifier></type><name>connectionState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PostgresPollingStatusType</name></type> <name>oldPollmode</name> <init>= <expr><name><name>connectionState</name><operator>-&gt;</operator><name>pollmode</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>==</operator> <name>MULTI_CONNECTION_PHASE_CONNECTING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <name>MULTI_CONNECTION_PHASE_CONNECTED</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* FIXME: retries? */</comment>
		<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <name>MULTI_CONNECTION_PHASE_ERROR</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <name>MULTI_CONNECTION_PHASE_CONNECTING</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>pollmode</name></name> <operator>=</operator> <call><name>PQconnectPoll</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * FIXME: Do we want to add transparent retry support here?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>connectionState</name><operator>-&gt;</operator><name>pollmode</name></name> <operator>==</operator> <name>PGRES_POLLING_FAILED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <name>MULTI_CONNECTION_PHASE_ERROR</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>connectionState</name><operator>-&gt;</operator><name>pollmode</name></name> <operator>==</operator> <name>PGRES_POLLING_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>=</operator> <name>MULTI_CONNECTION_PHASE_CONNECTED</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>connectionState</name><operator>-&gt;</operator><name>pollmode</name></name> <operator>==</operator> <name>PGRES_POLLING_WRITING</name> <operator>||</operator>
			   <name><name>connectionState</name><operator>-&gt;</operator><name>pollmode</name></name> <operator>==</operator> <name>PGRES_POLLING_READING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><ternary><condition><expr><operator>(</operator><name>oldPollmode</name> <operator>!=</operator> <name><name>connectionState</name><operator>-&gt;</operator><name>pollmode</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EventSetSizeForConnectionList calculates the space needed for a WaitEventSet based on a
 * list of connections.
 */</comment>
<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>int</name></type>
<name>EventSetSizeForConnectionList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connections</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* we need space for 2 postgres events in the waitset on top of the connections */</comment>
	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WaitEventSetFromMultiConnectionStates takes a list of MultiConnectionStates and adds
 * all sockets of the connections that are still in the connecting phase to a WaitSet,
 * taking into account the maximum number of connections that could be added in total to
 * a WaitSet.
 *
 * waitCount populates the number of connections added to the WaitSet in case when a
 * non-NULL pointer is provided.
 */</comment>
<function><type><specifier>static</specifier> <name>WaitEventSet</name> <modifier>*</modifier></type>
<name>WaitEventSetFromMultiConnectionStates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connections</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>waitCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>eventSetSize</name> <init>= <expr><call><name>EventSetSizeForConnectionList</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numEventsAdded</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>waitCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>waitCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name> <init>= <expr><call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>eventSetSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>EnsureReleaseResource</name><argument_list>(<argument><expr><operator>(</operator><name>MemoryContextCallbackFunction</name><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>FreeWaitEventSet</name><operator>)</operator></expr></argument>,
						  <argument><expr><name>waitEventSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Put the wait events for the signal latch and postmaster death at the end such that
	 * event index + pendingConnectionsStartIndex = the connection index in the array.
	 */</comment>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numEventsAdded</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiConnectionPollState</name> <modifier>*</modifier></type><name>connectionState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connectionState</argument>, <argument>connections</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>numEventsAdded</name> <operator>&gt;=</operator> <name>eventSetSize</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* room for events to schedule is exhausted */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>!=</operator> <name>MULTI_CONNECTION_PHASE_CONNECTING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connections that are not connecting will not be added to the WaitSet */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>eventMask</name> <init>= <expr><call><name>MultiConnectionStateEventMask</name><argument_list>(<argument><expr><name>connectionState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>waitEventSetIndex</name> <init>=
			<expr><call><name>CitusAddWaitEventSetToSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>eventMask</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>connectionState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>waitEventSetIndex</name> <operator>==</operator> <name>WAIT_EVENT_SET_INDEX_FAILED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection establishment for node %s:%d failed"</literal></expr></argument>,
								   <argument><expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
								   <argument><expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check both the local and remote server logs for the "</literal>
									<literal type="string">"connection establishment errors."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>numEventsAdded</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>waitCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>waitCount</name> <operator>=</operator> <operator>*</operator><name>waitCount</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>waitEventSet</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MultiConnectionStateEventMask returns the eventMask use by the WaitEventSet for the
 * for the socket associated with the connection based on the pollmode PQconnectPoll
 * returned in its last invocation
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>MultiConnectionStateEventMask</name><parameter_list>(<parameter><decl><type><name>MultiConnectionPollState</name> <modifier>*</modifier></type><name>connectionState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>eventMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>connectionState</name><operator>-&gt;</operator><name>pollmode</name></name> <operator>==</operator> <name>PGRES_POLLING_READING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>eventMask</name> <operator>|=</operator> <name>WL_SOCKET_READABLE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>eventMask</name> <operator>|=</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>eventMask</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FinishConnectionListEstablishment takes a list of MultiConnection and finishes the
 * connections establishment asynchronously for all connections not already fully
 * connected.
 */</comment>
<function><type><name>void</name></type>
<name>FinishConnectionListEstablishment</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>multiConnectionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>connectionStart</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>connectionStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStates</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>waitEventSetRebuild</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>waitCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>multiConnectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnectionPollState</name> <modifier>*</modifier></type><name>connectionState</name> <init>=
			<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MultiConnectionPollState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>connection</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * before we can build the waitset to wait for asynchronous IO we need to know the
		 * pollmode to use for the sockets. This is populated by executing one round of
		 * PQconnectPoll. This updates the MultiConnectionPollState struct with its phase and
		 * its next poll mode.
		 */</comment>
		<expr_stmt><expr><call><name>MultiConnectionStatePoll</name><argument_list>(<argument><expr><name>connectionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>connectionStates</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionStates</name></expr></argument>, <argument><expr><name>connectionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>==</operator> <name>MULTI_CONNECTION_PHASE_CONNECTING</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>waitCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* prepare space for socket events */</comment>
	<decl_stmt><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>events</name> <init>= <expr><operator>(</operator><name>WaitEvent</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>EventSetSizeForConnectionList</name><argument_list>(
												  <argument><expr><name>connectionStates</name></expr></argument>)</argument_list></call> <operator>*</operator>
											  <sizeof>sizeof<argument_list>(<argument><expr><name>WaitEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * for high connection counts with lots of round trips we could potentially have a lot
	 * of (big) waitsets that we'd like to clean right after we have used them. To do this
	 * we switch to a temporary memory context for this loop which gets reset at the end
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(
		<argument><expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
							  <argument><expr><literal type="string">"connection establishment temporary context"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>waitCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type> <name>timeout</name> <init>= <expr><call><name>MillisecondsToTimeout</name><argument_list>(<argument><expr><name>connectionStart</name></expr></argument>, <argument><expr><name>NodeConnectionTimeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>waitEventSetRebuild</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>waitEventSet</name> <operator>=</operator> <call><name>WaitEventSetFromMultiConnectionStates</name><argument_list>(<argument><expr><name>connectionStates</name></expr></argument>,
																 <argument><expr><operator>&amp;</operator><name>waitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>waitEventSetRebuild</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>waitCount</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>eventCount</name> <init>= <expr><call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>events</name></expr></argument>, <argument><expr><name>waitCount</name></expr></argument>,
										  <argument><expr><name>WAIT_EVENT_CLIENT_READ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>eventIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>eventIndex</name> <operator>&lt;</operator> <name>eventCount</name></expr>;</condition> <incr><expr><name>eventIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>event</name> <init>= <expr><operator>&amp;</operator><name><name>events</name><index>[<expr><name>eventIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MultiConnectionPollState</name> <modifier>*</modifier></type><name>connectionState</name> <init>=
				<expr><operator>(</operator><name>MultiConnectionPollState</name> <operator>*</operator><operator>)</operator> <name><name>event</name><operator>-&gt;</operator><name>user_data</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"postmaster was shut down, exiting"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsHoldOffCancellationReceived</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * because we can't break from 2 loops easily we need to not forget to
					 * reset the memory context
					 */</comment>
					<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>

				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>connectionStateChanged</name> <init>= <expr><call><name>MultiConnectionStatePoll</name><argument_list>(<argument><expr><name>connectionState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>connectionStateChanged</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>!=</operator> <name>MULTI_CONNECTION_PHASE_CONNECTING</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* we cannot stop waiting for connection, so rebuild the event set */</comment>
					<expr_stmt><expr><name>waitEventSetRebuild</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* connection state changed, reset the event mask */</comment>
					<decl_stmt><decl><type><name>uint32</name></type> <name>eventMask</name> <init>= <expr><call><name>MultiConnectionStateEventMask</name><argument_list>(<argument><expr><name>connectionState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>=
						<expr><call><name>CitusModifyWaitEvent</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name><name>event</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>,
											 <argument><expr><name>eventMask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
										<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection establishment for node %s:%d "</literal>
											   <literal type="string">"failed"</literal></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
											   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>,</operator>
										<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check both the local and remote server "</literal>
												<literal type="string">"logs for the connection establishment "</literal>
												<literal type="string">"errors."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * The state has changed to connected, update the connection's
				 * state as well.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>==</operator> <name>MULTI_CONNECTION_PHASE_CONNECTED</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>MarkConnectionConnected</name><argument_list>(<argument><expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>eventCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * timeout has occurred on waitset, double check the timeout since
			 * connectionStart and if passed close all non-finished connections
			 */</comment>

			<if_stmt><if>if <condition>(<expr><call><name>MillisecondsPassedSince</name><argument_list>(<argument><expr><name>connectionStart</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NodeConnectionTimeout</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * showing as a warning, can't be an error. In some cases queries can
				 * proceed with only some of the connections being fully established.
				 * Queries that can't will error then and there
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not establish connection after %u ms"</literal></expr></argument>,
										 <argument><expr><name>NodeConnectionTimeout</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Close all connections that have not been fully established.
				 */</comment>
				<expr_stmt><expr><call><name>CloseNotReadyMultiConnectionStates</name><argument_list>(<argument><expr><name>connectionStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MillisecondsPassedSince returns the number of milliseconds elapsed between an
 * instr_time &amp; the current time.
 */</comment>
<function><type><name>double</name></type>
<name>MillisecondsPassedSince</name><parameter_list>(<parameter><decl><type><name>instr_time</name></type> <name>moment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>timeSinceMoment</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>timeSinceMoment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>timeSinceMoment</name></expr></argument>, <argument><expr><name>moment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>INSTR_TIME_GET_MILLISEC</name><argument_list>(<argument><expr><name>timeSinceMoment</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MillisecondsToTimeout returns the numer of milliseconds that still need to elapse
 * before msAfterStart milliseconds have passed since start. The outcome can be used to
 * pass to the Wait of an EventSet to make sure it returns after the timeout has passed.
 */</comment>
<function><type><name>long</name></type>
<name>MillisecondsToTimeout</name><parameter_list>(<parameter><decl><type><name>instr_time</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>msAfterStart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>msAfterStart</name> <operator>-</operator> <call><name>MillisecondsPassedSince</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CloseNotReadyMultiConnectionStates calls CloseConnection for all MultiConnection's
 * tracked in the MultiConnectionPollState list passed in, only if the connection is not yet
 * fully established.
 *
 * This function removes the pointer to the MultiConnection data after the Connections are
 * closed since they should not be used anymore.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloseNotReadyMultiConnectionStates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnectionPollState</name> <modifier>*</modifier></type><name>connectionState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connectionState</argument>, <argument>connectionStates</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connectionState</name><operator>-&gt;</operator><name>phase</name></name> <operator>!=</operator> <name>MULTI_CONNECTION_PHASE_CONNECTING</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* close connection, otherwise we take up resource on the other side */</comment>
		<expr_stmt><expr><call><name>CitusPQFinish</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CitusPQFinish is a wrapper around PQfinish and does book keeping on shared connection
 * counters.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusPQFinish</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* behave idempotently, there is no gurantee that CitusPQFinish() is called once */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>initilizationState</name></name> <operator>&gt;=</operator> <name>POOL_STATE_COUNTER_INCREMENTED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DecrementSharedConnectionCounter</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>initilizationState</name></name> <operator>=</operator> <name>POOL_STATE_NOT_INITIALIZED</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Close connections on timeout in FinishConnectionListEstablishment
 * Synchronously finish connection establishment of an individual connection.
 * This function is a convenience wrapped around FinishConnectionListEstablishment.
 */</comment>
<function><type><name>void</name></type>
<name>FinishConnectionEstablishment</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>FinishConnectionListEstablishment</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ClaimConnectionExclusively signals that this connection is actively being
 * used. That means it'll not be, again, returned by
 * StartNodeUserDatabaseConnection() et al until releases with
 * UnclaimConnection().
 */</comment>
<function><type><name>void</name></type>
<name>ClaimConnectionExclusively</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>connection</name><operator>-&gt;</operator><name>claimedExclusively</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>claimedExclusively</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UnclaimConnection signals that this connection is not being used
 * anymore. That means it again may be returned by
 * StartNodeUserDatabaseConnection() et al.
 */</comment>
<function><type><name>void</name></type>
<name>UnclaimConnection</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>claimedExclusively</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>ConnectionHashHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>ConnectionHashKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>hash</name> <init>= <expr><call><name>string_hash</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>string_hash</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>string_hash</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>replicationConnParam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>ConnectionHashCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>ca</name> <init>= <expr><operator>(</operator><name>ConnectionHashKey</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>cb</name> <init>= <expr><operator>(</operator><name>ConnectionHashKey</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>ca</name><operator>-&gt;</operator><name>port</name></name> <operator>!=</operator> <name><name>cb</name><operator>-&gt;</operator><name>port</name></name> <operator>||</operator>
		<name><name>ca</name><operator>-&gt;</operator><name>replicationConnParam</name></name> <operator>!=</operator> <name><name>cb</name><operator>-&gt;</operator><name>replicationConnParam</name></name> <operator>||</operator>
		<call><name>strncmp</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>strncmp</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Asynchronously establish connection to a remote node, but don't wait for
 * that to finish. DNS lookups etc. are performed synchronously though.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartConnectionEstablishment</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>connectionId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ConnParamsHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>FindOrCreateConnParamsEntry</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>port</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>requiresReplication</name></name> <operator>=</operator> <name><name>key</name><operator>-&gt;</operator><name>replicationConnParam</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name> <operator>=</operator> <call><name>PQconnectStartParams</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>keywords</name></name></expr></argument>,
											  <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>values</name></name></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionEstablishmentStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do not increment for restarted connections */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>connectionId</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionId</name></name> <operator>=</operator> <name>connectionId</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * To avoid issues with interrupts not getting caught all our connections
	 * are managed in a non-blocking manner. remote_commands.c provides
	 * wrappers emulating blocking behaviour.
	 */</comment>
	<expr_stmt><expr><call><name>PQsetnonblocking</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetCitusNoticeReceiver</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:if>

<comment type="block">/*
 * WarmUpConnParamsHash warms up the ConnParamsHash by loading all the
 * conn params for active primary nodes.
 */</comment>
<function><type><name>void</name></type>
<name>WarmUpConnParamsHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActivePrimaryNodeList</name><argument_list>(<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ConnectionHashKey</name></type> <name>key</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>database</name></name></expr></argument>, <argument><expr><call><name>CurrentDatabaseName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>replicationConnParam</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FindOrCreateConnParamsEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * FindOrCreateConnParamsEntry searches ConnParamsHash for the given key,
 * if it is not found, it is created.
 */</comment>
<function><type><specifier>static</specifier> <name>ConnParamsHashEntry</name> <modifier>*</modifier></type>
<name>FindOrCreateConnParamsEntry</name><parameter_list>(<parameter><decl><type><name>ConnectionHashKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* search our cache for precomputed connection settings */</comment>
	<decl_stmt><decl><type><name>ConnParamsHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ConnParamsHash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Zero out entry, but not the key part.
			 * Avoids leaving invalid pointers in hash table if GetConnParam throws with MemoryContextAllocZero.
			 */</comment>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>entry</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionHashKey</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConnParamsHashEntry</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnectionHashKey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* avoid leaking memory in the keys and values arrays */</comment>
		<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FreeConnParamsHashEntryFields</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* if not found or not valid, compute them from GUC, runtime, etc. */</comment>
		<expr_stmt><expr><call><name>GetConnParams</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>keywords</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>runtimeParamStart</name></name></expr></argument>,
					  <argument><expr><name>ConnectionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FreeConnParamsHashEntryFields frees any dynamically allocated memory reachable
 * from the fields of the provided ConnParamsHashEntry. This includes all runtime
 * libpq keywords and values, as well as the actual arrays storing them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreeConnParamsHashEntryFields</name><parameter_list>(<parameter><decl><type><name>ConnParamsHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * if there was a memory error during the initialization of ConnParamHashEntry in
	 * GetConnParams the keywords or values might not have been initialized completely.
	 * We check if they have been initialized before freeing them.
	 *
	 * We only iteratively free the lists starting at the index pointed to by
	 * entry-&gt;runtimeParamStart as all entries before are settings that are managed
	 * separately.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>keywords</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyword</name> <init>= <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>keywords</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>runtimeParamStart</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>keyword</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>*</operator><name>keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keyword</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>keywords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>keywords</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>values</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>value</name> <init>= <expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>values</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>runtimeParamStart</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>value</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>values</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>runtimeParamStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AfterXactHostConnectionHandling closes all remote connections if not necessary anymore (i.e. not session
 * lifetime), or if in a failed state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AfterXactHostConnectionHandling</name><parameter_list>(<parameter><decl><type><name>ConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name> <operator>||</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isValid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* callers only pass valid hash entries but let's be on the safe side */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection hash entry is NULL or invalid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cachedConnectionCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>entry-&gt;connections</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>MultiConnection</name></expr></argument>, <argument><expr><name>connectionNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * To avoid leaking connections we warn if connections are
		 * still claimed exclusively. We can only do so if the transaction is
		 * committed, as it's normal that code didn't have chance to clean
		 * up after errors.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name> <operator>&amp;&amp;</operator> <name><name>connection</name><operator>-&gt;</operator><name>claimedExclusively</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection claimed exclusively at transaction commit"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>


		<if_stmt><if>if <condition>(<expr><call><name>ShouldShutdownConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>cachedConnectionCount</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ShutdownConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* unlink from list */</comment>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * reset healthy session lifespan connections.
			 */</comment>
			<expr_stmt><expr><call><name>ResetRemoteTransaction</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>UnclaimConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


			<expr_stmt><expr><name>cachedConnectionCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldShutdownConnection returns true if either one of the followings is true:
 * - The connection is citus initiated.
 * - Current cached connections is already at MaxCachedConnectionsPerWorker
 * - Connection is forced to close at the end of transaction
 * - Connection is not in OK state
 * - A transaction is still in progress (usually because we are cancelling a distributed transaction)
 * - A connection reached its maximum lifetime
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldShutdownConnection</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>cachedConnectionCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * When we are in a backend that was created to serve an internal connection
	 * from the coordinator or another worker, we disable connection caching to avoid
	 * escalating the number of cached connections. We can recognize such backends
	 * from their application name.
	 */</comment>
	<return>return <expr><operator>(</operator><call><name>IsCitusInternalBackend</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRebalancerInternalBackend</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
		   <name><name>connection</name><operator>-&gt;</operator><name>initilizationState</name></name> <operator>!=</operator> <name>POOL_STATE_INITIALIZED</name> <operator>||</operator>
		   <name>cachedConnectionCount</name> <operator>&gt;=</operator> <name>MaxCachedConnectionsPerWorker</name> <operator>||</operator>
		   <name><name>connection</name><operator>-&gt;</operator><name>forceCloseAtTransactionEnd</name></name> <operator>||</operator>
		   <call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name> <operator>||</operator>
		   <operator>!</operator><call><name>RemoteTransactionIdle</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <name><name>connection</name><operator>-&gt;</operator><name>requiresReplication</name></name> <operator>||</operator>
		   <operator>(</operator><name>MaxCachedConnectionLifetime</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>MillisecondsToTimeout</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionEstablishmentStart</name></name></expr></argument>,
								  <argument><expr><name>MaxCachedConnectionLifetime</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RestartConnection starts a new connection attempt for the given
 * MultiConnection.
 *
 * The internal state of the MultiConnection is preserved. For example, we
 * assume that we already went through all the other initialization steps in
 * StartNodeUserDatabaseConnection, such as incrementing shared connection
 * counters.
 *
 * This function should be used cautiously. If a connection is already
 * involved in a remote transaction, we cannot restart the underlying
 * connection. The caller is responsible for enforcing the restrictions
 * on this.
 */</comment>
<function><type><name>void</name></type>
<name>RestartConnection</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* we cannot restart any connection that refers to a placement */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>connection</name><operator>-&gt;</operator><name>referencedPlacements</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we cannot restart any connection that is part of a transaction */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name><operator>.</operator><name>transactionState</name></name> <operator>==</operator> <name>REMOTE_TRANS_NOT_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ConnectionHashKey</name></type> <name>key</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>user</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>database</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>replicationConnParam</name></name> <operator>=</operator> <name><name>connection</name><operator>-&gt;</operator><name>requiresReplication</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * With low-level APIs, we shutdown and restart the connection.
	 * The main trick here is that we are using the same MultiConnection *
	 * such that all the state of the connection is preserved.
	 */</comment>
	<expr_stmt><expr><call><name>ShutdownConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartConnectionEstablishment</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We are restarting an already initialized connection which has
	 * gone through StartNodeUserDatabaseConnection(). That's why we
	 * can safely mark the state initialized.
	 *
	 * Not that we have to do this because ShutdownConnection() sets the
	 * state to not initialized.
	 */</comment>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>initilizationState</name></name> <operator>=</operator> <name>POOL_STATE_INITIALIZED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_CONNECTING</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteTransactionIdle function returns true if we manually
 * set flag on run_commands_on_session_level_connection_to_node to true to
 * force connection API keeping connection open or the status of the connection
 * is idle.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RemoteTransactionIdle</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This is a very special case where we're running isolation tests on MX.
	 * We don't care whether the transaction is idle or not when we're
	 * running MX isolation tests. Thus, let the caller act as if the remote
	 * transactions is idle.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AllowNonIdleTransactionOnXactHandling</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PQTRANS_IDLE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MarkConnectionConnected is a helper function which sets the  connection
 * connectionState to MULTI_CONNECTION_CONNECTED, and also updates connection
 * establishment time when necessary.
 */</comment>
<function><type><name>void</name></type>
<name>MarkConnectionConnected</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>MULTI_CONNECTION_CONNECTED</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>INSTR_TIME_IS_ZERO</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionEstablishmentEnd</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionEstablishmentEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusAddWaitEventSetToSet is a wrapper around Postgres' AddWaitEventToSet().
 *
 * AddWaitEventToSet() may throw hard errors. For example, when the
 * underlying socket for a connection is closed by the remote server
 * and already reflected by the OS, however Citus hasn't had a chance
 * to get this information. In that case, if replication factor is &gt;1,
 * Citus can failover to other nodes for executing the query. Even if
 * replication factor = 1, Citus can give much nicer errors.
 *
 * So CitusAddWaitEventSetToSet simply puts ModifyWaitEvent into a
 * PG_TRY/PG_CATCH block in order to catch any hard errors, and
 * returns this information to the caller.
 */</comment>
<function><type><name>int</name></type>
<name>CitusAddWaitEventSetToSet</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>pgsocket</name></type> <name>fd</name></decl></parameter>,
						  <parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>waitEventSetIndex</name> <init>= <expr><name>WAIT_EVENT_SET_INDEX_NOT_INITIALIZED</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>savedContext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>waitEventSetIndex</name> <operator>=</operator>
			<call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>events</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>latch</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>user_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * We might be in an arbitrary memory context when the
		 * error is thrown and we should get back to one we had
		 * at PG_TRY() time, especially because we are not
		 * re-throwing the error.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savedContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* let the callers know about the failure */</comment>
		<expr_stmt><expr><name>waitEventSetIndex</name> <operator>=</operator> <name>WAIT_EVENT_SET_INDEX_FAILED</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>waitEventSetIndex</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusModifyWaitEvent is a wrapper around Postgres' ModifyWaitEvent().
 *
 * ModifyWaitEvent may throw hard errors. For example, when the underlying
 * socket for a connection is closed by the remote server and already
 * reflected by the OS, however Citus hasn't had a chance to get this
 * information. In that case, if replication factor is &gt;1, Citus can
 * failover to other nodes for executing the query. Even if replication
 * factor = 1, Citus can give much nicer errors.
 *
 * So CitusModifyWaitEvent simply puts ModifyWaitEvent into a PG_TRY/PG_CATCH
 * block in order to catch any hard errors, and returns this information to the
 * caller.
 */</comment>
<function><type><name>bool</name></type>
<name>CitusModifyWaitEvent</name><parameter_list>(<parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>set</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>Latch</name> <modifier>*</modifier></type><name>latch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>savedContext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ModifyWaitEvent</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>events</name></expr></argument>, <argument><expr><name>latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * We might be in an arbitrary memory context when the
		 * error is thrown and we should get back to one we had
		 * at PG_TRY() time, especially because we are not
		 * re-throwing the error.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savedContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* let the callers know about the failure */</comment>
		<expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>
</unit>
