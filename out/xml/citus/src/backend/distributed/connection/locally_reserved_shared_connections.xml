<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/connection/locally_reserved_shared_connections.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * locally_reserved_shared_connections.c
 *
 *   Keeps track of the number of reserved connections to remote nodes
 *   for this backend. The primary goal is to complement the logic
 *   implemented in shared_connections.c which aims to prevent excessive
 *   number of connections (typically &gt; max_connections) to any worker node.
 *   With this locally reserved connection stats, we enforce the same
 *   constraints considering these locally reserved shared connections.
 *
 *   To be more precise, shared connection stats are incremented only with two
 *   operations: (a) Establishing a connection to a remote node
 *               (b) Reserving connections, the logic that this
 *                   file implements.
 *
 *   Finally, as the name already implies, once a node has reserved a  shared
 *   connection, it is guaranteed to have the right to establish a connection
 *   to the given remote node when needed.
 *
 *   For COPY command, we use this fact to reserve connections to the remote nodes
 *   in the same order as the adaptive executor in order to prevent any resource
 *   starvations. We need to do this because COPY establishes connections when it
 *   receives a tuple that targets a remote node. This is a valuable optimization
 *   to prevent unnecessary connection establishments, which are pretty expensive.
 *   Instead, COPY command can reserve connections upfront, and utilize them when
 *   they are actually needed.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/locally_reserved_shared_connections.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/placement_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_connection_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESERVED_CONNECTION_COLUMNS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>


<comment type="block">/* session specific hash map*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>SessionLocalReservedConnections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Hash key for connection reservations
 */</comment>
<typedef>typedef <type><struct>struct <name>ReservedConnectionHashKey</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name><name>hostname</name><index>[<expr><name>MAX_NODE_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>port</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>databaseOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>userId</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReservedConnectionHashKey</name>;</typedef>

<comment type="block">/*
 * Hash entry for per worker information. The rules are as follows:
 *  - If there is no entry in the hash, we can make a reservation.
 *  - If usedReservation is false, we have a reservation that we can use.
 *  - If usedReservation is true, we used the reservation and cannot make more reservations.
 */</comment>
<typedef>typedef <type><struct>struct <name>ReservedConnectionHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>ReservedConnectionHashKey</name></type> <name>key</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>usedReservation</name></decl>;</decl_stmt>
}</block></struct></type> <name>ReservedConnectionHashEntry</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreAllReservedConnections</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name></decl></parameter>,
										<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ReservedConnectionHashEntry</name> <modifier>*</modifier></type> <name>AllocateOrGetReservedConnectionEntry</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hostName</name></decl></parameter>,
																		  <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>,
																		  <parameter><decl><type><name>Oid</name></type>
																		  <name>userId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
																		  <name>databaseOid</name></decl></parameter>,
																		  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureConnectionPossibilityForNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>EnsureConnectionPossibilityForNode</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>waitForConnection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>LocalConnectionReserveHashHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>LocalConnectionReserveHashCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_reserved_connection_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * citus_reserved_connection_stats returns all the avaliable information about all
 * the reserved connections. This function is used mostly for testing.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_reserved_connection_stats</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StoreAllReservedConnections</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StoreAllReservedConnections gets connections established from the current node
 * and inserts them into the given tuplestore.
 *
 * We don't need to enforce any access privileges as the number of backends
 * on any node is already visible on pg_stat_activity to all users.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreAllReservedConnections</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>RESERVED_CONNECTION_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNulls</name><index>[<expr><name>RESERVED_CONNECTION_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReservedConnectionHashEntry</name> <modifier>*</modifier></type><name>connectionEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SessionLocalReservedConnections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>connectionEntry</name> <operator>=</operator>
				<operator>(</operator><name>ReservedConnectionHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* get ready for the next tuple */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>isNulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isNulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>databaseOid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>databaseName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* database might have been dropped */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>connectionEntry</name><operator>-&gt;</operator><name>usedReservation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * InitializeLocallyReservedSharedConnections initializes the hashmap in
 * ConnectionContext.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeLocallyReservedSharedConnections</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>reservedConnectionInfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reservedConnectionInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>reservedConnectionInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>reservedConnectionInfo</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReservedConnectionHashKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>reservedConnectionInfo</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ReservedConnectionHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/*
	 * ConnectionContext is the session local memory context that is used for
	 * tracking remote connections.
	 */</comment>
	<expr_stmt><expr><name><name>reservedConnectionInfo</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>ConnectionContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>reservedConnectionInfo</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>LocalConnectionReserveHashHash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>reservedConnectionInfo</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>LocalConnectionReserveHashCompare</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_COMPARE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>SessionLocalReservedConnections</name> <operator>=</operator>
		<call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"citus session level reserved connections (host,port,database,user)"</literal></expr></argument>,
					<argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>reservedConnectionInfo</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *  CanUseReservedConnection returns true if we have already reserved at least
 *  one shared connection in this session that is not used.
 */</comment>
<function><type><name>bool</name></type>
<name>CanUseReservedConnection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userId</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>databaseOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReservedConnectionHashKey</name></type> <name>key</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>hostName</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>userId</name></name> <operator>=</operator> <name>userId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>nodePort</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>databaseOid</name></name> <operator>=</operator> <name>databaseOid</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReservedConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>=
		<expr><operator>(</operator><name>ReservedConnectionHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SessionLocalReservedConnections</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
													<argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <operator>!</operator><name>entry</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>usedReservation</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeallocateReservedConnections is responsible for two things. First, if the operation
 * has reserved a connection but not used, it gives back the connection back to the
 * shared memory pool. Second, for all cases, it deallocates the session local entry from
 * the hash.
 */</comment>
<function><type><name>void</name></type>
<name>DeallocateReservedConnections</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReservedConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SessionLocalReservedConnections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>ReservedConnectionHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>usedReservation</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have not used this reservation, make sure to clean-up from
			 * the shared memory as well.
			 */</comment>
			<expr_stmt><expr><call><name>DecrementSharedConnectionCounter</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* for completeness, set it to true */</comment>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>usedReservation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We cleaned up all the entries because we may not need reserved connections
		 * in the next iteration.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SessionLocalReservedConnections</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * MarkReservedConnectionUsed sets the local hash that the reservation is used.
 */</comment>
<function><type><name>void</name></type>
<name>MarkReservedConnectionUsed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userId</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>databaseOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReservedConnectionHashKey</name></type> <name>key</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>hostName</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>userId</name></name> <operator>=</operator> <name>userId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>nodePort</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>databaseOid</name></name> <operator>=</operator> <name>databaseOid</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReservedConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>=
		<expr><operator>(</operator><name>ReservedConnectionHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
			<argument><expr><name>SessionLocalReservedConnections</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BUG: untracked reserved connection"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set citus.max_shared_pool_size TO -1 to "</literal>
								<literal type="string">"disable reserved connection counters"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* a reservation can only be used once */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>usedReservation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>usedReservation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureConnectionPossibilityForRemotePrimaryNodes is a wrapper around
 * EnsureConnectionPossibilityForNodeList.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureConnectionPossibilityForRemotePrimaryNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * By using NoLock there is a tiny risk of that we miss to reserve a
	 * connection for a concurrently added node. However, that doesn't
	 * seem to cause any problems as none of the placements that we are
	 * going to access would be on the new node.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>primaryNodeList</name> <init>= <expr><call><name>ActivePrimaryRemoteNodeList</name><argument_list>(<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>EnsureConnectionPossibilityForNodeList</name><argument_list>(<argument><expr><name>primaryNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TryConnectionPossibilityForLocalPrimaryNode returns true if the primary
 * local node is in the metadata an we can reserve a connection for the node.
 * If not, the function returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>TryConnectionPossibilityForLocalPrimaryNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>nodeIsInMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>localNode</name> <init>=
		<expr><call><name>PrimaryNodeForGroup</name><argument_list>(<argument><expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeIsInMetadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>localNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the local node is not a primary node, we should not try to
		 * reserve a connection as there cannot be any shards.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>waitForConnection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>EnsureConnectionPossibilityForNode</name><argument_list>(<argument><expr><name>localNode</name></expr></argument>, <argument><expr><name>waitForConnection</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureConnectionPossibilityForNodeList reserves a shared connection
 * counter per node in the nodeList unless:
 *  - Reservation is possible/allowed (see IsReservationPossible())
 *  - there is at least one connection to the node so that we are guaranteed
 *    to get a connection
 *  - An earlier call already reserved a connection (e.g., we allow only a
 *    single reservation per backend)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureConnectionPossibilityForNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We sort the workerList because adaptive connection management
	 * (e.g., OPTIONAL_CONNECTION) requires any concurrent executions
	 * to wait for the connections in the same order to prevent any
	 * starvation. If we don't sort, we might end up with:
	 *      Execution 1: Get connection for worker 1, wait for worker 2
	 *      Execution 2: Get connection for worker 2, wait for worker 1
	 *
	 *  and, none could proceed. Instead, we enforce every execution establish
	 *  the required connections to workers in the same order.
	 */</comment>
	<expr_stmt><expr><name>nodeList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>CompareWorkerNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>nodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>waitForConnection</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>EnsureConnectionPossibilityForNode</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>waitForConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureConnectionPossibilityForNode reserves a shared connection
 * counter per node in the nodeList unless:
 *  - Reservation is not possible/allowed (see IsReservationPossible())
 *  - there is at least one connection to the node so that we are guranteed
 *    to get a connection
 *  - An earlier call already reserved a connection (e.g., we allow only a
 *    single reservation per backend)
 * - waitForConnection is false. When this is false, the function still tries
 *   to ensure connection possibility. If it fails (e.g., we
 *   reached max_shared_pool_size), it doesn't wait to get the connection. Instead,
 *   return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>EnsureConnectionPossibilityForNode</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>waitForConnection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsReservationPossible</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>userId</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>userName</name> <init>= <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>userId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ConnectionAvailableToNode</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
								  <argument><expr><name>userName</name></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The same user has already an active connection for the node. It
		 * means that the execution can use the same connection, so reservation
		 * is not necessary.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We are trying to be defensive here by ensuring that the required hash
	 * table entry can be allocated. The main goal is that we don't want to be
	 * in a situation where shared connection counter is incremented but not
	 * the local reserved counter due to out-of-memory.
	 *
	 * Note that shared connection stats operate on the shared memory, and we
	 * pre-allocate all the necessary memory. In other words, it would never
	 * throw out of memory error.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReservedConnectionHashEntry</name> <modifier>*</modifier></type><name>hashEntry</name> <init>=
		<expr><call><name>AllocateOrGetReservedConnectionEntry</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
											 <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>,
											 <argument><expr><name>userId</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have already reserved a connection for this user and database
		 * on the worker. We only allow a single reservation per
		 * transaction block. The reason is that the earlier command (either in
		 * a transaction block or a function call triggered by a single command)
		 * was able to reserve or establish a connection. That connection is
		 * guranteed to be available for us.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>waitForConnection</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Increment the shared counter, we may need to wait if there are
		 * no space left.
		 */</comment>
		<expr_stmt><expr><call><name>WaitLoopForSharedConnection</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>incremented</name> <init>=
			<expr><call><name>TryToIncrementSharedConnectionCounter</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
												  <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>incremented</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We could not reserve a connection. First, remove the entry from the
			 * hash. The reason is that we allow single reservation per transaction
			 * block and leaving the entry in the hash would be qualified as there is a
			 * reserved connection to the node.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>foundForRemove</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SessionLocalReservedConnections</name></expr></argument>, <argument><expr><name>hashEntry</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>foundForRemove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>foundForRemove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* locally mark that we have one connection reserved */</comment>
	<expr_stmt><expr><name><name>hashEntry</name><operator>-&gt;</operator><name>usedReservation</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsReservationPossible returns true if the state of the current
 * session is eligible for shared connection reservation.
 */</comment>
<function><type><name>bool</name></type>
<name>IsReservationPossible</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>GetMaxSharedPoolSize</name><argument_list>()</argument_list></call> <operator>==</operator> <name>DISABLE_CONNECTION_THROTTLING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection throttling disabled */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>UseConnectionPerPlacement</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For this case, we are not enforcing adaptive
		 * connection management anyway.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>SessionLocalReservedConnections</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is unexpected as SessionLocalReservedConnections hash table is
		 * created at startup. Still, let's be defensive.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AllocateReservedConectionEntry allocates the required entry in the hash
 * map by HASH_ENTER. The function throws an error if it cannot allocate
 * the entry.
 */</comment>
<function><type><specifier>static</specifier> <name>ReservedConnectionHashEntry</name> <modifier>*</modifier></type>
<name>AllocateOrGetReservedConnectionEntry</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hostName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userId</name></decl></parameter>,
									 <parameter><decl><type><name>Oid</name></type> <name>databaseOid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReservedConnectionHashKey</name></type> <name>key</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>hostName</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>userId</name></name> <operator>=</operator> <name>userId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>port</name></name> <operator>=</operator> <name>nodePort</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>databaseOid</name></name> <operator>=</operator> <name>databaseOid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Entering a new entry with HASH_ENTER flag is enough as it would
	 * throw out-of-memory error as it internally does palloc.
	 */</comment>
	<decl_stmt><decl><type><name>ReservedConnectionHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>=
		<expr><operator>(</operator><name>ReservedConnectionHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SessionLocalReservedConnections</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Until we reserve connection in the shared memory, we treat
		 * as if have used the reservation.
		 */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>usedReservation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LocalConnectionReserveHashHash is a utilty function to calculate hash of
 * ReservedConnectionHashKey.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>LocalConnectionReserveHashHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReservedConnectionHashKey</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>ReservedConnectionHashKey</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>hash</name> <init>= <expr><call><name>string_hash</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>userId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_combine</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>hash_uint32</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>databaseOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LocalConnectionReserveHashCompare is a utilty function to compare
 * ReservedConnectionHashKeys.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>LocalConnectionReserveHashCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>keysize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReservedConnectionHashKey</name> <modifier>*</modifier></type><name>ca</name> <init>= <expr><operator>(</operator><name>ReservedConnectionHashKey</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReservedConnectionHashKey</name> <modifier>*</modifier></type><name>cb</name> <init>= <expr><operator>(</operator><name>ReservedConnectionHashKey</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ca</name><operator>-&gt;</operator><name>port</name></name> <operator>!=</operator> <name><name>cb</name><operator>-&gt;</operator><name>port</name></name> <operator>||</operator>
		<name><name>ca</name><operator>-&gt;</operator><name>databaseOid</name></name> <operator>!=</operator> <name><name>cb</name><operator>-&gt;</operator><name>databaseOid</name></name> <operator>||</operator>
		<name><name>ca</name><operator>-&gt;</operator><name>userId</name></name> <operator>!=</operator> <name><name>cb</name><operator>-&gt;</operator><name>userId</name></name> <operator>||</operator>
		<call><name>strncmp</name><argument_list>(<argument><expr><name><name>ca</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
