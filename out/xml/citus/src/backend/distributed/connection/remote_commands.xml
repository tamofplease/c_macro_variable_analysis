<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/connection/remote_commands.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * remote_commands.c
 *   Helpers to make it easier to execute command on remote nodes.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/cancel_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/palloc.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Setting that controls how many bytes of COPY data libpq is allowed to buffer
 * internally before we force a flush.
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>RemoteCopyFlushThreshold</name> <init>= <expr><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/* GUC, determining whether statements sent to remote nodes are logged */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>LogRemoteCommands</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>GrepRemoteCommands</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ClearResultsInternal</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseErrors</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>discardWarnings</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FinishConnectionIO</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseInterrupts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WaitEventSet</name> <modifier>*</modifier></type> <name>BuildWaitEventSet</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier><modifier>*</modifier></type><name>allConnections</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>totalConnectionCount</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>pendingConnectionsStartIndex</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* simple helpers */</comment>

<comment type="block">/*
 * IsResponseOK checks whether the result is a successful one.
 */</comment>
<function><type><name>bool</name></type>
<name>IsResponseOK</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_SINGLE_TUPLE</name> <operator>||</operator> <name>resultStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator>
		<name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ForgetResults clears a connection from pending activity.
 *
 * Note that this might require network IO. If that's not acceptable, use
 * ClearResultsIfReady().
 *
 * ClearResults is variant of this function which can also raise errors.
 */</comment>
<function><type><name>void</name></type>
<name>ForgetResults</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ClearResults clears a connection from pending activity,
 * returns true if all pending commands return success. It raises
 * error if raiseErrors flag is set, any command fails and transaction
 * is marked critical.
 *
 * Note that this might require network IO. If that's not acceptable, use
 * ClearResultsIfReady().
 */</comment>
<function><type><name>bool</name></type>
<name>ClearResults</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseErrors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ClearResultsInternal</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ClearResultsDiscardWarnings does the same thing as ClearResults, but doesn't
 * emit warnings.
 */</comment>
<function><type><name>bool</name></type>
<name>ClearResultsDiscardWarnings</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseErrors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ClearResultsInternal</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ClearResultsInternal is used by ClearResults and ClearResultsDiscardWarnings.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ClearResultsInternal</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseErrors</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>discardWarnings</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * End any pending copy operation. Transaction will be marked
		 * as failed by the following part.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>discardWarnings</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>MarkRemoteTransactionFailed</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* an error happened, there is nothing we can do more */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_FATAL_ERROR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ClearResultsIfReady clears a connection from pending activity if doing
 * so does not require network IO. Returns true if successful, false
 * otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>ClearResultsIfReady</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgConn</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If busy, there might still be results already received and buffered
		 * by the OS. As connection is in non-blocking mode, we can check for
		 * that without blocking.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PQflush</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* write failed */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* some low-level failure */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* clearing would require blocking IO, return */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no more results available */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* only care about the status, can clear now */</comment>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator> <name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* in copy, can't reliably recover without blocking */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>resultStatus</name> <operator>==</operator> <name>PGRES_SINGLE_TUPLE</name> <operator>||</operator> <name>resultStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator>
			  <name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* an error occurred just when we were aborting */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check if there are more results to consume */</comment>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* report errors &amp; warnings */</comment>

<comment type="block">/*
 * Report libpq failure that's not associated with a result.
 */</comment>
<function><type><name>void</name></type>
<name>ReportConnectionError</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgConn</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>messageDetail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgConn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>messageDetail</name> <operator>=</operator> <call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>messageDetail</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>messageDetail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* give a similar messages to Postgres */</comment>
			<expr_stmt><expr><name>messageDetail</name> <operator>=</operator> <literal type="string">"connection not open"</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>messageDetail</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection to the remote node %s:%d failed with the "</literal>
								<literal type="string">"following error: %s"</literal></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>,
								<argument><expr><name>messageDetail</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection to the remote node %s:%d failed"</literal></expr></argument>,
								<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReportResultError reports libpq failure associated with a result.
 */</comment>
<function><type><name>void</name></type>
<name>ReportResultError</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* we release PQresult when throwing an error because the caller can't */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sqlStateString</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>messagePrimary</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>messageDetail</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>messageHint</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_HINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>messageContext</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_CONTEXT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>sqlState</name> <init>= <expr><name>ERRCODE_INTERNAL_ERROR</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sqlStateString</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sqlState</name> <operator>=</operator> <call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>sqlStateString</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>sqlStateString</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>sqlStateString</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>sqlStateString</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>sqlStateString</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the PGresult did not contain a message, the connection may provide a
		 * suitable top level one. At worst, this is an empty string.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>messagePrimary</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>messagePrimary</name> <operator>=</operator> <call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>sqlState</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>messagePrimary</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <ternary><condition><expr><name>messageDetail</name></expr> ?</condition><then>
						 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>messageDetail</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
						 <ternary><condition><expr><name>messageHint</name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>messageHint</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
						 <ternary><condition><expr><name>messageContext</name></expr> ?</condition><then> <expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>messageContext</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
						 <call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while executing command on %s:%d"</literal></expr></argument>,
									<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* *INDENT-ON* */</comment>

<comment type="block">/*
 * LogRemoteCommand logs commands send to remote nodes if
 * citus.log_remote_commands wants us to do so.
 */</comment>
<function><type><name>void</name></type>
<name>LogRemoteCommand</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LogRemoteCommands</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CommandMatchesLogGrepPattern</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"issuing %s"</literal></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"on server %s@%s:%d connectionId: %ld"</literal></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>user</name></name></expr></argument>,
							   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
							   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>connectionId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CommandMatchesLogGrepPattern returns true of the input command matches
 * the pattern specified by citus.grep_remote_commands.
 *
 * If citus.grep_remote_commands set to an empty string, all commands are
 * considered as a match.
 */</comment>
<function><type><name>bool</name></type>
<name>CommandMatchesLogGrepPattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>GrepRemoteCommands</name> <operator>&amp;&amp;</operator> <call><name>strnlen</name><argument_list>(<argument><expr><name>GrepRemoteCommands</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>boolDatum</name> <init>=
			<expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>textlike</name></expr></argument>, <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>GrepRemoteCommands</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>boolDatum</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* wrappers around libpq functions, with command logging support */</comment>


<comment type="block">/*
 * ExecuteCriticalRemoteCommandList calls ExecuteCriticalRemoteCommand for every
 * command in the commandList.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteCriticalRemoteCommandList</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteCriticalRemoteCommand executes a remote command that is critical
 * to the transaction. If the command fails then the transaction aborts.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteCriticalRemoteCommand</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteRemoteCommandInConnectionList executes a remote command, on all connections
 * given in the list, that is critical to the transaction. If the command fails then
 * the transaction aborts.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteRemoteCommandInConnectionList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeConnectionList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>nodeConnectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Process the result */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connection</argument>, <argument>nodeConnectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteOptionalRemoteCommand executes a remote command. If the command fails a WARNING
 * is emitted but execution continues.
 *
 * could return 0, QUERY_SEND_FAILED, or RESPONSE_NOT_OKAY
 * result is only set if there was no error
 */</comment>
<function><type><name>int</name></type>
<name>ExecuteOptionalRemoteCommand</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
							 <parameter><decl><type><name>PGresult</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>querySent</name> <init>= <expr><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>querySent</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>QUERY_SEND_FAILED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>localResult</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>localResult</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>localResult</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>localResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>RESPONSE_NOT_OKAY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * store result if result has been set, when the user is not interested in the result
	 * a NULL pointer could be passed and the result will be cleared.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>localResult</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>localResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>RESPONSE_OKAY</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SendRemoteCommandParams is a PQsendQueryParams wrapper that logs remote commands,
 * and accepts a MultiConnection instead of a plain PGconn. It makes sure it can
 * send commands asynchronously without blocking (at the potential expense of
 * an additional memory allocation). The command string can only include a single
 * command since PQsendQueryParams() supports only that.
 */</comment>
<function><type><name>int</name></type>
<name>SendRemoteCommandParams</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>parameterCount</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Oid</name> <modifier>*</modifier></type><name>parameterTypes</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>parameterValues</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>binaryResults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgConn</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LogRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Don't try to send command if connection is entirely gone
	 * (PQisnonblocking() would crash).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgConn</name> <operator>||</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>PQsendQueryParams</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>parameterCount</name></expr></argument>, <argument><expr><name>parameterTypes</name></expr></argument>,
							   <argument><expr><name>parameterValues</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name>binaryResults</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SendRemoteCommand is a PQsendQuery wrapper that logs remote commands, and
 * accepts a MultiConnection instead of a plain PGconn. It makes sure it can
 * send commands asynchronously without blocking (at the potential expense of
 * an additional memory allocation). The command string can include multiple
 * commands since PQsendQuery() supports that.
 */</comment>
<function><type><name>int</name></type>
<name>SendRemoteCommand</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgConn</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LogRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Don't try to send command if connection is entirely gone
	 * (PQisnonblocking() would crash).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgConn</name> <operator>||</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReadFirstColumnAsText reads the first column of result tuples from the given
 * PGresult struct and returns them in a StringInfo list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ReadFirstColumnAsText</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>queryResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>resultRowList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>rowCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>status</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rowCount</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>int64</name></type> <name>rowIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rowIndex</name> <operator>&lt;</operator> <name>rowCount</name></expr>;</condition> <incr><expr><name>rowIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rowValue</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>, <argument><expr><name>rowIndex</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>rowValueString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>rowValueString</name></expr></argument>, <argument><expr><name>rowValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>resultRowList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>resultRowList</name></expr></argument>, <argument><expr><name>rowValueString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>resultRowList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRemoteCommandResult is a wrapper around PQgetResult() that handles interrupts.
 *
 * If raiseInterrupts is true and an interrupt arrives, e.g. the query is
 * being cancelled, CHECK_FOR_INTERRUPTS() will be called, which then throws
 * an error.
 *
 * If raiseInterrupts is false and an interrupt arrives that'd otherwise raise
 * an error, GetRemoteCommandResult returns NULL, and the transaction is
 * marked as having failed. While that's not a perfect way to signal failure,
 * callers will usually treat that as an error, and it's easy to use.
 *
 * Handling of interrupts is important to allow queries being cancelled while
 * waiting on remote nodes. In a distributed deadlock scenario cancelling
 * might be the only way to resolve the deadlock.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>GetRemoteCommandResult</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseInterrupts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgConn</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Short circuit tests around the more expensive parts of this
	 * routine. This'd also trigger a return in the, unlikely, case of a
	 * failed/nonexistant connection.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FinishConnectionIO</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* some error(s) happened while doing the I/O, signal the callers */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>PQmakeEmptyPGresult</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>, <argument><expr><name>PGRES_FATAL_ERROR</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* no IO should be necessary to get result */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PutRemoteCopyData is a wrapper around PQputCopyData() that handles
 * interrupts.
 *
 * Returns false if PQputCopyData() failed, true otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>PutRemoteCopyData</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgConn</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>allowInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>copyState</name> <init>= <expr><call><name>PQputCopyData</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>copyState</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * PQputCopyData may have queued up part of the data even if it managed
	 * to send some of it succesfully. We provide back pressure by waiting
	 * until the socket is writable to prevent the internal libpq buffers
	 * from growing excessively.
	 *
	 * We currently allow the internal buffer to grow to 8MB before
	 * providing back pressure based on experimentation that showed
	 * throughput get worse at 4MB and lower due to the number of CPU
	 * cycles spent in networking system calls.
	 */</comment>

	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>copyBytesWrittenSinceLastFlush</name></name> <operator>+=</operator> <name>nbytes</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>connection</name><operator>-&gt;</operator><name>copyBytesWrittenSinceLastFlush</name></name> <operator>&gt;</operator> <name>RemoteCopyFlushThreshold</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>copyBytesWrittenSinceLastFlush</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><call><name>FinishConnectionIO</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>allowInterrupts</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PutRemoteCopyEnd is a wrapper around PQputCopyEnd() that handles
 * interrupts.
 *
 * Returns false if PQputCopyEnd() failed, true otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>PutRemoteCopyEnd</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errormsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgConn</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>allowInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>copyState</name> <init>= <expr><call><name>PQputCopyEnd</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>, <argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>copyState</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* see PutRemoteCopyData() */</comment>

	<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>copyBytesWrittenSinceLastFlush</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>FinishConnectionIO</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>allowInterrupts</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FinishConnectionIO performs pending IO for the connection, while accepting
 * interrupts.
 *
 * See GetRemoteCommandResult() for documentation of interrupt handling
 * behaviour.
 *
 * Returns true if IO was successfully completed, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FinishConnectionIO</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseInterrupts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>pgConn</name> <init>= <expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQisnonblocking</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>raiseInterrupts</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* perform the necessary IO */</comment>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>waitFlags</name> <init>= <expr><name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_LATCH_SET</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* try to send all pending data */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>sendStatus</name> <init>= <expr><call><name>PQflush</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if sending failed, there's nothing more we can do */</comment>
		<if_stmt><if>if <condition>(<expr><name>sendStatus</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>sendStatus</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>waitFlags</name> <operator>|=</operator> <name>WL_SOCKET_WRITEABLE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* if reading fails, there's not much we can do */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>pgConn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>waitFlags</name> <operator>|=</operator> <name>WL_SOCKET_READABLE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>waitFlags</name> <operator>&amp;</operator> <operator>(</operator><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no IO necessary anymore, we're done */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>waitFlags</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PG_WAIT_EXTENSION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"postmaster was shut down, exiting"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* if allowed raise errors */</comment>
			<if_stmt><if>if <condition>(<expr><name>raiseInterrupts</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If raising errors allowed, or called within in a section with
			 * interrupts held, return instead, and mark the transaction as
			 * failed.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsHoldOffCancellationReceived</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>connection</name><operator>-&gt;</operator><name>remoteTransaction</name><operator>.</operator><name>transactionFailed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WaitForAllConnections blocks until all connections in the list are no
 * longer busy, meaning the pending command has either finished or failed.
 */</comment>
<function><type><name>void</name></type>
<name>WaitForAllConnections</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseInterrupts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>totalConnectionCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>pendingConnectionsStartIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>connectionIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier><modifier>*</modifier></type><name>allConnections</name> <init>=
		<expr><call><name>palloc</name><argument_list>(<argument><expr><name>totalConnectionCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MultiConnection</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>events</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>totalConnectionCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WaitEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>connectionReady</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>totalConnectionCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* convert connection list to an array such that we can move items around */</comment>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connectionItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>connectionItem</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>allConnections</name><index>[<expr><name>connectionIndex</name></expr>]</index></name> <operator>=</operator> <name>connectionItem</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>connectionReady</name><index>[<expr><name>connectionIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>connectionIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* make an initial pass to check for failed and idle connections */</comment>
	<for>for <control>(<init><expr><name>connectionIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>connectionIndex</name> <operator>&lt;</operator> <name>totalConnectionCount</name></expr>;</condition> <incr><expr><name>connectionIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>allConnections</name><index>[<expr><name>connectionIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name> <operator>||</operator>
			<operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* connection is already done; keep non-ready connections at the end */</comment>
			<expr_stmt><expr><name><name>allConnections</name><index>[<expr><name>connectionIndex</name></expr>]</index></name> <operator>=</operator>
				<name><name>allConnections</name><index>[<expr><name>pendingConnectionsStartIndex</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pendingConnectionsStartIndex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>rebuildWaitEventSet</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>pendingConnectionsStartIndex</name> <operator>&lt;</operator> <name>totalConnectionCount</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>cancellationReceived</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>eventIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>long</name></type> <name>timeout</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>pendingConnectionCount</name> <init>= <expr><name>totalConnectionCount</name> <operator>-</operator>
										 <name>pendingConnectionsStartIndex</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* rebuild the WaitEventSet whenever connections are ready */</comment>
			<if_stmt><if>if <condition>(<expr><name>rebuildWaitEventSet</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>waitEventSet</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>waitEventSet</name> <operator>=</operator> <call><name>BuildWaitEventSet</name><argument_list>(<argument><expr><name>allConnections</name></expr></argument>, <argument><expr><name>totalConnectionCount</name></expr></argument>,
												 <argument><expr><name>pendingConnectionsStartIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>rebuildWaitEventSet</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* wait for I/O events */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>eventCount</name> <init>= <expr><call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>events</name></expr></argument>,
											  <argument><expr><name>pendingConnectionCount</name></expr></argument>,
											  <argument><expr><name>WAIT_EVENT_CLIENT_READ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* process I/O events */</comment>
			<for>for <control>(<init>;</init> <condition><expr><name>eventIndex</name> <operator>&lt;</operator> <name>eventCount</name></expr>;</condition> <incr><expr><name>eventIndex</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>event</name> <init>= <expr><operator>&amp;</operator><name><name>events</name><index>[<expr><name>eventIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>connectionIsReady</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"postmaster was shut down, exiting"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>raiseInterrupts</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsHoldOffCancellationReceived</name><argument_list>()</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Break out of event loop immediately in case of cancellation.
						 * We cannot use "return" here inside a PG_TRY() block since
						 * then the exception stack won't be reset.
						 */</comment>
						<expr_stmt><expr><name>cancellationReceived</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><operator>(</operator><name>MultiConnection</name> <operator>*</operator><operator>)</operator> <name><name>event</name><operator>-&gt;</operator><name>user_data</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>WL_SOCKET_WRITEABLE</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type> <name>sendStatus</name> <init>= <expr><call><name>PQflush</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>sendStatus</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* send failed, done with this connection */</comment>
						<expr_stmt><expr><name>connectionIsReady</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>sendStatus</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* done writing, only wait for read events */</comment>
						<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>=
							<expr><call><name>CitusModifyWaitEvent</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name><name>event</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>,
												 <argument><expr><name>WL_SOCKET_READABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
											<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection establishment for "</literal>
												   <literal type="string">"node %s:%d failed"</literal></expr></argument>,
												   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
												   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>,</operator>
											<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check both the local and remote "</literal>
													<literal type="string">"server logs for the connection "</literal>
													<literal type="string">"establishment errors."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Check whether the connection is done is the socket is either readable
				 * or writable. If it was only writable, we performed a PQflush which
				 * might have read from the socket, meaning we may not see the socket
				 * becoming readable again, so better to check it now.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>event</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <operator>(</operator><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type> <name>receiveStatus</name> <init>= <expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>receiveStatus</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* receive failed, done with this connection */</comment>
						<expr_stmt><expr><name>connectionIsReady</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* result was received */</comment>
						<expr_stmt><expr><name>connectionIsReady</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>connectionIsReady</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * All pending connections are kept at the end of the allConnections
					 * array and the connectionReady array matches the allConnections
					 * array. The wait event set corresponds to the pending connections
					 * subarray so we can get the index in the allConnections array by
					 * taking the event index + the offset of the subarray.
					 */</comment>
					<expr_stmt><expr><name>connectionIndex</name> <operator>=</operator> <name><name>event</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <name>pendingConnectionsStartIndex</name></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>connectionReady</name><index>[<expr><name>connectionIndex</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<comment type="block">/*
					 * When a connection is ready, we should build a new wait event
					 * set that excludes this connection.
					 */</comment>
					<expr_stmt><expr><name>rebuildWaitEventSet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>cancellationReceived</name></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* move non-ready connections to the back of the array */</comment>
			<for>for <control>(<init><expr><name>connectionIndex</name> <operator>=</operator> <name>pendingConnectionsStartIndex</name></expr>;</init>
				 <condition><expr><name>connectionIndex</name> <operator>&lt;</operator> <name>totalConnectionCount</name></expr>;</condition> <incr><expr><name>connectionIndex</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>connectionReady</name><index>[<expr><name>connectionIndex</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Replace the ready connection with a connection from
					 * the start of the pending connections subarray. This
					 * may be the connection itself, in which case this is
					 * a noop.
					 */</comment>
					<expr_stmt><expr><name><name>allConnections</name><index>[<expr><name>connectionIndex</name></expr>]</index></name> <operator>=</operator>
						<name><name>allConnections</name><index>[<expr><name>pendingConnectionsStartIndex</name></expr>]</index></name></expr>;</expr_stmt>

					<comment type="block">/* offset of the pending connections subarray is now 1 higher */</comment>
					<expr_stmt><expr><name>pendingConnectionsStartIndex</name><operator>++</operator></expr>;</expr_stmt>

					<comment type="block">/*
					 * We've moved a pending connection into this position,
					 * so we must reset the ready flag. Otherwise, we'd
					 * falsely interpret it as ready in the next round.
					 */</comment>
					<expr_stmt><expr><name><name>connectionReady</name><index>[<expr><name>connectionIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></while>

		<if_stmt><if>if <condition>(<expr><name>waitEventSet</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>waitEventSet</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>allConnections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connectionReady</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* make sure the epoll file descriptor is always closed */</comment>
		<if_stmt><if>if <condition>(<expr><name>waitEventSet</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>waitEventSet</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>allConnections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connectionReady</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BuildWaitEventSet creates a WaitEventSet for the given array of connections
 * which can be used to wait for any of the sockets to become read-ready or
 * write-ready.
 */</comment>
<function><type><specifier>static</specifier> <name>WaitEventSet</name> <modifier>*</modifier></type>
<name>BuildWaitEventSet</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier><modifier>*</modifier></type><name>allConnections</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>totalConnectionCount</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>pendingConnectionsStartIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>pendingConnectionCount</name> <init>= <expr><name>totalConnectionCount</name> <operator>-</operator> <name>pendingConnectionsStartIndex</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * subtract 3 to make room for WL_POSTMASTER_DEATH, WL_LATCH_SET, and
	 * pgwin32_signal_event.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingConnectionCount</name> <operator>&gt;</operator> <name>FD_SETSIZE</name> <operator>-</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pendingConnectionCount</name> <operator>=</operator> <name>FD_SETSIZE</name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* allocate pending connections + 2 for the signal latch and postmaster death */</comment>
	<comment type="block">/* (CreateWaitEventSet makes room for pgwin32_signal_event automatically) */</comment>
	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitEventSet</name> <init>= <expr><call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
													<argument><expr><name>pendingConnectionCount</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>connectionIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>connectionIndex</name> <operator>&lt;</operator> <name>pendingConnectionCount</name></expr>;</condition>
		 <incr><expr><name>connectionIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>allConnections</name><index>[<expr><name>pendingConnectionsStartIndex</name> <operator>+</operator>
													 <name>connectionIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Always start by polling for both readability (server sent bytes)
		 * and writeability (server is ready to receive bytes).
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>eventMask</name> <init>= <expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_SOCKET_WRITEABLE</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>waitEventSetIndex</name> <init>=
			<expr><call><name>CitusAddWaitEventSetToSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>eventMask</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>connection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>waitEventSetIndex</name> <operator>==</operator> <name>WAIT_EVENT_SET_INDEX_FAILED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection establishment for node %s:%d failed"</literal></expr></argument>,
								   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Check both the local and remote server logs for the "</literal>
									<literal type="string">"connection establishment errors."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Put the wait events for the signal latch and postmaster death at the end such that
	 * event index + pendingConnectionsStartIndex = the connection index in the array.
	 */</comment>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>waitEventSet</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>waitEventSet</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SendCancelationRequest sends a cancelation request on the given connection.
 * Return value indicates whether the cancelation request was sent successfully.
 */</comment>
<function><type><name>bool</name></type>
<name>SendCancelationRequest</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>errorBuffer</name><index>[<expr><name>ERROR_BUFFER_SIZE</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PGcancel</name> <modifier>*</modifier></type><name>cancelObject</name> <init>= <expr><call><name>PQgetCancel</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cancelObject</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this can happen if connection is invalid */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>cancelSent</name> <init>= <expr><call><name>PQcancel</name><argument_list>(<argument><expr><name>cancelObject</name></expr></argument>, <argument><expr><name>errorBuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errorBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cancelSent</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not issue cancel request"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Client error: %s"</literal></expr></argument>, <argument><expr><name>errorBuffer</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>cancelObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cancelSent</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EvaluateSingleQueryResult gets the query result from connection and returns
 * true if the query is executed successfully, false otherwise. A query result
 * or an error message is returned in queryResultString. The function requires
 * that the query returns a single column/single row result. It returns an
 * error otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>EvaluateSingleQueryResult</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>queryResult</name></decl></parameter>,
						  <parameter><decl><type><name>StringInfo</name></type> <name>queryResultString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>commandStatus</name> <init>= <expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>commandStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>ntuples</name> <init>= <expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>nfields</name> <init>= <expr><call><name>PQnfields</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* error if query returns more than 1 rows, or more than 1 fields */</comment>
		<if_stmt><if>if <condition>(<expr><name>nfields</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>,
							 <argument><expr><literal type="string">"expected a single column in query target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ntuples</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>,
							 <argument><expr><literal type="string">"expected a single row in query result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>row</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>column</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryResultValue</name> <init>= <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>queryResultValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>success</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>StoreErrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>queryResultString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StoreErrorMessage gets the error message from connection and stores it
 * in queryResultString. It should be called only when error is present
 * otherwise it would return a default error message.
 */</comment>
<function><type><name>void</name></type>
<name>StoreErrorMessage</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>queryResultString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errorMessage</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>errorMessage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* copy the error message to a writable memory */</comment>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>firstNewlineIndex</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* trim the error message at the line break */</comment>
		<if_stmt><if>if <condition>(<expr><name>firstNewlineIndex</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>firstNewlineIndex</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* put a default error message if no error message is reported */</comment>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"An error occurred while running the query"</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>queryResultString</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsSettingSafeToPropagate returns whether a SET LOCAL is safe to propagate.
 *
 * We exclude settings that are highly specific to the client or session and also
 * ban propagating the citus.propagate_set_commands setting (not for correctness,
 * more to avoid confusion).
 */</comment>
<function><type><name>bool</name></type>
<name>IsSettingSafeToPropagate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if this list grows considerably we should switch to bsearch */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>skipSettings</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="string">"application_name"</literal></expr>,
		<expr><literal type="string">"citus.propagate_set_commands"</literal></expr>,
		<expr><literal type="string">"client_encoding"</literal></expr>,
		<expr><literal type="string">"exit_on_error"</literal></expr>,
		<expr><literal type="string">"max_stack_depth"</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>Index</name></type> <name>settingIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>settingIndex</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>skipSettings</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>settingIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>skipSettings</name><index>[<expr><name>settingIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
