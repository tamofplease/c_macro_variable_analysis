<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/planner/multi_explain.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * multi_explain.c
 *	  Citus explain support.
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/createas.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_depended_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/connection_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/combine_query_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/recursive_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/placement_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuple_destination.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tuplestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/jsonbutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tstoreReceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/instr_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/dest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>


<comment type="block">/* Config variables that enable printing distributed query plans */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>ExplainDistributedQueries</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ExplainAllTasks</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ExplainAnalyzeSortMethod</name> <init>= <expr><name>EXPLAIN_ANALYZE_SORT_BY_TIME</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * If enabled, EXPLAIN ANALYZE output &amp; other statistics of last worker task
 * are saved in following variables.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>SavedExplainPlan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>SavedExecutionDurationMillisec</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* struct to save explain flags */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>bool</name></type> <name>verbose</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>costs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>buffers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>timing</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>summary</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExplainFormat</name></type> <name>format</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExplainOptions</name>;</typedef>


<comment type="block">/* EXPLAIN flags of current distributed explain */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ExplainOptions</name></type> <name>CurrentDistributedQueryExplainOptions</name> <init>= <expr><block>{
	<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Result for a single remote EXPLAIN command */</comment>
<typedef>typedef <type><struct>struct <name>RemoteExplainPlan</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>placementIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>explainOutputList</name></decl>;</decl_stmt>
}</block></struct></type> <name>RemoteExplainPlan</name>;</typedef>


<comment type="block">/*
 * ExplainAnalyzeDestination is internal representation of a TupleDestination
 * which collects EXPLAIN ANALYZE output after the main query is run.
 */</comment>
<typedef>typedef <type><struct>struct <name>ExplainAnalyzeDestination</name>
<block>{
	<decl_stmt><decl><type><name>TupleDestination</name></type> <name>pub</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>originalTask</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>originalTaskDestination</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>lastSavedExplainAnalyzeTupDesc</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExplainAnalyzeDestination</name>;</typedef>


<comment type="block">/* Explain functions for distributed queries */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainSubPlans</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainJob</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>, <parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
					   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainMapMergeJob</name><parameter_list>(<parameter><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainTaskList</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
							<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RemoteExplainPlan</name> <modifier>*</modifier></type> <name>RemoteExplain</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type>
										 <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RemoteExplainPlan</name> <modifier>*</modifier></type> <name>GetSavedRemoteExplain</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RemoteExplainPlan</name> <modifier>*</modifier></type> <name>FetchRemoteExplainFromWorkers</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
														 <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainTask</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>, <parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>placementIndex</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>explainOutputList</name></decl></parameter>,
						<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainTaskPlacement</name><parameter_list>(<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>explainOutputList</name></decl></parameter>,
								 <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>BuildRemoteExplainQuery</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>ExplainFormatStr</name><parameter_list>(<parameter><decl><type><name>ExplainFormat</name></type> <name>format</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainWorkerPlan</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedStmt</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
							  <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
							  <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>instr_time</name> <modifier>*</modifier></type><name>planduration</name></decl></parameter>,
							  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>executionDurationMillisec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ExplainFormat</name></type> <name>ExtractFieldExplainFormat</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>jsonbDoc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fieldName</name></decl></parameter>,
											   <parameter><decl><type><name>ExplainFormat</name></type> <name>defaultValue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDestination</name> <modifier>*</modifier></type> <name>CreateExplainAnlyzeDestination</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>,
														 <parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>taskDest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainAnalyzeDestPutTuple</name><parameter_list>(<parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>placementIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queryNumber</name></decl></parameter>,
									   <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tupleLibpqSize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>ExplainAnalyzeDestTupleDescForQuery</name><parameter_list>(<parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type>
													 <name>queryNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>WrapQueryForExplainAnalyze</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
										 <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>FetchPlanQueryForExplainAnalyze</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
											  <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>ParameterResolutionSubquery</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>SplitString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>delimiter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxLength</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Static Explain functions copied from explain.c */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainOneQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>,
							<parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
							<parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>elapsed_time</name><parameter_list>(<parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>starttime</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExplainPropertyBytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>TaskReceivedTupleData</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShowReceivedTupleData</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_last_saved_explain_analyze</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_save_query_explain_analyze</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * CitusExplainScan is a custom scan explain callback function which is used to
 * print explain information of a Citus plan which includes both combine query and
 * distributed plan.
 */</comment>
<function><type><name>void</name></type>
<name>CitusExplainScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ExplainState</name></name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><operator>(</operator><name>CitusScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name> <init>= <expr><call><name>ScanStateGetExecutorState</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name> <init>= <expr><name><name>executorState</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ExplainDistributedQueries</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"explain statements for distributed queries "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"are not enabled\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * ALTER TABLE statements are not explained by postgres. However ALTER TABLE statements
	 * may trigger SELECT statements causing explain hook to run. This situation causes a crash in a worker.
	 * Therefore we will detect if we are explaining a triggered query when we are processing
	 * an ALTER TABLE statement and stop explain in this situation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AlterTableInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Citus Explain Scan"</literal></expr></argument>,
							<argument><expr><literal type="string">"Explain for triggered constraint validation queries during ALTER TABLE commands are not supported by Citus"</literal></expr></argument>,
							<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Distributed Query"</literal></expr></argument>, <argument><expr><literal type="string">"Distributed Query"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * ExplainOnePlan function of postgres might be called in this codepath.
	 * It requires an ActiveSnapshot being set. Make sure to make ActiveSnapshot available before calling into
	 * Citus Explain functions.
	 */</comment>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name><name>executorState</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>subPlanList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainSubPlans</name><argument_list>(<argument><expr><name>distributedPlan</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainJob</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>, <argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>workerJob</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Distributed Query"</literal></expr></argument>, <argument><expr><literal type="string">"Distributed Query"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * NonPushableInsertSelectExplainScan is a custom scan explain callback function
 * which is used to print explain information of a Citus plan for an INSERT INTO
 * distributed_table SELECT ... query that is evaluated on the coordinator or
 * uses repartitioning.
 */</comment>
<function><type><name>void</name></type>
<name>NonPushableInsertSelectExplainScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
								   <parameter><decl><type><name><name>struct</name> <name>ExplainState</name></name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><operator>(</operator><name>CitusScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>distributedPlan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name> <init>= <expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>insertSelectQuery</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>selectRte</name> <init>= <expr><call><name>ExtractSelectRangeTableEntry</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create a copy because ExplainOneQuery can modify the query, and later
	 * executions of prepared statements might require it. See
	 * https://github.com/citusdata/citus/issues/3947 for what can happen.
	 */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryCopy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>repartition</name> <init>= <expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>insertSelectMethod</name></name> <operator>==</operator> <name>INSERT_SELECT_REPARTITION</name></expr></init></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"EXPLAIN ANALYZE is currently not supported for INSERT "</literal>
							   <literal type="string">"... SELECT commands %s"</literal></expr></argument>,
							   <argument><expr><ternary><condition><expr><name>repartition</name></expr> ?</condition><then> <expr><literal type="string">"with repartitioning"</literal></expr> </then><else>: <expr><literal type="string">"via coordinator"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>repartition</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"INSERT/SELECT method"</literal></expr></argument>, <argument><expr><literal type="string">"repartition"</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"INSERT/SELECT method"</literal></expr></argument>, <argument><expr><literal type="string">"pull to coordinator"</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Select Query"</literal></expr></argument>, <argument><expr><literal type="string">"Select Query"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* explain the inner SELECT query */</comment>
	<decl_stmt><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * With PG14, we need to provide a string here,
	 * for now we put an empty string, which is valid according to postgres.
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExplainOneQuery</name><argument_list>(<argument><expr><name>queryCopy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Select Query"</literal></expr></argument>, <argument><expr><literal type="string">"Select Query"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainSubPlans generates EXPLAIN output for subplans for CTEs
 * and complex subqueries. Because the planning for these queries
 * is done along with the top-level plan, we cannot determine the
 * planning time and set it to 0.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainSubPlans</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>subPlanCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>planId</name> <init>= <expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planId</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Subplans"</literal></expr></argument>, <argument><expr><literal type="string">"Subplans"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>subPlanCell</argument>, <argument>distributedPlan-&gt;subPlanList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DistributedSubPlan</name> <modifier>*</modifier></type><name>subPlan</name> <init>= <expr><operator>(</operator><name>DistributedSubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subPlanCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>subPlan</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * With PG14, we need to provide a string here,
		 * for now we put an empty string, which is valid according to postgres.
		 */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>instr_time</name></type> <name>planduration</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferUsage</name></type> <name>bufusage_start</name></decl>,
					<decl><type ref="prev"/><name>bufusage</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bufusage_start</name> <operator>=</operator> <name>pgBufferUsage</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><call><name>GenerateResultId</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name><name>subPlan</name><operator>-&gt;</operator><name>subPlanId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"-&gt;  Distributed Subplan %s\n"</literal></expr></argument>, <argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Subplan"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Subplan Duration"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>, <argument><expr><name><name>subPlan</name><operator>-&gt;</operator><name>durationMillisecs</name></name></expr></argument>,
									 <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ExplainPropertyBytes</name><argument_list>(<argument><expr><literal type="string">"Intermediate Data Size"</literal></expr></argument>,
								 <argument><expr><name><name>subPlan</name><operator>-&gt;</operator><name>bytesSentPerWorker</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>StringInfo</name></type> <name>destination</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>subPlan</name><operator>-&gt;</operator><name>remoteWorkerCount</name></name> <operator>&amp;&amp;</operator> <name><name>subPlan</name><operator>-&gt;</operator><name>writeLocalFile</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"Send to %d nodes, write locally"</literal></expr></argument>,
								 <argument><expr><name><name>subPlan</name><operator>-&gt;</operator><name>remoteWorkerCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>subPlan</name><operator>-&gt;</operator><name>writeLocalFile</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"Write locally"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><literal type="string">"Send to %d nodes"</literal></expr></argument>,
								 <argument><expr><name><name>subPlan</name><operator>-&gt;</operator><name>remoteWorkerCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Result destination"</literal></expr></argument>, <argument><expr><name><name>destination</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>INSTR_TIME_SET_ZERO</name><argument_list>(<argument><expr><name>planduration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* calc differences of buffer counters. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BufferUsageAccumDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgBufferUsage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bufusage_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"PlannedStmt"</literal></expr></argument>, <argument><expr><literal type="string">"PlannedStmt"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExplainOnePlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>planduration</name></expr></argument>,
					   <argument><expr><operator>(</operator><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>bufusage</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"PlannedStmt"</literal></expr></argument>, <argument><expr><literal type="string">"PlannedStmt"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Subplan"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Subplans"</literal></expr></argument>, <argument><expr><literal type="string">"Subplans"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainPropertyBytes formats bytes in a human readable way by using
 * pg_size_pretty.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainPropertyBytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qlabel</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>textDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_size_pretty</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><name>qlabel</name></expr></argument>, <argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>textDatum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShowReceivedTupleData returns true if explain should show received data.
 * This is only the case when using EXPLAIN ANALYZE on queries that return
 * rows.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShowReceivedTupleData</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupDesc</name> <init>= <expr><call><name>ScanStateGetTupleDescriptor</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name>tupDesc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainJob shows the EXPLAIN output for a Job in the physical plan of
 * a distributed query by showing the remote EXPLAIN for the first task,
 * or all tasks if citus.explain_all_tasks is on.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainJob</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>, <parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
		   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>dependentJobList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>dependentJobCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>dependentJobCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>taskCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Job"</literal></expr></argument>, <argument><expr><literal type="string">"Job"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Task Count"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>taskCount</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ShowReceivedTupleData</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>totalReceivedTupleDataForAllTasks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>totalReceivedTupleDataForAllTasks</name> <operator>+=</operator> <call><name>TaskReceivedTupleData</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>ExplainPropertyBytes</name><argument_list>(<argument><expr><literal type="string">"Tuple data received from nodes"</literal></expr></argument>,
							 <argument><expr><name>totalReceivedTupleDataForAllTasks</name></expr></argument>,
							 <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dependentJobCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Tasks Shown"</literal></expr></argument>, <argument><expr><literal type="string">"None, not supported for re-partition "</literal>
										   <literal type="string">"queries"</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>ExplainAllTasks</name> <operator>||</operator> <name>taskCount</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Tasks Shown"</literal></expr></argument>, <argument><expr><literal type="string">"All"</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>tasksShownText</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>tasksShownText</name></expr></argument>, <argument><expr><literal type="string">"One of %d"</literal></expr></argument>, <argument><expr><name>taskCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Tasks Shown"</literal></expr></argument>, <argument><expr><name><name>tasksShownText</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We cannot fetch EXPLAIN plans for jobs that have dependencies, since the
	 * intermediate tables have not been created.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dependentJobCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Tasks"</literal></expr></argument>, <argument><expr><literal type="string">"Tasks"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExplainTaskList</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Tasks"</literal></expr></argument>, <argument><expr><literal type="string">"Tasks"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Dependent Jobs"</literal></expr></argument>, <argument><expr><literal type="string">"Dependent Jobs"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* show explain output for dependent jobs, if any */</comment>
		<macro><name>foreach</name><argument_list>(<argument>dependentJobCell</argument>, <argument>dependentJobList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>dependentJob</name> <init>= <expr><operator>(</operator><name>Job</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>dependentJobCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>dependentJob</name></expr></argument>, <argument><expr><name>MapMergeJob</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainMapMergeJob</name><argument_list>(<argument><expr><operator>(</operator><name>MapMergeJob</name> <operator>*</operator><operator>)</operator> <name>dependentJob</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Dependent Jobs"</literal></expr></argument>, <argument><expr><literal type="string">"Dependent Jobs"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Job"</literal></expr></argument>, <argument><expr><literal type="string">"Job"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TaskReceivedTupleData returns the amount of data that was received by the
 * coordinator for the task. If it's a RETURNING DML task the value stored in
 * totalReceivedTupleData is not correct yet because it only counts the bytes for
 * one placement.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>TaskReceivedTupleData</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>==</operator> <name>MODIFY_TASK</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>task</name><operator>-&gt;</operator><name>totalReceivedTupleData</name></name> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>task</name><operator>-&gt;</operator><name>totalReceivedTupleData</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainMapMergeJob shows a very basic EXPLAIN plan for a MapMergeJob. It does
 * not yet show the EXPLAIN plan for the individual tasks, because this requires
 * specific logic for getting the query (which is wrapped in a UDF), and the
 * queries may use intermediate tables that have not been created.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainMapMergeJob</name><parameter_list>(<parameter><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>job</name><operator>.</operator><name>dependentJobList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>dependentJobCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>dependentJobCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mapTaskCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>mapTaskList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>mergeTaskCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>mergeTaskList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"-&gt;  MapMergeJob\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"MapMergeJob"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Map Task Count"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mapTaskCount</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(<argument><expr><literal type="string">"Merge Task Count"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mergeTaskCount</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dependentJobCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Dependent Jobs"</literal></expr></argument>, <argument><expr><literal type="string">"Dependent Jobs"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>dependentJobCell</argument>, <argument>dependentJobList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>dependentJob</name> <init>= <expr><operator>(</operator><name>Job</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>dependentJobCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>dependentJob</name></expr></argument>, <argument><expr><name>MapMergeJob</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExplainMapMergeJob</name><argument_list>(<argument><expr><operator>(</operator><name>MapMergeJob</name> <operator>*</operator><operator>)</operator> <name>dependentJob</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Dependent Jobs"</literal></expr></argument>, <argument><expr><literal type="string">"Dependent Jobs"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"MapMergeJob"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CompareTasksByFetchedExplainAnalyzeDuration is a helper function to compare two tasks by their execution duration.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareTasksByFetchedExplainAnalyzeDuration</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier>
											<name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Task</name> <modifier>*</modifier></type><name>leftTask</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Task</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Task</name> <modifier>*</modifier></type><name>rightTask</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Task</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>leftTaskExecutionDuration</name> <init>= <expr><name><name>leftTask</name><operator>-&gt;</operator><name>fetchedExplainAnalyzeExecutionDuration</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>rightTaskExecutionDuration</name> <init>= <expr><name><name>rightTask</name><operator>-&gt;</operator><name>fetchedExplainAnalyzeExecutionDuration</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>diff</name> <init>= <expr><name>leftTaskExecutionDuration</name> <operator>-</operator> <name>rightTaskExecutionDuration</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>diff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainTaskList shows the remote EXPLAIN and execution time for the first task
 * in taskList, or all tasks if citus.explain_all_tasks is on.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainTaskList</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
				<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>remoteExplainList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if tasks are executed, we sort them by time; unless we are on a test env */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name>ExplainAnalyzeSortMethod</name> <operator>==</operator> <name>EXPLAIN_ANALYZE_SORT_BY_TIME</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* sort by execution duration only in case of ANALYZE */</comment>
		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>CompareTasksByFetchedExplainAnalyzeDuration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* make sure that the output is consistent */</comment>
		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>CompareTasksByTaskId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RemoteExplainPlan</name> <modifier>*</modifier></type><name>remoteExplain</name> <init>= <expr><call><name>RemoteExplain</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>remoteExplainList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>remoteExplainList</name></expr></argument>, <argument><expr><name>remoteExplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ExplainAllTasks</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>RemoteExplainPlan</name> <modifier>*</modifier></type><name>remoteExplain</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>, <argument>remoteExplain</argument>, <argument>remoteExplainList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainTask</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>, <argument><expr><name>task</name></expr></argument>, <argument><expr><name><name>remoteExplain</name><operator>-&gt;</operator><name>placementIndex</name></name></expr></argument>,
					<argument><expr><name><name>remoteExplain</name><operator>-&gt;</operator><name>explainOutputList</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteExplain fetches the remote EXPLAIN output for a single task.
 */</comment>
<function><type><specifier>static</specifier> <name>RemoteExplainPlan</name> <modifier>*</modifier></type>
<name>RemoteExplain</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * For EXPLAIN EXECUTE we still use the old method, so task-&gt;fetchedExplainAnalyzePlan
	 * can be NULL for some cases of es-&gt;analyze == true.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>task</name><operator>-&gt;</operator><name>fetchedExplainAnalyzePlan</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>GetSavedRemoteExplain</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>FetchRemoteExplainFromWorkers</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetSavedRemoteExplain creates a remote EXPLAIN output from information saved
 * in task.
 */</comment>
<function><type><specifier>static</specifier> <name>RemoteExplainPlan</name> <modifier>*</modifier></type>
<name>GetSavedRemoteExplain</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RemoteExplainPlan</name> <modifier>*</modifier></type><name>remotePlan</name> <init>= <expr><operator>(</operator><name>RemoteExplainPlan</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteExplainPlan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Similar to postgres' ExplainQuery(), we split by newline only for
	 * text format.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We limit the size of EXPLAIN plans to RSIZE_MAX_MEM (256MB).
		 */</comment>
		<expr_stmt><expr><name><name>remotePlan</name><operator>-&gt;</operator><name>explainOutputList</name></name> <operator>=</operator> <call><name>SplitString</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>fetchedExplainAnalyzePlan</name></name></expr></argument>,
													<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>RSIZE_MAX_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>explainAnalyzeString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>explainAnalyzeString</name></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>fetchedExplainAnalyzePlan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>remotePlan</name><operator>-&gt;</operator><name>explainOutputList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>explainAnalyzeString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>remotePlan</name><operator>-&gt;</operator><name>placementIndex</name></name> <operator>=</operator> <name><name>task</name><operator>-&gt;</operator><name>fetchedExplainAnalyzePlacementIndex</name></name></expr>;</expr_stmt>

	<return>return <expr><name>remotePlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FetchRemoteExplainFromWorkers fetches the remote EXPLAIN output for a single
 * task by querying it from worker nodes. It tries each shard placement until
 * one succeeds or all failed.
 */</comment>
<function><type><specifier>static</specifier> <name>RemoteExplainPlan</name> <modifier>*</modifier></type>
<name>FetchRemoteExplainFromWorkers</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskPlacementList</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>placementCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RemoteExplainPlan</name> <modifier>*</modifier></type><name>remotePlan</name> <init>= <expr><operator>(</operator><name>RemoteExplainPlan</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteExplainPlan</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>explainQuery</name> <init>= <expr><call><name>BuildRemoteExplainQuery</name><argument_list>(<argument><expr><call><name>TaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use a coordinated transaction to ensure that we open a transaction block
	 * such that we can set a savepoint.
	 */</comment>
	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>placementIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>placementIndex</name> <operator>&lt;</operator> <name>placementCount</name></expr>;</condition> <incr><expr><name>placementIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>taskPlacementList</name></expr></argument>, <argument><expr><name>placementIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>remotePlan</name><operator>-&gt;</operator><name>placementIndex</name></name> <operator>=</operator> <name>placementIndex</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetPlacementConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
															 <argument><expr><name>taskPlacement</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * This code-path doesn't support optional connections, so we don't expect
		 * NULL connections.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>connection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* try other placements if we fail to connect this one */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>RemoteTransactionBeginIfNecessary</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start a savepoint for the explain query. After running the explain
		 * query, we will rollback to this savepoint. This saves us from side
		 * effects of EXPLAIN ANALYZE on DML queries.
		 */</comment>
		<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT citus_explain_savepoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* run explain query */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>numParams</name> <init>= <expr><ternary><condition><expr><name>params</name></expr> ?</condition><then> <expr><name><name>params</name><operator>-&gt;</operator><name>numParams</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramValues</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>queryResult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>params</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExtractParametersFromParamList</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramTypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramValues</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>sendStatus</name> <init>= <expr><call><name>SendRemoteCommandParams</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>explainQuery</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
												 <argument><expr><name>numParams</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>paramValues</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>sendStatus</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>queryResult</name> <operator>=</operator> <call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* read explain query results */</comment>
		<expr_stmt><expr><name><name>remotePlan</name><operator>-&gt;</operator><name>explainOutputList</name></name> <operator>=</operator> <call><name>ReadFirstColumnAsText</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>queryResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* rollback to the savepoint */</comment>
		<expr_stmt><expr><call><name>ExecuteCriticalRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>,
									 <argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT citus_explain_savepoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>remotePlan</name><operator>-&gt;</operator><name>explainOutputList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>remotePlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainTask shows the EXPLAIN output for an single task. The output has been
 * fetched from the placement at index placementIndex. If explainOutputList is NIL,
 * then the EXPLAIN output could not be fetched from any placement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainTask</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>scanState</name></decl></parameter>, <parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>placementIndex</name></decl></parameter>,
			<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>explainOutputList</name></decl></parameter>,
			<parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Task"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"-&gt;  Task\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryText</name> <init>= <expr><call><name>TaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Query"</literal></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ShowReceivedTupleData</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyBytes</name><argument_list>(<argument><expr><literal type="string">"Tuple data received from node"</literal></expr></argument>,
							 <argument><expr><call><name>TaskReceivedTupleData</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>explainOutputList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskPlacementList</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>taskPlacementList</name></expr></argument>, <argument><expr><name>placementIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExplainTaskPlacement</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>, <argument><expr><name>explainOutputList</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Error"</literal></expr></argument>, <argument><expr><literal type="string">"Could not get remote plan."</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Task"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainTaskPlacement shows the EXPLAIN output for an individual task placement.
 * It corrects the indentation of the remote explain output to match the local
 * output.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainTaskPlacement</name><parameter_list>(<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>explainOutputList</name></decl></parameter>,
					 <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>savedIndentation</name> <init>= <expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>nodeAddress</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>taskPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>nodePort</name> <init>= <expr><name><name>taskPlacement</name><operator>-&gt;</operator><name>nodePort</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nodeDatabase</name> <init>= <expr><call><name>CurrentDatabaseName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>explainOutputCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rowIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>nodeAddress</name></expr></argument>, <argument><expr><literal type="string">"host=%s port=%d dbname=%s"</literal></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>,
					 <argument><expr><name>nodeDatabase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Node"</literal></expr></argument>, <argument><expr><name><name>nodeAddress</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Remote Plan"</literal></expr></argument>, <argument><expr><literal type="string">"Remote Plan"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_JSON</name> <operator>||</operator> <name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_YAML</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* prevent appending the remote EXPLAIN on the same line */</comment>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>explainOutputCell</argument>, <argument>explainOutputList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>rowString</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>explainOutputCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>rowLength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>rowString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lineStart</name> <init>= <expr><name><name>rowString</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* parse the lines in the remote EXPLAIN for proper indentation */</comment>
		<while>while <condition>(<expr><name>lineStart</name> <operator>&lt;</operator> <name><name>rowString</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>rowLength</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* find the end-of-line */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lineEnd</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>lineStart</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>lineEnd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no end-of-line, use end of row string instead */</comment>
				<expr_stmt><expr><name>lineEnd</name> <operator>=</operator> <name><name>rowString</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>rowLength</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* convert line to a separate string */</comment>
			<expr_stmt><expr><operator>*</operator><name>lineEnd</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<comment type="block">/* indentation that is applied to all lines */</comment>
			<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name> <operator>&amp;&amp;</operator> <name>rowIndex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* indent the first line of the remote plan with an arrow */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"-&gt;  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* show line in the output */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>lineStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* continue at the start of the next line */</comment>
			<expr_stmt><expr><name>lineStart</name> <operator>=</operator> <name>lineEnd</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><name>rowIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Remote Plan"</literal></expr></argument>, <argument><expr><literal type="string">"Remote Plan"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>EXPLAIN_FORMAT_TEXT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>indent</name></name> <operator>=</operator> <name>savedIndentation</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BuildRemoteExplainQuery returns an EXPLAIN query string
 * to run on a worker node which explicitly contains all
 * the options in the explain state.
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>BuildRemoteExplainQuery</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>explainQuery</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>formatStr</name> <init>= <expr><call><name>ExplainFormatStr</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>explainQuery</name></expr></argument>,
					 <argument><expr><literal type="string">"EXPLAIN (ANALYZE %s, VERBOSE %s, "</literal>
					 <literal type="string">"COSTS %s, BUFFERS %s, WAL %s, "</literal>
					 <literal type="string">"TIMING %s, SUMMARY %s, FORMAT %s) %s"</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>wal</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>summary</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><name>formatStr</name></expr></argument>,
					 <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>explainQuery</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainFormatStr converts the given explain format to string.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExplainFormatStr</name><parameter_list>(<parameter><decl><type><name>ExplainFormat</name></type> <name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>format</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPLAIN_FORMAT_XML</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"XML"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>EXPLAIN_FORMAT_JSON</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"JSON"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>EXPLAIN_FORMAT_YAML</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"YAML"</literal></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<return>return <expr><literal type="string">"TEXT"</literal></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * worker_last_saved_explain_analyze returns the last saved EXPLAIN ANALYZE output of
 * a worker task query. It returns NULL if nothing has been saved yet.
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_last_saved_explain_analyze</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>SavedExplainPlan</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>columnCount</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expected 3 output columns in definition of "</literal>
								   <literal type="string">"worker_last_saved_explain_analyze, but got %d"</literal></expr></argument>,
								   <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name><name>columnNulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>columnValues</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
			<expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>SavedExplainPlan</name></expr></argument>)</argument_list></call></expr>,
			<macro><name>Float8GetDatum</name><argument_list>(<argument>SavedExecutionDurationMillisec</argument>)</argument_list></macro>
		}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupleStore</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * worker_save_query_explain_analyze executes and returns results of query while
 * saving its EXPLAIN ANALYZE to be fetched later.
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_save_query_explain_analyze</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>queryText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>queryText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>executionDurationMillisec</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>explainOptions</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name> <init>= <expr><call><name>NewExplainState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* use the same defaults as NewExplainState() for following options */</comment>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name> <operator>=</operator> <call><name>ExtractFieldBoolean</name><argument_list>(<argument><expr><name>explainOptions</name></expr></argument>, <argument><expr><literal type="string">"buffers"</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>wal</name></name> <operator>=</operator> <call><name>ExtractFieldBoolean</name><argument_list>(<argument><expr><name>explainOptions</name></expr></argument>, <argument><expr><literal type="string">"wal"</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name> <operator>=</operator> <call><name>ExtractFieldBoolean</name><argument_list>(<argument><expr><name>explainOptions</name></expr></argument>, <argument><expr><literal type="string">"costs"</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>summary</name></name> <operator>=</operator> <call><name>ExtractFieldBoolean</name><argument_list>(<argument><expr><name>explainOptions</name></expr></argument>, <argument><expr><literal type="string">"summary"</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>summary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <call><name>ExtractFieldBoolean</name><argument_list>(<argument><expr><name>explainOptions</name></expr></argument>, <argument><expr><literal type="string">"verbose"</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <call><name>ExtractFieldBoolean</name><argument_list>(<argument><expr><name>explainOptions</name></expr></argument>, <argument><expr><literal type="string">"timing"</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <call><name>ExtractFieldExplainFormat</name><argument_list>(<argument><expr><name>explainOptions</name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupleStore</name> <init>= <expr><call><name>SetupTuplestore</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>tupleStoreDest</name> <init>= <expr><call><name>CreateTuplestoreDestReceiver</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetTuplestoreDestReceiverParams_compat</name><argument_list>(<argument><expr><name>tupleStoreDest</name></expr></argument>, <argument><expr><name>tupleStore</name></expr></argument>,
										   <argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parseTreeList</name> <init>= <expr><call><name>pg_parse_query</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>parseTreeList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot EXPLAIN ANALYZE multiple queries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RawStmt</name> <modifier>*</modifier></type><name>parseTree</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>parseTreeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>boundParams</name> <init>= <expr><call><name>ExecutorBoundParams</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numParams</name> <init>= <expr><ternary><condition><expr><name>boundParams</name></expr> ?</condition><then> <expr><name><name>boundParams</name><operator>-&gt;</operator><name>numParams</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>paramTypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramValues</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>boundParams</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExtractParametersFromParamList</name><argument_list>(<argument><expr><name>boundParams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramTypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramValues</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* resolve OIDs of unknown (user-defined) types */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>analyzedQuery</name> <init>= <expr><call><name>parse_analyze_varparams_compat</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>paramTypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numParams</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>

	<comment type="block">/* pg_rewrite_query is a wrapper around QueryRewrite with some debugging logic */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queryList</name> <init>= <expr><call><name>pg_rewrite_query</name><argument_list>(<argument><expr><name>analyzedQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/* pg_rewrite_query is not yet public in PostgreSQL 13 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queryList</name> <init>= <expr><call><name>QueryRewrite</name><argument_list>(<argument><expr><name>analyzedQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>queryList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot EXPLAIN ANALYZE a query rewritten "</literal>
							   <literal type="string">"into multiple queries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>queryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExplainBeginOutput</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* plan query and record planning stats */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>planStart</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>planDuration</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>planStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>planDuration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>planDuration</name></expr></argument>, <argument><expr><name>planStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do the actual EXPLAIN ANALYZE */</comment>
	<expr_stmt><expr><call><name>ExplainWorkerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>tupleStoreDest</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>planDuration</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>executionDurationMillisec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExplainEndOutput</name><argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* save EXPLAIN ANALYZE result to be fetched later */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>FreeSavedExplainPlan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>SavedExplainPlan</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>SavedExecutionDurationMillisec</name> <operator>=</operator> <name>executionDurationMillisec</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FreeSavedExplainPlan frees allocated saved explain plan if any.
 */</comment>
<function><type><name>void</name></type>
<name>FreeSavedExplainPlan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>SavedExplainPlan</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>SavedExplainPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>SavedExplainPlan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractFieldExplainFormat gets value of fieldName from jsonbDoc, or returns
 * defaultValue if it doesn't exist.
 */</comment>
<function><type><specifier>static</specifier> <name>ExplainFormat</name></type>
<name>ExtractFieldExplainFormat</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>jsonbDoc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fieldName</name></decl></parameter>, <parameter><decl><type><name>ExplainFormat</name></type>
						  <name>defaultValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>jsonbDatum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><call><name>ExtractFieldJsonbDatum</name><argument_list>(<argument><expr><name>jsonbDoc</name></expr></argument>, <argument><expr><name>fieldName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jsonbDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>defaultValue</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>formatStr</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>jsonb_out</name></expr></argument>, <argument><expr><name>jsonbDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>formatStr</name></expr></argument>, <argument><expr><literal type="string">"\"text\""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>EXPLAIN_FORMAT_TEXT</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>formatStr</name></expr></argument>, <argument><expr><literal type="string">"\"xml\""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>EXPLAIN_FORMAT_XML</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>formatStr</name></expr></argument>, <argument><expr><literal type="string">"\"yaml\""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>EXPLAIN_FORMAT_YAML</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>formatStr</name></expr></argument>, <argument><expr><literal type="string">"\"json\""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>EXPLAIN_FORMAT_JSON</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid explain analyze format: %s"</literal></expr></argument>, <argument><expr><name>formatStr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusExplainOneQuery is the executor hook that is called when
 * postgres wants to explain a query.
 */</comment>
<function><type><name>void</name></type>
<name>CitusExplainOneQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>,
					 <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
					 <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* save the flags of current EXPLAIN command */</comment>
	<expr_stmt><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>costs</name></name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>costs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>buffers</name></name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>wal</name></name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>wal</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>verbose</name></name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>verbose</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>summary</name></name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>summary</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>timing</name></name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>format</name></name> <operator>=</operator> <name><name>es</name><operator>-&gt;</operator><name>format</name></name></expr>;</expr_stmt>

	<comment type="block">/* rest is copied from ExplainOneQuery() */</comment>
	<decl_stmt><decl><type><name>instr_time</name></type> <name>planstart</name></decl>,
			   <decl><type ref="prev"/><name>planduration</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferUsage</name></type> <name>bufusage_start</name></decl>,
				<decl><type ref="prev"/><name>bufusage</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bufusage_start</name> <operator>=</operator> <name>pgBufferUsage</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>planstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should not hide any objects while explaining some query to not break
	 * postgres vanilla tests.
	 *
	 * The filter 'is_citus_depended_object' is added to explain result
	 * and causes some tests to fail if HideCitusDependentObjects is true.
	 * Therefore, we disable HideCitusDependentObjects until the current transaction
	 * ends.
	 *
	 * We do not use security quals because a postgres vanilla test fails
	 * with a change of order for its result.
	 */</comment>
	<expr_stmt><expr><call><name>SetLocalHideCitusDependentObjectsDisabledWhenAlreadyEnabled</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* plan the query */</comment>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>planduration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>planduration</name></expr></argument>, <argument><expr><name>planstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* calc differences of buffer counters. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BufferUsageAccumDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgBufferUsage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bufusage_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* run it (if needed) and produce output */</comment>
	<expr_stmt><expr><call><name>ExplainOnePlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>planduration</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>bufusage</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateExplainAnlyzeDestination creates a destination suitable for collecting
 * explain analyze output from workers.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDestination</name> <modifier>*</modifier></type>
<name>CreateExplainAnlyzeDestination</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>taskDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExplainAnalyzeDestination</name> <modifier>*</modifier></type><name>tupleDestination</name> <init>= <expr><call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExplainAnalyzeDestination</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>originalTask</name></name> <operator>=</operator> <name>task</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>originalTaskDestination</name></name> <operator>=</operator> <name>taskDest</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>lastSavedExplainAnalyzeTupDesc</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>lastSavedExplainAnalyzeTupDesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"explain analyze"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>lastSavedExplainAnalyzeTupDesc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"duration"</literal></expr></argument>, <argument><expr><name>FLOAT8OID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>lastSavedExplainAnalyzeTupDesc</name></name> <operator>=</operator> <name>lastSavedExplainAnalyzeTupDesc</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>putTuple</name></name> <operator>=</operator> <name>ExplainAnalyzeDestPutTuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>tupleDescForQuery</name></name> <operator>=</operator> <name>ExplainAnalyzeDestTupleDescForQuery</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>TupleDestination</name> <operator>*</operator><operator>)</operator> <name>tupleDestination</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainAnalyzeDestPutTuple implements TupleDestination-&gt;putTuple
 * for ExplainAnalyzeDestination.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainAnalyzeDestPutTuple</name><parameter_list>(<parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>placementIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queryNumber</name></decl></parameter>,
						   <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>tupleLibpqSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExplainAnalyzeDestination</name> <modifier>*</modifier></type><name>tupleDestination</name> <init>= <expr><operator>(</operator><name>ExplainAnalyzeDestination</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>queryNumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>originalTupDest</name> <init>= <expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>originalTaskDestination</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name><name>originalTupDest</name><operator>-&gt;</operator><name>putTuple</name></name><argument_list>(<argument><expr><name>originalTupDest</name></expr></argument>, <argument><expr><name>task</name></expr></argument>, <argument><expr><name>placementIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>,
								  <argument><expr><name>tupleLibpqSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>originalTask</name><operator>-&gt;</operator><name>totalReceivedTupleData</name></name> <operator>+=</operator> <name>tupleLibpqSize</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>queryNumber</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupDesc</name> <init>= <expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>lastSavedExplainAnalyzeTupDesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>explainAnalyze</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								  <argument><expr><literal type="string">"received null explain analyze output from worker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>executionDuration</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received null execution time from worker"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fetchedExplainAnalyzePlan</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>explainAnalyze</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>fetchedExplainAnalyzeExecutionDuration</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>executionDuration</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Allocate fetchedExplainAnalyzePlan in the same context as the Task, since we are
		 * currently in execution context and a Task can span multiple executions.
		 *
		 * Although we won't reuse the same value in a future execution, but we have
		 * calls to CheckNodeCopyAndSerialization() which asserts copy functions of the task
		 * work as expected, which will try to copy this value in a future execution.
		 *
		 * Why don't we just allocate this field in executor context and reset it before
		 * the next execution? Because when an error is raised we can skip pretty much most
		 * of the meaningful places that we can insert the reset.
		 *
		 * TODO: Take all EXPLAIN ANALYZE related fields out of Task and store them in a
		 * Task to ExplainAnalyzePrivate mapping in multi_explain.c, so we don't need to
		 * do these hacky memory context management tricks.
		 */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>taskContext</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>originalTask</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>originalTask</name><operator>-&gt;</operator><name>fetchedExplainAnalyzePlan</name></name> <operator>=</operator>
			<call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>taskContext</name></expr></argument>, <argument><expr><name>fetchedExplainAnalyzePlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>originalTask</name><operator>-&gt;</operator><name>fetchedExplainAnalyzePlacementIndex</name></name> <operator>=</operator>
			<name>placementIndex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>originalTask</name><operator>-&gt;</operator><name>fetchedExplainAnalyzeExecutionDuration</name></name> <operator>=</operator>
			<name>fetchedExplainAnalyzeExecutionDuration</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot get EXPLAIN ANALYZE of multiple queries"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"while receiving tuples for query %d"</literal></expr></argument>, <argument><expr><name>queryNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ResetExplainAnalyzeData reset fields in Task that are used by multi_explain.c
 */</comment>
<function><type><name>void</name></type>
<name>ResetExplainAnalyzeData</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>task</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>fetchedExplainAnalyzePlan</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>fetchedExplainAnalyzePlan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>totalReceivedTupleData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>fetchedExplainAnalyzePlacementIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>fetchedExplainAnalyzePlan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainAnalyzeDestTupleDescForQuery implements TupleDestination-&gt;tupleDescForQuery
 * for ExplainAnalyzeDestination.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>ExplainAnalyzeDestTupleDescForQuery</name><parameter_list>(<parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>queryNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExplainAnalyzeDestination</name> <modifier>*</modifier></type><name>tupleDestination</name> <init>= <expr><operator>(</operator><name>ExplainAnalyzeDestination</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>queryNumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>originalTupDest</name> <init>= <expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>originalTaskDestination</name></name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name><name>originalTupDest</name><operator>-&gt;</operator><name>tupleDescForQuery</name></name><argument_list>(<argument><expr><name>originalTupDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>queryNumber</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>tupleDestination</name><operator>-&gt;</operator><name>lastSavedExplainAnalyzeTupDesc</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot get EXPLAIN ANALYZE of multiple queries"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"while requesting for tuple descriptor of query %d"</literal></expr></argument>,
							  <argument><expr><name>queryNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RequestedForExplainAnalyze returns true if we should get the EXPLAIN ANALYZE
 * output for the given custom scan node.
 */</comment>
<function><type><name>bool</name></type>
<name>RequestedForExplainAnalyze</name><parameter_list>(<parameter><decl><type><name>CitusScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>customScanState</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_instrument</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainAnalyzeTaskList returns a task list suitable for explain analyze. After executing
 * these tasks, fetchedExplainAnalyzePlan of originalTaskList should be populated.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ExplainAnalyzeTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>originalTaskList</name></decl></parameter>,
					   <parameter><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>defaultTupleDest</name></decl></parameter>,
					   <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
					   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>explainAnalyzeTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>originalTask</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>originalTask</argument>, <argument>originalTaskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>originalTask</name><operator>-&gt;</operator><name>queryCount</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot get EXPLAIN ANALYZE of multiple queries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>explainAnalyzeTask</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalTask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name> <init>= <expr><call><name>TaskQueryString</name><argument_list>(<argument><expr><name>explainAnalyzeTask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>taskParams</name> <init>= <expr><name>params</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We will not send parameters if they have already been resolved in the query
		 * string.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>explainAnalyzeTask</name><operator>-&gt;</operator><name>parametersInQueryStringResolved</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>taskParams</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>wrappedQuery</name> <init>= <expr><call><name>WrapQueryForExplainAnalyze</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>tupleDesc</name></expr></argument>,
														<argument><expr><name>taskParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fetchQuery</name> <init>= <expr><call><name>FetchPlanQueryForExplainAnalyze</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>taskParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SetTaskQueryStringList</name><argument_list>(<argument><expr><name>explainAnalyzeTask</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>wrappedQuery</name></expr></argument>, <argument><expr><name>fetchQuery</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TupleDestination</name> <modifier>*</modifier></type><name>originalTaskDest</name> <init>= <expr><ternary><condition><expr><name><name>originalTask</name><operator>-&gt;</operator><name>tupleDest</name></name></expr> ?</condition><then>
											 <expr><name><name>originalTask</name><operator>-&gt;</operator><name>tupleDest</name></name></expr> </then><else>:
											 <expr><name>defaultTupleDest</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>explainAnalyzeTask</name><operator>-&gt;</operator><name>tupleDest</name></name> <operator>=</operator>
			<call><name>CreateExplainAnlyzeDestination</name><argument_list>(<argument><expr><name>originalTask</name></expr></argument>, <argument><expr><name>originalTaskDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>explainAnalyzeTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>explainAnalyzeTaskList</name></expr></argument>, <argument><expr><name>explainAnalyzeTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>explainAnalyzeTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WrapQueryForExplainAnalyze wraps a query into a worker_save_query_explain_analyze()
 * call so we can fetch its explain analyze after its execution.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>WrapQueryForExplainAnalyze</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
						   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>columnDef</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>columnIndex</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>columnDef</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><operator>&amp;</operator><name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attrType</name> <init>= <expr><call><name>format_type_extended</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
											  <argument><expr><name>FORMAT_TYPE_TYPEMOD_GIVEN</name> <operator>|</operator>
											  <name>FORMAT_TYPE_FORCE_QUALIFY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>columnDef</name></expr></argument>, <argument><expr><literal type="string">"field_%d %s"</literal></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>, <argument><expr><name>attrType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * column definition cannot be empty, so create a dummy column definition for
	 * queries with no results.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>columnDef</name></expr></argument>, <argument><expr><literal type="string">"dummy_field int"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>explainOptions</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>explainOptions</name></expr></argument>,
					 <argument><expr><literal type="string">"{\"verbose\": %s, \"costs\": %s, \"buffers\": %s, \"wal\": %s, "</literal>
					 <literal type="string">"\"timing\": %s, \"summary\": %s, \"format\": \"%s\"}"</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>verbose</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>costs</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>buffers</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>wal</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>timing</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>summary</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><call><name>ExplainFormatStr</name><argument_list>(<argument><expr><name><name>CurrentDistributedQueryExplainOptions</name><operator>.</operator><name>format</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>wrappedQuery</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We do not include dummy column if original query didn't return any columns.
	 * Otherwise, number of columns that original query returned wouldn't match
	 * number of columns returned by worker_save_query_explain_analyze.
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>workerSaveQueryFetchCols</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"*"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>params</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Add a dummy CTE to ensure all parameters are referenced, such that their
		 * types can be resolved.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>wrappedQuery</name></expr></argument>, <argument><expr><literal type="string">"WITH unused AS (%s) "</literal></expr></argument>,
						 <argument><expr><call><name>ParameterResolutionSubquery</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>wrappedQuery</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT %s FROM worker_save_query_explain_analyze(%s, %s) AS (%s)"</literal></expr></argument>,
					 <argument><expr><name>workerSaveQueryFetchCols</name></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name><name>explainOptions</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>columnDef</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>wrappedQuery</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FetchPlanQueryForExplainAnalyze generates a query to fetch the plan saved
 * by worker_save_query_explain_analyze from the worker.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>FetchPlanQueryForExplainAnalyze</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>fetchQuery</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>params</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Add a dummy CTE to ensure all parameters are referenced, such that their
		 * types can be resolved.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>fetchQuery</name></expr></argument>, <argument><expr><literal type="string">"WITH unused AS (%s) "</literal></expr></argument>,
						 <argument><expr><call><name>ParameterResolutionSubquery</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>fetchQuery</name></expr></argument>,
						   <argument><expr><literal type="string">"SELECT explain_analyze_output, execution_duration "</literal>
						   <literal type="string">"FROM worker_last_saved_explain_analyze()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>fetchQuery</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ParameterResolutionSubquery generates a subquery that returns all parameters
 * in params with explicit casts to their type names. This can be used in cases
 * where we use custom type parameters that are not directly referenced.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ParameterResolutionSubquery</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>paramsQuery</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>paramsQuery</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>paramIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>paramIndex</name> <operator>&lt;</operator> <name><name>params</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</condition> <incr><expr><name>paramIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>&amp;</operator><name><name>params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>format_type_extended</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
											  <argument><expr><name>FORMAT_TYPE_FORCE_QUALIFY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>paramsQuery</name></expr></argument>, <argument><expr><literal type="string">"%s $%d::%s"</literal></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>paramIndex</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><name>paramIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name><name>paramsQuery</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SplitString splits the given string by the given delimiter.
 *
 * Why not use strtok_s()? Its signature and semantics are difficult to understand.
 *
 * Why not use strchr() (similar to do_text_output_multiline)? Although not banned,
 * it isn't safe if by any chance str is not null-terminated.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>SplitString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>delimiter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strnlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>maxLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tokenList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>token</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>size_t</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>index</name></expr>]</index></name> <operator>==</operator> <name>delimiter</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tokenList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tokenList</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* append last token */</comment>
	<expr_stmt><expr><name>tokenList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tokenList</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tokenList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* below are private functions copied from explain.c */</comment>


<comment type="block">/* *INDENT-OFF* */</comment>
<comment type="block">/*
 * ExplainOneQuery -
 *	  print out the execution plan for one Query
 *
 * "into" is NULL unless we are explaining the contents of a CreateTableAsStmt.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainOneQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>,
				<parameter><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
				<parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if an advisor plugin is present, let it manage things */</comment>
	<if_stmt><if>if <condition>(<expr><name>ExplainOneQuery_hook</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ExplainOneQuery_hook</name>) <argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>,
								 <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>instr_time</name></type>	<name>planstart</name></decl>,
					<decl><type ref="prev"/><name>planduration</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufferUsage</name></type> <name>bufusage_start</name></decl>,
			    <decl><type ref="prev"/><name>bufusage</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bufusage_start</name> <operator>=</operator> <name>pgBufferUsage</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>planstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* plan the query */</comment>
		<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>pg_plan_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>planduration</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>planduration</name></expr></argument>, <argument><expr><name>planstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* calc differences of buffer counters. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferUsage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>BufferUsageAccumDiff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufusage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pgBufferUsage</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bufusage_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* run it (if needed) and produce output */</comment>
		<expr_stmt><expr><call><name>ExplainOnePlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>into</name></expr></argument>, <argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>planduration</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>bufusage</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExplainWorkerPlan produces explain output into es. If es-&gt;analyze, it also executes
 * the given plannedStmt and sends the results to dest. It puts total time to execute in
 * executionDurationMillisec.
 *
 * This is based on postgres' ExplainOnePlan(). We couldn't use an IntoClause to store results
 * into tupleStore, so we had to copy the same functionality with some minor changes.
 *
 * Keeping the formatting to make comparing with the ExplainOnePlan() easier.
 *
 * TODO: Send a PR to postgres to change ExplainOnePlan's API to use a more generic result
 * destination.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExplainWorkerPlan</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedstmt</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>QueryEnvironment</name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>instr_time</name> <modifier>*</modifier></type><name>planduration</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>executionDurationMillisec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>QueryDesc</name>  <modifier>*</modifier></type><name>queryDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>starttime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>totaltime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>instrument_option</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>timing</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>instrument_option</name> <operator>|=</operator> <name>INSTRUMENT_TIMER</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>instrument_option</name> <operator>|=</operator> <name>INSTRUMENT_ROWS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>buffers</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>instrument_option</name> <operator>|=</operator> <name>INSTRUMENT_BUFFERS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>wal</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>instrument_option</name> <operator>|=</operator> <name>INSTRUMENT_WAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We always collect timing for the entire statement, even when node-level
	 * timing is off, so we don't look at es-&gt;timing here.  (We could skip
	 * this if !es-&gt;summary, but it's hardly worth the complication.)
	 */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use a snapshot with an updated command ID to ensure this query sees
	 * results of any previously executed queries.
	 */</comment>
	<expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a QueryDesc for the query */</comment>
	<expr_stmt><expr><name>queryDesc</name> <operator>=</operator> <call><name>CreateQueryDesc</name><argument_list>(<argument><expr><name>plannedstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
								<argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InvalidSnapshot</name></expr></argument>,
								<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>instrument_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Select execution options */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>eflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>				<comment type="block">/* default run-to-completion flags */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>eflags</name> <operator>=</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* call ExecutorStart to prepare the plan for execution */</comment>
	<expr_stmt><expr><call><name>ExecutorStart</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute the plan for statistics if asked for */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ScanDirection</name></type> <name>dir</name> <init>= <expr><name>ForwardScanDirection</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* run the plan */</comment>
		<expr_stmt><expr><call><name>ExecutorRun</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* run cleanup too */</comment>
		<expr_stmt><expr><call><name>ExecutorFinish</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We can't run ExecutorEnd 'till we're done printing the stats... */</comment>
		<expr_stmt><expr><name>totaltime</name> <operator>+=</operator> <call><name>elapsed_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExplainOpenGroup</name><argument_list>(<argument><expr><literal type="string">"Query"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create textual dump of plan tree */</comment>
	<expr_stmt><expr><call><name>ExplainPrintPlan</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>summary</name></name> <operator>&amp;&amp;</operator> <name>planduration</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>plantime</name> <init>= <expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><operator>*</operator><name>planduration</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Planning Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>, <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <name>plantime</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Print info about runtime of triggers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPrintTriggers</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Print info about JITing. Tied to es-&gt;costs because we don't want to
	 * display this in regression tests, as it'd cause output differences
	 * depending on build options.  Might want to separate that out from COSTS
	 * at a later stage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>costs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPrintJITSummary</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Close down the query and free resources.  Include time for this in the
	 * total execution time (although it should be pretty minimal).
	 */</comment>
	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecutorEnd</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeQueryDesc</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We need a CCI just in case query expanded to multiple plans */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>totaltime</name> <operator>+=</operator> <call><name>elapsed_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We only report execution time if we actually ran the query (that is,
	 * the user specified ANALYZE), and if summary reporting is enabled (the
	 * user can set SUMMARY OFF to not have the timing information included in
	 * the output).  By default, ANALYZE sets SUMMARY to true.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>summary</name></name> <operator>&amp;&amp;</operator> <name><name>es</name><operator>-&gt;</operator><name>analyze</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExplainPropertyFloat</name><argument_list>(<argument><expr><literal type="string">"Execution Time"</literal></expr></argument>, <argument><expr><literal type="string">"ms"</literal></expr></argument>, <argument><expr><literal type="number">1000.0</literal> <operator>*</operator> <name>totaltime</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
							 <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>executionDurationMillisec</name> <operator>=</operator> <name>totaltime</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExplainCloseGroup</name><argument_list>(<argument><expr><literal type="string">"Query"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Compute elapsed time in seconds since given timestamp.
 *
 * Copied from explain.c.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>elapsed_time</name><parameter_list>(<parameter><decl><type><name>instr_time</name> <modifier>*</modifier></type><name>starttime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>instr_time</name></type>	<name>endtime</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INSTR_TIME_SET_CURRENT</name><argument_list>(<argument><expr><name>endtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INSTR_TIME_SUBTRACT</name><argument_list>(<argument><expr><name>endtime</name></expr></argument>, <argument><expr><operator>*</operator><name>starttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>INSTR_TIME_GET_DOUBLE</name><argument_list>(<argument><expr><name>endtime</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
