<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/planner/insert_select_planner.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * insert_select_planner.c
 *
 * Planning logic for INSERT..SELECT.
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_pushdown_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/recursive_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nodes/print.h&gt;</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PrepareInsertSelectForCitusPlanner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DistributedPlan</name> <modifier>*</modifier></type> <name>CreateInsertSelectPlanInternal</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>,
														<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
														<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
														<name>plannerRestrictionContext</name></decl></parameter>,
														<parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DistributedPlan</name> <modifier>*</modifier></type> <name>CreateDistributedInsertSelectPlan</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
														   <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
														   <name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type> <name>RouterModifyTaskForShardInterval</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
											   <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetTableCacheEntry</name></decl></parameter>,
											   <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>,
											   <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
											   <name>plannerRestrictionContext</name></decl></parameter>,
											   <parameter><decl><type><name>uint32</name></type> <name>taskIdIndex</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>allRelationsJoinedOnPartitionKey</name></decl></parameter>,
											   <parameter><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>routerPlannerError</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type> <name>CreateCombineQueryForRouterPlan</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distPlan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CreateTargetListForCombineQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DistributedInsertSelectSupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>,
															   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name></decl></parameter>,
															   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subqueryRte</name></decl></parameter>,
															   <parameter><decl><type><name>bool</name></type> <name>allReferenceTables</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>MultiTaskRouterSelectQuerySupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasUnsupportedDistinctOn</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>InsertPartitionColumnMatchesSelect</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
																 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name></decl></parameter>,
																 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
																 <name>subqueryRte</name></decl></parameter>,
																 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type>
																 <name>selectPartitionColumnTableId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DistributedPlan</name> <modifier>*</modifier></type> <name>CreateNonPushableInsertSelectPlan</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
														   <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>NonPushableInsertSelectSupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type> <name>WrapSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelabelTargetEntryList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectTargetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>AddInsertSelectCasts</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectTargetList</name></decl></parameter>,
								   <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type> <name>CastExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetCollation</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>targetTypeMod</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* depth of current insert/select planner. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>insertSelectPlannerLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * InsertSelectIntoCitusTable returns true when the input query is an
 * INSERT INTO ... SELECT kind of query and the target is a citus
 * table.
 *
 * Note that the input query should be the original parsetree of
 * the query (i.e., not passed trough the standard planner).
 */</comment>
<function><type><name>bool</name></type>
<name>InsertSelectIntoCitusTable</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>insertSelectQuery</name> <init>= <expr><call><name>CheckInsertSelectQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>insertSelectQuery</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InsertSelectIntoLocalTable checks whether INSERT INTO ... SELECT inserts
 * into local table. Note that query must be a sample of INSERT INTO ... SELECT
 * type of query.
 */</comment>
<function><type><name>bool</name></type>
<name>InsertSelectIntoLocalTable</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>insertSelectQuery</name> <init>= <expr><call><name>CheckInsertSelectQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>insertSelectQuery</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckInsertSelectQuery returns true when the input query is an INSERT INTO
 * ... SELECT kind of query.
 *
 * This function is inspired from getInsertSelectQuery() on
 * rewrite/rewriteManip.c.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckInsertSelectQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CmdType</name></type> <name>commandType</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>!=</operator> <name>CMD_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fromList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>fromList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableReference</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>fromList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rangeTableReference</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subqueryRte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rangeTableReference</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryRte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ensure that there is a query */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>subqueryRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CoordinatorInsertSelectExecScan is a wrapper around
 * CoordinatorInsertSelectExecScanInternal which also properly increments
 * or decrements insertSelectExecutorLevel.
 */</comment>
<function><type><name>DistributedPlan</name> <modifier>*</modifier></type>
<name>CreateInsertSelectPlan</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
					   <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>,
					   <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>insertSelectPlannerLevel</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CreateInsertSelectPlanInternal</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>,
												<argument><expr><name>plannerRestrictionContext</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>insertSelectPlannerLevel</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>insertSelectPlannerLevel</name><operator>--</operator></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateInsertSelectPlan tries to create a distributed plan for an
 * INSERT INTO distributed_table SELECT ... query by push down the
 * command to the workers and if that is not possible it creates a
 * plan for evaluating the SELECT on the coordinator.
 */</comment>
<function><type><specifier>static</specifier> <name>DistributedPlan</name> <modifier>*</modifier></type>
<name>CreateInsertSelectPlanInternal</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
							   <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>,
							   <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>deferredError</name> <init>= <expr><call><name>ErrorIfOnConflictNotSupported</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>deferredError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* raising the error as there is no possible solution for the unsupported on conflict statements */</comment>
		<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>deferredError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><call><name>CreateDistributedInsertSelectPlan</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>,
																		 <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If INSERT..SELECT cannot be distributed, pull to coordinator or use
		 * repartitioning.
		 */</comment>
		<expr_stmt><expr><name>distributedPlan</name> <operator>=</operator> <call><name>CreateNonPushableInsertSelectPlan</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>,
															<argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>distributedPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateDistributedInsertSelectPlan creates a DistributedPlan for distributed
 * INSERT ... SELECT queries which could consist of multiple tasks.
 *
 * The function never returns NULL, it errors out if cannot create the DistributedPlan.
 */</comment>
<function><type><specifier>static</specifier> <name>DistributedPlan</name> <modifier>*</modifier></type>
<name>CreateDistributedInsertSelectPlan</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
								  <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sqlTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>taskIdIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* 0 is reserved for invalid taskId */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>DistributedPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name> <init>= <expr><call><name>ExtractResultRelationRTEOrError</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subqueryRte</name> <init>= <expr><call><name>ExtractSelectRangeTableEntry</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetCacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name><name>targetCacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>relationRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>allReferenceTables</name> <init>= <expr><name><name>relationRestrictionContext</name><operator>-&gt;</operator><name>allReferenceTables</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>modLevel</name></name> <operator>=</operator> <call><name>RowModifyLevelForQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Error semantics for INSERT ... SELECT queries are different than regular
	 * modify queries. Thus, handle separately.
	 */</comment>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>=</operator> <call><name>DistributedInsertSelectSupported</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>,
																	  <argument><expr><name>insertRte</name></expr></argument>,
																	  <argument><expr><name>subqueryRte</name></expr></argument>,
																	  <argument><expr><name>allReferenceTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>distributedPlan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>allDistributionKeysInQueryAreEqual</name> <init>=
		<expr><call><name>AllDistributionKeysInQueryAreEqual</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Plan select query for each shard in the target table. Do so by replacing the
	 * partitioning qual parameter added in distributed_planner() using the current shard's
	 * actual boundary values. Also, add the current shard's boundary values to the
	 * top level subquery to ensure that even if the partitioning qual is not distributed
	 * to all the tables, we never run the queries on the shards that don't match with
	 * the current shard boundaries. Finally, perform the normal shard pruning to
	 * decide on whether to push the query to the current shard or not.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardOffset</name> <operator>&lt;</operator> <name>shardCount</name></expr>;</condition> <incr><expr><name>shardOffset</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>targetShardInterval</name> <init>=
			<expr><name><name>targetCacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardOffset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>modifyTask</name> <init>= <expr><call><name>RouterModifyTaskForShardInterval</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>,
															<argument><expr><name>targetCacheEntry</name></expr></argument>,
															<argument><expr><name>targetShardInterval</name></expr></argument>,
															<argument><expr><name>plannerRestrictionContext</name></expr></argument>,
															<argument><expr><name>taskIdIndex</name></expr></argument>,
															<argument><expr><name>allDistributionKeysInQueryAreEqual</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name><name>distributedPlan</name><operator>-&gt;</operator>
															<name>planningError</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>distributedPlan</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* add the task if it could be created */</comment>
		<if_stmt><if>if <condition>(<expr><name>modifyTask</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>modifyWithSubquery</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>sqlTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sqlTaskList</name></expr></argument>, <argument><expr><name>modifyTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>taskIdIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Create the worker job */</comment>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>sqlTaskList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>subqueryPushdown</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>dependentJobList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>jobQuery</name></name> <operator>=</operator> <name>originalQuery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerJob</name><operator>-&gt;</operator><name>requiresCoordinatorEvaluation</name></name> <operator>=</operator>
		<call><name>RequiresCoordinatorEvaluation</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and finally the multi plan */</comment>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>workerJob</name></name> <operator>=</operator> <name>workerJob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>combineQuery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>expectResults</name></name> <operator>=</operator> <name><name>originalQuery</name><operator>-&gt;</operator><name>returningList</name></name> <operator>!=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>targetRelationId</name></name> <operator>=</operator> <name>targetRelationId</name></expr>;</expr_stmt>

	<return>return <expr><name>distributedPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateInsertSelectIntoLocalTablePlan creates the plan for INSERT .. SELECT queries
 * where the selected table is distributed and the inserted table is not.
 *
 * To create the plan, this function first creates a distributed plan for the SELECT
 * part. Then puts it as a subquery to the original (non-distributed) INSERT query as
 * a subquery. Finally, it puts this INSERT query, which now has a distributed SELECT
 * subquery, in the combineQuery.
 *
 * If the SELECT query is a router query, whose distributed plan does not have a
 * combineQuery, this function also creates a dummy combineQuery for that.
 */</comment>
<function><type><name>DistributedPlan</name> <modifier>*</modifier></type>
<name>CreateInsertSelectIntoLocalTablePlan</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name></decl></parameter>,
									 <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasUnresolvedParams</name></decl></parameter>,
									 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>selectRte</name> <init>= <expr><call><name>ExtractSelectRangeTableEntry</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PrepareInsertSelectForCitusPlanner</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the SELECT query (may have changed after PrepareInsertSelectForCitusPlanner) */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>selectQuery</name> <init>= <expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distPlan</name> <init>= <expr><call><name>CreateDistributedPlan</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name>selectQuery</name></expr></argument>,
													  <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>selectQuery</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>boundParams</name></expr></argument>, <argument><expr><name>hasUnresolvedParams</name></expr></argument>,
													  <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't expect distPlan to be NULL here because hasUnresolvedParams is
	 * already checked before this function and CreateDistributedPlan only returns
	 * NULL when there are unresolved parameters.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distPlan</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distPlan</name><operator>-&gt;</operator><name>planningError</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>distPlan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distPlan</name><operator>-&gt;</operator><name>combineQuery</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For router queries, we construct a synthetic master query that simply passes
		 * on the results of the remote tasks, which we can then use as the select in
		 * the INSERT .. SELECT.
		 */</comment>
		<expr_stmt><expr><name><name>distPlan</name><operator>-&gt;</operator><name>combineQuery</name></name> <operator>=</operator> <call><name>CreateCombineQueryForRouterPlan</name><argument_list>(
			<argument><expr><name>distPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * combineQuery of a distributed select is for combining the results from
	 * worker nodes on the coordinator node. Putting it as a subquery to the
	 * INSERT query, causes the INSERT query to insert the combined select value
	 * from the workers. And making the resulting insert query the combineQuery
	 * let's us execute this insert command.
	 *
	 * So this operation makes the master query insert the result of the
	 * distributed select instead of returning it.
	 */</comment>
	<expr_stmt><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name><name>distPlan</name><operator>-&gt;</operator><name>combineQuery</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distPlan</name><operator>-&gt;</operator><name>combineQuery</name></name> <operator>=</operator> <name>insertSelectQuery</name></expr>;</expr_stmt>

	<return>return <expr><name>distPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PrepareInsertSelectForCitusPlanner prepares an INSERT..SELECT query tree
 * that was passed to the planner for use by Citus.
 *
 * First, it rebuilds the target lists of the INSERT and the SELECT
 * to be in the same order, which is not guaranteed in the parse tree.
 *
 * Second, some of the constants in the target list will have type
 * "unknown", which would confuse the Citus planner. To address that,
 * we add casts to SELECT target list entries whose type does not correspond
 * to the destination. This also helps us feed the output directly into
 * a COPY stream for INSERT..SELECT via coordinator.
 *
 * In case of UNION or other set operations, the SELECT does not have a
 * clearly defined target list, so we first wrap the UNION in a subquery.
 * UNION queries do not have the "unknown" type problem.
 *
 * Finally, if the INSERT has CTEs, we move those CTEs into the SELECT,
 * such that we can plan the SELECT as an independent query. To ensure
 * the ctelevelsup for CTE RTE's remain the same, we wrap the SELECT into
 * a subquery, unless we already did so in case of a UNION.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrepareInsertSelectForCitusPlanner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name> <init>= <expr><call><name>ExtractResultRelationRTEOrError</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>selectRte</name> <init>= <expr><call><name>ExtractSelectRangeTableEntry</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isWrapped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Prepare UNION query for reordering and adding casts by
		 * wrapping it in a subquery to have a single target list.
		 */</comment>
		<expr_stmt><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <call><name>WrapSubquery</name><argument_list>(<argument><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>isWrapped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* this is required for correct deparsing of the query */</comment>
	<expr_stmt><expr><call><name>ReorderInsertSelectTargetLists</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>, <argument><expr><name>insertRte</name></expr></argument>, <argument><expr><name>selectRte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cast types of insert target list and select projection list to
	 * match the column types of the target relation.
	 */</comment>
	<expr_stmt><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator>
		<call><name>AddInsertSelectCasts</name><argument_list>(<argument><expr><name><name>insertSelectQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							 <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>insertSelectQuery</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isWrapped</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * By wrapping the SELECT in a subquery, we can avoid adjusting
			 * ctelevelsup in RTE's that point to the CTEs.
			 */</comment>
			<expr_stmt><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <call><name>WrapSubquery</name><argument_list>(<argument><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* copy CTEs from the INSERT ... SELECT statement into outer SELECT */</comment>
		<expr_stmt><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>insertSelectQuery</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>insertSelectQuery</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>insertSelectQuery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateCombineQueryForRouterPlan is used for creating a dummy combineQuery
 * for a router plan, since router plans normally don't have one.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>CreateCombineQueryForRouterPlan</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distPlan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Index</name></type> <name>insertTableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeInteger</name><argument_list>(<argument><expr><name>insertTableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>dependentJob</name> <init>= <expr><name><name>distPlan</name><operator>-&gt;</operator><name>workerJob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentTargetList</name> <init>= <expr><name><name>dependentJob</name><operator>-&gt;</operator><name>jobQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* compute column names for the derived table */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>dependentTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><call><name>DerivedColumnNameList</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>,
												 <argument><expr><name><name>dependentJob</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnNames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnTypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnTypeMods</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcCollations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>dependentTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"unnamed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>funcColumnNames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>funcColumnNames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>funcColumnTypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>funcColumnTypes</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcColumnTypeMods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>funcColumnTypeMods</name></expr></argument>, <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcCollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>funcCollations</name></expr></argument>, <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>DerivedRangeTableEntry</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
															<argument><expr><name>columnNameList</name></expr></argument>,
															<argument><expr><name>tableIdList</name></expr></argument>,
															<argument><expr><name>funcColumnNames</name></expr></argument>,
															<argument><expr><name>funcColumnTypes</name></expr></argument>,
															<argument><expr><name>funcColumnTypeMods</name></expr></argument>,
															<argument><expr><name>funcCollations</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><call><name>CreateTargetListForCombineQuery</name><argument_list>(<argument><expr><name>dependentTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>joinTree</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>joinTree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinTree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>combineQuery</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>combineQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>combineQuery</name><operator>-&gt;</operator><name>querySource</name></name> <operator>=</operator> <name>QSRC_ORIGINAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>combineQuery</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>combineQuery</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>combineQuery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>targetList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>combineQuery</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <name>joinTree</name></expr>;</expr_stmt>
	<return>return <expr><name>combineQuery</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateTargetListForCombineQuery is used for creating a target list for
 * master query.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CreateTargetListForCombineQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newTargetEntryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint32</name></type> <name>masterTableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>columnId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate over original target entries */</comment>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>originalTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>originalTargetEntry</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newTargetEntry</name> <init>= <expr><call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>originalTargetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name>originalTargetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>columnId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <name>columnId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>columnId</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator> <name><name>column</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDARRAYOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>=</operator> <call><name>BlessRecordExpression</name><argument_list>(<argument><expr><name><name>originalTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>newExpression</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>column</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>newExpression</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newTargetEntryList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newTargetEntryList</name></expr></argument>, <argument><expr><name>newTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>newTargetEntryList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistributedInsertSelectSupported returns NULL if the INSERT ... SELECT query
 * is supported, or a description why not.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DistributedInsertSelectSupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name></decl></parameter>,
								 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subqueryRte</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allReferenceTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>selectPartitionColumnTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we only do this check for INSERT ... SELECT queries */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>InsertSelectIntoCitusTable</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>subqueryRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NeedsDistributedPlanning</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"distributed INSERT ... SELECT can only select from "</literal>
							 <literal type="string">"distributed tables"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RTEListProperties</name> <modifier>*</modifier></type><name>subqueryRteListProperties</name> <init>= <expr><call><name>GetRTEListPropertiesForQuery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryRteListProperties</name><operator>-&gt;</operator><name>hasDistributedTable</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>subqueryRteListProperties</name><operator>-&gt;</operator><name>hasCitusLocalTable</name></name> <operator>||</operator>
		 <name><name>subqueryRteListProperties</name><operator>-&gt;</operator><name>hasPostgresLocalTable</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"distributed INSERT ... SELECT cannot select from "</literal>
							 <literal type="string">"distributed tables and local tables at the same time"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryRteListProperties</name><operator>-&gt;</operator><name>hasDistributedTable</name></name> <operator>&amp;&amp;</operator>
		<call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"distributed INSERT ... SELECT cannot insert into a "</literal>
							 <literal type="string">"local table that is added to metadata"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In some cases, it might be possible to allow postgres local tables
	 * in distributed insert select. However, we want to behave consistent
	 * on all cases including Citus MX, and let insert select via coordinator
	 * to kick-in.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryRteListProperties</name><operator>-&gt;</operator><name>hasPostgresLocalTable</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"distributed INSERT ... SELECT cannot select from "</literal>
							 <literal type="string">"a local table"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we do not expect to see a view in modify target */</comment>
	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>queryTree-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot insert into view over distributed table"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>queryTree</name></expr></argument>, <argument><expr><name>CitusIsVolatileFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"volatile functions are not allowed in distributed "</literal>
							 <literal type="string">"INSERT ... SELECT queries"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we don't support LIMIT, OFFSET and WINDOW functions */</comment>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>MultiTaskRouterSelectQuerySupported</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>error</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we're inserting into a citus local table, it is ok because we've
		 * checked the non-existence of distributed tables in the subquery.
		 */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we're inserting into a reference table, all participating tables
		 * should be reference tables as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allReferenceTables</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"only reference tables may be queried when targeting "</literal>
								 <literal type="string">"a reference table with distributed INSERT ... SELECT"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* ensure that INSERT's partition column comes from SELECT's partition column */</comment>
		<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>InsertPartitionColumnMatchesSelect</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>, <argument><expr><name>insertRte</name></expr></argument>, <argument><expr><name>subqueryRte</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>selectPartitionColumnTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>error</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We expect partition column values come from colocated tables. Note that we
		 * skip this check from the reference table case given that all reference tables
		 * are already (and by default) co-located.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TablesColocated</name><argument_list>(<argument><expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>selectPartitionColumnTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"INSERT target table and the source relation of the SELECT partition "</literal>
								 <literal type="string">"column value must be colocated in distributed INSERT ... SELECT"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RouterModifyTaskForShardInterval creates a modify task by
 * replacing the partitioning qual parameter added in distributed_planner()
 * with the shardInterval's boundary value. Then perform the normal
 * shard pruning on the subquery. Finally, checks if the target shardInterval
 * has exactly same placements with the select task's available anchor
 * placements.
 *
 * The function errors out if the subquery is not router select query (i.e.,
 * subqueries with non equi-joins.).
 */</comment>
<function><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type>
<name>RouterModifyTaskForShardInterval</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
								 <parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetTableCacheEntry</name></decl></parameter>,
								 <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>,
								 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>,
								 <parameter><decl><type><name>uint32</name></type> <name>taskIdIndex</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>safeToPushdownSubquery</name></decl></parameter>,
								 <parameter><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>routerPlannerError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>copiedQuery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>copiedInsertRte</name> <init>= <expr><call><name>ExtractResultRelationRTEOrError</name><argument_list>(<argument><expr><name>copiedQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>copiedSubqueryRte</name> <init>= <expr><call><name>ExtractSelectRangeTableEntry</name><argument_list>(<argument><expr><name>copiedQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>copiedSubquery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>copiedSubqueryRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>copyOfPlannerRestrictionContext</name> <init>= <expr><call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>restrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectPlacementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>selectAnchorShardId</name> <init>= <expr><name>INVALID_SHARD_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardIntervalListList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>allReferenceTables</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name><operator>-&gt;</operator><name>allReferenceTables</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardOpExpressions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>shardRestrictionList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>multiShardModifyQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationRestrictionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>copyOfPlannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name> <operator>=</operator>
		<call><name>CopyRelationRestrictionContext</name><argument_list>(
			<argument><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOfPlannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name> <operator>=</operator>
		<name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOfPlannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name></name> <operator>=</operator>
		<name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>relationRestrictionList</name> <operator>=</operator>
		<name><name>copyOfPlannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name><operator>-&gt;</operator>
		<name>relationRestrictionList</name></name></expr>;</expr_stmt>

	<comment type="block">/* grab shared metadata lock to stop concurrent placement additions */</comment>
	<expr_stmt><expr><call><name>LockShardDistributionMetadata</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace the partitioning qual parameter value in all baserestrictinfos.
	 * Note that this has to be done on a copy, as the walker modifies in place.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>restrictionCell</argument>, <argument>relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>restriction</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>restrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>originalBaseRestrictInfo</name> <init>= <expr><name><name>restriction</name><operator>-&gt;</operator><name>relOptInfo</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>extendedBaseRestrictInfo</name> <init>= <expr><name>originalBaseRestrictInfo</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>rteIndex</name> <init>= <expr><name><name>restriction</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>safeToPushdownSubquery</name> <operator>||</operator> <name>allReferenceTables</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>shardOpExpressions</name> <operator>=</operator> <call><name>ShardIntervalOpExpressions</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>, <argument><expr><name>rteIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* means it is a reference table and do not add any shard interval information  */</comment>
		<if_stmt><if>if <condition>(<expr><name>shardOpExpressions</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>


		<comment type="block">/*
		 * passing NULL for plannerInfo will be problematic if we have placeholder
		 * vars. However, it won't be the case here because we are building
		 * the expression from shard intervals which don't have placeholder vars.
		 * Note that this is only the case with PG14 as the parameter doesn't exist
		 * prior to that.
		 */</comment>
		<expr_stmt><expr><name>shardRestrictionList</name> <operator>=</operator> <call><name>make_simple_restrictinfo_compat</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
															   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>shardOpExpressions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>extendedBaseRestrictInfo</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>extendedBaseRestrictInfo</name></expr></argument>,
										   <argument><expr><name>shardRestrictionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>restriction</name><operator>-&gt;</operator><name>relOptInfo</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator> <name>extendedBaseRestrictInfo</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We also need to add shard interval range to the subquery in case
	 * the partition qual not distributed all tables such as some
	 * subqueries in WHERE clause.
	 *
	 * Note that we need to add the ranges before the shard pruning to
	 * prevent shard pruning logic (i.e, namely UpdateRelationNames())
	 * modifies range table entries, which makes hard to add the quals.
	 */</comment>
	<decl_stmt><decl><type><name>RTEListProperties</name> <modifier>*</modifier></type><name>subqueryRteListProperties</name> <init>= <expr><call><name>GetRTEListPropertiesForQuery</name><argument_list>(
		<argument><expr><name>copiedSubquery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryRteListProperties</name><operator>-&gt;</operator><name>hasDistributedTable</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AddPartitionKeyNotNullFilterToSelect</name><argument_list>(<argument><expr><name>copiedSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* mark that we don't want the router planner to generate dummy hosts/queries */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>replacePrunedQueryWithDummy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use router planner to decide on whether we can push down the query or not.
	 * If we can, we also rely on the side-effects that all RTEs have been updated
	 * to point to the relevant nodes and selectPlacementList is determined.
	 */</comment>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>planningError</name> <init>= <expr><call><name>PlanRouterQuery</name><argument_list>(<argument><expr><name>copiedSubquery</name></expr></argument>,
														  <argument><expr><name>copyOfPlannerRestrictionContext</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>selectPlacementList</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>selectAnchorShardId</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>relationShardList</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>prunedShardIntervalListList</name></expr></argument>,
														  <argument><expr><name>replacePrunedQueryWithDummy</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>multiShardModifyQuery</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
														  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>multiShardModifyQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>planningError</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>routerPlannerError</name> <operator>=</operator> <name>planningError</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* ensure that we do not send queries where select is pruned away completely */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>selectPlacementList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Skipping target shard interval "</literal> <name>UINT64_FORMAT</name>
								<literal type="string">" since SELECT query for it pruned away"</literal></expr></argument>,
								<argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get the placements for insert target shard and its intersection with select */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertShardPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>intersectedPlacementList</name> <init>= <expr><call><name>IntersectPlacementList</name><argument_list>(<argument><expr><name>insertShardPlacementList</name></expr></argument>,
															<argument><expr><name>selectPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If insert target does not have exactly the same placements with the select,
	 * we sholdn't run the query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>insertShardPlacementList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>intersectedPlacementList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform distributed planning for the given "</literal>
							   <literal type="string">"modification"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Insert query cannot be executed on all placements "</literal>
								  <literal type="string">"for shard "</literal> <name>UINT64_FORMAT</name> <literal type="string">""</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* this is required for correct deparsing of the query */</comment>
	<expr_stmt><expr><call><name>ReorderInsertSelectTargetLists</name><argument_list>(<argument><expr><name>copiedQuery</name></expr></argument>, <argument><expr><name>copiedInsertRte</name></expr></argument>, <argument><expr><name>copiedSubqueryRte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* setting an alias simplifies deparsing of RETURNING */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>copiedInsertRte</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><call><name>makeAlias</name><argument_list>(<argument><expr><name>CITUS_TABLE_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>copiedInsertRte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* and generate the full query string */</comment>
	<expr_stmt><expr><call><name>deparse_shard_query</name><argument_list>(<argument><expr><name>copiedQuery</name></expr></argument>, <argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
						<argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributed statement: %s"</literal></expr></argument>,
							<argument><expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>modifyTask</name> <init>= <expr><call><name>CreateBasicTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskIdIndex</name></expr></argument>, <argument><expr><name>MODIFY_TASK</name></expr></argument>,
									   <argument><expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name>insertShardPlacementList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>relationShardList</name></name> <operator>=</operator> <name>relationShardList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name><name>targetTableCacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr>;</expr_stmt>

	<return>return <expr><name>modifyTask</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReorderInsertSelectTargetLists reorders the target lists of INSERT/SELECT
 * query which is required for deparsing purposes. The reordered query is returned.
 *
 * The necessity for this function comes from the fact that ruleutils.c is not supposed
 * to be used on "rewritten" queries (i.e. ones that have been passed through
 * QueryRewrite()). Query rewriting is the process in which views and such are expanded,
 * and, INSERT/UPDATE targetlists are reordered to match the physical order,
 * defaults etc. For the details of reordeing, see transformInsertRow() and
 * rewriteTargetListIU().
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>ReorderInsertSelectTargetLists</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name></decl></parameter>,
							   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subqueryRte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>insertTargetEntryCell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newSubqueryTargetlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newInsertTargetlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>selectTableId</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>targetEntryIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>subqueryRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>insertRelationId</name> <init>= <expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We implement the following algorithm for the reoderding:
	 *  - Iterate over the INSERT target list entries
	 *    - If the target entry includes a Var, find the corresponding
	 *      SELECT target entry on the original query and update resno
	 *    - If the target entry does not include a Var (i.e., defaults
	 *      or constants), create new target entry and add that to
	 *      SELECT target list
	 *    - Create a new INSERT target entry with respect to the new
	 *      SELECT target entry created.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>insertTargetEntryCell</argument>, <argument>originalQuery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>oldInsertTargetEntry</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>insertTargetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newSubqueryTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>originalAttrNo</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>insertRelationId</name></expr></argument>,
											   <argument><expr><name><name>oldInsertTargetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* see transformInsertRow() for the details */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>oldInsertTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name><name>oldInsertTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"cannot plan distributed INSERT INTO ... SELECT query"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not use array references and field stores "</literal>
									<literal type="string">"on the INSERT target list."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * It is safe to pull Var clause and ignore the coercions since that
		 * are already going to be added on the workers implicitly.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetVarList</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>oldInsertTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
											  <argument><expr><name>PVC_RECURSE_AGGREGATES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>targetVarCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>targetVarList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* a single INSERT target entry cannot have more than one Var */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetVarCount</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>targetVarCount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>oldInsertVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>targetVarList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>oldSubqueryTle</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
												   <argument><expr><name><name>oldInsertVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>newSubqueryTargetEntry</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>oldSubqueryTle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>newSubqueryTargetEntry</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>resno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>newSubqueryTargetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newSubqueryTargetlist</name></expr></argument>,
											<argument><expr><name>newSubqueryTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newSubqueryTargetEntry</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name><name>oldInsertTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
													 <argument><expr><name>resno</name></expr></argument>,
													 <argument><expr><name><name>oldInsertTargetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
													 <argument><expr><name><name>oldInsertTargetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newSubqueryTargetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newSubqueryTargetlist</name></expr></argument>,
											<argument><expr><name>newSubqueryTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>newSubqueryTargetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>columnNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columnNameList</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The newly created select target entry cannot be a junk entry since junk
		 * entries are not in the final target list and we're processing the
		 * final target list entries.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>newSubqueryTargetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>newInsertVar</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>selectTableId</name></expr></argument>, <argument><expr><name>resno</name></expr></argument>,
									<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>newSubqueryTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>newSubqueryTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>newSubqueryTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newInsertTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newInsertVar</name></expr></argument>,
															<argument><expr><name>originalAttrNo</name></expr></argument>,
															<argument><expr><name><name>oldInsertTargetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
															<argument><expr><name><name>oldInsertTargetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>newInsertTargetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newInsertTargetlist</name></expr></argument>, <argument><expr><name>newInsertTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * if there are any remaining target list entries (i.e., GROUP BY column not on the
	 * target list of subquery), update the remaining resnos.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>subqueryTargetLength</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init>;</init> <condition><expr><name>targetEntryIndex</name> <operator>&lt;</operator> <name>subqueryTargetLength</name></expr>;</condition> <incr><expr><operator>++</operator><name>targetEntryIndex</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>oldSubqueryTle</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
											   <argument><expr><name>targetEntryIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip non-junk entries since we've already processed them above and this
		 * loop only is intended for junk entries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>oldSubqueryTle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newSubqueryTargetEntry</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>oldSubqueryTle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>newSubqueryTargetEntry</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>resno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newSubqueryTargetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newSubqueryTargetlist</name></expr></argument>,
										<argument><expr><name>newSubqueryTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>resno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>originalQuery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>newInsertTargetlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>newSubqueryTargetlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryRte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>columnNameList</name></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MultiTaskRouterSelectQuerySupported returns NULL if the query may be used
 * as the source for an INSERT ... SELECT or returns a description why not.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>MultiTaskRouterSelectQuerySupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>queryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>errorDetail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasUnsupportedDistinctOn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractQueryWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>queryCell</argument>, <argument>queryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>queryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* pushing down rtes without relations yields (shardCount * expectedRows) */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HasEmptyJoinTree</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"Subqueries without relations are not allowed in "</literal>
								 <literal type="string">"distributed INSERT ... SELECT queries"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* pushing down limit per shard would yield wrong results */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"LIMIT clauses are not allowed in distributed INSERT "</literal>
								 <literal type="string">"... SELECT queries"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* pushing down limit offest per shard would yield wrong results */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"OFFSET clauses are not allowed in distributed "</literal>
								 <literal type="string">"INSERT ... SELECT queries"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* group clause list must include partition column */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name> <init>= <expr><name><name>subquery</name><operator>-&gt;</operator><name>groupClause</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupTargetEntryList</name> <init>= <expr><call><name>GroupTargetEntryList</name><argument_list>(<argument><expr><name>groupClauseList</name></expr></argument>,
															  <argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>groupOnPartitionColumn</name> <init>= <expr><call><name>TargetListOnPartitionColumn</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>,
																	  <argument><expr><name>groupTargetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>groupOnPartitionColumn</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"Group by list without distribution column is "</literal>
									 <literal type="string">"not allowed  in distributed INSERT ... "</literal>
									 <literal type="string">"SELECT queries"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We support window functions when the window function
		 * is partitioned on distribution column.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SafeToPushdownWindowFunction</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>,
																	<argument><expr><operator>&amp;</operator><name>errorDetail</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>, <argument><expr><name><name>errorDetail</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"Set operations are not allowed in distributed "</literal>
								 <literal type="string">"INSERT ... SELECT queries"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We currently do not support grouping sets since it could generate NULL
		 * results even after the restrictions are applied to the query. A solution
		 * would be to add the whole query into a subquery and add the restrictions
		 * on that subquery.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"grouping sets are not allowed in distributed "</literal>
								 <literal type="string">"INSERT ... SELECT queries"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We don't support DISTINCT ON clauses on non-partition columns.
		 */</comment>
		<expr_stmt><expr><name>hasUnsupportedDistinctOn</name> <operator>=</operator> <call><name>HasUnsupportedDistinctOn</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hasUnsupportedDistinctOn</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"DISTINCT ON (non-partition column) clauses are not "</literal>
								 <literal type="string">"allowed in distributed INSERT ... SELECT queries"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasUnsupportedDistinctOn returns true if the query has distinct on and
 * distinct targets do not contain partition column.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasUnsupportedDistinctOn</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>distinctCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>distinctCell</argument>, <argument>query-&gt;distinctClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>distinctClause</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>distinctCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>distinctEntry</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>,
															 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>skipOuterVars</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsPartitionColumn</name><argument_list>(<argument><expr><name><name>distinctEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InsertPartitionColumnMatchesSelect returns NULL the partition column in the
 * table targeted by INSERTed matches with the any of the SELECTed table's
 * partition column.  Returns the error description if there's no match.
 *
 * On return without error (i.e., if partition columns match), the function
 * also sets selectPartitionColumnTableId.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>InsertPartitionColumnMatchesSelect</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name></decl></parameter>,
								   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subqueryRte</name></decl></parameter>,
								   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>selectPartitionColumnTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>targetEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rangeTableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>insertRelationId</name> <init>= <expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>insertPartitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>insertRelationId</name></expr></argument>, <argument><expr><name>rangeTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>subqueryRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>targetTableHasPartitionColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetEntryColumnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>subqueryPartitionColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We only consider target entries that include a single column. Note that this
		 * is slightly different than directly checking the whether the targetEntry-&gt;expr
		 * is a var since the var could be wrapped into an implicit/explicit casting.
		 *
		 * Also note that we skip the target entry if it does not contain a Var, which
		 * corresponds to columns with DEFAULT values on the target list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>insertTargetEntryColumnList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>insertVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>insertTargetEntryColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>originalAttrNo</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resno</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* skip processing of target table non-partition columns */</comment>
		<if_stmt><if>if <condition>(<expr><name>originalAttrNo</name> <operator>!=</operator> <name><name>insertPartitionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* INSERT query includes the partition column */</comment>
		<expr_stmt><expr><name>targetTableHasPartitionColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>subqueryTargetEntry</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
													<argument><expr><name><name>insertVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>selectTargetExpr</name> <init>= <expr><name><name>subqueryTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subqueryPartitionColumnRelationIdRTE</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parentQueryList</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>skipOuterVars</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>FindReferencedTableColumn</name><argument_list>(<argument><expr><name>selectTargetExpr</name></expr></argument>,
								  <argument><expr><name>parentQueryList</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>subqueryPartitionColumn</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>subqueryPartitionColumnRelationIdRTE</name></expr></argument>,
								  <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>subqueryPartitionColumnRelationId</name> <init>= <expr><ternary><condition><expr><name>subqueryPartitionColumnRelationIdRTE</name></expr> ?</condition><then>
												<expr><name><name>subqueryPartitionColumnRelationIdRTE</name><operator>-&gt;</operator>
												<name>relid</name></name></expr> </then><else>:
												<expr><name>InvalidOid</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Corresponding (i.e., in the same ordinal position as the target table's
		 * partition column) select target entry does not directly belong a table.
		 * Evaluate its expression type and error out properly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>subqueryPartitionColumnRelationId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errorDetailTemplate</name> <init>= <expr><literal type="string">"Subquery contains %s in the "</literal>
										<literal type="string">"same position as the target table's "</literal>
										<literal type="string">"partition column."</literal></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>exprDescription</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>selectTargetExpr</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>T_Const</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"a constant value"</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>T_OpExpr</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"an operator"</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>T_FuncExpr</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>subqueryFunctionExpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>selectTargetExpr</name></expr></init></decl>;</decl_stmt>

					<switch>switch <condition>(<expr><name><name>subqueryFunctionExpr</name><operator>-&gt;</operator><name>funcformat</name></name></expr>)</condition>
					<block>{<block_content>
						<case>case <expr><name>COERCE_EXPLICIT_CALL</name></expr>:</case>
						<block>{<block_content>
							<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"a function call"</literal></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block>

						<case>case <expr><name>COERCE_EXPLICIT_CAST</name></expr>:</case>
						<block>{<block_content>
							<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"an explicit cast"</literal></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block>

						<case>case <expr><name>COERCE_IMPLICIT_CAST</name></expr>:</case>
						<block>{<block_content>
							<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"an implicit cast"</literal></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block>

						<default>default:</default>
						<block>{<block_content>
							<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"a function call"</literal></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block>
					</block_content>}</block></switch>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>T_Aggref</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"an aggregation"</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>T_CaseExpr</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"a case expression"</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"a coalesce expression"</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>T_RowExpr</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"a row expression"</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"a min/max expression"</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name>exprDescription</name> <operator>=</operator> <literal type="string">"an explicit coercion"</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

				<default>default:</default>
				<block>{<block_content>
					<expr_stmt><expr><name>exprDescription</name> <operator>=</operator>
						<literal type="string">"an expression that is not a simple column reference"</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			</block_content>}</block></switch>

			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot perform distributed INSERT INTO ... SELECT "</literal>
								 <literal type="string">"because the partition columns in the source table "</literal>
								 <literal type="string">"and subquery do not match"</literal></expr></argument>,
								 <argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><name>errorDetailTemplate</name></expr></argument>, <argument><expr><name>exprDescription</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><literal type="string">"Ensure the target table's partition column has a "</literal>
								 <literal type="string">"corresponding simple column reference to a distributed "</literal>
								 <literal type="string">"table's partition column in the subquery."</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Insert target expression could only be non-var if the select target
		 * entry does not have the same type (i.e., target column requires casting).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot perform distributed INSERT INTO ... SELECT "</literal>
								 <literal type="string">"because the partition columns in the source table "</literal>
								 <literal type="string">"and subquery do not match"</literal></expr></argument>,
								 <argument><expr><literal type="string">"The data type of the target table's partition column "</literal>
								 <literal type="string">"should exactly match the data type of the "</literal>
								 <literal type="string">"corresponding simple column reference in the subquery."</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* finally, check that the select target column is a partition column */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsPartitionColumn</name><argument_list>(<argument><expr><name>selectTargetExpr</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot perform distributed INSERT INTO ... SELECT "</literal>
								 <literal type="string">"because the partition columns in the source table "</literal>
								 <literal type="string">"and subquery do not match"</literal></expr></argument>,
								 <argument><expr><literal type="string">"The target table's partition column should correspond "</literal>
								 <literal type="string">"to a partition column in the subquery."</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* finally, check that the select target column is a partition column */</comment>
		<comment type="block">/* we can set the select relation id */</comment>
		<expr_stmt><expr><operator>*</operator><name>selectPartitionColumnTableId</name> <operator>=</operator> <name>subqueryPartitionColumnRelationId</name></expr>;</expr_stmt>

		<break>break;</break>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetTableHasPartitionColumn</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot perform distributed INSERT INTO ... SELECT "</literal>
							 <literal type="string">"because the partition columns in the source table "</literal>
							 <literal type="string">"and subquery do not match"</literal></expr></argument>,
							 <argument><expr><literal type="string">"the query doesn't include the target table's "</literal>
							 <literal type="string">"partition column"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateNonPushableInsertSelectPlan creates a query plan for a SELECT into a
 * distributed table. The query plan can also be executed on a worker in MX.
 */</comment>
<function><type><specifier>static</specifier> <name>DistributedPlan</name> <modifier>*</modifier></type>
<name>CreateNonPushableInsertSelectPlan</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>selectRte</name> <init>= <expr><call><name>ExtractSelectRangeTableEntry</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name> <init>= <expr><call><name>ExtractResultRelationRTEOrError</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>DistributedPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>modLevel</name></name> <operator>=</operator> <call><name>RowModifyLevelForQuery</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>=</operator>
		<call><name>NonPushableInsertSelectSupported</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>distributedPlan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PrepareInsertSelectForCitusPlanner</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the SELECT query (may have changed after PrepareInsertSelectForCitusPlanner) */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>selectQuery</name> <init>= <expr><name><name>selectRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Later we might need to call WrapTaskListForProjection(), which requires
	 * that select target list has unique names, otherwise the outer query
	 * cannot select columns unambiguously. So we relabel select columns to
	 * match target columns.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name> <init>= <expr><name><name>insertSelectQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelabelTargetEntryList</name><argument_list>(<argument><expr><name><name>selectQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>insertTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a copy of the select query, since following code scribbles it
	 * but we need to keep the original for EXPLAIN.
	 */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>selectQueryCopy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>selectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* plan the subquery, this may be another distributed query */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>cursorOptions</name> <init>= <expr><name>CURSOR_OPT_PARALLEL_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>selectPlan</name> <init>= <expr><call><name>pg_plan_query</name><argument_list>(<argument><expr><name>selectQueryCopy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>,
											<argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>repartitioned</name> <init>= <expr><call><name>IsRedistributablePlan</name><argument_list>(<argument><expr><name><name>selectPlan</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						 <call><name>IsSupportedRedistributionTarget</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>insertSelectQuery</name></name> <operator>=</operator> <name>insertSelectQuery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>selectPlanForInsertSelect</name></name> <operator>=</operator> <name>selectPlan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>insertSelectMethod</name></name> <operator>=</operator> <ternary><condition><expr><name>repartitioned</name></expr> ?</condition><then>
										  <expr><name>INSERT_SELECT_REPARTITION</name></expr> </then><else>:
										  <expr><name>INSERT_SELECT_VIA_COORDINATOR</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>expectResults</name></name> <operator>=</operator> <name><name>insertSelectQuery</name><operator>-&gt;</operator><name>returningList</name></name> <operator>!=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>intermediateResultIdPrefix</name></name> <operator>=</operator> <call><name>InsertSelectResultIdPrefix</name><argument_list>(<argument><expr><name>planId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>targetRelationId</name></name> <operator>=</operator> <name>targetRelationId</name></expr>;</expr_stmt>

	<return>return <expr><name>distributedPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NonPushableInsertSelectSupported returns an error if executing an
 * INSERT ... SELECT command by pulling results of the SELECT to the coordinator
 * or with repartitioning is unsupported because it needs to generate sequence
 * values or insert into an append-distributed table.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>NonPushableInsertSelectSupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>insertSelectQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>deferredError</name> <init>= <expr><call><name>ErrorIfOnConflictNotSupported</name><argument_list>(
		<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>deferredError</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>deferredError</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>insertRte</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>insertSelectQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>insertRte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"INSERT ... SELECT into an append-distributed table is "</literal>
							 <literal type="string">"not supported"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InsertSelectResultPrefix returns the prefix to use for intermediate
 * results of an INSERT ... SELECT via the coordinator that runs in two
 * phases in order to do RETURNING or ON CONFLICT.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>InsertSelectResultIdPrefix</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>resultIdPrefix</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>resultIdPrefix</name></expr></argument>, <argument><expr><literal type="string">"insert_select_"</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>planId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>resultIdPrefix</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WrapSubquery wraps the given query as a subquery in a newly constructed
 * "SELECT * FROM (...subquery...) citus_insert_select_subquery" query.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>WrapSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newTargetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>outerQuery</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>outerQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<comment type="block">/* create range table entries */</comment>
	<decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>selectAlias</name> <init>= <expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"citus_insert_select_subquery"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newRangeTableEntry</name> <init>= <expr><call><name>RangeTableEntryFromNSItem</name><argument_list>(
		<argument><expr><call><name>addRangeTableEntryForSubquery</name><argument_list>(
			<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
			<argument><expr><name>selectAlias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>outerQuery</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>newRangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set the FROM expression to the subquery */</comment>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>newRangeTableRef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>newRangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outerQuery</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>newRangeTableRef</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create a target list that matches the SELECT */</comment>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>selectTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>selectTargetEntry</argument>, <argument>subquery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* exactly 1 entry in FROM */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>indexInRangeTable</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>selectTargetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>newSelectVar</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>indexInRangeTable</name></expr></argument>, <argument><expr><name><name>selectTargetEntry</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
									<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>selectTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>selectTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>selectTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newSelectTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newSelectVar</name></expr></argument>,
															<argument><expr><name><name>selectTargetEntry</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
															<argument><expr><name><name>selectTargetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
															<argument><expr><name><name>selectTargetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>newTargetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newTargetList</name></expr></argument>, <argument><expr><name>newSelectTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>outerQuery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>newTargetList</name></expr>;</expr_stmt>

	<return>return <expr><name>outerQuery</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelabelTargetEntryList relabels select target list to have matching names with
 * insert target list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelabelTargetEntryList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectTargetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>selectTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>insertTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth_ptr</name><argument_list>(<argument>selectTargetEntry</argument>, <argument>selectTargetList</argument>, <argument>insertTargetEntry</argument>, <argument>insertTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>selectTargetEntry</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name><name>insertTargetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * AddInsertSelectCasts makes sure that the types in columns in the given
 * target lists have the same type as the columns of the given relation.
 * It might add casts to ensure that.
 *
 * It returns the updated selectTargetList.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>AddInsertSelectCasts</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTargetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectTargetList</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedEntries</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nonProjectedEntries</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * ReorderInsertSelectTargetLists() makes sure that first few columns of
	 * the SELECT query match the insert targets. It might contain additional
	 * items for GROUP BY, etc.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>insertTargetList</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>selectTargetList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>distributedRelation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>destTupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>targetEntryIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>insertEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>selectEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>forboth_ptr</name><argument_list>(<argument>insertEntry</argument>, <argument>insertTargetList</argument>, <argument>selectEntry</argument>, <argument>selectTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>destTupleDescriptor</name></expr></argument>,
											   <argument><expr><name><name>insertEntry</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>sourceType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>selectEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>targetType</name> <init>= <expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>sourceType</name> <operator>!=</operator> <name>targetType</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ReorderInsertSelectTargetLists ensures we only have Vars */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>insertEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* we will cast the SELECT expression, so the type changes */</comment>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>insertVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>insertEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>insertVar</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name>targetType</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>insertVar</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>insertVar</name><operator>-&gt;</operator><name>varcollid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * We cannot modify the selectEntry in-place, because ORDER BY or
			 * GROUP BY clauses might be pointing to it with comparison types
			 * of the source type. So instead we keep the original one as a
			 * non-projected entry, so GROUP BY and ORDER BY are happy, and
			 * create a duplicated projected entry with the coerced expression.
			 */</comment>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>coercedEntry</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>selectEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>coercedEntry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>CastExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>selectEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>sourceType</name></expr></argument>,
										  <argument><expr><name>targetType</name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
										  <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coercedEntry</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * The only requirement is that users don't use this name in ORDER BY
			 * or GROUP BY, and it should be unique across the same query.
			 */</comment>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>resnameString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>resnameString</name></expr></argument>, <argument><expr><literal type="string">"auto_coerced_by_citus_%d"</literal></expr></argument>, <argument><expr><name>targetEntryIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coercedEntry</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name><name>resnameString</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>projectedEntries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>projectedEntries</name></expr></argument>, <argument><expr><name>coercedEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>selectEntry</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>selectEntry</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * This entry might still end up in the SELECT output list, so
				 * rename it to avoid ambiguity.
				 *
				 * See https://github.com/citusdata/citus/pull/3470.
				 */</comment>
				<expr_stmt><expr><name>resnameString</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>resnameString</name></expr></argument>, <argument><expr><literal type="string">"discarded_target_item_%d"</literal></expr></argument>,
								 <argument><expr><name>targetEntryIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>selectEntry</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name><name>resnameString</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name>nonProjectedEntries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nonProjectedEntries</name></expr></argument>, <argument><expr><name>selectEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>projectedEntries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>projectedEntries</name></expr></argument>, <argument><expr><name>selectEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>targetEntryIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>entryIndex</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>insertTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</init>
		 <condition><expr><name>entryIndex</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>selectTargetList</name></expr></argument>)</argument_list></call></expr>;</condition>
		 <incr><expr><name>entryIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>nonProjectedEntries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nonProjectedEntries</name></expr></argument>, <argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name>selectTargetList</name></expr></argument>,
																	<argument><expr><name>entryIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* selectEntry-&gt;resno must be the ordinal number of the entry */</comment>
	<expr_stmt><expr><name>selectTargetList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>projectedEntries</name></expr></argument>, <argument><expr><name>nonProjectedEntries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>entryResNo</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>selectTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>selectTargetEntry</argument>, <argument>selectTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>selectTargetEntry</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>entryResNo</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>selectTargetList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CastExpr returns an expression which casts the given expr from sourceType to
 * the given targetType.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>CastExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sourceType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetCollation</name></decl></parameter>,
		 <parameter><decl><type><name>int</name></type> <name>targetTypeMod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>coercionFuncId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>coercionType</name> <init>= <expr><call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>sourceType</name></expr></argument>,
														  <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>coercionFuncId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>coercionType</name> <operator>==</operator> <name>COERCION_PATH_FUNC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>coerceExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>coercionFuncId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name>targetCollation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name>targetType</name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>coerceExpr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>coercionType</name> <operator>==</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>coerceExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>targetType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name>targetTypeMod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name>targetCollation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>coerceExpr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>coercionType</name> <operator>==</operator> <name>COERCION_PATH_ARRAYCOERCE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sourceBaseType</name> <init>= <expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><name>sourceType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>targetBaseType</name> <init>= <expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>elemExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>elemExpr</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>targetCollation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elemExpr</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>sourceBaseType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>elemExpr</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>elemCastExpr</name> <init>= <expr><call><name>CastExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>elemExpr</name></expr></argument>, <argument><expr><name>sourceBaseType</name></expr></argument>,
									  <argument><expr><name>targetBaseType</name></expr></argument>, <argument><expr><name>targetCollation</name></expr></argument>,
									  <argument><expr><name>targetTypeMod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>coerceExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>elemexpr</name></name> <operator>=</operator> <name>elemCastExpr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name>targetCollation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>targetType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>resulttypmod</name></name> <operator>=</operator> <name>targetTypeMod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>coerceExpr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>coercionType</name> <operator>==</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>coerceExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>targetType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name>targetCollation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>coerceExpr</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find a conversion path from type %d to %d"</literal></expr></argument>,
							   <argument><expr><name>sourceType</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* PlanningInsertSelect returns true if we are planning an INSERT ...SELECT query */</comment>
<function><type><name>bool</name></type>
<name>PlanningInsertSelect</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>insertSelectPlannerLevel</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
