<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/planner/distributed_planner.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * distributed_planner.c
 *	  General Citus planner code.
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_depended_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/cte_inline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/function_call_delegation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_result_pruning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_results.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_pushdown_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/combine_query_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/recursive_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_shard_visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>plannerRestrictionContextList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>MultiTaskQueryLogLevel</name> <init>= <expr><name>CITUS_LOG_LEVEL_OFF</name></expr></init></decl>;</decl_stmt> <comment type="block">/* multi-task query log level */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>NextPlanId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* keep track of planner call stack levels */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>PlannerLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfQueryHasMergeCommand</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsMergeCommandWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ListContainsDistributedTableRTE</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>,
											<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>maybeHasForeignDistributedTable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsUpdateOrDelete</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type> <name>CreateDistributedPlannedStmt</name><parameter_list>(
	<parameter><decl><type><name>DistributedPlanningContext</name> <modifier>*</modifier></type><name>planContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type> <name>InlineCtesAndCreateDistributedPlannedStmt</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>,
															   <parameter><decl><type><name>DistributedPlanningContext</name>
															   <modifier>*</modifier></type><name>planContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type> <name>TryCreateDistributedPlannedStmt</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>localPlan</name></decl></parameter>,
													 <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
													 <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type>
													 <name>boundParams</name></decl></parameter>,
													 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
													 <name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfPartitionTableNotSingleReplicated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type>
																			<name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>AssignRTEIdentities</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rteIdCounter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AssignRTEIdentity</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rteIdentifier</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdjustPartitioningForDistributedPlanning</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>,
													 <parameter><decl><type><name>bool</name></type> <name>setPartitionedTablesInherited</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type> <name>FinalizeNonRouterPlan</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>localPlan</name></decl></parameter>,
										   <parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name></decl></parameter>,
										   <parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>customScan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type> <name>FinalizeRouterPlan</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>localPlan</name></decl></parameter>, <parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>customScan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AppendRelInfo</name> <modifier>*</modifier></type> <name>FindTargetAppendRelInfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relationRteIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>makeTargetListFromCustomScanList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_scan_tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>makeCustomScanTargetlistFromExistingTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>existingTargetlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>BlessRecordExpressionList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckNodeIsDumpable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>CheckNodeCopyAndSerialization</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdjustReadIntermediateResultCost</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
											 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relOptInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdjustReadIntermediateResultArrayCost</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
												  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relOptInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdjustReadIntermediateResultsCostInternal</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relOptInfo</name></decl></parameter>,
													  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnTypes</name></decl></parameter>,
													  <parameter><decl><type><name>int</name></type> <name>resultIdCount</name></decl></parameter>,
													  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultIds</name></decl></parameter>,
													  <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultFormatConst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>OuterPlanParamsList</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CopyPlanParamList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>originalPlanParamList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannerRestrictionContext</name> <modifier>*</modifier></type> <name>CreateAndPushPlannerRestrictionContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannerRestrictionContext</name> <modifier>*</modifier></type> <name>CurrentPlannerRestrictionContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PopPlannerRestrictionContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResetPlannerRestrictionContext</name><parameter_list>(
	<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type> <name>PlanFastPathDistributedStmt</name><parameter_list>(<parameter><decl><type><name>DistributedPlanningContext</name> <modifier>*</modifier></type><name>planContext</name></decl></parameter>,
												 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>distributionKeyValue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type> <name>PlanDistributedStmt</name><parameter_list>(<parameter><decl><type><name>DistributedPlanningContext</name> <modifier>*</modifier></type><name>planContext</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>rteIdCounter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RTEListProperties</name> <modifier>*</modifier></type> <name>GetRTEListProperties</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>TranslatedVars</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relationIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WarnIfListHasForeignDistributedTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* Distributed planner hook */</comment>
<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>distributed_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>,
					<parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>needsDistributedPlanning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>fastPathRouterQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>distributionKeyValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><call><name>ExtractRangeTableEntryList</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_FORCE_DISTRIBUTED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this cursor flag could only be set when Citus has been loaded */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We cannot have merge command for this path as well because
		 * there cannot be recursively planned merge command.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ContainsMergeCommandWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parse</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>needsDistributedPlanning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>maybeHasForeignDistributedTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>needsDistributedPlanning</name> <operator>=</operator>
			<call><name>ListContainsDistributedTableRTE</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>maybeHasForeignDistributedTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>needsDistributedPlanning</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fastPathRouterQuery</name> <operator>=</operator> <call><name>FastPathRouterQuery</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>distributionKeyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>maybeHasForeignDistributedTable</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>WarnIfListHasForeignDistributedTable</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>rteIdCounter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedPlanningContext</name></type> <name>planContext</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>query</name> <operator>=</operator> <name>parse</name></expr>,
		<expr><operator>.</operator><name>cursorOptions</name> <operator>=</operator> <name>cursorOptions</name></expr>,
		<expr><operator>.</operator><name>boundParams</name> <operator>=</operator> <name>boundParams</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>needsDistributedPlanning</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * standard_planner scribbles on its input, but for deparsing we need the
		 * unmodified form. Before copying we call AssignRTEIdentities to be able
		 * to match RTEs in the rewritten query tree with those in the original
		 * tree.
		 */</comment>
		<expr_stmt><expr><name>rteIdCounter</name> <operator>=</operator> <call><name>AssignRTEIdentities</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>rteIdCounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>planContext</name><operator>.</operator><name>originalQuery</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fastPathRouterQuery</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Fast path queries cannot have merge command, and we
			 * prevent the remaining here.
			 */</comment>
			<expr_stmt><expr><call><name>ErrorIfQueryHasMergeCommand</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * When there are partitioned tables (not applicable to fast path),
			 * pretend that they are regular tables to avoid unnecessary work
			 * in standard_planner.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>setPartitionedTablesInherited</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>AdjustPartitioningForDistributedPlanning</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>,
													 <argument><expr><name>setPartitionedTablesInherited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make sure that we hide shard names on the Citus MX worker nodes. See comments in
	 * HideShardsFromSomeApplications() for the details.
	 */</comment>
	<expr_stmt><expr><call><name>HideShardsFromSomeApplications</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If GUC is set, we prevent queries, which contain pg meta relations, from
	 * showing any citus dependent object. The flag is expected to be set only before
	 * postgres vanilla tests.
	 */</comment>
	<expr_stmt><expr><call><name>HideCitusDependentObjectsOnQueriesOfPgMetaTables</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create a restriction context and put it at the end if context list */</comment>
	<expr_stmt><expr><name><name>planContext</name><operator>.</operator><name>plannerRestrictionContext</name></name> <operator>=</operator> <call><name>CreateAndPushPlannerRestrictionContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We keep track of how many times we've recursed into the planner, primarily
	 * to detect whether we are in a function call. We need to make sure that the
	 * PlannerLevel is decremented exactly once at the end of the next PG_TRY
	 * block, both in the happy case and when an error occurs.
	 */</comment>
	<expr_stmt><expr><name>PlannerLevel</name><operator>++</operator></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>fastPathRouterQuery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PlanFastPathDistributedStmt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>planContext</name></expr></argument>, <argument><expr><name>distributionKeyValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Call into standard_planner because the Citus planner relies on both the
			 * restriction information per table and parse tree transformations made by
			 * postgres' planner.
			 */</comment>
			<expr_stmt><expr><name><name>planContext</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name><name>planContext</name><operator>.</operator><name>query</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												<argument><expr><name><name>planContext</name><operator>.</operator><name>cursorOptions</name></name></expr></argument>,
												<argument><expr><name><name>planContext</name><operator>.</operator><name>boundParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>needsDistributedPlanning</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PlanDistributedStmt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>planContext</name></expr></argument>, <argument><expr><name>rteIdCounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>TryToDelegateFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>planContext</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>planContext</name><operator>.</operator><name>plan</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PopPlannerRestrictionContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>PlannerLevel</name><operator>--</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>PlannerLevel</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* remove the context from the context list */</comment>
	<expr_stmt><expr><call><name>PopPlannerRestrictionContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In some cases, for example; parameterized SQL functions, we may miss that
	 * there is a need for distributed planning. Such cases only become clear after
	 * standard_planner performs some modifications on parse tree. In such cases
	 * we will simply error out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needsDistributedPlanning</name> <operator>&amp;&amp;</operator> <call><name>NeedsDistributedPlanning</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform distributed planning on this "</literal>
							   <literal type="string">"query because parameterized queries for SQL "</literal>
							   <literal type="string">"functions referencing distributed tables are "</literal>
							   <literal type="string">"not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using PL/pgSQL functions instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfQueryHasMergeCommand walks over the query tree and throws error
 * if there are any Merge command (e.g., CMD_MERGE) in the query tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfQueryHasMergeCommand</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Postgres currently doesn't support Merge queries inside subqueries and
	 * ctes, but lets be defensive and do query tree walk anyway.
	 *
	 * We do not call this path for fast-path queries to avoid this additional
	 * overhead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ContainsMergeCommandWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>queryTree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MERGE command is not supported on Citus tables yet"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsMergeCommandWalker walks over the node and finds if there are any
 * Merge command (e.g., CMD_MERGE) in the node.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsMergeCommandWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_MERGE</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>ContainsMergeCommandWalker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ContainsMergeCommandWalker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractRangeTableEntryList is a wrapper around ExtractRangeTableEntryWalker.
 * The function traverses the input query and returns all the range table
 * entries that are in the query tree.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ExtractRangeTableEntryList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rteList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractRangeTableEntryWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rteList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rteList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NeedsDistributedPlanning returns true if the Citus extension is loaded and
 * the query contains a distributed table.
 *
 * This function allows queries containing local tables to pass through the
 * distributed planner. How to handle local tables is a decision that should
 * be made within the planner
 */</comment>
<function><type><name>bool</name></type>
<name>NeedsDistributedPlanning</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CmdType</name></type> <name>commandType</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <name>commandType</name> <operator>!=</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
		<name>commandType</name> <operator>!=</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <name>commandType</name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allRTEs</name> <init>= <expr><call><name>ExtractRangeTableEntryList</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ListContainsDistributedTableRTE</name><argument_list>(<argument><expr><name>allRTEs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ListContainsDistributedTableRTE gets a list of range table entries
 * and returns true if there is at least one distributed relation range
 * table entry in the list. The boolean maybeHasForeignDistributedTable
 * variable is set to true if the list contains a foreign table.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ListContainsDistributedTableRTE</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>,
								<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>maybeHasForeignDistributedTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>HideCitusDependentObjects</name> <operator>&amp;&amp;</operator> <call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsPgLocksTable</name><argument_list>(
				<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Postgres tidscan.sql test fails if we do not filter pg_locks table because
			 * test results, which show taken locks in serializable isolation mode,
			 * fails by showing extra lock taken by IsCitusTable below.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>maybeHasForeignDistributedTable</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<call><name>IsForeignTable</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>maybeHasForeignDistributedTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssignRTEIdentities function modifies query tree by adding RTE identities to the
 * RTE_RELATIONs.
 *
 * Please note that, we want to avoid modifying query tree as much as possible
 * because if PostgreSQL changes the way it uses modified fields, that may break
 * our logic.
 *
 * Returns the next id. This can be used to call on a rangeTableList that may've
 * been partially assigned. Should be set to 1 initially.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>AssignRTEIdentities</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rteIdCounter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * To be able to track individual RTEs through PostgreSQL's query
		 * planning, we need to be able to figure out whether an RTE is
		 * actually a copy of another, rather than a different one. We
		 * simply number the RTEs starting from 1.
		 *
		 * Note that we're only interested in RTE_RELATIONs and thus assigning
		 * identifiers to those RTEs only.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AssignRTEIdentity</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>rteIdCounter</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>rteIdCounter</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AdjustPartitioningForDistributedPlanning function modifies query tree by
 * changing inh flag and relkind of partitioned tables. We want Postgres to
 * treat partitioned tables as regular relations (i.e. we do not want to
 * expand them to their partitions) since it breaks Citus planning in different
 * ways. We let anything related to partitioning happen on the shards.
 *
 * Please note that, we want to avoid modifying query tree as much as possible
 * because if PostgreSQL changes the way it uses modified fields, that may break
 * our logic.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustPartitioningForDistributedPlanning</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name></type> <name>setPartitionedTablesInherited</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We want Postgres to behave partitioned tables as regular relations
		 * (i.e. we do not want to expand them to their partitions). To do this
		 * we set each partitioned table's inh flag to appropriate
		 * value before and after dropping to the standart_planner.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
			<call><name>PartitionedTable</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>setPartitionedTablesInherited</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>setPartitionedTablesInherited</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * AssignRTEIdentity assigns the given rteIdentifier to the given range table
 * entry.
 *
 * To be able to track RTEs through postgres' query planning, which copies and
 * duplicate, and modifies them, we sometimes need to figure out whether two
 * RTEs are copies of the same original RTE. For that we, hackishly, use a
 * field normally unused in RTE_RELATION RTEs.
 *
 * The assigned identifier better be unique within a plantree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AssignRTEIdentity</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rteIdentifier</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>=</operator> <call><name>list_make2_int</name><argument_list>(<argument><expr><name>rteIdentifier</name></expr></argument>, <argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* GetRTEIdentity returns the identity assigned with AssignRTEIdentity. */</comment>
<function><type><name>int</name></type>
<name>GetRTEIdentity</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since SQL functions might be in-lined by standard_planner,
	 * we might miss assigning an RTE identity for RangeTblEntries
	 * related to SQL functions. We already have checks in other
	 * places to throw an error for SQL functions but they are not
	 * sufficient due to function in-lining; so here we capture such
	 * cases and throw an error here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform distributed planning on this "</literal>
							   <literal type="string">"query because parameterized queries for SQL "</literal>
							   <literal type="string">"functions referencing distributed tables are "</literal>
							   <literal type="string">"not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using PL/pgSQL functions instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetOriginalInh gets the original value of the inheritance flag set by
 * AssignRTEIdentity. The planner resets this flag in the rewritten query,
 * but we need it during deparsing.
 */</comment>
<function><type><name>bool</name></type>
<name>GetOriginalInh</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>lsecond_int</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetQueryLockMode returns the necessary lock mode to be acquired for the
 * given query. (See comment written in RangeTblEntry-&gt;rellockmode)
 */</comment>
<function><type><name>LOCKMODE</name></type>
<name>GetQueryLockMode</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsModifyCommand</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>RowExclusiveLock</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasForUpdate</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>RowShareLock</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>AccessShareLock</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsModifyCommand returns true if the query performs modifications, false
 * otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>IsModifyCommand</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CmdType</name></type> <name>commandType</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
		<name>commandType</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsMultiTaskPlan returns true if job contains multiple tasks.
 */</comment>
<function><type><name>bool</name></type>
<name>IsMultiTaskPlan</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name> <init>= <expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>workerJob</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>workerJob</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>workerJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsUpdateOrDelete returns true if the query performs an update or delete.
 */</comment>
<function><type><name>bool</name></type>
<name>IsUpdateOrDelete</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
		   <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PlanFastPathDistributedStmt creates a distributed planned statement using
 * the FastPathPlanner.
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>PlanFastPathDistributedStmt</name><parameter_list>(<parameter><decl><type><name>DistributedPlanningContext</name> <modifier>*</modifier></type><name>planContext</name></decl></parameter>,
							<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>distributionKeyValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FastPathRestrictionContext</name> <modifier>*</modifier></type><name>fastPathContext</name> <init>=
		<expr><name><name>planContext</name><operator>-&gt;</operator><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>planContext</name><operator>-&gt;</operator><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name><operator>-&gt;</operator>
	<name>fastPathRouterQuery</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>distributionKeyValue</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to record */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>distributionKeyValue</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fastPathContext</name><operator>-&gt;</operator><name>distributionKeyValue</name></name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>distributionKeyValue</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>distributionKeyValue</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fastPathContext</name><operator>-&gt;</operator><name>distributionKeyHasParam</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>planContext</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <call><name>FastPathPlanner</name><argument_list>(<argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>originalQuery</name></name></expr></argument>, <argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>query</name></name></expr></argument>,
										<argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>boundParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>CreateDistributedPlannedStmt</name><argument_list>(<argument><expr><name>planContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PlanDistributedStmt creates a distributed planned statement using the PG
 * planner.
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>PlanDistributedStmt</name><parameter_list>(<parameter><decl><type><name>DistributedPlanningContext</name> <modifier>*</modifier></type><name>planContext</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>rteIdCounter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* may've inlined new relation rtes */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><call><name>ExtractRangeTableEntryList</name><argument_list>(<argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>rteIdCounter</name> <operator>=</operator> <call><name>AssignRTEIdentities</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>rteIdCounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>CreateDistributedPlannedStmt</name><argument_list>(<argument><expr><name>planContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>setPartitionedTablesInherited</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AdjustPartitioningForDistributedPlanning</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>,
											 <argument><expr><name>setPartitionedTablesInherited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DissuadePlannerFromUsingPlan try dissuade planner when planning a plan that
 * potentially failed due to unresolved prepared statement parameters.
 */</comment>
<function><type><name>void</name></type>
<name>DissuadePlannerFromUsingPlan</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Arbitrarily high cost, but low enough that it can be added up
	 * without overflowing by choose_custom_plan().
	 */</comment>
	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>FLT_MAX</name> <operator>/</operator> <literal type="number">100000000</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateDistributedPlannedStmt encapsulates the logic needed to transform a particular
 * query into a distributed plan that is encapsulated by a PlannedStmt.
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>CreateDistributedPlannedStmt</name><parameter_list>(<parameter><decl><type><name>DistributedPlanningContext</name> <modifier>*</modifier></type><name>planContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>planId</name> <init>= <expr><name>NextPlanId</name><operator>++</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasUnresolvedParams</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>resultPlan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>QueryTreeContainsInlinableCTE</name><argument_list>(<argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>originalQuery</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Inlining CTEs as subqueries in the query can avoid recursively
		 * planning some (or all) of the CTEs. In other words, the inlined
		 * CTEs could become part of query pushdown planning, which is much
		 * more efficient than recursively planning. So, first try distributed
		 * planning on the inlined CTEs in the query tree.
		 *
		 * We also should fallback to distributed planning with non-inlined CTEs
		 * if the distributed planning fails with inlined CTEs, because recursively
		 * planning CTEs can provide full SQL coverage, although it might be slow.
		 */</comment>
		<expr_stmt><expr><name>resultPlan</name> <operator>=</operator> <call><name>InlineCtesAndCreateDistributedPlannedStmt</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name>planContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>resultPlan</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>resultPlan</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HasUnresolvedExternParamsWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>planContext</name><operator>-&gt;</operator><name>originalQuery</name></name></expr></argument>,
										<argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>boundParams</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hasUnresolvedParams</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>=
		<expr><call><name>CreateDistributedPlan</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>originalQuery</name></name></expr></argument>, <argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>query</name></name></expr></argument>,
							  <argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>boundParams</name></name></expr></argument>,
							  <argument><expr><name>hasUnresolvedParams</name></expr></argument>,
							  <argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>plannerRestrictionContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If no plan was generated, prepare a generic error to be emitted.
	 * Normally this error message will never returned to the user, as it's
	 * usually due to unresolved prepared statement parameters - in that case
	 * the logic below will force a custom plan (i.e. with parameters bound to
	 * specific values) to be generated.  But sql (not plpgsql) functions
	 * unfortunately don't go through a codepath supporting custom plans - so
	 * we still need to have an error prepared.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>distributedPlan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* currently always should have a more specific error otherwise */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hasUnresolvedParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>distributedPlan</name> <operator>=</operator> <call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>DistributedPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>=</operator>
			<call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
						  <argument><expr><literal type="string">"could not create distributed plan"</literal></expr></argument>,
						  <argument><expr><literal type="string">"Possibly this is caused by the use of parameters in SQL "</literal>
						  <literal type="string">"functions, which is not supported in Citus."</literal></expr></argument>,
						  <argument><expr><literal type="string">"Consider using PL/pgSQL functions instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Error out if none of the planners resulted in a usable plan, unless the
	 * error was possibly triggered by missing parameters.  In that case we'll
	 * not error out here, but instead rely on postgres' custom plan logic.
	 * Postgres re-plans prepared statements the first five executions
	 * (i.e. it produces custom plans), after that the cost of a generic plan
	 * is compared with the average custom plan cost.  We support otherwise
	 * unsupported prepared statement parameters by assigning an exorbitant
	 * cost to the unsupported query.  That'll lead to the custom plan being
	 * chosen.  But for that to be possible we can't error out here, as
	 * otherwise that logic is never reached.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasUnresolvedParams</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* remember the plan's identifier for identifying subplans */</comment>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planId</name></name> <operator>=</operator> <name>planId</name></expr>;</expr_stmt>

	<comment type="block">/* create final plan by combining local plan with distributed plan */</comment>
	<expr_stmt><expr><name>resultPlan</name> <operator>=</operator> <call><name>FinalizePlan</name><argument_list>(<argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>distributedPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * As explained above, force planning costs to be unrealistically high if
	 * query planning failed (possibly) due to prepared statement parameters or
	 * if it is planned as a multi shard modify query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>||</operator>
		 <operator>(</operator><call><name>IsUpdateOrDelete</name><argument_list>(<argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>originalQuery</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsMultiTaskPlan</name><argument_list>(
			  <argument><expr><name>distributedPlan</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>hasUnresolvedParams</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DissuadePlannerFromUsingPlan</name><argument_list>(<argument><expr><name>resultPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>resultPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InlineCtesAndCreateDistributedPlannedStmt gets all the parameters required
 * for creating a distributed planned statement. The function is primarily a
 * wrapper on top of CreateDistributedPlannedStmt(), by first inlining the
 * CTEs and calling CreateDistributedPlannedStmt() in PG_TRY() block. The
 * function returns NULL if the planning fails on the query where eligable
 * CTEs are inlined.
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>InlineCtesAndCreateDistributedPlannedStmt</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>,
										  <parameter><decl><type><name>DistributedPlanningContext</name> <modifier>*</modifier></type><name>planContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We'll inline the CTEs and try distributed planning, preserve the original
	 * query in case the planning fails and we fallback to recursive planning of
	 * CTEs.
	 */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>copyOfOriginalQuery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>originalQuery</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RecursivelyInlineCtesInQueryTree</name><argument_list>(<argument><expr><name>copyOfOriginalQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* after inlining, we shouldn't have any inlinable CTEs */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>QueryTreeContainsInlinableCTE</name><argument_list>(<argument><expr><name>copyOfOriginalQuery</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* simply recurse into CreateDistributedPlannedStmt() in a PG_TRY() block */</comment>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>TryCreateDistributedPlannedStmt</name><argument_list>(<argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
														  <argument><expr><name>copyOfOriginalQuery</name></expr></argument>,
														  <argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>query</name></name></expr></argument>,
														  <argument><expr><name><name>planContext</name><operator>-&gt;</operator><name>boundParams</name></name></expr></argument>,
														  <argument><expr><name><name>planContext</name><operator>-&gt;</operator>
														  <name>plannerRestrictionContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TryCreateDistributedPlannedStmt is a wrapper around CreateDistributedPlannedStmt, simply
 * calling it in PG_TRY()/PG_CATCH() block. The function returns a PlannedStmt if the input
 * query can be planned by Citus. If not, the function returns NULL and generates a DEBUG4
 * message with the reason for the failure.
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>TryCreateDistributedPlannedStmt</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>localPlan</name></decl></parameter>,
								<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
								<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>,
								<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>savedContext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedPlanningContext</name> <modifier>*</modifier></type><name>planContext</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedPlanningContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>planContext</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>localPlan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>planContext</name><operator>-&gt;</operator><name>boundParams</name></name> <operator>=</operator> <name>boundParams</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>planContext</name><operator>-&gt;</operator><name>originalQuery</name></name> <operator>=</operator> <name>originalQuery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>planContext</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>planContext</name><operator>-&gt;</operator><name>plannerRestrictionContext</name></name> <operator>=</operator> <name>plannerRestrictionContext</name></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CreateDistributedPlannedStmt</name><argument_list>(<argument><expr><name>planContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savedContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* don't try to intercept PANIC or FATAL, let those breeze past us */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>!=</operator> <name>ERROR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Planning after CTEs inlined failed with "</literal>
								<literal type="string">"\nmessage: %s\ndetail: %s\nhint: %s"</literal></expr></argument>,
								<argument><expr><ternary><condition><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr> ?</condition><then> <expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								<argument><expr><ternary><condition><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr> ?</condition><then> <expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
								<argument><expr><ternary><condition><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr> ?</condition><then> <expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* leave the error handling system */</comment>
		<expr_stmt><expr><call><name>FreeErrorData</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateDistributedPlan generates a distributed plan for a query.
 * It goes through 3 steps:
 *
 * 1. Try router planner
 * 2. Generate subplans for CTEs and complex subqueries
 *    - If any, go back to step 1 by calling itself recursively
 * 3. Logical planner
 */</comment>
<function><type><name>DistributedPlan</name> <modifier>*</modifier></type>
<name>CreateDistributedPlan</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type>
					  <name>boundParams</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasUnresolvedParams</name></decl></parameter>,
					  <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasCtes</name> <init>= <expr><name><name>originalQuery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>!=</operator> <name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsModifyCommand</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationId</name> <init>= <expr><call><name>ModifyQueryResultRelationId</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>EnsureModificationsCanRunOnRelation</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>EnsurePartitionTableNotReplicated</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>InsertSelectIntoCitusTable</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>hasUnresolvedParams</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Unresolved parameters can cause performance regressions in
				 * INSERT...SELECT when the partition column is a parameter
				 * because we don't perform any additional pruning in the executor.
				 */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>distributedPlan</name> <operator>=</operator>
				<call><name>CreateInsertSelectPlan</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>,
									   <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>InsertSelectIntoLocalTable</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>hasUnresolvedParams</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Unresolved parameters can cause performance regressions in
				 * INSERT...SELECT when the partition column is a parameter
				 * because we don't perform any additional pruning in the executor.
				 */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>distributedPlan</name> <operator>=</operator>
				<call><name>CreateInsertSelectIntoLocalTablePlan</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>,
													 <argument><expr><name>hasUnresolvedParams</name></expr></argument>,
													 <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* modifications are always routed through the same planner/executor */</comment>
			<expr_stmt><expr><name>distributedPlan</name> <operator>=</operator>
				<call><name>CreateModifyPlan</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* the functions above always return a plan, possibly with an error */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distributedPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>distributedPlan</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For select queries we, if router executor is enabled, first try to
		 * plan the query as a router query. If not supported, otherwise try
		 * the full blown plan/optimize/physical planning process needed to
		 * produce distributed query plans.
		 */</comment>

		<expr_stmt><expr><name>distributedPlan</name> <operator>=</operator> <call><name>CreateRouterPlan</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
										   <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>distributedPlan</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * For debugging it's useful to display why query was not
			 * router plannable.
			 */</comment>
			<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasUnresolvedParams</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There are parameters that don't have a value in boundParams.
		 *
		 * The remainder of the planning logic cannot handle unbound
		 * parameters. We return a NULL plan, which will have an
		 * extremely high cost, such that postgres will replan with
		 * bound parameters.
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* force evaluation of bound params */</comment>
	<expr_stmt><expr><name>boundParams</name> <operator>=</operator> <call><name>copyParamList</name><argument_list>(<argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there are parameters that do have a value in boundParams, replace
	 * them in the original query. This allows us to more easily cut the
	 * query into pieces (during recursive planning) or deparse parts of
	 * the query (during subquery pushdown planning).
	 */</comment>
	<expr_stmt><expr><name>originalQuery</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>ResolveExternalParams</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalQuery</name></expr></argument>,
													<argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>originalQuery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Plan subqueries and CTEs that cannot be pushed down by recursively
	 * calling the planner and return the resulting plans to subPlanList.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subPlanList</name> <init>= <expr><call><name>GenerateSubplansForSubqueriesAndCTEs</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>,
															 <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If subqueries were recursively planned then we need to replan the query
	 * to get the new planner restriction context and apply planner transformations.
	 *
	 * We could simplify this code if the logical planner was capable of dealing
	 * with an original query. In that case, we would only have to filter the
	 * planner restriction context.
	 *
	 * Note that we check both for subplans and whether the query had CTEs
	 * prior to calling GenerateSubplansForSubqueriesAndCTEs. If none of
	 * the CTEs are referenced then there are no subplans, but we still want
	 * to retry the router planner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>subPlanList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>hasCtes</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>newQuery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>setPartitionedTablesInherited</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>currentPlannerRestrictionContext</name> <init>=
			<expr><call><name>CurrentPlannerRestrictionContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* reset the current planner restrictions context */</comment>
		<expr_stmt><expr><call><name>ResetPlannerRestrictionContext</name><argument_list>(<argument><expr><name>currentPlannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We force standard_planner to treat partitioned tables as regular tables
		 * by clearing the inh flag on RTEs. We already did this at the start of
		 * distributed_planner, but on a copy of the original query, so we need
		 * to do it again here.
		 */</comment>
		<expr_stmt><expr><call><name>AdjustPartitioningForDistributedPlanning</name><argument_list>(<argument><expr><call><name>ExtractRangeTableEntryList</name><argument_list>(<argument><expr><name>newQuery</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>setPartitionedTablesInherited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Some relations may have been removed from the query, but we can skip
		 * AssignRTEIdentities since we currently do not rely on RTE identities
		 * being contiguous.
		 */</comment>

		<expr_stmt><expr><call><name>standard_planner</name><argument_list>(<argument><expr><name>newQuery</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* overwrite the old transformed query with the new transformed query */</comment>
		<expr_stmt><expr><operator>*</operator><name>query</name> <operator>=</operator> <operator>*</operator><name>newQuery</name></expr>;</expr_stmt>

		<comment type="block">/* recurse into CreateDistributedPlan with subqueries/CTEs replaced */</comment>
		<expr_stmt><expr><name>distributedPlan</name> <operator>=</operator> <call><name>CreateDistributedPlan</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
												<argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* distributedPlan cannot be null since hasUnresolvedParams argument was false */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distributedPlan</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>subPlanList</name></name> <operator>=</operator> <name>subPlanList</name></expr>;</expr_stmt>

		<return>return <expr><name>distributedPlan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * DML command returns a planning error, even after recursive planning. The
	 * logical planner cannot handle DML commands so return the plan with the
	 * error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsModifyCommand</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>distributedPlan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * CTEs are stripped from the original query by RecursivelyPlanSubqueriesAndCTEs.
	 * If we get here and there are still CTEs that means that none of the CTEs are
	 * referenced. We therefore also strip the CTEs from the rewritten query.
	 */</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>originalQuery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiTreeRoot</name> <modifier>*</modifier></type><name>logicalPlan</name> <init>= <expr><call><name>MultiLogicalPlanCreate</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
														<argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MultiLogicalPlanOptimize</name><argument_list>(<argument><expr><name>logicalPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This check is here to make it likely that all node types used in
	 * Citus are dumpable. Explain can dump logical and physical plans
	 * using the extended outfuncs infrastructure, but it's infeasible to
	 * test most plans. MultiQueryContainerNode always serializes the
	 * physical plan, so there's no need to check that separately
	 */</comment>
	<expr_stmt><expr><call><name>CheckNodeIsDumpable</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>logicalPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the physical plan */</comment>
	<expr_stmt><expr><name>distributedPlan</name> <operator>=</operator> <call><name>CreatePhysicalDistributedPlan</name><argument_list>(<argument><expr><name>logicalPlan</name></expr></argument>,
													<argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* distributed plan currently should always succeed or error out */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distributedPlan</name> <operator>&amp;&amp;</operator> <name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>distributedPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsurePartitionTableNotReplicated errors out if the input relation is
 * a partition table and the table has a replication factor greater than
 * one.
 *
 * If the table is not a partition or replication factor is 1, the function
 * becomes a no-op.
 */</comment>
<function><type><name>void</name></type>
<name>EnsurePartitionTableNotReplicated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>deferredError</name> <init>=
		<expr><call><name>DeferErrorIfPartitionTableNotSingleReplicated</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>deferredError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>deferredError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfPartitionTableNotSingleReplicated defers error if the input relation
 * is a partition table with replication factor &gt; 1. Otherwise, the function returns
 * NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfPartitionTableNotSingleReplicated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionTableNoLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SingleReplicatedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>parentOid</name> <init>= <expr><call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationTest</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>errorHint</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorHint</name></expr></argument>, <argument><expr><literal type="string">"Run the query on the parent table "</literal>
									<literal type="string">"\"%s\" instead."</literal></expr></argument>, <argument><expr><name>parentRelationTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"modifications on partitions when replication "</literal>
							 <literal type="string">"factor is greater than 1 is not supported"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>errorHint</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResolveExternalParams replaces the external parameters that appears
 * in the query with the corresponding entries in the boundParams.
 *
 * Note that this function is inspired by eval_const_expr() on Postgres.
 * We cannot use that function because it requires access to PlannerInfo.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>ResolveExternalParams</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>inputNode</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* consider resolving external parameters only when boundParams exists */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>boundParams</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>inputNode</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>inputNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>inputNode</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>paramToProcess</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>inputNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>numberOfParameters</name> <init>= <expr><name><name>boundParams</name><operator>-&gt;</operator><name>numParams</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>parameterId</name> <init>= <expr><name><name>paramToProcess</name><operator>-&gt;</operator><name>paramid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type> <name>typeLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>typeByValue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>constValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>paramToProcess</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>!=</operator> <name>PARAM_EXTERN</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>inputNode</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>parameterId</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>inputNode</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* parameterId starts from 1 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>parameterIndex</name> <init>= <expr><name>parameterId</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>parameterIndex</name> <operator>&gt;=</operator> <name>numberOfParameters</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>inputNode</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>correspondingParameterData</name> <init>=
			<expr><operator>&amp;</operator><name><name>boundParams</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>parameterIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>correspondingParameterData</name><operator>-&gt;</operator><name>pflags</name></name> <operator>&amp;</operator> <name>PARAM_FLAG_CONST</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>inputNode</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>paramToProcess</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeLength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeByValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>paramIsNull</name> <init>= <expr><name><name>correspondingParameterData</name><operator>-&gt;</operator><name>isnull</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>paramIsNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>constValue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>typeByValue</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>constValue</name> <operator>=</operator> <name><name>correspondingParameterData</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Out of paranoia ensure that datum lives long enough,
			 * although bind params currently should always live
			 * long enough.
			 */</comment>
			<expr_stmt><expr><name>constValue</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>correspondingParameterData</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>typeByValue</name></expr></argument>,
								   <argument><expr><name>typeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>paramToProcess</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>, <argument><expr><name><name>paramToProcess</name><operator>-&gt;</operator><name>paramtypmod</name></name></expr></argument>,
								  <argument><expr><name><name>paramToProcess</name><operator>-&gt;</operator><name>paramcollid</name></name></expr></argument>, <argument><expr><name>typeLength</name></expr></argument>, <argument><expr><name>constValue</name></expr></argument>,
								  <argument><expr><name>paramIsNull</name></expr></argument>, <argument><expr><name>typeByValue</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>inputNode</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>inputNode</name></expr></argument>, <argument><expr><name>ResolveExternalParams</name></expr></argument>,
										   <argument><expr><name>boundParams</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>inputNode</name></expr></argument>, <argument><expr><name>ResolveExternalParams</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDistributedPlan returns the associated DistributedPlan for a CustomScan.
 *
 * Callers should only read from the returned data structure, since it may be
 * the plan of a prepared statement and may therefore be reused.
 */</comment>
<function><type><name>DistributedPlan</name> <modifier>*</modifier></type>
<name>GetDistributedPlan</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>customScan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>customScan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>customScan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>DistributedPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CheckNodeCopyAndSerialization</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><operator>(</operator><name>DistributedPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>distributedPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FinalizePlan combines local plan with distributed plan and creates a plan
 * which can be run by the PostgreSQL executor.
 */</comment>
<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>FinalizePlan</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>localPlan</name></decl></parameter>, <parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>finalPlan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>customScan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiExecutorType</name></type> <name>executorType</name> <init>= <expr><name>MULTI_EXECUTOR_INVALID_FIRST</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this field is used in JobExecutorType */</comment>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>relationIdList</name></name> <operator>=</operator> <name><name>localPlan</name><operator>-&gt;</operator><name>relationOids</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>executorType</name> <operator>=</operator> <call><name>JobExecutorType</name><argument_list>(<argument><expr><name>distributedPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>executorType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>MULTI_EXECUTOR_ADAPTIVE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name><name>customScan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>AdaptiveExecutorCustomScanMethods</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>MULTI_EXECUTOR_NON_PUSHABLE_INSERT_SELECT</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name><name>customScan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>NonPushableInsertSelectCustomScanMethods</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><name><name>customScan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>DelayedErrorCustomScanMethods</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><call><name>IsMultiTaskPlan</name><argument_list>(<argument><expr><name>distributedPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if it is not a single task executable plan, inform user according to the log level */</comment>
		<if_stmt><if>if <condition>(<expr><name>MultiTaskQueryLogLevel</name> <operator>!=</operator> <name>CITUS_LOG_LEVEL_OFF</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>MultiTaskQueryLogLevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
												 <argument><expr><literal type="string">"multi-task query about to be executed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
											 <call><name>errhint</name><argument_list>(
												 <argument><expr><literal type="string">"Queries are split to multiple tasks "</literal>
												 <literal type="string">"if they have to be split into several"</literal>
												 <literal type="string">" queries on the workers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <name><name>localPlan</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>distributedPlanData</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>distributedPlan</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>customScan</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>distributedPlanData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name><operator>)</operator></expr></cpp:if>

	<comment type="block">/* necessary to avoid extra Result node in PG15 */</comment>
	<expr_stmt><expr><name><name>customScan</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</name> <operator>|</operator> <name>CUSTOMPATH_SUPPORT_PROJECTION</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>customScan</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Fast path queries cannot have any subplans by definition, so skip
	 * expensive traversals.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>distributedPlan</name><operator>-&gt;</operator><name>fastPathRouterPlan</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Record subplans used by distributed plan to make intermediate result
		 * pruning easier.
		 *
		 * We do this before finalizing the plan, because the combineQuery is
		 * rewritten by standard_planner in FinalizeNonRouterPlan.
		 */</comment>
		<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>usedSubPlanNodeList</name></name> <operator>=</operator> <call><name>FindSubPlanUsages</name><argument_list>(<argument><expr><name>distributedPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>combineQuery</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>finalPlan</name> <operator>=</operator> <call><name>FinalizeNonRouterPlan</name><argument_list>(<argument><expr><name>localPlan</name></expr></argument>, <argument><expr><name>distributedPlan</name></expr></argument>, <argument><expr><name>customScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>finalPlan</name> <operator>=</operator> <call><name>FinalizeRouterPlan</name><argument_list>(<argument><expr><name>localPlan</name></expr></argument>, <argument><expr><name>customScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>finalPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FinalizeNonRouterPlan gets the distributed custom scan plan, and creates the
 * final master select plan on the top of this distributed plan for adaptive executor.
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>FinalizeNonRouterPlan</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>localPlan</name></decl></parameter>, <parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name></decl></parameter>,
					  <parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>customScan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>finalPlan</name> <init>= <expr><call><name>PlanCombineQuery</name><argument_list>(<argument><expr><name>distributedPlan</name></expr></argument>, <argument><expr><name>customScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>finalPlan</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <name><name>localPlan</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>finalPlan</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>localPlan</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>

	<comment type="block">/* add original range table list for access permission checks */</comment>
	<expr_stmt><expr><name><name>finalPlan</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>finalPlan</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>localPlan</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>finalPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FinalizeRouterPlan gets a CustomScan node which already wrapped distributed
 * part of a router plan and sets it as the direct child of the router plan
 * because we don't run any query on master node for router executable queries.
 * Here, we also rebuild the column list to read from the remote scan.
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>FinalizeRouterPlan</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>localPlan</name></decl></parameter>, <parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>customScan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>customScan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name> <operator>=</operator>
		<call><name>makeCustomScanTargetlistFromExistingTargetList</name><argument_list>(<argument><expr><name><name>localPlan</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>customScan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator>
		<call><name>makeTargetListFromCustomScanList</name><argument_list>(<argument><expr><name><name>customScan</name><operator>-&gt;</operator><name>custom_scan_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* extract the column names from the final targetlist*/</comment>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>customScan-&gt;scan.plan.targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>columnNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columnNameList</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>routerPlan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>routerPlan</name><operator>-&gt;</operator><name>planTree</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>customScan</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>remoteScanRangeTableEntry</name> <init>= <expr><call><name>RemoteScanRangeTableEntry</name><argument_list>(<argument><expr><name>columnNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>routerPlan</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>remoteScanRangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add original range table list for access permission checks */</comment>
	<expr_stmt><expr><name><name>routerPlan</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>routerPlan</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>localPlan</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>routerPlan</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routerPlan</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>routerPlan</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <name><name>localPlan</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routerPlan</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>localPlan</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routerPlan</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name><name>localPlan</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>routerPlan</name><operator>-&gt;</operator><name>hasReturning</name></name> <operator>=</operator> <name><name>localPlan</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>;</expr_stmt>

	<return>return <expr><name>routerPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * makeCustomScanTargetlistFromExistingTargetList rebuilds the targetlist from the remote
 * query into a list that can be used as the custom_scan_tlist for our Citus Custom Scan.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>makeCustomScanTargetlistFromExistingTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>existingTargetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_scan_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we will have custom scan range table entry as the first one in the list */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>customScanRangeTableIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build a targetlist to read from the custom scan output */</comment>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>existingTargetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>targetEntry</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * This is unlikely to be hit because we would not need resjunk stuff
		 * at the toplevel of a router query - all things needing it have been
		 * pushed down.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* build target entry pointing to remote scan range table entry */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>newVar</name> <init>= <expr><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>customScanRangeTableIndex</name></expr></argument>, <argument><expr><name>targetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>newVar</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator> <name><name>newVar</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDARRAYOID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Add the anonymous composite type to the type cache and store
			 * the key in vartypmod. Eventually this makes its way into the
			 * TupleDesc used by the executor, which uses it to parse the
			 * query results from the workers in BuildTupleFromCStrings.
			 */</comment>
			<expr_stmt><expr><name><name>newVar</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>=</operator> <call><name>BlessRecordExpression</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newTargetEntry</name> <init>= <expr><call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>targetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newVar</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>custom_scan_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>custom_scan_tlist</name></expr></argument>, <argument><expr><name>newTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>custom_scan_tlist</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * makeTargetListFromCustomScanList based on a custom_scan_tlist create the target list to
 * use on the Citus Custom Scan Node. The targetlist differs from the custom_scan_tlist in
 * a way that the expressions in the targetlist all are references to the index (resno) in
 * the custom_scan_tlist in their varattno while the varno is replaced with INDEX_VAR
 * instead of the range table entry index.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>makeTargetListFromCustomScanList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_scan_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>custom_scan_tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * INDEX_VAR is used to reference back to the TargetEntry in custom_scan_tlist by
		 * its resno (index)
		 */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>newVar</name> <init>= <expr><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>INDEX_VAR</name></expr></argument>, <argument><expr><name>targetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newVar</name></expr></argument>, <argument><expr><name>resno</name></expr></argument>,
													  <argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
													  <argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>newTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>targetList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BlessRecordExpression ensures we can parse an anonymous composite type on the
 * target list of a query that is sent to the worker.
 *
 * We cannot normally parse record types coming from the workers unless we
 * "bless" the tuple descriptor, which adds a transient type to the type cache
 * and assigns it a type mod value, which is the key in the type cache.
 */</comment>
<function><type><name>int32</name></type>
<name>BlessRecordExpression</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>typeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Handle functions that return records on the target
		 * list, e.g. SELECT function_call(1,2);
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>resultTypeId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>resultTupleDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* get_expr_result_type blesses the tuple descriptor */</comment>
		<decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>typeClass</name> <init>= <expr><call><name>get_expr_result_type</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultTypeId</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>resultTupleDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>typeClass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>typeMod</name> <operator>=</operator> <name><name>resultTupleDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Handle row expressions, e.g. SELECT (1,2);
		 */</comment>
		<decl_stmt><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>rowExpr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>argCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>currentResno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>rowTupleDesc</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rowExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>argCell</argument>, <argument>rowExpr-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rowArg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>argCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>rowArgTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>rowArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>rowArgTypeMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>rowArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>rowArgTypeId</name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator> <name>rowArgTypeId</name> <operator>==</operator> <name>RECORDARRAYOID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ensure nested rows are blessed as well */</comment>
				<expr_stmt><expr><name>rowArgTypeMod</name> <operator>=</operator> <call><name>BlessRecordExpression</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rowArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>rowTupleDesc</name></expr></argument>, <argument><expr><name>currentResno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>rowArgTypeId</name></expr></argument>, <argument><expr><name>rowArgTypeMod</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>rowTupleDesc</name></expr></argument>, <argument><expr><name>currentResno</name></expr></argument>,
										<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>rowArg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>currentResno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>rowTupleDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>typeMod</name> <operator>=</operator> <name><name>rowTupleDesc</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Handle row array expressions, e.g. SELECT ARRAY[(1,2)];
		 * Postgres allows ARRAY[(1,2),(1,2,3)]. We do not.
		 */</comment>
		<decl_stmt><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>arrayExpr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>typeMod</name> <operator>=</operator> <call><name>BlessRecordExpressionList</name><argument_list>(<argument><expr><name><name>arrayExpr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NullIfExpr</name> <modifier>*</modifier></type><name>nullIfExpr</name> <init>= <expr><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>typeMod</name> <operator>=</operator> <call><name>BlessRecordExpressionList</name><argument_list>(<argument><expr><name><name>nullIfExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>MinMaxExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>minMaxExpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>typeMod</name> <operator>=</operator> <call><name>BlessRecordExpressionList</name><argument_list>(<argument><expr><name><name>minMaxExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesceExpr</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>typeMod</name> <operator>=</operator> <call><name>BlessRecordExpressionList</name><argument_list>(<argument><expr><name><name>coalesceExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CaseExpr</name> <modifier>*</modifier></type><name>caseExpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>results</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>whenCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>whenCell</argument>, <argument>caseExpr-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CaseWhen</name> <modifier>*</modifier></type><name>whenArg</name> <init>= <expr><operator>(</operator><name>CaseWhen</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>whenCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name><name>whenArg</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name><name>caseExpr</name><operator>-&gt;</operator><name>defresult</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name><name>caseExpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>typeMod</name> <operator>=</operator> <call><name>BlessRecordExpressionList</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>typeMod</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BlessRecordExpressionList maps BlessRecordExpression over a list.
 * Returns typmod of all expressions, or -1 if they are not all the same.
 * Ignores expressions with a typmod of -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>BlessRecordExpressionList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>finalTypeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>exprCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>exprCell</argument>, <argument>exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>exprArg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>exprCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>exprTypeMod</name> <init>= <expr><call><name>BlessRecordExpression</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>exprArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>exprTypeMod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>finalTypeMod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>finalTypeMod</name> <operator>=</operator> <name>exprTypeMod</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>finalTypeMod</name> <operator>!=</operator> <name>exprTypeMod</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>finalTypeMod</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoteScanRangeTableEntry creates a range table entry from given column name
 * list to represent a remote scan.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>RemoteScanRangeTableEntry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>remoteScanRangeTableEntry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we use RTE_VALUES for custom scan because we can't look up relation */</comment>
	<expr_stmt><expr><name><name>remoteScanRangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_VALUES</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remoteScanRangeTableEntry</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"remote_scan"</literal></expr></argument>, <argument><expr><name>columnNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remoteScanRangeTableEntry</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remoteScanRangeTableEntry</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>remoteScanRangeTableEntry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckNodeIsDumpable checks that the passed node can be dumped using
 * nodeToString(). As this checks is expensive, it's only active when
 * assertions are enabled.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckNodeIsDumpable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * CheckNodeCopyAndSerialization checks copy/dump/read functions
 * for nodes and returns copy of the input.
 *
 * It is only active when assertions are enabled, otherwise it returns
 * the input directly. We use this to confirm that our serialization
 * and copy logic produces the correct plan during regression tests.
 *
 * It does not check string equality on node dumps due to differences
 * in some Postgres types.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>CheckNodeCopyAndSerialization</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>nodeCopy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>outCopy</name> <init>= <expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>nodeCopy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nodeCopy</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>node</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * multi_join_restriction_hook is a hook called by postgresql standard planner
 * to notify us about various planning information regarding joins. We use
 * it to learn about the joining column.
 */</comment>
<function><type><name>void</name></type>
<name>multi_join_restriction_hook</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outerrel</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>innerrel</name></decl></parameter>,
							<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
							<parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We do not expect empty relids. Still, ignoring such JoinRestriction is
		 * preferable for two reasons:
		 * 1. This might be a query that doesn't rely on JoinRestrictions at all (e.g.,
		 * local query).
		 * 2. We cannot process them when they are empty (and likely to segfault if
		 * we allow as-is).
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Join restriction information is NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Use a memory context that's guaranteed to live long enough, could be
	 * called in a more shortly lived one (e.g. with GEQO).
	 */</comment>
	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name> <init>=
		<expr><call><name>CurrentPlannerRestrictionContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>restrictionsMemoryContext</name> <init>= <expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldMemoryContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>restrictionsMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>JoinRestrictionContext</name> <modifier>*</modifier></type><name>joinRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>joinRestrictionContext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>JoinRestriction</name> <modifier>*</modifier></type><name>joinRestriction</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JoinRestriction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>joinType</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>plannerInfo</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We create a copy of restrictInfoList and relids because with geqo they may
	 * be created in a memory context which will be deleted when we still need it,
	 * thus we create a copy of it in our memory context.
	 */</comment>
	<expr_stmt><expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>joinRestrictInfoList</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>extra</name><operator>-&gt;</operator><name>restrictlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>innerrelRelids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>outerrelRelids</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerrel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>joinRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionList</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>joinRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionList</name></name></expr></argument>, <argument><expr><name>joinRestriction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Keep track if we received any semi joins here. If we didn't we can
	 * later safely convert any semi joins in the rewritten query to inner
	 * joins.
	 */</comment>
	<expr_stmt><expr><name><name>joinRestrictionContext</name><operator>-&gt;</operator><name>hasSemiJoin</name></name> <operator>=</operator> <name><name>joinRestrictionContext</name><operator>-&gt;</operator><name>hasSemiJoin</name></name> <operator>||</operator>
										  <name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinRestrictionContext</name><operator>-&gt;</operator><name>hasOuterJoin</name></name> <operator>=</operator> <name><name>joinRestrictionContext</name><operator>-&gt;</operator><name>hasOuterJoin</name></name> <operator>||</operator>
										   <call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * multi_relation_restriction_hook is a hook called by postgresql standard planner
 * to notify us about various planning information regarding a relation. We use
 * it to retrieve restrictions on relations.
 */</comment>
<function><type><name>void</name></type>
<name>multi_relation_restriction_hook</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relOptInfo</name></decl></parameter>,
								<parameter><decl><type><name>Index</name></type> <name>restrictionIndex</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ReplaceCitusExtraDataContainer</name> <operator>&amp;&amp;</operator> <call><name>IsCitusExtraDataContainerRelation</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We got here by planning the query part that needs to be executed on the query
		 * coordinator node.
		 * We have verified the occurrence of the citus_extra_datacontainer function
		 * encoding the remote scan we plan to execute here. We will replace all paths
		 * with a path describing our custom scan.
		 */</comment>
		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>CreateCitusCustomScanPath</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relOptInfo</name></expr></argument>, <argument><expr><name>restrictionIndex</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>,
											   <argument><expr><name>ReplaceCitusExtraDataContainerWithCustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* replace all paths with our custom scan and recalculate cheapest */</comment>
		<expr_stmt><expr><name><name>relOptInfo</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>relOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AdjustReadIntermediateResultCost</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>relOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdjustReadIntermediateResultArrayCost</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>relOptInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Use a memory context that's guaranteed to live long enough, could be
	 * called in a more shortly lived one (e.g. with GEQO).
	 */</comment>
	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name> <init>=
		<expr><call><name>CurrentPlannerRestrictionContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>restrictionsMemoryContext</name> <init>= <expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldMemoryContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>restrictionsMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isCitusTable</name> <init>= <expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationRestriction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>restrictionIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>rte</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relOptInfo</name></name> <operator>=</operator> <name>relOptInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>citusTable</name></name> <operator>=</operator> <name>isCitusTable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>plannerInfo</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>

	<comment type="block">/* see comments on GetVarFromAssignedParam() */</comment>
	<expr_stmt><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>outerPlanParamsList</name></name> <operator>=</operator> <call><name>OuterPlanParamsList</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>translatedVars</name></name> <operator>=</operator> <call><name>TranslatedVars</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>relationRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We're also keeping track of whether all participant
	 * tables are reference tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isCitusTable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cacheEntry</name> <operator>=</operator> <call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The statistics objects of the distributed table are not relevant
		 * for the distributed planning, so we can override it.
		 *
		 * Normally, we should not need this. However, the combination of
		 * Postgres commit 269b532aef55a579ae02a3e8e8df14101570dfd9 and
		 * Citus function AdjustPartitioningForDistributedPlanning()
		 * forces us to do this. The commit expects statistics objects
		 * of partitions to have "inh" flag set properly. Whereas, the
		 * function overrides "inh" flag. To avoid Postgres to throw error,
		 * we override statlist such that Postgres does not try to process
		 * any statistics objects during the standard_planner() on the
		 * coordinator. In the end, we do not need the standard_planner()
		 * on the coordinator to generate an optimized plan. We call
		 * into standard_planner() for other purposes, such as generating the
		 * relationRestrictionContext here.
		 *
		 * AdjustPartitioningForDistributedPlanning() is a hack that we use
		 * to prevent Postgres' standard_planner() to expand all the partitions
		 * for the distributed planning when a distributed partitioned table
		 * is queried. It is required for both correctness and performance
		 * reasons. Although we can eliminate the use of the function for
		 * the correctness (e.g., make sure that rest of the planner can handle
		 * partitions), it's performance implication is hard to avoid. Certain
		 * planning logic of Citus (such as router or query pushdown) relies
		 * heavily on the relationRestrictionList. If
		 * AdjustPartitioningForDistributedPlanning() is removed, all the
		 * partitions show up in the, causing high planning times for
		 * such queries.
		 */</comment>
		<expr_stmt><expr><name><name>relOptInfo</name><operator>-&gt;</operator><name>statlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>relationRestrictionContext</name><operator>-&gt;</operator><name>allReferenceTables</name></name> <operator>&amp;=</operator>
			<call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>relationRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionList</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>relationRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionList</name></name></expr></argument>, <argument><expr><name>relationRestriction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TranslatedVars deep copies the translated vars for the given relation index
 * if there is any append rel list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>TranslatedVars</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relationIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>translatedVars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>targetAppendRelInfo</name> <init>=
			<expr><call><name>FindTargetAppendRelInfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relationIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>targetAppendRelInfo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* postgres deletes translated_vars, hence we deep copy them here */</comment>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>targetNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>targetNode</argument>, <argument>targetAppendRelInfo-&gt;translated_vars</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>translatedVars</name> <operator>=</operator>
					<call><name>lappend</name><argument_list>(<argument><expr><name>translatedVars</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>targetNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>translatedVars</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindTargetAppendRelInfo finds the target append rel info for the given
 * relation rte index.
 */</comment>
<function><type><specifier>static</specifier> <name>AppendRelInfo</name> <modifier>*</modifier></type>
<name>FindTargetAppendRelInfo</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relationRteIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appendRelInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate on the queries that are part of UNION ALL subselects */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>appendRelInfo</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * We're only interested in the child rel that is equal to the
		 * relation we're investigating. Here we don't need to find the offset
		 * because postgres adds an offset to child_relid and parent_relid after
		 * calling multi_relation_restriction_hook.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>appendRelInfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>==</operator> <name>relationRteIndex</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>appendRelInfo</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AdjustReadIntermediateResultCost adjusts the row count and total cost
 * of a read_intermediate_result call based on the file size.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustReadIntermediateResultCost</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relOptInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_FUNCTION</name> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* avoid more expensive checks below for non-functions */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* read_intermediate_result may not exist */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ContainsReadIntermediateResultFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rangeTableFunction</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(
		<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcExpression</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultIdConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>funcExpression</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>resultIdConst</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not sure how to interpret non-const */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>resultIdDatum</name> <init>= <expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultFormatConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>funcExpression</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>resultFormatConst</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not sure how to interpret non-const */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AdjustReadIntermediateResultsCostInternal</name><argument_list>(<argument><expr><name>relOptInfo</name></expr></argument>,
											  <argument><expr><name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>,
											  <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultIdDatum</name></expr></argument>, <argument><expr><name>resultFormatConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AdjustReadIntermediateResultArrayCost adjusts the row count and total cost
 * of a read_intermediate_results(resultIds, format) call based on the file size.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustReadIntermediateResultArrayCost</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
									  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relOptInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultIdArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>resultIdCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_FUNCTION</name> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* avoid more expensive checks below for non-functions */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* read_intermediate_result may not exist */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ContainsReadIntermediateResultArrayFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rangeTableFunction</name> <init>=
		<expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcExpression</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultIdConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>funcExpression</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>resultIdConst</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not sure how to interpret non-const */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>resultIdArrayDatum</name> <init>= <expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>resultIdArrayDatum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					  <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultIdArray</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultIdCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultFormatConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>funcExpression</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>resultFormatConst</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not sure how to interpret non-const */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AdjustReadIntermediateResultsCostInternal</name><argument_list>(<argument><expr><name>relOptInfo</name></expr></argument>,
											  <argument><expr><name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>,
											  <argument><expr><name>resultIdCount</name></expr></argument>, <argument><expr><name>resultIdArray</name></expr></argument>,
											  <argument><expr><name>resultFormatConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AdjustReadIntermediateResultsCostInternal adjusts the row count and total cost
 * of reading intermediate results based on file sizes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustReadIntermediateResultsCostInternal</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relOptInfo</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnTypes</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>resultIdCount</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resultIds</name></decl></parameter>,
										  <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultFormatConst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>reltarget</name> <init>= <expr><name><name>relOptInfo</name><operator>-&gt;</operator><name>reltarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pathList</name> <init>= <expr><name><name>relOptInfo</name><operator>-&gt;</operator><name>pathlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>rowCost</name> <init>= <expr><literal type="number">0.</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>rowSizeEstimate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>rowCountEstimate</name> <init>= <expr><literal type="number">0.</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>ioCost</name> <init>= <expr><literal type="number">0.</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type> <name>funcCost</name> <init>= <expr><block>{ <expr><literal type="number">0.</literal></expr>, <expr><literal type="number">0.</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>totalResultSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>typeCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>resultFormatDatum</name> <init>= <expr><name><name>resultFormatConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>resultFormatId</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>resultFormatDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>binaryFormat</name> <init>= <expr><operator>(</operator><name>resultFormatId</name> <operator>==</operator> <call><name>BinaryCopyFormatId</name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>resultIdCount</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>resultIds</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>resultSize</name> <init>= <expr><call><name>IntermediateResultSize</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>resultSize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* result does not exist, will probably error out later on */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>binaryFormat</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* subtract 11-byte signature + 8 byte header + 2-byte footer */</comment>
			<expr_stmt><expr><name>totalResultSize</name> <operator>-=</operator> <literal type="number">21</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>totalResultSize</name> <operator>+=</operator> <name>resultSize</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* start with the cost of evaluating quals */</comment>
	<expr_stmt><expr><name>rowCost</name> <operator>+=</operator> <name><name>relOptInfo</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

	<comment type="block">/* postgres' estimate for the width of the rows */</comment>
	<expr_stmt><expr><name>rowSizeEstimate</name> <operator>+=</operator> <name><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>

	<comment type="block">/* add 2 bytes for column count (binary) or line separator (text) */</comment>
	<expr_stmt><expr><name>rowSizeEstimate</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>typeCell</argument>, <argument>columnTypes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>columnTypeId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>typeCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>inputFunctionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>typeIOParam</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>binaryFormat</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>getTypeBinaryInputInfo</name><argument_list>(<argument><expr><name>columnTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inputFunctionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeIOParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* binary format: 4 bytes for field size */</comment>
			<expr_stmt><expr><name>rowSizeEstimate</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>columnTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inputFunctionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeIOParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* text format: 1 byte for tab separator */</comment>
			<expr_stmt><expr><name>rowSizeEstimate</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>


		<comment type="block">/* add the cost of parsing a column */</comment>
		<expr_stmt><expr><call><name>add_function_cost</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>inputFunctionId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funcCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>rowCost</name> <operator>+=</operator> <name><name>funcCost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>

	<comment type="block">/* estimate the number of rows based on the file size and estimated row size */</comment>
	<expr_stmt><expr><name>rowCountEstimate</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>totalResultSize</name> <operator>/</operator> <name>rowSizeEstimate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cost of reading the data */</comment>
	<expr_stmt><expr><name>ioCost</name> <operator>=</operator> <name>seq_page_cost</name> <operator>*</operator> <name>totalResultSize</name> <operator>/</operator> <name>BLCKSZ</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathList</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* tell the planner about the cost and row count of the function */</comment>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pathList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name>rowCountEstimate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>rowCountEstimate</name> <operator>*</operator> <name>rowCost</name> <operator>+</operator> <name>ioCost</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>funcCost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>relOptInfo</name><operator>-&gt;</operator><name>baserestrictcost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * OuterPlanParamsList creates a list of RootPlanParams for outer nodes of the
 * given root. The first item in the list corresponds to parent_root, and the
 * last item corresponds to the outer most node.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>OuterPlanParamsList</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>planParamsList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>outerNodeRoot</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr></init></decl>;</init> <condition><expr><name>outerNodeRoot</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>outerNodeRoot</name> <operator>=</operator> <name><name>outerNodeRoot</name><operator>-&gt;</operator><name>parent_root</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RootPlanParams</name> <modifier>*</modifier></type><name>rootPlanParams</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RootPlanParams</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rootPlanParams</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name>outerNodeRoot</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * TODO: In SearchPlannerParamList() we are only interested in Var plan
		 * params, consider copying just them here.
		 */</comment>
		<expr_stmt><expr><name><name>rootPlanParams</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <call><name>CopyPlanParamList</name><argument_list>(<argument><expr><name><name>outerNodeRoot</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>planParamsList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>planParamsList</name></expr></argument>, <argument><expr><name>rootPlanParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>planParamsList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyPlanParamList deep copies the input PlannerParamItem list and returns the newly
 * allocated list.
 * Note that we cannot use copyObject() function directly since there is no support for
 * copying PlannerParamItem structs.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CopyPlanParamList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>originalPlanParamList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>planParamCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>copiedPlanParamList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>planParamCell</argument>, <argument>originalPlanParamList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>originalParamItem</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>planParamCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>copiedParamItem</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>copiedParamItem</name><operator>-&gt;</operator><name>paramId</name></name> <operator>=</operator> <name><name>originalParamItem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copiedParamItem</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>originalParamItem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>copiedPlanParamList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>copiedPlanParamList</name></expr></argument>, <argument><expr><name>copiedParamItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>copiedPlanParamList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateAndPushPlannerRestrictionContext creates a new relation restriction context
 * and a new join context, inserts it to the beginning of the
 * plannerRestrictionContextList. Finally, the planner restriction context is
 * inserted to the beginning of the plannerRestrictionContextList and it is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
<name>CreateAndPushPlannerRestrictionContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name> <operator>=</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name> <operator>=</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JoinRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name></name> <operator>=</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FastPathRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<comment type="block">/* we'll apply logical AND as we add tables */</comment>
	<expr_stmt><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name><operator>-&gt;</operator><name>allReferenceTables</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>plannerRestrictionContextList</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>plannerRestrictionContext</name></expr></argument>,
										  <argument><expr><name>plannerRestrictionContextList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plannerRestrictionContext</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TranslatedVarsForRteIdentity gets an rteIdentity and returns the
 * translatedVars that belong to the range table relation. If no
 * translatedVars found, the function returns NIL;
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>TranslatedVarsForRteIdentity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rteIdentity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>currentPlannerRestrictionContext</name> <init>=
		<expr><call><name>CurrentPlannerRestrictionContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationRestrictionList</name> <init>=
		<expr><name><name>currentPlannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name><operator>-&gt;</operator>
		<name>relationRestrictionList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>relationRestriction</argument>, <argument>relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>rte</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rteIdentity</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>translatedVars</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CurrentRestrictionContext returns the most recently added
 * PlannerRestrictionContext from the plannerRestrictionContextList list.
 */</comment>
<function><type><specifier>static</specifier> <name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
<name>CurrentPlannerRestrictionContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>plannerRestrictionContextList</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name> <init>=
		<expr><operator>(</operator><name>PlannerRestrictionContext</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>plannerRestrictionContextList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>plannerRestrictionContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"planner restriction context stack was empty"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Please report this to the Citus core team."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>plannerRestrictionContext</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PopPlannerRestrictionContext removes the most recently added restriction contexts from
 * the planner restriction context list. The function assumes the list is not empty.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PopPlannerRestrictionContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>plannerRestrictionContextList</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>plannerRestrictionContextList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ResetPlannerRestrictionContext resets the element of the given planner
 * restriction context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetPlannerRestrictionContext</name><parameter_list>(<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name> <operator>=</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name> <operator>=</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JoinRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name></name> <operator>=</operator>
		<call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FastPathRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* we'll apply logical AND as we add tables */</comment>
	<expr_stmt><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name><operator>-&gt;</operator><name>allReferenceTables</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * HasUnresolvedExternParamsWalker returns true if the passed in expression
 * has external parameters that are not contained in boundParams, false
 * otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>HasUnresolvedExternParamsWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>expression</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>paramId</name> <init>= <expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* only care about user supplied parameters */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>!=</operator> <name>PARAM_EXTERN</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check whether parameter is available (and valid) */</comment>
		<if_stmt><if>if <condition>(<expr><name>boundParams</name> <operator>&amp;&amp;</operator> <name>paramId</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>paramId</name> <operator>&lt;=</operator> <name><name>boundParams</name><operator>-&gt;</operator><name>numParams</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>externParam</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* give hook a chance in case parameter is dynamic */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>boundParams</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ParamExternData</name></type> <name>externParamPlaceholder</name></decl>;</decl_stmt>
				<expr_stmt><expr><name>externParam</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>boundParams</name><operator>-&gt;</operator><name>paramFetch</name></name>)<argument_list>(<argument><expr><name>boundParams</name></expr></argument>, <argument><expr><name>paramId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>externParamPlaceholder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>externParam</name> <operator>=</operator> <operator>&amp;</operator><name><name>boundParams</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>paramId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<decl_stmt><decl><type><name>Oid</name></type> <name>paramType</name> <init>= <expr><name><name>externParam</name><operator>-&gt;</operator><name>ptype</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* keep traversing */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></argument>,
								 <argument><expr><name>HasUnresolvedExternParamsWalker</name></expr></argument>,
								 <argument><expr><name>boundParams</name></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>expression</name></expr></argument>,
									  <argument><expr><name>HasUnresolvedExternParamsWalker</name></expr></argument>,
									  <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetRTEListPropertiesForQuery is a wrapper around GetRTEListProperties that
 * returns RTEListProperties for the rte list retrieved from query.
 */</comment>
<function><type><name>RTEListProperties</name> <modifier>*</modifier></type>
<name>GetRTEListPropertiesForQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rteList</name> <init>= <expr><call><name>ExtractRangeTableEntryList</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>GetRTEListProperties</name><argument_list>(<argument><expr><name>rteList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRTEListProperties returns RTEListProperties struct processing the given
 * rangeTableList.
 */</comment>
<function><type><specifier>static</specifier> <name>RTEListProperties</name> <modifier>*</modifier></type>
<name>GetRTEListProperties</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RTEListProperties</name> <modifier>*</modifier></type><name>rteListProperties</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RTEListProperties</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>rangeTableEntry</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Skip over views, distributed tables within (regular) views are
			 * already in rangeTableList.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>


		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Record materialized views as they are similar to postgres local tables
			 * but it is nice to record them separately.
			 *
			 * Regular tables, partitioned tables or foreign tables can be a local or
			 * distributed tables and we can qualify them accurately.
			 *
			 * For regular views, we don't care because their definitions are already
			 * in the same query tree and we can detect what is inside the view definition.
			 *
			 * For materialized views, they are just local tables in the queries. But, when
			 * REFRESH MATERIALIZED VIEW is used, they behave similar to regular views, adds
			 * the view definition to the query. Hence, it is useful to record it seperately
			 * and let the callers decide on what to do.
			 */</comment>
			<expr_stmt><expr><name><name>rteListProperties</name><operator>-&gt;</operator><name>hasMaterializedView</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>LookupCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cacheEntry</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rteListProperties</name><operator>-&gt;</operator><name>hasPostgresLocalTable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rteListProperties</name><operator>-&gt;</operator><name>hasReferenceTable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rteListProperties</name><operator>-&gt;</operator><name>hasCitusLocalTable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rteListProperties</name><operator>-&gt;</operator><name>hasDistributedTable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* it's not expected, but let's do a bug catch here */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"encountered with an unexpected citus "</literal>
								   <literal type="string">"table type while processing range table "</literal>
								   <literal type="string">"entries of query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>rteListProperties</name><operator>-&gt;</operator><name>hasCitusTable</name></name> <operator>=</operator> <operator>(</operator><name><name>rteListProperties</name><operator>-&gt;</operator><name>hasDistributedTable</name></name> <operator>||</operator>
										<name><name>rteListProperties</name><operator>-&gt;</operator><name>hasReferenceTable</name></name> <operator>||</operator>
										<name><name>rteListProperties</name><operator>-&gt;</operator><name>hasCitusLocalTable</name></name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>rteListProperties</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WarnIfListHasForeignDistributedTable iterates the given list and logs a WARNING
 * if the given relation is a distributed foreign table.
 * We do that because now we only support Citus Local Tables for foreign tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WarnIfListHasForeignDistributedTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>DistributedForeignTableWarningPrompted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>rangeTableEntry</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>DistributedForeignTableWarningPrompted</name></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>DistributedForeignTableWarningPrompted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								  <argument><expr><literal type="string">"support for distributed foreign tables are deprecated, "</literal>
								  <literal type="string">"please use Citus managed local tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							  <operator>(</operator><call><name>errdetail</name><argument_list>(
								   <argument><expr><literal type="string">"Foreign tables can be added to metadata using UDF: "</literal>
								   <literal type="string">"citus_add_local_table_to_metadata()"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
