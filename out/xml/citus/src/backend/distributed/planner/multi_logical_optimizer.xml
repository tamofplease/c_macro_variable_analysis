<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/planner/multi_logical_optimizer.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * multi_logical_optimizer.c
 *	  Routines for optimizing logical plan trees based on multi-relational
 *	  algebra.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/extended_op_node_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/function_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_pushdown_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/tdigest_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/* Config variable managed via guc.c */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>LimitClauseRowFetchCount</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* number of rows to fetch from each task */</comment>
<decl_stmt><decl><type><name>double</name></type> <name>CountDistinctErrorRate</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* precision of count(distinct) approximate */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>CoordinatorAggregationStrategy</name> <init>= <expr><name>COORDINATOR_AGGREGATION_ROW_GATHER</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Constant used throughout file */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32</name></type> <name>masterTableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* first range table reference on the master node */</comment>

<typedef>typedef <type><struct>struct <name>MasterAggregateWalkerContext</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type><name>extendedOpNodeProperties</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>columnId</name></decl>;</decl_stmt>
}</block></struct></type> <name>MasterAggregateWalkerContext</name>;</typedef>

<typedef>typedef <type><struct>struct <name>WorkerAggregateWalkerContext</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type><name>extendedOpNodeProperties</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>expressionList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>createGroupByClause</name></decl>;</decl_stmt>
}</block></struct></type> <name>WorkerAggregateWalkerContext</name>;</typedef>


<comment type="block">/*
 * QueryTargetList encapsulates the necessary fields to form
 * worker query's target list.
 */</comment>
<typedef>typedef <type><struct>struct <name>QueryTargetList</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl>;</decl_stmt> <comment type="block">/* the list of target entries */</comment>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>targetProjectionNumber</name></decl>;</decl_stmt> <comment type="block">/* the index of the last entry */</comment>
}</block></struct></type> <name>QueryTargetList</name>;</typedef>


<comment type="block">/*
 * QueryGroupClause encapsulates the necessary fields to form
 * worker query's group by clause.
 */</comment>
<typedef>typedef <type><struct>struct <name>QueryGroupClause</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl>;</decl_stmt> <comment type="block">/* the list of group clause entries */</comment>
	<decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>nextSortGroupRefIndex</name></decl>;</decl_stmt> <comment type="block">/* pointer to the index of the largest sort group reference index */</comment>
}</block></struct></type> <name>QueryGroupClause</name>;</typedef>


<comment type="block">/*
 * QueryDistinctClause encapsulates the necessary fields to form
 * worker query's DISTINCT/DISTINCT ON parts.
 */</comment>
<typedef>typedef <type><struct>struct <name>QueryDistinctClause</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerDistinctClause</name></decl>;</decl_stmt> <comment type="block">/* the list of distinct clause entries */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>workerHasDistinctOn</name></decl>;</decl_stmt>
}</block></struct></type> <name>QueryDistinctClause</name>;</typedef>


<comment type="block">/*
 * QueryWindowClause encapsulates the necessary fields to form
 * worker query's window clause.
 */</comment>
<typedef>typedef <type><struct>struct <name>QueryWindowClause</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerWindowClauseList</name></decl>;</decl_stmt> <comment type="block">/* the list of window clause entries */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasWindowFunctions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>nextSortGroupRefIndex</name></decl>;</decl_stmt> <comment type="block">/* see QueryGroupClause */</comment>
}</block></struct></type> <name>QueryWindowClause</name>;</typedef>


<comment type="block">/*
 * QueryOrderByLimit encapsulates the necessary fields to form
 * worker query's order by and limit clauses. Note that we don't
 * keep track of limit offset clause since it is incorporated
 * into the limit clause during the processing.
 */</comment>
<typedef>typedef <type><struct>struct <name>QueryOrderByLimit</name>
<block>{
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>workerLimitCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerSortClauseList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name> <modifier>*</modifier></type><name>nextSortGroupRefIndex</name></decl>;</decl_stmt> <comment type="block">/* see QueryGroupClause */</comment>
}</block></struct></type> <name>QueryOrderByLimit</name>;</typedef>


<comment type="block">/*
 * LimitPushdownable tells us how a limit can be pushed down.
 * See WorkerLimitCount for details.
 */</comment>
<typedef>typedef <type><enum>enum <name>LimitPushdownable</name>
<block>{
	<decl><name>LIMIT_CANNOT_PUSHDOWN</name></decl>,
	<decl><name>LIMIT_CAN_PUSHDOWN</name></decl>,
	<decl><name>LIMIT_CAN_APPROXIMATE</name></decl>,
}</block></enum></type> <name>LimitPushdownable</name>;</typedef>


<comment type="block">/*
 * OrderByLimitReference a structure that is used commonly while
 * processing sort and limit clauses.
 */</comment>
<typedef>typedef <type><struct>struct <name>OrderByLimitReference</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type> <name>groupedByDisjointPartitionColumn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>onlyPushableWindowFunctions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>groupClauseIsEmpty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>sortClauseIsEmpty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasOrderByAggregate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>canApproximate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasDistinctOn</name></decl>;</decl_stmt>
}</block></struct></type> <name>OrderByLimitReference</name>;</typedef>


<comment type="block">/* Local functions forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>MultiSelect</name> <modifier>*</modifier></type> <name>AndSelectNode</name><parameter_list>(<parameter><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiSelect</name> <modifier>*</modifier></type> <name>OrSelectNode</name><parameter_list>(<parameter><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>OrSelectClauseList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PushDownNodeLoop</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PullUpCollectLoop</name><parameter_list>(<parameter><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>collectNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddressProjectSpecialConditions</name><parameter_list>(<parameter><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>projectNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PushDownStatus</name></type> <name>CanPushDown</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PullUpStatus</name></type> <name>CanPullUp</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PushDownStatus</name></type> <name>Commutative</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>,
								  <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PushDownStatus</name></type> <name>Distributive</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>,
								   <parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PullUpStatus</name></type> <name>Factorizable</name><parameter_list>(<parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>,
								 <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>SelectClauseTableIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiUnaryNode</name> <modifier>*</modifier></type> <name>GenerateLeftNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name></decl></parameter>,
										 <parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiUnaryNode</name> <modifier>*</modifier></type> <name>GenerateRightNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name></decl></parameter>,
										  <parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiUnaryNode</name> <modifier>*</modifier></type> <name>GenerateNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>TableIdListColumns</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>TableIdListSelectClauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PushDownBelowUnaryChild</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name></decl></parameter>,
									<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlaceUnaryNodeChild</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryNode</name></decl></parameter>, <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlaceBinaryNodeLeftChild</name><parameter_list>(<parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name></decl></parameter>,
									 <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>newLeftChildNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PlaceBinaryNodeRightChild</name><parameter_list>(<parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name></decl></parameter>,
									  <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>newRightChildNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveUnaryNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PullUpUnaryNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParentSetNewChild</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>oldChildNode</name></decl></parameter>,
							  <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>newChildNode</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Local functions forward declarations for aggregate expressions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ApplyExtendedOpNodes</name><parameter_list>(<parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>originalNode</name></decl></parameter>,
								 <parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>masterNode</name></decl></parameter>,
								 <parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TransformSubqueryNode</name><parameter_list>(<parameter><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>subqueryNode</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>subqueryHasNonDistributableAggregates</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiExtendedOp</name> <modifier>*</modifier></type> <name>MasterExtendedOpNode</name><parameter_list>(<parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>originalOpNode</name></decl></parameter>,
											  <parameter><decl><type><name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type>
											  <name>extendedOpNodeProperties</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>MasterAggregateMutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalNode</name></decl></parameter>,
									 <parameter><decl><type><name>MasterAggregateWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type> <name>MasterAggregateExpression</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>originalAggregate</name></decl></parameter>,
										<parameter><decl><type><name>MasterAggregateWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type> <name>MasterAverageExpression</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sumAggregateType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>countAggregateType</name></decl></parameter>,
									  <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>columnId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type> <name>AddTypeConversion</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalAggregate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newExpression</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiExtendedOp</name> <modifier>*</modifier></type> <name>WorkerExtendedOpNode</name><parameter_list>(<parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>originalOpNode</name></decl></parameter>,
											  <parameter><decl><type><name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type>
											  <name>extendedOpNodeProperties</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessTargetListForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>,
											<parameter><decl><type><name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type>
											<name>extendedOpNodeProperties</name></decl></parameter>,
											<parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>,
											<parameter><decl><type><name>QueryGroupClause</name> <modifier>*</modifier></type><name>queryGroupClause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessHavingClauseForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>,
											  <parameter><decl><type><name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type>
											  <name>extendedOpNodeProperties</name></decl></parameter>,
											  <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>workerHavingQual</name></decl></parameter>,
											  <parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>,
											  <parameter><decl><type><name>QueryGroupClause</name> <modifier>*</modifier></type><name>queryGroupClause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessDistinctClauseForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctClause</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasDistinctOn</name></decl></parameter>,
												<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl></parameter>,
												<parameter><decl><type><name>bool</name></type> <name>queryHasAggregates</name></decl></parameter>,
												<parameter><decl><type><name>QueryDistinctClause</name> <modifier>*</modifier></type><name>queryDistinctClause</name></decl></parameter>,
												<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>distinctPreventsLimitPushdown</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessWindowFunctionsForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>windowClauseList</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>originalTargetEntryList</name></decl></parameter>,
												 <parameter><decl><type><name>QueryWindowClause</name> <modifier>*</modifier></type><name>queryWindowClause</name></decl></parameter>,
												 <parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessWindowFunctionPullUpForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>windowClause</name></decl></parameter>,
													  <parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessLimitOrderByForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>OrderByLimitReference</name></type> <name>orderByLimitReference</name></decl></parameter>,
											  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalLimitCount</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>originalTargetList</name></decl></parameter>,
											  <parameter><decl><type><name>QueryOrderByLimit</name> <modifier>*</modifier></type><name>queryOrderByLimit</name></decl></parameter>,
											  <parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OrderByLimitReference</name></type> <name>BuildOrderByLimitReference</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>hasDistinctOn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
														<name>groupedByDisjointPartitionColumn</name></decl></parameter>,
														<parameter><decl><type><name>bool</name></type> <name>onlyPushableWindowFunctions</name></decl></parameter>,
														<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
														<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>,
														<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExpandWorkerTargetEntry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>expressionList</name></decl></parameter>,
									<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>originalTargetEntry</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>addToGroupByClause</name></decl></parameter>,
									<parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>,
									<parameter><decl><type><name>QueryGroupClause</name> <modifier>*</modifier></type><name>queryGroupClause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Index</name></type> <name>GetNextSortGroupRef</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type> <name>GenerateWorkerTargetEntry</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name></decl></parameter>,
											   <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>workerExpression</name></decl></parameter>,
											   <parameter><decl><type><name>AttrNumber</name></type> <name>targetProjectionNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendTargetEntryToGroupClause</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name></decl></parameter>,
										   <parameter><decl><type><name>QueryGroupClause</name> <modifier>*</modifier></type><name>queryGroupClause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>WorkerAggregateWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								  <parameter><decl><type><name>WorkerAggregateWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>WorkerAggregateExpressionList</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>originalAggregate</name></decl></parameter>,
											<parameter><decl><type><name>WorkerAggregateWalkerContext</name> <modifier>*</modifier></type><name>walkerContextry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AggregateType</name></type> <name>GetAggregateType</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregatExpression</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>AggregateArgumentType</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type> <name>FirstAggregateArgument</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AggregateEnabledCustom</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregateExpression</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>CitusFunctionOidWithSignature</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>WorkerPartialAggOid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>CoordCombineAggOid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>AggregateFunctionOid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>functionName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>TypeOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>schemaId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SortGroupClause</name> <modifier>*</modifier></type> <name>CreateSortGroupClause</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Local functions forward declarations for count(distinct) approximations */</comment>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>CountDistinctHashFunctionName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>argumentType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CountDistinctStorageSize</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>approximationErrorRate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type> <name>MakeIntegerConstInt64</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>integerValue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type> <name>MakeIntegerConst</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>integerValue</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* Local functions forward declarations for aggregate expression checks */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasNonDistributableAggregates</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>logicalPlanNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CanPushDownExpression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>,
								  <parameter><decl><type><specifier>const</specifier> <name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type><name>extendedOpNodeProperties</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfHasNonDistributableAggregates</name><parameter_list>(
	<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>logicalPlanNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfUnsupportedArrayAggregate</name><parameter_list>(
	<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>arrayAggregateExpression</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfUnsupportedJsonAggregate</name><parameter_list>(<parameter><decl><type><name>AggregateType</name></type> <name>type</name></decl></parameter>,
																   <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type>
																   <name>aggregateExpression</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfUnsupportedAggregateDistinct</name><parameter_list>(
	<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregateExpression</name></decl></parameter>,
	<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type>
	<name>logicalPlanNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type> <name>AggregateDistinctColumn</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregateExpression</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TablePartitioningSupportsDistinct</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNodeList</name></decl></parameter>,
											  <parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>opNode</name></decl></parameter>,
											  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distinctColumn</name></decl></parameter>,
											  <parameter><decl><type><name>AggregateType</name></type> <name>aggregateType</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Local functions forward declarations for limit clauses */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>WorkerLimitCount</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name></decl></parameter>, <parameter><decl><type><name>OrderByLimitReference</name></type>
							   <name>orderByLimitReference</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>WorkerSortClauseList</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>,
								   <parameter><decl><type><name>OrderByLimitReference</name></type> <name>orderByLimitReference</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CanPushDownLimitApproximate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasOrderByAggregate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasOrderByNonCommutativeAggregate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasOrderByComplexExpression</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasOrderByHllType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldProcessDistinctOrderAndLimitForWorker</name><parameter_list>(
	<parameter><decl><type><name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type><name>extendedOpNodeProperties</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>pushingDownOriginalGrouping</name></decl></parameter>,
	<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsIndexInRange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * MultiLogicalPlanOptimize applies multi-relational algebra optimizations on
 * the given logical plan tree. Specifically, the function applies four set of
 * optimizations in a particular order.
 *
 * First, the function splits the search node into two nodes that contain And
 * and Or clauses, and pushes down the node that contains And clauses. Second,
 * the function pushes down the project node; this node either contains columns
 * to return to the user, or aggregate expressions used by the aggregate node.
 * Third, the function pulls up the collect operators in the tree. Fourth, the
 * function finds the extended operator node, and splits this node into master
 * and worker extended operator nodes.
 */</comment>
<function><type><name>void</name></type>
<name>MultiLogicalPlanOptimize</name><parameter_list>(<parameter><decl><type><name>MultiTreeRoot</name> <modifier>*</modifier></type><name>multiLogicalPlan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>logicalPlanNode</name> <init>= <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>multiLogicalPlan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasNonDistributableAggregates</name> <init>= <expr><call><name>HasNonDistributableAggregates</name><argument_list>(
		<argument><expr><name>logicalPlanNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>extendedOpNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiExtendedOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOpNode</name> <init>= <expr><operator>(</operator><name>MultiExtendedOp</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>extendedOpNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtendedOpNodeProperties</name></type> <name>extendedOpNodeProperties</name> <init>= <expr><call><name>BuildExtendedOpNodeProperties</name><argument_list>(
		<argument><expr><name>extendedOpNode</name></expr></argument>, <argument><expr><name>hasNonDistributableAggregates</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extendedOpNodeProperties</name><operator>.</operator><name>groupedByDisjointPartitionColumn</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>extendedOpNodeProperties</name><operator>.</operator><name>pullUpIntermediateRows</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>aggregatePushdownError</name> <init>=
			<expr><call><name>DeferErrorIfHasNonDistributableAggregates</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggregatePushdownError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>CoordinatorAggregationStrategy</name> <operator>==</operator> <name>COORDINATOR_AGGREGATION_DISABLED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>aggregatePushdownError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>extendedOpNodeProperties</name><operator>.</operator><name>pullUpIntermediateRows</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>extendedOpNodeProperties</name><operator>.</operator><name>pushDownGroupingAndHaving</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If a select node exists, we use the idempower property to split the node
	 * into two nodes that contain And and Or clauses. If both And and Or nodes
	 * exist, we modify the tree in place to swap the original select node with
	 * And and Or nodes. We then push down the And select node if it exists.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiSelect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>selectNodeList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name> <init>= <expr><operator>(</operator><name>MultiSelect</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>selectNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>andSelectNode</name> <init>= <expr><call><name>AndSelectNode</name><argument_list>(<argument><expr><name>selectNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>orSelectNode</name> <init>= <expr><call><name>OrSelectNode</name><argument_list>(<argument><expr><name>selectNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>andSelectNode</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>orSelectNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name> <init>= <expr><call><name>ParentNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>selectNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>selectNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>orSelectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>orSelectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>andSelectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>andSelectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>andSelectNode</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>orSelectNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>andSelectNode</name> <operator>=</operator> <name>selectNode</name></expr>;</expr_stmt> <comment type="block">/* no need to modify the tree */</comment>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>andSelectNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushDownNodeLoop</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>andSelectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* push down the multi project node */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>projectNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiProject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>projectNode</name> <init>= <expr><operator>(</operator><name>MultiProject</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>projectNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PushDownNodeLoop</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>projectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pull up collect nodes and merge duplicate collects */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>collectNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiCollect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>collectNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>collectNode</argument>, <argument>collectNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PullUpCollectLoop</name><argument_list>(<argument><expr><name>collectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We split the extended operator node into its equivalent master and worker
	 * operator nodes; and if the extended operator has aggregates, we transform
	 * aggregate functions accordingly for the master and worker operator nodes.
	 * If we can push down the limit clause, we also add limit count and sort
	 * clause list to the worker operator node. We then push the worker operator
	 * node below the collect node.
	 */</comment>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>masterExtendedOpNode</name> <init>=
		<expr><call><name>MasterExtendedOpNode</name><argument_list>(<argument><expr><name>extendedOpNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extendedOpNodeProperties</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>workerExtendedOpNode</name> <init>=
		<expr><call><name>WorkerExtendedOpNode</name><argument_list>(<argument><expr><name>extendedOpNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extendedOpNodeProperties</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ApplyExtendedOpNodes</name><argument_list>(<argument><expr><name>extendedOpNode</name></expr></argument>, <argument><expr><name>masterExtendedOpNode</name></expr></argument>, <argument><expr><name>workerExtendedOpNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>tableNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>tableNode</argument>, <argument>tableNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tableNode</name><operator>-&gt;</operator><name>relationId</name></name> <operator>==</operator> <name>SUBQUERY_RELATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>error</name> <init>=
				<expr><call><name>DeferErrorIfHasNonDistributableAggregates</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>tableNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>subqueryHasNonDistributableAggregates</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>CoordinatorAggregationStrategy</name> <operator>==</operator> <name>COORDINATOR_AGGREGATION_DISABLED</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>subqueryHasNonDistributableAggregates</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>TransformSubqueryNode</name><argument_list>(<argument><expr><name>tableNode</name></expr></argument>, <argument><expr><name>subqueryHasNonDistributableAggregates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * When enabled, count(distinct) approximation uses hll as the intermediate
	 * data type. We currently have a mismatch between hll target entry and sort
	 * clause's sortop oid, so we can't push an order by on the hll data type to
	 * the worker node. We check that here and error out if necessary.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasOrderByHllType</name> <init>= <expr><call><name>HasOrderByHllType</name><argument_list>(<argument><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>sortClauseList</name></name></expr></argument>,
											   <argument><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasOrderByHllType</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot approximate count(distinct) and order by it"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might need to disable approximations for either "</literal>
								<literal type="string">"count(distinct) or limit through configuration."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TargetListContainsSubquery</name><argument_list>(<argument><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot push down subquery on the target list"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Subqueries in the SELECT part of the query can only "</literal>
								  <literal type="string">"be pushed down if they happen before aggregates and "</literal>
								  <literal type="string">"window functions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AndSelectNode looks for AND clauses in the given select node. If they exist,
 * the function returns these clauses in a new node. Otherwise, the function
 * returns null.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiSelect</name> <modifier>*</modifier></type>
<name>AndSelectNode</name><parameter_list>(<parameter><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>andSelectNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name> <init>= <expr><name><name>selectNode</name><operator>-&gt;</operator><name>selectClauseList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>orSelectClauseList</name> <init>= <expr><call><name>OrSelectClauseList</name><argument_list>(<argument><expr><name>selectClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* AND clauses are select clauses that are not OR clauses */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>andSelectClauseList</name> <init>= <expr><call><name>list_difference</name><argument_list>(<argument><expr><name>selectClauseList</name></expr></argument>, <argument><expr><name>orSelectClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>andSelectClauseList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>andSelectNode</name> <operator>=</operator> <call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>andSelectNode</name><operator>-&gt;</operator><name>selectClauseList</name></name> <operator>=</operator> <name>andSelectClauseList</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>andSelectNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OrSelectNode looks for OR clauses in the given select node. If they exist,
 * the function returns these clauses in a new node. Otherwise, the function
 * returns null.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiSelect</name> <modifier>*</modifier></type>
<name>OrSelectNode</name><parameter_list>(<parameter><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>orSelectNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name> <init>= <expr><name><name>selectNode</name><operator>-&gt;</operator><name>selectClauseList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>orSelectClauseList</name> <init>= <expr><call><name>OrSelectClauseList</name><argument_list>(<argument><expr><name>selectClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>orSelectClauseList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>orSelectNode</name> <operator>=</operator> <call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>orSelectNode</name><operator>-&gt;</operator><name>selectClauseList</name></name> <operator>=</operator> <name>orSelectClauseList</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>orSelectNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OrSelectClauseList walks over the select clause list, and returns all clauses
 * that have OR expressions in them.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>OrSelectClauseList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>orSelectClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>selectClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>selectClause</argument>, <argument>selectClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>orClause</name> <init>= <expr><call><name>is_orclause</name><argument_list>(<argument><expr><name>selectClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>orClause</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>orSelectClauseList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>orSelectClauseList</name></expr></argument>, <argument><expr><name>selectClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>orSelectClauseList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PushDownNodeLoop pushes down the current node as far down the plan tree as
 * possible. For this, the function first addresses any special conditions that
 * may apply on the current node. Then, the function pushes down the current
 * node if its child node is unary. If the child is binary, the function splits
 * the current node into two nodes by applying generation rules, and recurses
 * into itself to push down these two nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PushDownNodeLoop</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>projectNodeGenerated</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>leftNodeGenerated</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>rightNodeGenerated</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PushDownStatus</name></type> <name>pushDownStatus</name> <init>= <expr><call><name>CanPushDown</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>pushDownStatus</name> <operator>==</operator> <name>PUSH_DOWN_VALID</name> <operator>||</operator>
		   <name>pushDownStatus</name> <operator>==</operator> <name>PUSH_DOWN_SPECIAL_CONDITIONS</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><name><name>currentNode</name><operator>-&gt;</operator><name>childNode</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>unaryChild</name> <init>= <expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>binaryChild</name> <init>= <expr><call><name>BinaryOperator</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We first check if we can use the idempower property to split the
		 * project node. We split at a partition node as it captures the
		 * minimal set of columns needed from a partition job. After the split
		 * we break from the loop and recursively call pushdown for the
		 * generated project node.
		 */</comment>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name> <init>= <expr><call><name>ParentNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>currentNodeType</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>parentNodeType</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>currentNodeType</name> <operator>==</operator> <name>T_MultiProject</name> <operator>&amp;&amp;</operator> <name>parentNodeType</name> <operator>==</operator> <name>T_MultiPartition</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>projectNodeGenerated</name> <operator>=</operator> <call><name>GenerateNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>, <argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PlaceUnaryNodeChild</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>, <argument><expr><name>projectNodeGenerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* address any special conditions before we can perform the pushdown */</comment>
		<if_stmt><if>if <condition>(<expr><name>pushDownStatus</name> <operator>==</operator> <name>PUSH_DOWN_SPECIAL_CONDITIONS</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>projectNode</name> <init>= <expr><operator>(</operator><name>MultiProject</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>currentNodeType</name> <operator>==</operator> <name>T_MultiProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AddressProjectSpecialConditions</name><argument_list>(<argument><expr><name>projectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>unaryChild</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryChildNode</name> <init>= <expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>PushDownBelowUnaryChild</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>, <argument><expr><name>unaryChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>binaryChild</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryChildNode</name> <init>= <expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>leftNodeGenerated</name> <operator>=</operator> <call><name>GenerateLeftNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>, <argument><expr><name>binaryChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rightNodeGenerated</name> <operator>=</operator> <call><name>GenerateRightNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>, <argument><expr><name>binaryChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* push down the generated nodes below the binary child node */</comment>
			<expr_stmt><expr><call><name>PlaceBinaryNodeLeftChild</name><argument_list>(<argument><expr><name>binaryChildNode</name></expr></argument>, <argument><expr><name>leftNodeGenerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PlaceBinaryNodeRightChild</name><argument_list>(<argument><expr><name>binaryChildNode</name></expr></argument>, <argument><expr><name>rightNodeGenerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Remove the current node, and break out of the push down loop for
			 * the current node. Then, recurse into the push down function for
			 * the newly generated nodes.
			 */</comment>
			<expr_stmt><expr><call><name>RemoveUnaryNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <call><name>CanPushDown</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* recursively perform pushdown of any nodes generated in the loop */</comment>
	<if_stmt><if>if <condition>(<expr><name>projectNodeGenerated</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PushDownNodeLoop</name><argument_list>(<argument><expr><name>projectNodeGenerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>leftNodeGenerated</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PushDownNodeLoop</name><argument_list>(<argument><expr><name>leftNodeGenerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rightNodeGenerated</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PushDownNodeLoop</name><argument_list>(<argument><expr><name>rightNodeGenerated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PullUpCollectLoop pulls up the collect node as far up as possible in the plan
 * tree. The function also merges two collect nodes that are direct descendants
 * of each other by removing the given collect node from the tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PullUpCollectLoop</name><parameter_list>(<parameter><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>collectNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name> <init>= <expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PullUpStatus</name></type> <name>pullUpStatus</name> <init>= <expr><call><name>CanPullUp</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>pullUpStatus</name> <operator>==</operator> <name>PULL_UP_VALID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PullUpUnaryNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pullUpStatus</name> <operator>=</operator> <call><name>CanPullUp</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * After pulling up the collect node, if we find that our child node is also
	 * a collect, we merge the two collect nodes together by removing this node.
	 */</comment>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><name><name>currentNode</name><operator>-&gt;</operator><name>childNode</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>, <argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RemoveUnaryNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AddressProjectSpecialConditions adds columns to the project node if necessary
 * to make the node commutative and distributive with its child node. For this,
 * the function checks for any special conditions between the project and child
 * node, and determines the child node columns to add for the special conditions
 * to apply. The function then adds these columns to the project node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddressProjectSpecialConditions</name><parameter_list>(<parameter><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>projectNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>projectNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>childNodeTag</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>childColumnList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We check if we need to include any child columns in the project node to
	 * address the following special conditions.
	 *
	 * SNC1: project node must include child node's projected columns, or
	 * SNC2: project node must include child node's partition column,  or
	 * SNC3: project node must include child node's selection columns, or
	 * NSC1: project node must include child node's join columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>childNodeTag</name> <operator>==</operator> <name>T_MultiProject</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>projectChildNode</name> <init>= <expr><operator>(</operator><name>MultiProject</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>projectColumnList</name> <init>= <expr><name><name>projectChildNode</name><operator>-&gt;</operator><name>columnList</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>childColumnList</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>projectColumnList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>childNodeTag</name> <operator>==</operator> <name>T_MultiPartition</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiPartition</name> <modifier>*</modifier></type><name>partitionNode</name> <init>= <expr><operator>(</operator><name>MultiPartition</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name><name>partitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>partitionColumn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>childColumnList</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>partitionColumnList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>childNodeTag</name> <operator>==</operator> <name>T_MultiSelect</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name> <init>= <expr><operator>(</operator><name>MultiSelect</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>selectClauseList</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>selectNode</name><operator>-&gt;</operator><name>selectClauseList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><name>selectClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>childColumnList</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>selectList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>childNodeTag</name> <operator>==</operator> <name>T_MultiJoin</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>= <expr><operator>(</operator><name>MultiJoin</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinClauseList</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>joinNode</name><operator>-&gt;</operator><name>joinClauseList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><name>joinClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>childColumnList</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>joinList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we need to include any child columns, then find the columns that are
	 * not already in the project column list, and add them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>childColumnList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>projectColumnList</name> <init>= <expr><name><name>projectNode</name><operator>-&gt;</operator><name>columnList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newColumnList</name> <init>= <expr><call><name>list_concat_unique</name><argument_list>(<argument><expr><name>projectColumnList</name></expr></argument>, <argument><expr><name>childColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>projectNode</name><operator>-&gt;</operator><name>columnList</name></name> <operator>=</operator> <name>newColumnList</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CanPushDown determines if a particular node can be moved below its child. The
 * criteria for pushing down a node is determined by multi-relational algebra's
 * rules for commutativity and distributivity.
 */</comment>
<function><type><specifier>static</specifier> <name>PushDownStatus</name></type>
<name>CanPushDown</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PushDownStatus</name></type> <name>pushDownStatus</name> <init>= <expr><name>PUSH_DOWN_INVALID_FIRST</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><name><name>parentNode</name><operator>-&gt;</operator><name>childNode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>unaryChild</name> <init>= <expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>binaryChild</name> <init>= <expr><call><name>BinaryOperator</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>unaryChild</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <call><name>Commutative</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>binaryChild</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <call><name>Distributive</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pushDownStatus</name> <operator>!=</operator> <name>PUSH_DOWN_INVALID_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>pushDownStatus</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CanPullUp determines if a particular node can be moved above its parent. The
 * criteria for pulling up a node is determined by multi-relational algebra's
 * rules for commutativity and factorizability.
 */</comment>
<function><type><specifier>static</specifier> <name>PullUpStatus</name></type>
<name>CanPullUp</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PullUpStatus</name></type> <name>pullUpStatus</name> <init>= <expr><name>PULL_UP_INVALID_FIRST</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name> <init>= <expr><call><name>ParentNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>unaryParent</name> <init>= <expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>binaryParent</name> <init>= <expr><call><name>BinaryOperator</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>unaryParent</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Evaluate if parent can be pushed down below the child node, since it
		 * is equivalent to pulling up the child above its parent.
		 */</comment>
		<decl_stmt><decl><type><name>PushDownStatus</name></type> <name>parentPushDownStatus</name> <init>= <expr><call><name>Commutative</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></argument>,
														  <argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>parentPushDownStatus</name> <operator>==</operator> <name>PUSH_DOWN_VALID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pullUpStatus</name> <operator>=</operator> <name>PULL_UP_VALID</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>pullUpStatus</name> <operator>=</operator> <name>PULL_UP_NOT_VALID</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>binaryParent</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pullUpStatus</name> <operator>=</operator> <call><name>Factorizable</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></argument>, <argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pullUpStatus</name> <operator>!=</operator> <name>PULL_UP_INVALID_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>pullUpStatus</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Commutative returns a status which denotes whether the given parent node can
 * be pushed down below its child node using the commutative property.
 */</comment>
<function><type><specifier>static</specifier> <name>PushDownStatus</name></type>
<name>Commutative</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>, <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PushDownStatus</name></type> <name>pushDownStatus</name> <init>= <expr><name>PUSH_DOWN_NOT_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>parentNodeTag</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>childNodeTag</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we cannot be commutative with non-query operators */</comment>
	<if_stmt><if>if <condition>(<expr><name>childNodeTag</name> <operator>==</operator> <name>T_MultiTreeRoot</name> <operator>||</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiTable</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>PUSH_DOWN_NOT_VALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* first check for commutative operators and no special conditions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiPartition</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiProject</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiPartition</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiPartition</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiPartition</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiSelect</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <name>PUSH_DOWN_VALID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiCollect</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiProject</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiCollect</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiCollect</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiCollect</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiSelect</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <name>PUSH_DOWN_VALID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiSelect</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <name>PUSH_DOWN_VALID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiProject</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiCollect</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <name>PUSH_DOWN_VALID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The project node is commutative with the below operators given that
	 * its special conditions apply.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiProject</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiProject</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiProject</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiPartition</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiProject</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiSelect</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiProject</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiJoin</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <name>PUSH_DOWN_SPECIAL_CONDITIONS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>pushDownStatus</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Distributive returns a status which denotes whether the given parent node can
 * be pushed down below its binary child node using the distributive property.
 */</comment>
<function><type><specifier>static</specifier> <name>PushDownStatus</name></type>
<name>Distributive</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>, <parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PushDownStatus</name></type> <name>pushDownStatus</name> <init>= <expr><name>PUSH_DOWN_NOT_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>parentNodeTag</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>childNodeTag</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* special condition checks for partition operator are not implemented */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parentNodeTag</name> <operator>!=</operator> <name>T_MultiPartition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The project node is distributive with the join operator given that its
	 * special conditions apply.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiProject</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <name>PUSH_DOWN_SPECIAL_CONDITIONS</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* collect node is distributive without special conditions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiCollect</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiJoin</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiCollect</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiCartesianProduct</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <name>PUSH_DOWN_VALID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The select node is distributive with a binary operator if all tables in
	 * the select clauses are output by the binary child. The select clauses are
	 * individually AND'd; and therefore this check is sufficient to implement
	 * the NSC3 special condition in multi-relational algebra.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiSelect</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiJoin</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>parentNodeTag</name> <operator>==</operator> <name>T_MultiSelect</name> <operator>&amp;&amp;</operator> <name>childNodeTag</name> <operator>==</operator> <name>T_MultiCartesianProduct</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name> <init>= <expr><operator>(</operator><name>MultiSelect</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name> <init>= <expr><name><name>selectNode</name><operator>-&gt;</operator><name>selectClauseList</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectTableIdList</name> <init>= <expr><call><name>SelectClauseTableIdList</name><argument_list>(<argument><expr><name>selectClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>childTableIdList</name> <init>= <expr><call><name>OutputTableIdList</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* find tables that are in select clause list, but not in child list */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>diffList</name> <init>= <expr><call><name>list_difference_int</name><argument_list>(<argument><expr><name>selectTableIdList</name></expr></argument>, <argument><expr><name>childTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>diffList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pushDownStatus</name> <operator>=</operator> <name>PUSH_DOWN_VALID</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>pushDownStatus</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Factorizable returns a status which denotes whether the given unary child
 * node can be pulled up above its binary parent node using the factorizability
 * property. The function currently performs this check only for collect node
 * types; other node types have generation rules that are not yet implemented.
 */</comment>
<function><type><specifier>static</specifier> <name>PullUpStatus</name></type>
<name>Factorizable</name><parameter_list>(<parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>, <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PullUpStatus</name></type> <name>pullUpStatus</name> <init>= <expr><name>PULL_UP_NOT_VALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>parentNodeTag</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>childNodeTag</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The following nodes are factorizable with their parents, but we don't
	 * have their generation rules implemented. We therefore assert here.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childNodeTag</name> <operator>!=</operator> <name>T_MultiProject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childNodeTag</name> <operator>!=</operator> <name>T_MultiPartition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childNodeTag</name> <operator>!=</operator> <name>T_MultiSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>childNodeTag</name> <operator>==</operator> <name>T_MultiCollect</name> <operator>&amp;&amp;</operator> <name>parentNodeTag</name> <operator>==</operator> <name>T_MultiJoin</name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>childNodeTag</name> <operator>==</operator> <name>T_MultiCollect</name> <operator>&amp;&amp;</operator> <name>parentNodeTag</name> <operator>==</operator> <name>T_MultiCartesianProduct</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pullUpStatus</name> <operator>=</operator> <name>PULL_UP_VALID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>pullUpStatus</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SelectClauseTableIdList finds the (range) table identifier for each select
 * clause in the given list, and returns these identifiers in a new list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>SelectClauseTableIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>selectClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>selectClause</argument>, <argument>selectClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectColumnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><name>selectClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>selectColumnList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* filter is a constant, e.g. false or 1=0 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>selectColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>selectColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>selectColumnTableId</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>selectColumn</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>tableIdList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>tableIdList</name></expr></argument>, <argument><expr><name>selectColumnTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>tableIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateLeftNode splits the current node over the binary node by applying the
 * generation rule for distributivity in multi-relational algebra. After the
 * split, the function returns the left node.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiUnaryNode</name> <modifier>*</modifier></type>
<name>GenerateLeftNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name></decl></parameter>, <parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftChildNode</name> <init>= <expr><name><name>binaryNode</name><operator>-&gt;</operator><name>leftChildNode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>leftNodeGenerated</name> <init>= <expr><call><name>GenerateNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>, <argument><expr><name>leftChildNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>leftNodeGenerated</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateRightNode splits the current node over the binary node by applying
 * the generation rule for distributivity in multi-relational algebra. After the
 * split, the function returns the right node.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiUnaryNode</name> <modifier>*</modifier></type>
<name>GenerateRightNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name></decl></parameter>, <parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightChildNode</name> <init>= <expr><name><name>binaryNode</name><operator>-&gt;</operator><name>rightChildNode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>rightNodeGenerated</name> <init>= <expr><call><name>GenerateNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>, <argument><expr><name>rightChildNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>rightNodeGenerated</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateNode determines the current node's type, and applies the relevant
 * generation node for that node type. If the current node is a project node,
 * the function creates a new project node with attributes that only have the
 * child subtree's tables. Else if the current node is a select node, the
 * function creates a new select node with select clauses that only belong to
 * the tables output by the child node's subtree.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiUnaryNode</name> <modifier>*</modifier></type>
<name>GenerateNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>generatedNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>currentNodeType</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name> <init>= <expr><call><name>OutputTableIdList</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>currentNodeType</name> <operator>==</operator> <name>T_MultiProject</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>projectNode</name> <init>= <expr><operator>(</operator><name>MultiProject</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>projectNode</name><operator>-&gt;</operator><name>columnList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newColumnList</name> <init>= <expr><call><name>TableIdListColumns</name><argument_list>(<argument><expr><name>tableIdList</name></expr></argument>, <argument><expr><name>columnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>newColumnList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>newProjectNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiProject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>newProjectNode</name><operator>-&gt;</operator><name>columnList</name></name> <operator>=</operator> <name>newColumnList</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>generatedNode</name> <operator>=</operator> <operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>newProjectNode</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>currentNodeType</name> <operator>==</operator> <name>T_MultiSelect</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name> <init>= <expr><operator>(</operator><name>MultiSelect</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>selectNode</name><operator>-&gt;</operator><name>selectClauseList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newSelectClauseList</name> <init>= <expr><call><name>TableIdListSelectClauses</name><argument_list>(<argument><expr><name>tableIdList</name></expr></argument>,
															 <argument><expr><name>selectClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>newSelectClauseList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>newSelectNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiSelect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>newSelectNode</name><operator>-&gt;</operator><name>selectClauseList</name></name> <operator>=</operator> <name>newSelectClauseList</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>generatedNode</name> <operator>=</operator> <operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>newSelectNode</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>generatedNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TableIdListColumns walks over the given column list, finds columns belonging
 * to the given table id list, and returns the found columns in a new list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>TableIdListColumns</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableColumnList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>column</argument>, <argument>columnList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>columnTableId</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>column</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>tableListMember</name> <init>= <expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>tableIdList</name></expr></argument>, <argument><expr><name>columnTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>tableListMember</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tableColumnList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableColumnList</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>tableColumnList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TableIdListSelectClauses walks over the given select clause list, finds the
 * select clauses whose column references belong to the given table list, and
 * returns the found clauses in a new list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>TableIdListSelectClauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableSelectClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>selectClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>selectClause</argument>, <argument>selectClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectColumnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><name>selectClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>selectColumnList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* filter is a constant, e.g. false or 1=0, always include it */</comment>
			<expr_stmt><expr><name>tableSelectClauseList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableSelectClauseList</name></expr></argument>, <argument><expr><name>selectClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>selectColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>selectColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>selectClauseTableId</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>selectColumn</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>tableIdListMember</name> <init>= <expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>tableIdList</name></expr></argument>, <argument><expr><name>selectClauseTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>tableIdListMember</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tableSelectClauseList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableSelectClauseList</name></expr></argument>, <argument><expr><name>selectClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>tableSelectClauseList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Pushes down the current node below its unary child node. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PushDownBelowUnaryChild</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>currentNode</name></decl></parameter>, <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>childNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name> <init>= <expr><call><name>ParentNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childChildNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* current node's parent now points to the child node */</comment>
	<expr_stmt><expr><call><name>ParentSetNewChild</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* current node's child becomes its parent */</comment>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* current node points to the child node's child */</comment>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>, <argument><expr><name>childChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PlaceUnaryNodeChild inserts the new node as a child node under the given
 * unary node. The function also places the previous child node under the new
 * child node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PlaceUnaryNodeChild</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryNode</name></decl></parameter>, <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>newChildNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>oldChildNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><name>unaryNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><name>unaryNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>newChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><name>newChildNode</name></expr></argument>, <argument><expr><name>oldChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PlaceBinaryNodeLeftChild inserts the new left child as the binary node's left
 * child. The function also places the previous left child below the new child
 * node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PlaceBinaryNodeLeftChild</name><parameter_list>(<parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name></decl></parameter>, <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>newLeftChildNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newLeftChildNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><name>newLeftChildNode</name></expr></argument>, <argument><expr><name><name>binaryNode</name><operator>-&gt;</operator><name>leftChildNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLeftChild</name><argument_list>(<argument><expr><name>binaryNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>newLeftChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PlaceBinaryNodeRightChild inserts the new right child as the binary node's
 * right child. The function also places the previous right child below the new
 * child node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PlaceBinaryNodeRightChild</name><parameter_list>(<parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name></decl></parameter>, <parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>newRightChildNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newRightChildNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><name>newRightChildNode</name></expr></argument>, <argument><expr><name><name>binaryNode</name><operator>-&gt;</operator><name>rightChildNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetRightChild</name><argument_list>(<argument><expr><name>binaryNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>newRightChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Removes the given unary node from the logical plan, and frees the node. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveUnaryNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name> <init>= <expr><call><name>ParentNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>unaryNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><name>unaryNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set parent to directly point to unary node's child */</comment>
	<expr_stmt><expr><call><name>ParentSetNewChild</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>unaryNode</name></expr></argument>, <argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>unaryNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Pulls up the given current node above its parent node. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PullUpUnaryNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name> <init>= <expr><call><name>ParentNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>unaryNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>unaryParent</name> <init>= <expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>binaryParent</name> <init>= <expr><call><name>BinaryOperator</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>unaryParent</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* pulling up a node is the same as pushing down the node's unary parent */</comment>
		<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryParentNode</name> <init>= <expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PushDownBelowUnaryChild</name><argument_list>(<argument><expr><name>unaryParentNode</name></expr></argument>, <argument><expr><name>unaryNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>binaryParent</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryParentNode</name> <init>= <expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentParentNode</name> <init>= <expr><call><name>ParentNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>binaryParentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><name><name>unaryNode</name><operator>-&gt;</operator><name>childNode</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* make the parent node point to the unary node's child node */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>binaryParentNode</name><operator>-&gt;</operator><name>leftChildNode</name></name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>unaryNode</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetLeftChild</name><argument_list>(<argument><expr><name>binaryParentNode</name></expr></argument>, <argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetRightChild</name><argument_list>(<argument><expr><name>binaryParentNode</name></expr></argument>, <argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* make the parent parent node point to the unary node */</comment>
		<expr_stmt><expr><call><name>ParentSetNewChild</name><argument_list>(<argument><expr><name>parentParentNode</name></expr></argument>, <argument><expr><name>parentNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>unaryNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make the unary node point to the (old) parent node */</comment>
		<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><name>unaryNode</name></expr></argument>, <argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ParentSetNewChild takes in the given parent node, and replaces the parent's
 * old child node with the new child node. The function needs the old child node
 * in case the parent is a binary node and the function needs to determine which
 * side of the parent node the new child node needs to go to.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParentSetNewChild</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>oldChildNode</name></decl></parameter>,
				  <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>newChildNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>unaryParent</name> <init>= <expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>binaryParent</name> <init>= <expr><call><name>BinaryOperator</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>unaryParent</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryParentNode</name> <init>= <expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><name>unaryParentNode</name></expr></argument>, <argument><expr><name>newChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>binaryParent</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryParentNode</name> <init>= <expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* determine which side of the parent the old child is on */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>binaryParentNode</name><operator>-&gt;</operator><name>leftChildNode</name></name> <operator>==</operator> <name>oldChildNode</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetLeftChild</name><argument_list>(<argument><expr><name>binaryParentNode</name></expr></argument>, <argument><expr><name>newChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetRightChild</name><argument_list>(<argument><expr><name>binaryParentNode</name></expr></argument>, <argument><expr><name>newChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ApplyExtendedOpNodes replaces the original extended operator node with the
 * master and worker extended operator nodes. The function then pushes down the
 * worker node below the original node's child node. Note that for the push down
 * to apply, the original node's child must be a collect node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ApplyExtendedOpNodes</name><parameter_list>(<parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>originalNode</name></decl></parameter>, <parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>masterNode</name></decl></parameter>,
					 <parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name> <init>= <expr><call><name>ParentNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>originalNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>collectNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>originalNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>collectChildNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* original node's child must be a collect node */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>collectNode</name></expr></argument>, <argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* swap the original aggregate node with the master extended node */</comment>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>parentNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>masterNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>masterNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add the worker extended node below the collect node */</comment>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>workerNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>collectChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up the original extended operator node */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>originalNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TransformSubqueryNode splits the extended operator node under subquery
 * multi table node into its equivalent master and worker operator nodes, and
 * we transform aggregate functions accordingly for the master and worker
 * operator nodes. We create a partition node based on the first group by
 * column of the extended operator node and set it as the child of the master
 * operator node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TransformSubqueryNode</name><parameter_list>(<parameter><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>subqueryNode</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>subqueryHasNonDistributableAggregates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>CoordinatorAggregationStrategy</name> <operator>!=</operator> <name>COORDINATOR_AGGREGATION_DISABLED</name> <operator>&amp;&amp;</operator>
		<call><name>HasNonDistributableAggregates</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>subqueryNode</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>subqueryHasNonDistributableAggregates</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOpNode</name> <init>=
		<expr><operator>(</operator><name>MultiExtendedOp</name> <operator>*</operator><operator>)</operator> <call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>subqueryNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>collectNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>extendedOpNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>collectChildNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ExtendedOpNodeProperties</name></type> <name>extendedOpNodeProperties</name> <init>=
		<expr><call><name>BuildExtendedOpNodeProperties</name><argument_list>(<argument><expr><name>extendedOpNode</name></expr></argument>,
									  <argument><expr><name>subqueryHasNonDistributableAggregates</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>masterExtendedOpNode</name> <init>=
		<expr><call><name>MasterExtendedOpNode</name><argument_list>(<argument><expr><name>extendedOpNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extendedOpNodeProperties</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>workerExtendedOpNode</name> <init>=
		<expr><call><name>WorkerExtendedOpNode</name><argument_list>(<argument><expr><name>extendedOpNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extendedOpNodeProperties</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name> <init>= <expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>groupClauseList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupTargetEntryList</name> <init>= <expr><call><name>GroupTargetEntryList</name><argument_list>(<argument><expr><name>groupClauseList</name></expr></argument>, <argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>groupByTargetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>groupTargetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>groupByExpression</name> <init>= <expr><name><name>groupByTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiPartition</name> <modifier>*</modifier></type><name>partitionNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If group by is on a function expression, then we create a new column from
	 * function expression result type. Because later while creating partition
	 * tasks, we expect a column type to partition intermediate results.
	 * Note that we will only need partition type. So we set column type to
	 * result type of the function expression, and set other fields of column to
	 * default values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>groupByExpression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>partitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>groupByExpression</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>groupByExpression</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>functionExpression</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>groupByExpression</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>tableId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>columnAttributeNumber</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>columnType</name> <init>= <expr><name><name>functionExpression</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>columnTypeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>columnCollationOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>columnLevelSup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>columnAttributeNumber</name></expr></argument>, <argument><expr><name>columnType</name></expr></argument>,
									   <argument><expr><name>columnTypeMod</name></expr></argument>, <argument><expr><name>columnCollationOid</name></expr></argument>, <argument><expr><name>columnLevelSup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>partitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>partitionColumn</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot run this subquery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Currently only columns and function expressions "</literal>
								  <literal type="string">"are allowed in group by expression of subqueries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>subqueryNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>masterExtendedOpNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>masterExtendedOpNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>workerExtendedOpNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>workerExtendedOpNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>collectChildNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MasterExtendedOpNode creates the master extended operator node from the given
 * target entries. The function walks over these target entries; and for entries
 * with aggregates in them, this function calls the aggregate expression mutator
 * function.
 *
 * Note that the function logically depends on the worker extended operator node
 * function. If the target entry does not contain aggregate functions, we assume
 * all work is done on the worker side, and create a column that references the
 * worker nodes' results.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiExtendedOp</name> <modifier>*</modifier></type>
<name>MasterExtendedOpNode</name><parameter_list>(<parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>originalOpNode</name></decl></parameter>,
					 <parameter><decl><type><name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type><name>extendedOpNodeProperties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newTargetEntryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newGroupClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalHavingQual</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>havingQual</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>newHavingQual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MasterAggregateWalkerContext</name></type> <name>walkerContext</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>extendedOpNodeProperties</name> <operator>=</operator> <name>extendedOpNodeProperties</name></expr>,
		<expr><operator>.</operator><name>columnId</name> <operator>=</operator> <literal type="number">1</literal></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate over original target entries */</comment>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>originalTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>originalTargetEntry</argument>, <argument>targetEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newTargetEntry</name> <init>= <expr><call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>originalTargetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>originalExpression</name> <init>= <expr><name><name>originalTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>newExpression</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CanPushDownExpression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalExpression</name></expr></argument>, <argument><expr><name>extendedOpNodeProperties</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The expression was entirely pushed down to worker.
			 * We simply make it reference the output generated by worker nodes.
			 */</comment>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name>originalTargetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>walkerContext</name><operator>.</operator><name>columnId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <name><name>walkerContext</name><operator>.</operator><name>columnId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walkerContext</name><operator>.</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator> <name><name>column</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDARRAYOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>=</operator> <call><name>BlessRecordExpression</name><argument_list>(<argument><expr><name><name>originalTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>newExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>column</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>newNode</name> <init>= <expr><call><name>MasterAggregateMutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalExpression</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>walkerContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>newExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newNode</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>newExpression</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newTargetEntryList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newTargetEntryList</name></expr></argument>, <argument><expr><name>newTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>pushDownGroupingAndHaving</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Not pushing down GROUP BY, need to regroup on coordinator
		 * and apply having on the coordinator.
		 */</comment>
		<expr_stmt><expr><name>newGroupClauseList</name> <operator>=</operator> <name><name>originalOpNode</name><operator>-&gt;</operator><name>groupClauseList</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>originalHavingQual</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newHavingQual</name> <operator>=</operator> <call><name>MasterAggregateMutator</name><argument_list>(<argument><expr><name>originalHavingQual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>walkerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>newHavingQual</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * unflatten having qual to allow standard planner to work when transforming
				 * the master query to a plan
				 */</comment>
				<expr_stmt><expr><name>newHavingQual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_explicit</name><argument_list>(
					<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>newHavingQual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>masterExtendedOpNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiExtendedOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>newTargetEntryList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>groupClauseList</name></name> <operator>=</operator> <name>newGroupClauseList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>sortClauseList</name></name> <operator>=</operator> <name><name>originalOpNode</name><operator>-&gt;</operator><name>sortClauseList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name><name>originalOpNode</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name><name>originalOpNode</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name><name>originalOpNode</name><operator>-&gt;</operator><name>limitCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name><name>originalOpNode</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>limitOption</name></name> <operator>=</operator> <name><name>originalOpNode</name><operator>-&gt;</operator><name>limitOption</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <name>newHavingQual</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>onlyPushableWindowFunctions</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name><name>originalOpNode</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name><name>originalOpNode</name><operator>-&gt;</operator><name>windowClause</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>masterExtendedOpNode</name><operator>-&gt;</operator><name>onlyPushableWindowFunctions</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>masterExtendedOpNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MasterAggregateMutator walks over the original target entry expression, and
 * creates the new expression tree to execute on the master node. The function
 * transforms aggregates, and copies columns; and recurses into the expression
 * mutator function for all other expression types.
 *
 * Please note that the recursive mutator function traverses the expression tree
 * in depth first order. For this function to set attribute numbers correctly,
 * WorkerAggregateWalker() *must* walk over the expression tree in the same
 * depth first order.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>MasterAggregateMutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalNode</name></decl></parameter>, <parameter><decl><type><name>MasterAggregateWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>newNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>originalNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>originalNode</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>originalAggregate</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>originalNode</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>CanPushDownExpression</name><argument_list>(<argument><expr><name>originalNode</name></expr></argument>,
								  <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>extendedOpNodeProperties</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The expression was entirely pushed down to worker.
			 * We simply make it reference the output generated by worker nodes.
			 */</comment>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>,
								  <argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>,
								  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggcollid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>||</operator> <name><name>column</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>RECORDARRAYOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>=</operator> <call><name>BlessRecordExpression</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>originalNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>newNode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>column</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>newExpression</name> <init>= <expr><call><name>MasterAggregateExpression</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>,
															<argument><expr><name>walkerContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>newNode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newExpression</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>originalNode</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>newColumn</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>originalNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newColumn</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>masterTableId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>newNode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newColumn</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>newNode</name> <operator>=</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>originalNode</name></expr></argument>, <argument><expr><name>MasterAggregateMutator</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>walkerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>newNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MasterAggregateExpression creates the master aggregate expression using the
 * original aggregate and aggregate's type information. This function handles
 * the average, count, array_agg, hll and topn aggregates separately due to
 * differences in these aggregate functions' transformations.
 *
 * Note that this function has implicit knowledge of the transformations applied
 * for worker nodes on the original aggregate. The function uses this implicit
 * knowledge to create the appropriate master function with correct data types.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>MasterAggregateExpression</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>originalAggregate</name></decl></parameter>,
						  <parameter><decl><type><name>MasterAggregateWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Index</name></type> <name>columnLevelsUp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* normal column */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>AttrNumber</name></type> <name>argumentId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* our aggregates have single arguments */</comment>
	<decl_stmt><decl><type><name>AggregateType</name></type> <name>aggregateType</name> <init>= <expr><call><name>GetAggregateType</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>newMasterExpression</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>walkerContext</name><operator>-&gt;</operator><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>pullUpIntermediateRows</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregate</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>aggregate-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
								<call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>,
										<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>aggregate</name><operator>-&gt;</operator><name>aggdirectargs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>directarg</name></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>directarg</argument>, <argument>originalAggregate-&gt;aggdirectargs</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * Need to replace nodes that contain any Vars with Vars referring
			 * to the related column of the result set returned for the worker
			 * aggregation.
			 *
			 * When there are no Vars, then the expression can be fully evaluated
			 * on the coordinator, so we skip it here. This is not just an
			 * optimization, but the result of the expression might require
			 * calling the final function of the aggregate, and doing so when
			 * there are no input rows (i.e.: with an empty tuple slot) is not
			 * desirable for the node-executor methods.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>directarg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>,
								   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>directarg</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>directarg</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>directarg</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>aggregate</name><operator>-&gt;</operator><name>aggdirectargs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>aggregate</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>aggregate</name><operator>-&gt;</operator><name>aggdirectargs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>aggregate</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>, <argument><expr><name>directarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name><name>aggregate</name><operator>-&gt;</operator><name>aggfilter</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>aggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
								   <call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>,
										   <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>aggregate</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_COUNT</name> <operator>&amp;&amp;</operator> <name><name>originalAggregate</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>&amp;&amp;</operator>
			 <name>CountDistinctErrorRate</name> <operator>==</operator> <name>DISABLE_DISTINCT_APPROXIMATION</name> <operator>&amp;&amp;</operator>
			 <name><name>walkerContext</name><operator>-&gt;</operator><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>pullDistinctColumns</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregate</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>varList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>aggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>uniqueVarList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>startColumnCount</name> <init>= <expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* determine unique vars that were placed in target list by worker */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>column</argument>, <argument>varList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>uniqueVarList</name> <operator>=</operator> <call><name>list_append_unique</name><argument_list>(<argument><expr><name>uniqueVarList</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Go over each var inside aggregate and update their varattno's according to
		 * worker query target entry column index.
		 */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>columnToUpdate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>columnToUpdate</argument>, <argument>varList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>currentVar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>currentVar</argument>, <argument>uniqueVarList</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>columnToUpdate</name></expr></argument>, <argument><expr><name>currentVar</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>columnIndex</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name><name>columnToUpdate</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>masterTableId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>columnToUpdate</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <name>masterTableId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>columnToUpdate</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>startColumnCount</name> <operator>+</operator> <name>columnIndex</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>columnToUpdate</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <name>startColumnCount</name> <operator>+</operator> <name>columnIndex</name></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* we added that many columns */</comment>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name> <operator>+=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>uniqueVarList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>aggregate</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_COUNT</name> <operator>&amp;&amp;</operator> <name><name>originalAggregate</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>&amp;&amp;</operator>
			 <name>CountDistinctErrorRate</name> <operator>!=</operator> <name>DISABLE_DISTINCT_APPROXIMATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If enabled, we check for count(distinct) approximations before count
		 * distincts. For this, we first compute hll_add_agg(hll_hash(column)) on
		 * worker nodes, and get hll values. We then gather hlls on the master
		 * node, and compute hll_cardinality(hll_union_agg(hll)).
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>argCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>defaultTypeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


		<comment type="block">/* extract schema name of hll */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hllId</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name>HLL_EXTENSION_NAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hllSchemaOid</name> <init>= <expr><call><name>get_extension_schema</name><argument_list>(<argument><expr><name>hllId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hllSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>hllSchemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>unionFunctionId</name> <init>= <expr><call><name>FunctionOid</name><argument_list>(<argument><expr><name>hllSchemaName</name></expr></argument>, <argument><expr><name>HLL_UNION_AGGREGATE_NAME</name></expr></argument>,
										  <argument><expr><name>argCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>cardinalityFunctionId</name> <init>= <expr><call><name>FunctionOid</name><argument_list>(<argument><expr><name>hllSchemaName</name></expr></argument>, <argument><expr><name>HLL_CARDINALITY_FUNC_NAME</name></expr></argument>,
												<argument><expr><name>argCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>cardinalityReturnType</name> <init>= <expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>cardinalityFunctionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>hllType</name> <init>= <expr><call><name>TypeOid</name><argument_list>(<argument><expr><name>hllSchemaOid</name></expr></argument>, <argument><expr><name>HLL_TYPE_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hllTypeCollationId</name> <init>= <expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>hllType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>hllColumn</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>, <argument><expr><name>hllType</name></expr></argument>,
								 <argument><expr><name>defaultTypeMod</name></expr></argument>,
								 <argument><expr><name>hllTypeCollationId</name></expr></argument>, <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>hllTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>hllColumn</name></expr></argument>, <argument><expr><name>argumentId</name></expr></argument>,
													  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>unionAggregate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>unionFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>hllType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>hllTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>cardinalityExpression</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>cardinalityExpression</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>cardinalityFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cardinalityExpression</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name>cardinalityReturnType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cardinalityExpression</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>unionAggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>cardinalityExpression</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_AVERAGE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the original aggregate is an average, we first compute sum(colum)
		 * and count(column) on worker nodes. Then, we compute (sum(sum(column))
		 * / sum(count(column))) on the master node.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sumAggregateName</name> <init>= <expr><name><name>AggregateNames</name><index>[<expr><name>AGGREGATE_SUM</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>countAggregateName</name> <init>= <expr><name><name>AggregateNames</name><index>[<expr><name>AGGREGATE_COUNT</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>argumentType</name> <init>= <expr><call><name>AggregateArgumentType</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>sumFunctionId</name> <init>= <expr><call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>sumAggregateName</name></expr></argument>, <argument><expr><name>argumentType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>countFunctionId</name> <init>= <expr><call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>countAggregateName</name></expr></argument>, <argument><expr><name>ANYOID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* calculate the aggregate types that worker nodes are going to return */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>workerSumReturnType</name> <init>= <expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>sumFunctionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>workerCountReturnType</name> <init>= <expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>countFunctionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* create the expression sum(sum(column) / sum(count(column))) */</comment>
		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <call><name>MasterAverageExpression</name><argument_list>(<argument><expr><name>workerSumReturnType</name></expr></argument>,
													  <argument><expr><name>workerCountReturnType</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_COUNT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Count aggregates are handled in two steps. First, worker nodes report
		 * their count results. Then, the master node sums up these results.
		 */</comment>

		<comment type="block">/* worker aggregate and original aggregate have the same return type */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>workerReturnType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>workerReturnTypeMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>workerCollationId</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sumAggregateName</name> <init>= <expr><name><name>AggregateNames</name><index>[<expr><name>AGGREGATE_SUM</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sumFunctionId</name> <init>= <expr><call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>sumAggregateName</name></expr></argument>, <argument><expr><name>workerReturnType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>masterReturnType</name> <init>= <expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>sumFunctionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newMasterAggregate</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggstar</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>sumFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>masterReturnType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>, <argument><expr><name>workerReturnType</name></expr></argument>,
							  <argument><expr><name>workerReturnTypeMod</name></expr></argument>, <argument><expr><name>workerCollationId</name></expr></argument>, <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* aggref expects its arguments to be wrapped in target entries */</comment>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>columnTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>column</name></expr></argument>, <argument><expr><name>argumentId</name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>columnTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* cast numeric sum result to bigint (count's return type) */</comment>
		<decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>coerceExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newMasterAggregate</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>resulttype</name></name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>resultcollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coerceExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* convert NULL to 0 in case of no rows */</comment>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>zeroConst</name> <init>= <expr><call><name>MakeIntegerConstInt64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>coalesceArgs</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><name>coerceExpr</name></expr></argument>, <argument><expr><name>zeroConst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesceExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>coalesceExpr</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesceExpr</name><operator>-&gt;</operator><name>coalescecollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesceExpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>coalesceArgs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>coalesceExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>coalesceExpr</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_ARRAY_AGG</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_JSONB_AGG</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_JSONB_OBJECT_AGG</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_JSON_AGG</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_JSON_OBJECT_AGG</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Array and json aggregates are handled in two steps. First, we compute
		 * array_agg() or json aggregate on the worker nodes. Then, we gather
		 * the arrays or jsons on the master and compute the array_cat_agg()
		 * or jsonb_cat_agg() aggregate on them to get the final array or json.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>catAggregateName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>catInputType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* worker aggregate and original aggregate have same return type */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>workerReturnType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>workerReturnTypeMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>workerCollationId</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* assert that we do not support array or json aggregation with
		 * distinct or order by */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_ARRAY_AGG</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* array_cat_agg() takes anyarray as input */</comment>
			<expr_stmt><expr><name>catAggregateName</name> <operator>=</operator> <name>ARRAY_CAT_AGGREGATE_NAME</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
			<expr_stmt><expr><name>catInputType</name> <operator>=</operator> <name>ANYCOMPATIBLEARRAYOID</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>catInputType</name> <operator>=</operator> <name>ANYARRAYOID</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_JSONB_AGG</name> <operator>||</operator>
				 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_JSONB_OBJECT_AGG</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* jsonb_cat_agg() takes jsonb as input */</comment>
			<expr_stmt><expr><name>catAggregateName</name> <operator>=</operator> <name>JSONB_CAT_AGGREGATE_NAME</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>catInputType</name> <operator>=</operator> <name>JSONBOID</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* json_cat_agg() takes json as input */</comment>
			<expr_stmt><expr><name>catAggregateName</name> <operator>=</operator> <name>JSON_CAT_AGGREGATE_NAME</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>catInputType</name> <operator>=</operator> <name>JSONOID</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>catAggregateName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>catInputType</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>aggregateFunctionId</name> <init>= <expr><call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>catAggregateName</name></expr></argument>,
													   <argument><expr><name>catInputType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* create argument for the array_cat_agg() or jsonb_cat_agg() aggregate */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>, <argument><expr><name>workerReturnType</name></expr></argument>,
							  <argument><expr><name>workerReturnTypeMod</name></expr></argument>, <argument><expr><name>workerCollationId</name></expr></argument>, <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>catAggArgument</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>column</name></expr></argument>, <argument><expr><name>argumentId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* construct the master array_cat_agg() or jsonb_cat_agg() expression */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newMasterAggregate</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>aggregateFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>catAggArgument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_ARRAY_AGG</name></expr>)</condition>
		<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>

			<comment type="block">/*
			 * Postgres expects the type of the array here such as INT4ARRAYOID.
			 * Hence we set it to workerReturnType. If we set this to
			 * ANYCOMPATIBLEARRAYOID then we will get the following error:
			 * "argument declared anycompatiblearray is not an array but type anycompatiblearray"
			 */</comment>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>workerReturnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>ANYARRAYOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>ANYARRAYOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newMasterAggregate</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_HLL_ADD</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_HLL_UNION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If hll aggregates are called, we simply create the hll_union_aggregate
		 * to apply in the master after running the original aggregate in
		 * workers.
		 */</comment>

		<decl_stmt><decl><type><name>Oid</name></type> <name>hllType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>unionFunctionId</name> <init>= <expr><call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>HLL_UNION_AGGREGATE_NAME</name></expr></argument>, <argument><expr><name>hllType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>hllReturnTypeMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hllTypeCollationId</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>hllColumn</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>, <argument><expr><name>hllType</name></expr></argument>,
								 <argument><expr><name>hllReturnTypeMod</name></expr></argument>, <argument><expr><name>hllTypeCollationId</name></expr></argument>, <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>hllTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>hllColumn</name></expr></argument>, <argument><expr><name>argumentId</name></expr></argument>,
													  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>unionAggregate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>unionFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>hllType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>hllTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>hllType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>unionAggregate</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TOPN_UNION_AGG</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TOPN_ADD_AGG</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Top-N aggregates are handled in two steps. First, we compute
		 * topn_add_agg() or topn_union_agg() aggregates on the worker nodes.
		 * Then, we gather the Top-Ns on the master and take the union of all
		 * to get the final topn.
		 */</comment>

		<comment type="block">/* worker aggregate and original aggregate have same return type */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>topnType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>unionFunctionId</name> <init>= <expr><call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>TOPN_UNION_AGGREGATE_NAME</name></expr></argument>,
												   <argument><expr><name>topnType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>topnReturnTypeMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>topnTypeCollationId</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* create argument for the topn_union_agg() aggregate */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>topnColumn</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>, <argument><expr><name>topnType</name></expr></argument>,
								  <argument><expr><name>topnReturnTypeMod</name></expr></argument>, <argument><expr><name>topnTypeCollationId</name></expr></argument>, <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>topNTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>topnColumn</name></expr></argument>, <argument><expr><name>argumentId</name></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* construct the master topn_union_agg() expression */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>unionAggregate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>unionFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>topnType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>topNTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>topnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>unionAggregate</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_COMBINE</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_ADD_DOUBLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* tdigest of column */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>tdigestType</name> <init>= <expr><call><name>TDigestExtensionTypeOid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* tdigest type */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>unionFunctionId</name> <init>= <expr><call><name>TDigestExtensionAggTDigest1</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int32</name></type> <name>tdigestReturnTypeMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>tdigestTypeCollationId</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* create first argument for tdigest_precentile(tdigest, double) */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>tdigestColumn</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>, <argument><expr><name>tdigestType</name></expr></argument>,
									 <argument><expr><name>tdigestReturnTypeMod</name></expr></argument>, <argument><expr><name>tdigestTypeCollationId</name></expr></argument>,
									 <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tdigestTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>tdigestColumn</name></expr></argument>,
														  <argument><expr><name>argumentId</name></expr></argument>,
														  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* construct the master tdigest(tdigest) expression */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>unionAggregate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>unionFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name><name>originalAggregate</name><operator>-&gt;</operator><name>aggtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>tdigestTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>tdigestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>unionAggregate</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_ADD_DOUBLE</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_ADD_DOUBLEARRAY</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_OF_ADD_DOUBLE</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_OF_ADD_DOUBLEARRAY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* tdigest of column */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>tdigestType</name> <init>= <expr><call><name>TDigestExtensionTypeOid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>unionFunctionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_ADD_DOUBLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>unionFunctionId</name> <operator>=</operator> <call><name>TDigestExtensionAggTDigestPercentile2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_ADD_DOUBLEARRAY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>unionFunctionId</name> <operator>=</operator> <call><name>TDigestExtensionAggTDigestPercentile2a</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_OF_ADD_DOUBLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>unionFunctionId</name> <operator>=</operator> <call><name>TDigestExtensionAggTDigestPercentileOf2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_OF_ADD_DOUBLEARRAY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>unionFunctionId</name> <operator>=</operator> <call><name>TDigestExtensionAggTDigestPercentileOf2a</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>unionFunctionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int32</name></type> <name>tdigestReturnTypeMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>tdigestTypeCollationId</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* create first argument for tdigest_precentile(tdigest, double) */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>tdigestColumn</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>, <argument><expr><name>tdigestType</name></expr></argument>,
									 <argument><expr><name>tdigestReturnTypeMod</name></expr></argument>, <argument><expr><name>tdigestTypeCollationId</name></expr></argument>,
									 <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tdigestTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>tdigestColumn</name></expr></argument>,
														  <argument><expr><name>argumentId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* construct the master tdigest_precentile(tdigest, double) expression */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>unionAggregate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>unionFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name><name>originalAggregate</name><operator>-&gt;</operator><name>aggtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(
			<argument><expr><name>tdigestTargetEntry</name></expr></argument>,
			<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make2_oid</name><argument_list>(
			<argument><expr><name>tdigestType</name></expr></argument>,
			<argument><expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>unionAggregate</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_TDIGEST_DOUBLE</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_TDIGEST_DOUBLEARRAY</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_OF_TDIGEST_DOUBLE</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_OF_TDIGEST_DOUBLEARRAY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* tdigest of column */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>tdigestType</name> <init>= <expr><call><name>TDigestExtensionTypeOid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* These functions already will combine the tdigest arguments returned */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>unionFunctionId</name> <init>= <expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int32</name></type> <name>tdigestReturnTypeMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>tdigestTypeCollationId</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* create first argument for tdigest_precentile(tdigest, double) */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>tdigestColumn</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>, <argument><expr><name>tdigestType</name></expr></argument>,
									 <argument><expr><name>tdigestReturnTypeMod</name></expr></argument>, <argument><expr><name>tdigestTypeCollationId</name></expr></argument>,
									 <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tdigestTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>tdigestColumn</name></expr></argument>,
														  <argument><expr><name>argumentId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* construct the master tdigest_precentile(tdigest, double) expression */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>unionAggregate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>unionFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name><name>originalAggregate</name><operator>-&gt;</operator><name>aggtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(
			<argument><expr><name>tdigestTargetEntry</name></expr></argument>,
			<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make2_oid</name><argument_list>(
			<argument><expr><name>tdigestType</name></expr></argument>,
			<argument><expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unionAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>unionAggregate</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_CUSTOM_COMBINE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>aggTuple</name> <init>=
			<expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>combine</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"citus cache lookup failed for aggregate %u"</literal></expr></argument>,
				 <argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>aggform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>combine</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>combine</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>coordCombineId</name> <init>= <expr><call><name>CoordCombineAggOid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>workerReturnType</name> <init>= <expr><name>CSTRINGOID</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type> <name>workerReturnTypeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>workerCollationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>resultType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>aggOidParam</name> <init>= <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>,
								  <argument><expr><name>workerReturnType</name></expr></argument>,
								  <argument><expr><name>workerReturnTypeMod</name></expr></argument>, <argument><expr><name>workerCollationId</name></expr></argument>, <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>nullTag</name> <init>= <expr><call><name>makeNullConst</name><argument_list>(<argument><expr><name>resultType</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>aggArguments</name> <init>=
				<expr><call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>aggOidParam</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>column</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>nullTag</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* coord_combine_agg(agg, workercol) */</comment>
			<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newMasterAggregate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>coordCombineId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name><name>originalAggregate</name><operator>-&gt;</operator><name>aggtype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>aggArguments</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make3_oid</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><name>CSTRINGOID</name></expr></argument>,
															 <argument><expr><name>resultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newMasterAggregate</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Aggregate lacks COMBINEFUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * All other aggregates are handled as they are. These include sum, min,
		 * and max.
		 */</comment>

		<comment type="block">/* worker aggregate and original aggregate have the same return type */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>workerReturnType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>workerReturnTypeMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>workerCollationId</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggregateName</name> <init>= <expr><name><name>AggregateNames</name><index>[<expr><name>aggregateType</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>aggregateFunctionId</name> <init>= <expr><call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>aggregateName</name></expr></argument>, <argument><expr><name>workerReturnType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>masterReturnType</name> <init>= <expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>aggregateFunctionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newMasterAggregate</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>aggregateFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>masterReturnType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If return type aggregate is anyelement, its actual return type is
		 * determined on the type of its argument. So we replace it with the
		 * argument type in that case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>masterReturnType</name> <operator>==</operator> <name>ANYELEMENTOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>workerReturnType</name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>firstArg</name> <init>= <expr><call><name>FirstAggregateArgument</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>aggcollid</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>firstArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name></expr></argument>, <argument><expr><name>workerReturnType</name></expr></argument>,
							  <argument><expr><name>workerReturnTypeMod</name></expr></argument>, <argument><expr><name>workerCollationId</name></expr></argument>, <argument><expr><name>columnLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>columnId</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* aggref expects its arguments to be wrapped in target entries */</comment>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>columnTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>column</name></expr></argument>, <argument><expr><name>argumentId</name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newMasterAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>columnTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newMasterAggregate</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>


	<comment type="block">/*
	 * Aggregate functions could have changed the return type. If so, we wrap
	 * the new expression with a conversion function to make it have the same
	 * type as the original aggregate. We need this since functions like sorting
	 * and grouping have already been chosen based on the original type.
	 */</comment>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>typeConvertedExpression</name> <init>= <expr><call><name>AddTypeConversion</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalAggregate</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newMasterExpression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>typeConvertedExpression</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newMasterExpression</name> <operator>=</operator> <name>typeConvertedExpression</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>newMasterExpression</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MasterAverageExpression creates an expression of the form (sum(column1) /
 * sum(column2)), where column1 is the sum of the original value, and column2 is
 * the count of that value. This expression allows us to evaluate the average
 * function over distributed data.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>MasterAverageExpression</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sumAggregateType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>countAggregateType</name></decl></parameter>,
						<parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>columnId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sumAggregateName</name> <init>= <expr><name><name>AggregateNames</name><index>[<expr><name>AGGREGATE_SUM</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int32</name></type> <name>defaultTypeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Index</name></type> <name>defaultLevelsUp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>AttrNumber</name></type> <name>argumentId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>sumTypeCollationId</name> <init>= <expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>sumAggregateType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>countTypeCollationId</name> <init>= <expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>countAggregateType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create the first argument for sum(column1) */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>firstColumn</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>columnId</name><operator>)</operator></expr></argument>, <argument><expr><name>sumAggregateType</name></expr></argument>,
							   <argument><expr><name>defaultTypeMod</name></expr></argument>, <argument><expr><name>sumTypeCollationId</name></expr></argument>, <argument><expr><name>defaultLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>firstTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>firstColumn</name></expr></argument>, <argument><expr><name>argumentId</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>(</operator><operator>*</operator><name>columnId</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>firstSum</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>firstSum</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>sumAggregateName</name></expr></argument>, <argument><expr><name>sumAggregateType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>firstSum</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name><name>firstSum</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>firstSum</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>firstTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>firstSum</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>firstSum</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>firstSum</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>firstSum</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>firstSum</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

	<comment type="block">/* create the second argument for sum(column2) */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>secondColumn</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>masterTableId</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>columnId</name><operator>)</operator></expr></argument>, <argument><expr><name>countAggregateType</name></expr></argument>,
								<argument><expr><name>defaultTypeMod</name></expr></argument>, <argument><expr><name>countTypeCollationId</name></expr></argument>, <argument><expr><name>defaultLevelsUp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>secondTargetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>secondColumn</name></expr></argument>, <argument><expr><name>argumentId</name></expr></argument>,
													 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>(</operator><operator>*</operator><name>columnId</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>secondSum</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>secondSum</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>sumAggregateName</name></expr></argument>, <argument><expr><name>countAggregateType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>secondSum</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name><name>secondSum</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>secondSum</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>secondTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>secondSum</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>secondSum</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>secondSum</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>firstSum</name><operator>-&gt;</operator><name>aggtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>secondSum</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the division operator between these two aggregates. This function
	 * will convert the types of the aggregates if necessary.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>operatorNameList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>DIVISION_OPER_NAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>opExpr</name> <init>= <expr><call><name>make_op</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>operatorNameList</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>firstSum</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>secondSum</name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>opExpr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddTypeConversion checks if the given expressions generate the same types. If
 * they don't, the function adds a type conversion function on top of the new
 * expression to have it generate the same type as the original aggregate.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>AddTypeConversion</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalAggregate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>newExpression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>newTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>newExpression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>originalTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>originalTypeMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* nothing to do if the two types are the same */</comment>
	<if_stmt><if>if <condition>(<expr><name>originalTypeId</name> <operator>==</operator> <name>newTypeId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* otherwise, add a type conversion function */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>typeConvertedExpression</name> <init>= <expr><call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newExpression</name></expr></argument>, <argument><expr><name>newTypeId</name></expr></argument>,
														  <argument><expr><name>originalTypeId</name></expr></argument>, <argument><expr><name>originalTypeMod</name></expr></argument>,
														  <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>,
														  <argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typeConvertedExpression</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>typeConvertedExpression</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerExtendedOpNode creates the worker extended operator node from the given
 * originalOpNode and extendedOpNodeProperties.
 *
 * For the details of the processing see the comments of the functions that
 * are called from this function.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiExtendedOp</name> <modifier>*</modifier></type>
<name>WorkerExtendedOpNode</name><parameter_list>(<parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>originalOpNode</name></decl></parameter>,
					 <parameter><decl><type><name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type><name>extendedOpNodeProperties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>distinctPreventsLimitPushdown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>QueryTargetList</name></type> <name>queryTargetList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryGroupClause</name></type> <name>queryGroupClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDistinctClause</name></type> <name>queryDistinctClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryWindowClause</name></type> <name>queryWindowClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryOrderByLimit</name></type> <name>queryOrderByLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>queryHavingQual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>originalTargetEntryList</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>originalGroupClauseList</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>groupClauseList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>originalSortClauseList</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>sortClauseList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalHavingQual</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>havingQual</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalLimitCount</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>limitCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalLimitOffset</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>originalWindowClause</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>windowClause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>originalDistinctClause</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasDistinctOn</name> <init>= <expr><name><name>originalOpNode</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>originalGroupClauseLength</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>originalGroupClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* initialize to default values */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queryTargetList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>queryTargetList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queryGroupClause</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>queryGroupClause</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queryDistinctClause</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>queryDistinctClause</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queryWindowClause</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>queryWindowClause</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>queryOrderByLimit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>queryOrderByLimit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* calculate the next sort group index based on the original target list */</comment>
	<decl_stmt><decl><type><name>Index</name></type> <name>nextSortGroupRefIndex</name> <init>= <expr><call><name>GetNextSortGroupRef</name><argument_list>(<argument><expr><name>originalTargetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* targetProjectionNumber starts from 1 */</comment>
	<expr_stmt><expr><name><name>queryTargetList</name><operator>.</operator><name>targetProjectionNumber</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>pullUpIntermediateRows</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryGroupClause</name><operator>.</operator><name>groupClauseList</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>originalGroupClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryGroupClause</name><operator>.</operator><name>groupClauseList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * For the purpose of this variable, not pushing down when there are no groups
	 * is pushing down the original grouping, ie the worker's GROUP BY matches
	 * the master's GROUP BY.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>pushingDownOriginalGrouping</name> <init>=
		<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>queryGroupClause</name><operator>.</operator><name>groupClauseList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>originalGroupClauseLength</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * nextSortGroupRefIndex is used by group by, window and order by clauses.
	 * Thus, we pass a reference to a single nextSortGroupRefIndex and expect
	 * it modified separately while processing those parts of the query.
	 */</comment>
	<expr_stmt><expr><name><name>queryGroupClause</name><operator>.</operator><name>nextSortGroupRefIndex</name></name> <operator>=</operator> <operator>&amp;</operator><name>nextSortGroupRefIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryWindowClause</name><operator>.</operator><name>nextSortGroupRefIndex</name></name> <operator>=</operator> <operator>&amp;</operator><name>nextSortGroupRefIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryOrderByLimit</name><operator>.</operator><name>nextSortGroupRefIndex</name></name> <operator>=</operator> <operator>&amp;</operator><name>nextSortGroupRefIndex</name></expr>;</expr_stmt>

	<comment type="block">/* process each part of the query in order to generate the worker query's parts */</comment>
	<expr_stmt><expr><call><name>ProcessTargetListForWorkerQuery</name><argument_list>(<argument><expr><name>originalTargetEntryList</name></expr></argument>, <argument><expr><name>extendedOpNodeProperties</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>queryTargetList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ProcessHavingClauseForWorkerQuery</name><argument_list>(<argument><expr><name>originalHavingQual</name></expr></argument>, <argument><expr><name>extendedOpNodeProperties</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>queryHavingQual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryTargetList</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>queryGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Planner optimizations may leave window clauses with hasWindowFuncs as false.
	 * Ignore window clauses in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>onlyPushableWindowFunctions</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ProcessWindowFunctionsForWorkerQuery</name><argument_list>(<argument><expr><name>originalWindowClause</name></expr></argument>,
												 <argument><expr><name>originalTargetEntryList</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>queryWindowClause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ProcessWindowFunctionPullUpForWorkerQuery</name><argument_list>(<argument><expr><name>originalWindowClause</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>queryTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ShouldProcessDistinctOrderAndLimitForWorker</name><argument_list>(<argument><expr><name>extendedOpNodeProperties</name></expr></argument>,
													<argument><expr><name>pushingDownOriginalGrouping</name></expr></argument>,
													<argument><expr><name>originalHavingQual</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>queryHasAggregates</name> <init>= <expr><call><name>TargetListHasAggregates</name><argument_list>(<argument><expr><name>originalTargetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ProcessDistinctClauseForWorkerQuery</name><argument_list>(<argument><expr><name>originalDistinctClause</name></expr></argument>, <argument><expr><name>hasDistinctOn</name></expr></argument>,
											<argument><expr><name><name>queryGroupClause</name><operator>.</operator><name>groupClauseList</name></name></expr></argument>,
											<argument><expr><name>queryHasAggregates</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryDistinctClause</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>distinctPreventsLimitPushdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Order by and limit clauses are relevant to each other, and processing
		 * them together makes it handy for us.
		 *
		 * The other parts of the query might have already prohibited pushing down
		 * LIMIT and ORDER BY clauses as described below:
		 *      (1) Creating a new group by clause during aggregate mutation, or
		 *      (2) Distinct clause is not pushed down
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>groupByExtended</name> <init>=
			<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>queryGroupClause</name><operator>.</operator><name>groupClauseList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>originalGroupClauseLength</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>pushingDownOriginalGrouping</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>groupByExtended</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>distinctPreventsLimitPushdown</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* both sort and limit clauses rely on similar information */</comment>
			<decl_stmt><decl><type><name>OrderByLimitReference</name></type> <name>limitOrderByReference</name> <init>=
				<expr><call><name>BuildOrderByLimitReference</name><argument_list>(<argument><expr><name>hasDistinctOn</name></expr></argument>,
										   <argument><expr><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator>
										   <name>groupedByDisjointPartitionColumn</name></name></expr></argument>,
										   <argument><expr><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator>
										   <name>onlyPushableWindowFunctions</name></name></expr></argument>,
										   <argument><expr><name>originalGroupClauseList</name></expr></argument>,
										   <argument><expr><name>originalSortClauseList</name></expr></argument>,
										   <argument><expr><name>originalTargetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ProcessLimitOrderByForWorkerQuery</name><argument_list>(<argument><expr><name>limitOrderByReference</name></expr></argument>, <argument><expr><name>originalLimitCount</name></expr></argument>,
											  <argument><expr><name>originalLimitOffset</name></expr></argument>,
											  <argument><expr><name>originalSortClauseList</name></expr></argument>,
											  <argument><expr><name>originalGroupClauseList</name></expr></argument>,
											  <argument><expr><name>originalTargetEntryList</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>queryOrderByLimit</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>queryTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finally, fill the extended op node with the data we gathered */</comment>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>workerExtendedOpNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiExtendedOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name><name>queryTargetList</name><operator>.</operator><name>targetEntryList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>groupClauseList</name></name> <operator>=</operator> <name><name>queryGroupClause</name><operator>.</operator><name>groupClauseList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <name>queryHavingQual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name><name>queryDistinctClause</name><operator>.</operator><name>workerHasDistinctOn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name><name>queryDistinctClause</name><operator>.</operator><name>workerDistinctClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name><name>queryWindowClause</name><operator>.</operator><name>hasWindowFunctions</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name><name>queryWindowClause</name><operator>.</operator><name>workerWindowClauseList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>sortClauseList</name></name> <operator>=</operator> <name><name>queryOrderByLimit</name><operator>.</operator><name>workerSortClauseList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name><name>queryOrderByLimit</name><operator>.</operator><name>workerLimitCount</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the limitCount cannot be pushed down it will be NULL, so the deparser will
	 * ignore the limitOption.
	 */</comment>
	<expr_stmt><expr><name><name>workerExtendedOpNode</name><operator>-&gt;</operator><name>limitOption</name></name> <operator>=</operator> <name><name>originalOpNode</name><operator>-&gt;</operator><name>limitOption</name></name></expr>;</expr_stmt>

	<return>return <expr><name>workerExtendedOpNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessTargetListForWorkerQuery gets the inputs and modifies the outputs
 * such that the worker query's target list and group by clauses are extended
 * for the given inputs.
 *
 * The function walks over the input targetEntryList. For the entries
 * with aggregates in them, it calls the recursive aggregate walker function to
 * create aggregates for the worker nodes. For example, the avg() is sent to
 * the worker with two expressions count() and sum(). Thus, a single target entry
 * might end up with multiple expressions in the worker query.
 *
 * The function doesn't change the aggregates in the window functions and sends them
 * as-is. The reason is that Citus only supports pushing down window functions when
 * this is safe to do.
 *
 * The function also handles count distinct operator if it is used in repartition
 * subqueries or on non-partition columns (e.g., cannot be pushed down). Each
 * column in count distinct aggregate is added to target list, and group by
 * list of worker extended operator. This approach guarantees the distinctness
 * in the worker queries.
 *
 *     inputs: targetEntryList, extendedOpNodeProperties
 *     outputs: queryTargetList, queryGroupClause
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessTargetListForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>,
								<parameter><decl><type><name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type><name>extendedOpNodeProperties</name></decl></parameter>,
								<parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>,
								<parameter><decl><type><name>QueryGroupClause</name> <modifier>*</modifier></type><name>queryGroupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkerAggregateWalkerContext</name></type> <name>workerAggContext</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>extendedOpNodeProperties</name> <operator>=</operator> <name>extendedOpNodeProperties</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate over original target entries */</comment>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>originalTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>originalTargetEntry</argument>, <argument>targetEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>originalExpression</name> <init>= <expr><name><name>originalTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newExpressionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* reset walker context */</comment>
		<expr_stmt><expr><name><name>workerAggContext</name><operator>.</operator><name>expressionList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workerAggContext</name><operator>.</operator><name>createGroupByClause</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we can push down the expression we copy the expression to the targetlist of the worker query.
		 * Otherwise the expression is processed to be combined on the coordinator.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CanPushDownExpression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalExpression</name></expr></argument>, <argument><expr><name>extendedOpNodeProperties</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newExpressionList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>originalExpression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>WorkerAggregateWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalExpression</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workerAggContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newExpressionList</name> <operator>=</operator> <name><name>workerAggContext</name><operator>.</operator><name>expressionList</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ExpandWorkerTargetEntry</name><argument_list>(<argument><expr><name>newExpressionList</name></expr></argument>, <argument><expr><name>originalTargetEntry</name></expr></argument>,
								<argument><expr><name><name>workerAggContext</name><operator>.</operator><name>createGroupByClause</name></name></expr></argument>,
								<argument><expr><name>queryTargetList</name></expr></argument>, <argument><expr><name>queryGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessHavingClauseForWorkerQuery gets the inputs and modifies the outputs
 * such that the worker query's target list and group by clauses are extended
 * based on the inputs.
 *
 * The rule is that Citus always applies the HAVING clause on the
 * coordinator. Thus, it pulls the necessary data from the workers. Also, when the
 * having clause is safe to pushdown to the workers, workerHavingQual is set to
 * be the original having clause.
 *
 *     inputs: originalHavingQual, extendedOpNodeProperties
 *     outputs: workerHavingQual, queryTargetList, queryGroupClause
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessHavingClauseForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalHavingQual</name></decl></parameter>,
								  <parameter><decl><type><name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type><name>extendedOpNodeProperties</name></decl></parameter>,
								  <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>workerHavingQual</name></decl></parameter>,
								  <parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>,
								  <parameter><decl><type><name>QueryGroupClause</name> <modifier>*</modifier></type><name>queryGroupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>workerHavingQual</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>originalHavingQual</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>pushDownGroupingAndHaving</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We converted the having expression to a list in subquery pushdown
		 * planner. However, this query cannot be parsed as it is in the worker.
		 * We should convert this back to being explicit for worker query
		 * so that it can be parsed when it hits the standard planner in worker.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>originalHavingQual</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>workerHavingQual</name> <operator>=</operator>
				<operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_explicit</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>originalHavingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>workerHavingQual</name> <operator>=</operator> <name>originalHavingQual</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If the GROUP BY or PARTITION BY is not on the distribution column
		 * then we need to combine the aggregates in the HAVING across shards.
		 */</comment>
		<decl_stmt><decl><type><name>WorkerAggregateWalkerContext</name></type> <name>workerAggContext</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>extendedOpNodeProperties</name> <operator>=</operator> <name>extendedOpNodeProperties</name></expr>,
		}</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>WorkerAggregateWalker</name><argument_list>(<argument><expr><name>originalHavingQual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>workerAggContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newExpressionList</name> <init>= <expr><name><name>workerAggContext</name><operator>.</operator><name>expressionList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExpandWorkerTargetEntry</name><argument_list>(<argument><expr><name>newExpressionList</name></expr></argument>, <argument><expr><name>targetEntry</name></expr></argument>,
								<argument><expr><name><name>workerAggContext</name><operator>.</operator><name>createGroupByClause</name></name></expr></argument>,
								<argument><expr><name>queryTargetList</name></expr></argument>, <argument><expr><name>queryGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessDistinctClauseForWorkerQuery gets the inputs and modifies the outputs
 * such that worker query's DISTINCT and DISTINCT ON clauses are set accordingly.
 * Note the function may or may not decide to pushdown the DISTINCT and DISTINCT
 * on clauses based on the inputs.
 *
 * See the detailed comments in the function for the rules of pushing down DISTINCT
 * and DISTINCT ON clauses to the worker queries.
 *
 * The function also sets distinctPreventsLimitPushdown. As the name reveals,
 * distinct could prevent pushing down LIMIT clauses later in the planning.
 * For the details, see the comments in the function.
 *
 *     inputs: distinctClause, hasDistinctOn, groupClauseList, queryHasAggregates
 *     outputs: queryDistinctClause, distinctPreventsLimitPushdown
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessDistinctClauseForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctClause</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hasDistinctOn</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>queryHasAggregates</name></decl></parameter>,
									<parameter><decl><type><name>QueryDistinctClause</name> <modifier>*</modifier></type><name>queryDistinctClause</name></decl></parameter>,
									<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>distinctPreventsLimitPushdown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>distinctPreventsLimitPushdown</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>distinctClause</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>distinctClauseSupersetofGroupClause</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>groupClauseList</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		<call><name>IsGroupBySubsetOfDistinct</name><argument_list>(<argument><expr><name>groupClauseList</name></expr></argument>, <argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>distinctClauseSupersetofGroupClause</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>distinctClauseSupersetofGroupClause</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * GROUP BY being a subset of DISTINCT guarantees the
		 * distinctness on the workers. Otherwise, pushing down
		 * LIMIT might cause missing the necessary data from
		 * the worker query
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>distinctPreventsLimitPushdown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Distinct is pushed down to worker query only if the query does not
	 * contain an aggregate in which master processing might be required to
	 * complete the final result before distinct operation. We also prevent
	 * distinct pushdown if distinct clause is missing some entries that
	 * group by clause has.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>shouldPushdownDistinct</name> <init>= <expr><operator>!</operator><name>queryHasAggregates</name> <operator>&amp;&amp;</operator>
								  <name>distinctClauseSupersetofGroupClause</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shouldPushdownDistinct</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>queryDistinctClause</name><operator>-&gt;</operator><name>workerDistinctClause</name></name> <operator>=</operator> <name>distinctClause</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>queryDistinctClause</name><operator>-&gt;</operator><name>workerHasDistinctOn</name></name> <operator>=</operator> <name>hasDistinctOn</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessWindowFunctionsForWorkerQuery gets the inputs and modifies the outputs such
 * that worker query's workerWindowClauseList is set when the window clauses are safe to
 * pushdown.
 *
 * Note that even though Citus only pushes down the window functions, it may need to
 * modify the target list of the worker query when the window function refers to
 * an avg(). The reason is that any aggregate which is also referred by other
 * target entries would be mutated by Citus. Thus, we add a copy of the same aggregate
 * to the worker target list to make sure that the window function refers to the
 * non-mutated aggregate.
 *
 *     inputs: windowClauseList, originalTargetEntryList
 *     outputs: queryWindowClause, queryTargetList
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessWindowFunctionsForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>windowClauseList</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>originalTargetEntryList</name></decl></parameter>,
									 <parameter><decl><type><name>QueryWindowClause</name> <modifier>*</modifier></type><name>queryWindowClause</name></decl></parameter>,
									 <parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>windowClauseList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>queryWindowClause</name><operator>-&gt;</operator><name>workerWindowClauseList</name></name> <operator>=</operator> <name>windowClauseList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryWindowClause</name><operator>-&gt;</operator><name>hasWindowFunctions</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ProcessWindowFunctionPullUpForWorkerQuery pulls up inputs for window functions */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessWindowFunctionPullUpForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>windowClause</name></decl></parameter>,
										  <parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>windowClause</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>windowClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>newExpression</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>newExpression</argument>, <argument>columnList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newTargetEntry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>newExpression</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator>
				<call><name>WorkerColumnName</name><argument_list>(<argument><expr><name><name>queryTargetList</name><operator>-&gt;</operator><name>targetProjectionNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* force resjunk to false as we may need this on the master */</comment>
			<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name><name>queryTargetList</name><operator>-&gt;</operator><name>targetProjectionNumber</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>queryTargetList</name><operator>-&gt;</operator><name>targetEntryList</name></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>queryTargetList</name><operator>-&gt;</operator><name>targetEntryList</name></name></expr></argument>, <argument><expr><name>newTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryTargetList</name><operator>-&gt;</operator><name>targetProjectionNumber</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessLimitOrderByForWorkerQuery gets the inputs and modifies the outputs
 * such that worker query's LIMIT and ORDER BY clauses are set accordingly.
 * Adding entries to ORDER BY might trigger adding new entries to newTargetEntryList.
 * See GenerateNewTargetEntriesForSortClauses() for the details.
 *
 * For the decisions on whether and how to pushdown LIMIT and ORDER BY are documented
 * in the functions that are called from this function.
 *
 *     inputs: sortLimitReference, originalLimitCount, limitOffset,
 *             sortClauseList, groupClauseList, originalTargetList
 *     outputs: queryOrderByLimit, queryTargetList
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessLimitOrderByForWorkerQuery</name><parameter_list>(<parameter><decl><type><name>OrderByLimitReference</name></type> <name>orderByLimitReference</name></decl></parameter>,
								  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>originalLimitCount</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>originalTargetList</name></decl></parameter>,
								  <parameter><decl><type><name>QueryOrderByLimit</name> <modifier>*</modifier></type><name>queryOrderByLimit</name></decl></parameter>,
								  <parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>queryOrderByLimit</name><operator>-&gt;</operator><name>workerLimitCount</name></name> <operator>=</operator>
		<call><name>WorkerLimitCount</name><argument_list>(<argument><expr><name>originalLimitCount</name></expr></argument>, <argument><expr><name>limitOffset</name></expr></argument>, <argument><expr><name>orderByLimitReference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>queryOrderByLimit</name><operator>-&gt;</operator><name>workerSortClauseList</name></name> <operator>=</operator>
		<call><name>WorkerSortClauseList</name><argument_list>(<argument><expr><name>originalLimitCount</name></expr></argument>,
							 <argument><expr><name>groupClauseList</name></expr></argument>,
							 <argument><expr><name>sortClauseList</name></expr></argument>,
							 <argument><expr><name>orderByLimitReference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BuildOrderByLimitReference is a helper function that simply builds
 * the necessary information for processing the limit and order by.
 * The return value should be used in a read-only manner.
 */</comment>
<function><type><specifier>static</specifier> <name>OrderByLimitReference</name></type>
<name>BuildOrderByLimitReference</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>hasDistinctOn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>groupedByDisjointPartitionColumn</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>onlyPushableWindowFunctions</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OrderByLimitReference</name></type> <name>limitOrderByReference</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>limitOrderByReference</name><operator>.</operator><name>groupedByDisjointPartitionColumn</name></name> <operator>=</operator>
		<name>groupedByDisjointPartitionColumn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>limitOrderByReference</name><operator>.</operator><name>onlyPushableWindowFunctions</name></name> <operator>=</operator>
		<name>onlyPushableWindowFunctions</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>limitOrderByReference</name><operator>.</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>hasDistinctOn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>limitOrderByReference</name><operator>.</operator><name>groupClauseIsEmpty</name></name> <operator>=</operator> <operator>(</operator><name>groupClause</name> <operator>==</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>limitOrderByReference</name><operator>.</operator><name>sortClauseIsEmpty</name></name> <operator>=</operator> <operator>(</operator><name>sortClauseList</name> <operator>==</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>limitOrderByReference</name><operator>.</operator><name>canApproximate</name></name> <operator>=</operator>
		<call><name>CanPushDownLimitApproximate</name><argument_list>(<argument><expr><name>sortClauseList</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>limitOrderByReference</name><operator>.</operator><name>hasOrderByAggregate</name></name> <operator>=</operator>
		<call><name>HasOrderByAggregate</name><argument_list>(<argument><expr><name>sortClauseList</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>limitOrderByReference</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TargetListHasAggregates returns true if any of the elements in the
 * target list contain aggregates that are not inside the window functions.
 * This function should not be called if window functions are being pulled up.
 */</comment>
<function><type><name>bool</name></type>
<name>TargetListHasAggregates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>targetEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>targetExpr</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>hasAggregates</name> <init>= <expr><call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>hasWindowFunction</name> <init>= <expr><call><name>contain_window_function</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the expression uses aggregates inside window function contain agg
		 * clause still returns true. We want to make sure it is not a part of
		 * window function before we proceed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hasAggregates</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasWindowFunction</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExpandWorkerTargetEntry is a utility function which processes the
 * expressions that are intended to be added to the worker target list.
 *
 * In summary, the function gets a list of expressions, converts them to target
 * entries and updates all the necessary fields such that the expression is correctly
 * added to the worker query's target list.
 *
 * Inputs:
 *  - expressionList: The list of expressions that should be added to the worker query's
 *                    target list.
 *  - originalTargetEntry: Target entry that the expressionList generated for. NULL
 *                         if the expressionList is not generated from any target entry.
 *  - addToGroupByClause: True if the expressionList should also be added to the
 *                        worker query's GROUP BY clause.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExpandWorkerTargetEntry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>expressionList</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>originalTargetEntry</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>addToGroupByClause</name></decl></parameter>, <parameter><decl><type><name>QueryTargetList</name> <modifier>*</modifier></type><name>queryTargetList</name></decl></parameter>,
						<parameter><decl><type><name>QueryGroupClause</name> <modifier>*</modifier></type><name>queryGroupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* now create target entries for each new expression */</comment>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>newExpression</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>newExpression</argument>, <argument>expressionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* generate and add the new target entry to the target list */</comment>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newTargetEntry</name> <init>=
			<expr><call><name>GenerateWorkerTargetEntry</name><argument_list>(<argument><expr><name>originalTargetEntry</name></expr></argument>, <argument><expr><name>newExpression</name></expr></argument>,
									  <argument><expr><name><name>queryTargetList</name><operator>-&gt;</operator><name>targetProjectionNumber</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>queryTargetList</name><operator>-&gt;</operator><name>targetProjectionNumber</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>queryTargetList</name><operator>-&gt;</operator><name>targetEntryList</name></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>queryTargetList</name><operator>-&gt;</operator><name>targetEntryList</name></name></expr></argument>, <argument><expr><name>newTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Detect new targets of type Var and add it to group clause list.
		 * This case is expected only if the target entry has aggregates and
		 * it is inside a repartitioned subquery. We create group by entry
		 * for each Var in target list. This code does not check if this
		 * Var was already in the target list or in group by clauses.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>newExpression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>addToGroupByClause</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AppendTargetEntryToGroupClause</name><argument_list>(<argument><expr><name>newTargetEntry</name></expr></argument>, <argument><expr><name>queryGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetNextSortGroupRef gets a target list entry and returns
 * the next ressortgroupref that should be used based on the
 * input target list.
 */</comment>
<function><type><specifier>static</specifier> <name>Index</name></type>
<name>GetNextSortGroupRef</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type> <name>nextSortGroupRefIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* find max of sort group ref index */</comment>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>targetEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>targetEntry</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>&gt;</operator> <name>nextSortGroupRefIndex</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextSortGroupRefIndex</name> <operator>=</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* next group ref index starts from max group ref index + 1 */</comment>
	<expr_stmt><expr><name>nextSortGroupRefIndex</name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>nextSortGroupRefIndex</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateWorkerTargetEntry is a simple utility function which gets a
 * target entry, an expression and a targetProjectionNumber.
 *
 * The function returns a newly allocated target entry which can be added
 * to the worker's target list.
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>GenerateWorkerTargetEntry</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>workerExpression</name></decl></parameter>,
						  <parameter><decl><type><name>AttrNumber</name></type> <name>targetProjectionNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If a target entry is already provided, use a copy of
	 * it because some of the callers rely on resorigtbl and
	 * resorigcol.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetEntry</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newTargetEntry</name> <operator>=</operator> <call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>targetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>newTargetEntry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>WorkerColumnName</name><argument_list>(<argument><expr><name>targetProjectionNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we can't generate a target entry without an expression */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>workerExpression</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* force resjunk to false as we may need this on the master */</comment>
	<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>workerExpression</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>targetProjectionNumber</name></expr>;</expr_stmt>

	<return>return <expr><name>newTargetEntry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AppendTargetEntryToGroupClause gets a target entry, pointer to group list
 * and the ressortgroupref index.
 *
 * The function modifies all of the three input such that the target entry is
 * appended to the group clause and the index is incremented by one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendTargetEntryToGroupClause</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name></decl></parameter>,
							   <parameter><decl><type><name>QueryGroupClause</name> <modifier>*</modifier></type><name>queryGroupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier><name>targetExpr</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we currently only support appending Var target entries */</comment>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>targetExpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupByClause</name> <init>= <expr><call><name>CreateSortGroupClause</name><argument_list>(<argument><expr><name>targetColumn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* the target entry should have an index */</comment>
	<expr_stmt><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <operator>*</operator><name><name>queryGroupClause</name><operator>-&gt;</operator><name>nextSortGroupRefIndex</name></name></expr>;</expr_stmt>

	<comment type="block">/* the group by clause entry should point to the correct index in the target list */</comment>
	<expr_stmt><expr><name><name>groupByClause</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <operator>*</operator><name><name>queryGroupClause</name><operator>-&gt;</operator><name>nextSortGroupRefIndex</name></name></expr>;</expr_stmt>

	<comment type="block">/* update the group by list and the index's value */</comment>
	<expr_stmt><expr><name><name>queryGroupClause</name><operator>-&gt;</operator><name>groupClauseList</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>queryGroupClause</name><operator>-&gt;</operator><name>groupClauseList</name></name></expr></argument>, <argument><expr><name>groupByClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>queryGroupClause</name><operator>-&gt;</operator><name>nextSortGroupRefIndex</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerAggregateWalker walks over the original target entry expression, and
 * creates the list of expression trees (potentially more than one) to execute
 * on the worker nodes. The function creates new expressions for aggregates and
 * columns; and recurses into expression_tree_walker() for all other expression
 * types.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>WorkerAggregateWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>WorkerAggregateWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>walkerResult</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>CanPushDownExpression</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>extendedOpNodeProperties</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>expressionList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>expressionList</name></name></expr></argument>,
													<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>originalAggregate</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerAggregateList</name> <init>= <expr><call><name>WorkerAggregateExpressionList</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>,
																	  <argument><expr><name>walkerContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>expressionList</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>expressionList</name></name></expr></argument>,
														<argument><expr><name>workerAggregateList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>originalColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>expressionList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>expressionList</name></name></expr></argument>,
												<argument><expr><name>originalColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>walkerResult</name> <operator>=</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WorkerAggregateWalker</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>walkerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>walkerResult</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerAggregateExpressionList takes in the original aggregate function, and
 * determines the transformed aggregate functions to execute on worker nodes.
 * The function then returns these aggregates in a list. It also creates
 * group by clauses for newly added targets to be placed in the extended operator
 * node.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>WorkerAggregateExpressionList</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>originalAggregate</name></decl></parameter>,
							  <parameter><decl><type><name>WorkerAggregateWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerAggregateList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>walkerContext</name><operator>-&gt;</operator><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>pullUpIntermediateRows</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>originalAggregate-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerAggregateList</name></expr></argument>, <argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>directarg</name></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>directarg</argument>, <argument>originalAggregate-&gt;aggdirectargs</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * The worker aggregation should execute any node that contains any
			 * Var nodes and return the result in the targetlist, so that the
			 * combine query can then fetch the result via remote scan; see
			 * MasterAggregateExpression.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>directarg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerAggregateList</name></expr></argument>, <argument><expr><name>directarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerAggregateList</name></expr></argument>,
										  <argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>workerAggregateList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AggregateType</name></type> <name>aggregateType</name> <init>= <expr><call><name>GetAggregateType</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_COUNT</name> <operator>&amp;&amp;</operator> <name><name>originalAggregate</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>&amp;&amp;</operator>
		<name>CountDistinctErrorRate</name> <operator>==</operator> <name>DISABLE_DISTINCT_APPROXIMATION</name> <operator>&amp;&amp;</operator>
		<name><name>walkerContext</name><operator>-&gt;</operator><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>pullDistinctColumns</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregate</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>aggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>column</argument>, <argument>columnList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>list_append_unique</name><argument_list>(<argument><expr><name>workerAggregateList</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>createGroupByClause</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_COUNT</name> <operator>&amp;&amp;</operator> <name><name>originalAggregate</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>&amp;&amp;</operator>
			 <name>CountDistinctErrorRate</name> <operator>!=</operator> <name>DISABLE_DISTINCT_APPROXIMATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the original aggregate is a count(distinct) approximation, we want
		 * to compute hll_add_agg(hll_hash(var), storageSize) on worker nodes.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>AttrNumber</name></type> <name>firstArgumentId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>AttrNumber</name></type> <name>secondArgumentId</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>hashArgumentCount</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>addArgumentCount</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>


		<comment type="block">/* init hll_hash() related variables */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>argumentType</name> <init>= <expr><call><name>AggregateArgumentType</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>argument</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>argumentExpression</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>argument</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* extract schema name of hll */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hllId</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name>HLL_EXTENSION_NAME</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hllSchemaOid</name> <init>= <expr><call><name>get_extension_schema</name><argument_list>(<argument><expr><name>hllId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hllSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>hllSchemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hashFunctionName</name> <init>= <expr><call><name>CountDistinctHashFunctionName</name><argument_list>(<argument><expr><name>argumentType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hashFunctionId</name> <init>= <expr><call><name>FunctionOid</name><argument_list>(<argument><expr><name>hllSchemaName</name></expr></argument>, <argument><expr><name>hashFunctionName</name></expr></argument>,
										 <argument><expr><name>hashArgumentCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hashFunctionReturnType</name> <init>= <expr><call><name>get_func_rettype</name><argument_list>(<argument><expr><name>hashFunctionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* init hll_add_agg() related variables */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>addFunctionId</name> <init>= <expr><call><name>FunctionOid</name><argument_list>(<argument><expr><name>hllSchemaName</name></expr></argument>, <argument><expr><name>HLL_ADD_AGGREGATE_NAME</name></expr></argument>,
										<argument><expr><name>addArgumentCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hllType</name> <init>= <expr><call><name>TypeOid</name><argument_list>(<argument><expr><name>hllSchemaOid</name></expr></argument>, <argument><expr><name>HLL_TYPE_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>logOfStorageSize</name> <init>= <expr><call><name>CountDistinctStorageSize</name><argument_list>(<argument><expr><name>CountDistinctErrorRate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>logOfStorageSizeConst</name> <init>= <expr><call><name>MakeIntegerConst</name><argument_list>(<argument><expr><name>logOfStorageSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* construct hll_hash() expression */</comment>
		<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>hashFunction</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>hashFunction</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>hashFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashFunction</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name>hashFunctionReturnType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hashFunction</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>argumentExpression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* construct hll_add_agg() expression */</comment>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>hashedColumnArgument</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>hashFunction</name></expr></argument>,
															<argument><expr><name>firstArgumentId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>storageSizeArgument</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>logOfStorageSizeConst</name></expr></argument>,
														   <argument><expr><name>secondArgumentId</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>addAggregateArgumentList</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><name>hashedColumnArgument</name></expr></argument>,
													<argument><expr><name>storageSizeArgument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>addAggregateFunction</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>addAggregateFunction</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>addFunctionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addAggregateFunction</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>hllType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addAggregateFunction</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>addAggregateArgumentList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addAggregateFunction</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addAggregateFunction</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(
			<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerAggregateList</name></expr></argument>, <argument><expr><name>addAggregateFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_AVERAGE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the original aggregate is an average, we want to compute sum(var)
		 * and count(var) on worker nodes.
		 */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>sumAggregate</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>countAggregate</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* extract function names for sum and count */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sumAggregateName</name> <init>= <expr><name><name>AggregateNames</name><index>[<expr><name>AGGREGATE_SUM</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>countAggregateName</name> <init>= <expr><name><name>AggregateNames</name><index>[<expr><name>AGGREGATE_COUNT</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Find the type of the expression over which we execute the aggregate.
		 * We then need to find the right sum function for that type.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>argumentType</name> <init>= <expr><call><name>AggregateArgumentType</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* find function implementing sum over the original type */</comment>
		<expr_stmt><expr><name><name>sumAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>sumAggregateName</name></expr></argument>, <argument><expr><name>argumentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sumAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name><name>sumAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sumAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sumAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>argumentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sumAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<comment type="block">/* count has any input type */</comment>
		<expr_stmt><expr><name><name>countAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <call><name>AggregateFunctionOid</name><argument_list>(<argument><expr><name>countAggregateName</name></expr></argument>, <argument><expr><name>ANYOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>countAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name><name>countAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>countAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>countAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>argumentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>countAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerAggregateList</name></expr></argument>, <argument><expr><name>sumAggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerAggregateList</name></expr></argument>, <argument><expr><name>countAggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_ADD_DOUBLE</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_ADD_DOUBLEARRAY</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_OF_ADD_DOUBLE</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_OF_ADD_DOUBLEARRAY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The original query has an aggregate in the form of either
		 *  - tdigest_percentile(column, compression, quantile)
		 *  - tdigest_percentile(column, compression, quantile[])
		 *  - tdigest_percentile_of(column, compression, value)
		 *  - tdigest_percentile_of(column, compression, value[])
		 *
		 * We are creating the worker part of this query by creating a
		 *  - tdigest(column, compression)
		 *
		 * One could see we are passing argument 0 and argument 1 from the original query
		 * in here. This corresponds with the list_nth calls in the args and aggargstypes
		 * list construction. The tdigest function and type are read from the catalog.
		 */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newWorkerAggregate</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <call><name>TDigestExtensionAggTDigest2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <call><name>TDigestExtensionTypeOid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(
			<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make2_oid</name><argument_list>(
			<argument><expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerAggregateList</name></expr></argument>, <argument><expr><name>newWorkerAggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_TDIGEST_DOUBLE</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_TDIGEST_DOUBLEARRAY</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_OF_TDIGEST_DOUBLE</name> <operator>||</operator>
			 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_TDIGEST_PERCENTILE_OF_TDIGEST_DOUBLEARRAY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The original query has an aggregate in the form of either
		 *  - tdigest_percentile(tdigest, quantile)
		 *  - tdigest_percentile(tdigest, quantile[])
		 *  - tdigest_percentile_of(tdigest, value)
		 *  - tdigest_percentile_of(tdigest, value[])
		 *
		 * We are creating the worker part of this query by creating a
		 *  - tdigest(tdigest)
		 *
		 * One could see we are passing argument 0 from the original query in here. This
		 * corresponds with the list_nth calls in the args and aggargstypes list
		 * construction. The tdigest function and type are read from the catalog.
		 */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newWorkerAggregate</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <call><name>TDigestExtensionAggTDigest1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <call><name>TDigestExtensionTypeOid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(
			<argument><expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerAggregateList</name></expr></argument>, <argument><expr><name>newWorkerAggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_CUSTOM_COMBINE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>aggTuple</name> <init>=
			<expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>combine</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"citus cache lookup failed for aggregate %u"</literal></expr></argument>,
				 <argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>aggform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>combine</name> <operator>=</operator> <name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>combine</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>workerPartialId</name> <init>= <expr><call><name>WorkerPartialAggOid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>aggOidParam</name> <init>= <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>REGPROCEDUREOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newWorkerAggregateArgs</name> <init>=
				<expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>aggOidParam</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Single argument case, append 'arg' to worker_partial_agg(agg, arg).
				 * We don't wrap single argument in a row expression because
				 * it has performance implications to unwrap arguments on each
				 * SFUNC invocation.
				 */</comment>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newArg</name> <init>=
					<expr><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>originalAggregate</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>newArg</name><operator>-&gt;</operator><name>resno</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>newWorkerAggregateArgs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newWorkerAggregateArgs</name></expr></argument>, <argument><expr><name>newArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Aggregation on workers assumes a single aggregation parameter.
				 * To still be able to handle multiple parameters, we combine
				 * parameters into a single row expression, i.e., append 'ROW(...args)'
				 * to worker_partial_agg(agg, ROW(...args)).
				 */</comment>
				<decl_stmt><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>rowExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>rowExpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rowExpr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_EXPLICIT_CALL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rowExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rowExpr</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<macro><name>foreach_ptr</name><argument_list>(<argument>arg</argument>, <argument>originalAggregate-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name><name>rowExpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rowExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name>newWorkerAggregateArgs</name> <operator>=</operator>
					<call><name>lappend</name><argument_list>(<argument><expr><name>newWorkerAggregateArgs</name></expr></argument>,
							<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rowExpr</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* worker_partial_agg(agg, arg) or worker_partial_agg(agg, ROW(...args)) */</comment>
			<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>newWorkerAggregate</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>workerPartialId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>CSTRINGOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newWorkerAggregateArgs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>INTERNALOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>,
														<argument><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newWorkerAggregate</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>newWorkerAggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Aggregate lacks COMBINEFUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * All other aggregates are sent as they are to the worker nodes.
		 */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>workerAggregate</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalAggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>workerAggregateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>workerAggregateList</name></expr></argument>, <argument><expr><name>workerAggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>workerAggregateList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAggregateType scans pg_catalog.pg_proc for the given aggregate oid, and
 * finds the aggregate's name. The function then matches the aggregate's name to
 * previously stored strings, and returns the appropriate aggregate type.
 */</comment>
<function><type><specifier>static</specifier> <name>AggregateType</name></type>
<name>GetAggregateType</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregateExpression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>aggFunctionId</name> <init>= <expr><name><name>aggregateExpression</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* look up the function name */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aggregateProcName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>aggFunctionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggregateProcName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus cache lookup failed for function %u"</literal></expr></argument>,
							   <argument><expr><name>aggFunctionId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>aggregateCount</name> <init>= <expr><call><name>lengthof</name><argument_list>(<argument><expr><name>AggregateNames</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>AGGREGATE_INVALID_FIRST</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>aggregateIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>aggregateIndex</name> <operator>&lt;</operator> <name>aggregateCount</name></expr>;</condition> <incr><expr><name>aggregateIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggregateName</name> <init>= <expr><name><name>AggregateNames</name><index>[<expr><name>aggregateIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>aggregateName</name></expr></argument>, <argument><expr><name>aggregateProcName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>aggregateIndex</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * All functions from github.com/tvondra/tdigest start with the "tdigest" prefix.
	 * Since it requires lookups of function names in a schema we would like to only
	 * perform these checks if there is some chance it will actually result in a positive
	 * hit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>StringStartsWith</name><argument_list>(<argument><expr><name>aggregateProcName</name></expr></argument>, <argument><expr><literal type="string">"tdigest"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>aggFunctionId</name> <operator>==</operator> <call><name>TDigestExtensionAggTDigest1</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>AGGREGATE_TDIGEST_COMBINE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggFunctionId</name> <operator>==</operator> <call><name>TDigestExtensionAggTDigest2</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>AGGREGATE_TDIGEST_ADD_DOUBLE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggFunctionId</name> <operator>==</operator> <call><name>TDigestExtensionAggTDigestPercentile3</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>AGGREGATE_TDIGEST_PERCENTILE_ADD_DOUBLE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggFunctionId</name> <operator>==</operator> <call><name>TDigestExtensionAggTDigestPercentile3a</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>AGGREGATE_TDIGEST_PERCENTILE_ADD_DOUBLEARRAY</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggFunctionId</name> <operator>==</operator> <call><name>TDigestExtensionAggTDigestPercentile2</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>AGGREGATE_TDIGEST_PERCENTILE_TDIGEST_DOUBLE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggFunctionId</name> <operator>==</operator> <call><name>TDigestExtensionAggTDigestPercentile2a</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>AGGREGATE_TDIGEST_PERCENTILE_TDIGEST_DOUBLEARRAY</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggFunctionId</name> <operator>==</operator> <call><name>TDigestExtensionAggTDigestPercentileOf3</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>AGGREGATE_TDIGEST_PERCENTILE_OF_ADD_DOUBLE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggFunctionId</name> <operator>==</operator> <call><name>TDigestExtensionAggTDigestPercentileOf3a</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>AGGREGATE_TDIGEST_PERCENTILE_OF_ADD_DOUBLEARRAY</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggFunctionId</name> <operator>==</operator> <call><name>TDigestExtensionAggTDigestPercentileOf2</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>AGGREGATE_TDIGEST_PERCENTILE_OF_TDIGEST_DOUBLE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggFunctionId</name> <operator>==</operator> <call><name>TDigestExtensionAggTDigestPercentileOf2a</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>AGGREGATE_TDIGEST_PERCENTILE_OF_TDIGEST_DOUBLEARRAY</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><call><name>AggregateEnabledCustom</name><argument_list>(<argument><expr><name>aggregateExpression</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>AGGREGATE_CUSTOM_COMBINE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>CoordinatorAggregationStrategy</name> <operator>==</operator> <name>COORDINATOR_AGGREGATION_DISABLED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported aggregate function %s"</literal></expr></argument>, <argument><expr><name>aggregateProcName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>AGGREGATE_CUSTOM_ROW_GATHER</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Extracts the type of the argument over which the aggregate is operating. */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>AggregateArgumentType</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>argumentList</name> <init>= <expr><name><name>aggregate</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>argument</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>returnTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>argument</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Here we currently support aggregates with only one argument; assert that. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>returnTypeId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FirstAggregateArgument returns the first argument of the aggregate.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>FirstAggregateArgument</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>argumentList</name> <init>= <expr><name><name>aggregate</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>argument</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>argument</name><operator>-&gt;</operator><name>expr</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AggregateEnabledCustom returns whether given aggregate can be
 * distributed across workers using worker_partial_agg &amp; coord_combine_agg.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AggregateEnabledCustom</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregateExpression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>aggregateExpression</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>aggregateExpression</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>aggregateOid</name> <init>= <expr><name><name>aggregateExpression</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>aggTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name>aggregateOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"citus cache lookup failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name> <init>= <expr><operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>typeTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"citus cache lookup failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeform</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>supportsSafeCombine</name> <init>= <expr><name><name>typeform</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_PSEUDO</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>supportsSafeCombine</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AggregateFunctionOid performs a reverse lookup on aggregate function name,
 * and returns the corresponding aggregate function oid for the given function
 * name and input type.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>AggregateFunctionOid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>functionName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>functionOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>procRelation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_proc_proname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>functionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>procRelation</name></expr></argument>,
													<argument><expr><name>ProcedureNameArgsNspIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* loop until we find the right function */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procForm</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>argumentCount</name> <init>= <expr><name><name>procForm</name><operator>-&gt;</operator><name>pronargs</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>argumentCount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* check if input type and found value type match */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>procForm</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>inputType</name> <operator>||</operator>
				<name><name>procForm</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ANYELEMENTOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>functionOid</name> <operator>=</operator> <name><name>procForm</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>argumentCount</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>functionOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no matching oid for function: %s"</literal></expr></argument>, <argument><expr><name>functionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>procRelation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>functionOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusFunctionOidWithSignature looks up a function with given input types.
 * Looks in pg_catalog schema, as this function's sole purpose is
 * support aggregate lookup.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>CitusFunctionOidWithSignature</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>aggregateName</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>functionName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name> <init>= <expr><call><name>FuncnameGetCandidates_compat</name><argument_list>(<argument><expr><name>aggregateName</name></expr></argument>, <argument><expr><name>numargs</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
														   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>clist</name></expr>;</condition> <incr><expr><name>clist</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>clist</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name><name>clist</name><operator>-&gt;</operator><name>oid</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no matching oid for function: %s"</literal></expr></argument>, <argument><expr><name>functionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerPartialAggOid looks up oid of pg_catalog.worker_partial_agg
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>WorkerPartialAggOid</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[]</index></name> <init>= <expr><block>{
		<expr><name>OIDOID</name></expr>,
		<expr><name>ANYELEMENTOID</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>CitusFunctionOidWithSignature</name><argument_list>(<argument><expr><name>WORKER_PARTIAL_AGGREGATE_NAME</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CoordCombineAggOid looks up oid of pg_catalog.coord_combine_agg
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>CoordCombineAggOid</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name><name>argtypes</name><index>[]</index></name> <init>= <expr><block>{
		<expr><name>OIDOID</name></expr>,
		<expr><name>CSTRINGOID</name></expr>,
		<expr><name>ANYELEMENTOID</name></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>CitusFunctionOidWithSignature</name><argument_list>(<argument><expr><name>COORD_COMBINE_AGGREGATE_NAME</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TypeOid looks for a type that has the given name and schema, and returns the
 * corresponding type's oid.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>TypeOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>schemaId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>, <argument><expr><name>Anum_pg_type_oid</name></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>typeOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateSortGroupClause creates SortGroupClause for a given column Var.
 * The caller should set tleSortGroupRef field and respective
 * TargetEntry-&gt;ressortgroupref fields to appropriate SortGroupRefIndex.
 */</comment>
<function><type><specifier>static</specifier> <name>SortGroupClause</name> <modifier>*</modifier></type>
<name>CreateSortGroupClause</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>lessThanOperator</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>equalsOperator</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hashable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupByClause</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>lessThanOperator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>equalsOperator</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>groupByClause</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>equalsOperator</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>groupByClause</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>groupByClause</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>groupByClause</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>lessThanOperator</name></expr>;</expr_stmt>

	<return>return <expr><name>groupByClause</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CountDistinctHashFunctionName resolves the hll_hash function name to use for
 * the given input type, and returns this function name.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CountDistinctHashFunctionName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>argumentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* resolve hash function name based on input argument type */</comment>
	<switch>switch <condition>(<expr><name>argumentType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>HLL_HASH_INTEGER_FUNC_NAME</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>INT8OID</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>HLL_HASH_BIGINT_FUNC_NAME</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>TEXTOID</name></expr>:</case>
		<case>case <expr><name>BPCHAROID</name></expr>:</case>
		<case>case <expr><name>VARCHAROID</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>HLL_HASH_TEXT_FUNC_NAME</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<return>return <expr><name>HLL_HASH_ANY_FUNC_NAME</name></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * CountDistinctStorageSize takes in the desired precision for count distinct
 * approximations, and returns the log-base-2 of storage space needed for the
 * HyperLogLog algorithm.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CountDistinctStorageSize</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>approximationErrorRate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>desiredStorageSize</name> <init>= <expr><call><name>pow</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1.04</literal> <operator>/</operator> <name>approximationErrorRate</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>logOfDesiredStorageSize</name> <init>= <expr><call><name>log</name><argument_list>(<argument><expr><name>desiredStorageSize</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>log</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* keep log2(storage size) inside allowed range */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>logOfStorageSize</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>logOfDesiredStorageSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>logOfStorageSize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>logOfStorageSize</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>logOfStorageSize</name> <operator>&gt;</operator> <literal type="number">17</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>logOfStorageSize</name> <operator>=</operator> <literal type="number">17</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>logOfStorageSize</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Makes an integer constant node from the given value, and returns that node. */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>MakeIntegerConst</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>integerValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>typeCollationId</name> <init>= <expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int16</name></type> <name>typeLength</name> <init>= <expr><call><name>get_typlen</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int32</name></type> <name>typeModifier</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>typeIsNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>typePassByValue</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>integerDatum</name> <init>= <expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>integerValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>integerConst</name> <init>= <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><name>typeModifier</name></expr></argument>, <argument><expr><name>typeCollationId</name></expr></argument>, <argument><expr><name>typeLength</name></expr></argument>,
									<argument><expr><name>integerDatum</name></expr></argument>, <argument><expr><name>typeIsNull</name></expr></argument>, <argument><expr><name>typePassByValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>integerConst</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Makes a 64-bit integer constant node from the given value, and returns that node. */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>MakeIntegerConstInt64</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>integerValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>typeCollationId</name> <init>= <expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int16</name></type> <name>typeLength</name> <init>= <expr><call><name>get_typlen</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int32</name></type> <name>typeModifier</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>typeIsNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>typePassByValue</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>integer64Datum</name> <init>= <expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>integerValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>integer64Const</name> <init>= <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><name>typeModifier</name></expr></argument>, <argument><expr><name>typeCollationId</name></expr></argument>, <argument><expr><name>typeLength</name></expr></argument>,
									  <argument><expr><name>integer64Datum</name></expr></argument>, <argument><expr><name>typeIsNull</name></expr></argument>, <argument><expr><name>typePassByValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>integer64Const</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasNonDistributableAggregates checks for if any aggregates cannot be pushed down.
 * This only checks with GetAggregateType. DeferErrorIfHasNonDistributableAggregates
 * performs further checks which should be done if aggregates are not being pushed down.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasNonDistributableAggregates</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>logicalPlanNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>CoordinatorAggregationStrategy</name> <operator>==</operator> <name>COORDINATOR_AGGREGATION_DISABLED</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>opNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiExtendedOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOpNode</name> <init>= <expr><operator>(</operator><name>MultiExtendedOp</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>opNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name> <init>= <expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * PVC_REJECT_PLACEHOLDERS is implicit if PVC_INCLUDE_PLACEHOLDERS isn't
	 * specified.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>expressionList</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr></argument>, <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
										   <name>PVC_INCLUDE_WINDOWFUNCS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>expressionList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>expressionList</name></expr></argument>,
								 <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>, <argument><expr><name>PVC_INCLUDE_AGGREGATES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>expression</argument>, <argument>expressionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* only consider aggregate expressions */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>AggregateType</name></type> <name>aggregateType</name> <init>= <expr><call><name>GetAggregateType</name><argument_list>(<argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_INVALID_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_CUSTOM_ROW_GATHER</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CanPushDownExpression returns whether the expression can be pushed down to workers.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CanPushDownExpression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type><name>extendedOpNodeProperties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>contain_nextval_expression_walker</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nextval can only be evaluated on the coordinator */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>hasAggregate</name> <init>= <expr><call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasWindowFunction</name> <init>= <expr><call><name>contain_window_function</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasAggregate</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasWindowFunction</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the query has the form SELECT expression, agg(..) FROM table;
		 * then expression should be evaluated on the coordinator.
		 *
		 * Other than the efficiency part of this, we could also crash if
		 * we pushed down the expression to the workers. When pushing down
		 * expressions to workers we create a Var reference to the worker
		 * tuples. If the result from worker is empty, but we need to have
		 * at least a row in coordinator result, postgres will crash when
		 * trying to evaluate the Var.
		 *
		 * For details, see https://github.com/citusdata/citus/pull/3961
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>hasAggregate</name></name> <operator>||</operator>
			<name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>hasGroupBy</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* aggregates inside pushed down window functions can be pushed down */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasPushableWindowFunction</name> <init>=
		<expr><name>hasWindowFunction</name> <operator>&amp;&amp;</operator> <name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>onlyPushableWindowFunctions</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasPushableWindowFunction</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>pushDownGroupingAndHaving</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasWindowFunction</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasAggregate</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hasWindowFunction</name> <operator>&amp;&amp;</operator>
		<name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>groupedByDisjointPartitionColumn</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfHasNonDistributableAggregates extracts aggregate expressions from
 * the logical plan, walks over them and uses helper functions to check if we
 * can transform these aggregate expressions and push them down to worker nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfHasNonDistributableAggregates</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>logicalPlanNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>opNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiExtendedOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOpNode</name> <init>= <expr><operator>(</operator><name>MultiExtendedOp</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>opNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name> <init>= <expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * PVC_REJECT_PLACEHOLDERS is implicit if PVC_INCLUDE_PLACEHOLDERS isn't
	 * specified.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>expressionList</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr></argument>, <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
										   <name>PVC_INCLUDE_WINDOWFUNCS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>expressionList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>expressionList</name></expr></argument>,
								 <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>, <argument><expr><name>PVC_INCLUDE_AGGREGATES</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>expression</argument>, <argument>expressionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* only consider aggregate expressions */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* GetAggregateType errors out on unsupported aggregate types */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregateExpression</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggregateType</name></type> <name>aggregateType</name> <init>= <expr><call><name>GetAggregateType</name><argument_list>(<argument><expr><name>aggregateExpression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_INVALID_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check that we can transform the current aggregate expression. These
		 * functions error out on unsupported array_agg and aggregate (distinct)
		 * clauses.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_ARRAY_AGG</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>DeferErrorIfUnsupportedArrayAggregate</name><argument_list>(<argument><expr><name>aggregateExpression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_JSONB_AGG</name> <operator>||</operator>
				 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_JSON_AGG</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>DeferErrorIfUnsupportedJsonAggregate</name><argument_list>(<argument><expr><name>aggregateType</name></expr></argument>,
														 <argument><expr><name>aggregateExpression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_JSONB_OBJECT_AGG</name> <operator>||</operator>
				 <name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_JSON_OBJECT_AGG</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>DeferErrorIfUnsupportedJsonAggregate</name><argument_list>(<argument><expr><name>aggregateType</name></expr></argument>,
														 <argument><expr><name>aggregateExpression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aggregateExpression</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>DeferErrorIfUnsupportedAggregateDistinct</name><argument_list>(<argument><expr><name>aggregateExpression</name></expr></argument>,
															 <argument><expr><name>logicalPlanNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>error</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfUnsupportedArrayAggregate checks if we can transform the array aggregate
 * expression and push it down to the worker node. If we cannot transform the
 * aggregate, this function errors.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfUnsupportedArrayAggregate</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>arrayAggregateExpression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if array_agg has order by, we error out */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>arrayAggregateExpression</name><operator>-&gt;</operator><name>aggorder</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"array_agg with order by is unsupported"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if array_agg has distinct, we error out */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>arrayAggregateExpression</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"array_agg (distinct) is unsupported"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfUnsupportedJsonAggregate checks if we can transform the json
 * aggregate expression and push it down to the worker node. If we cannot
 * transform the aggregate, this function errors.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfUnsupportedJsonAggregate</name><parameter_list>(<parameter><decl><type><name>AggregateType</name></type> <name>type</name></decl></parameter>,
									 <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregateExpression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if json aggregate has order by, we error out */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>aggregateExpression</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>||</operator> <name><name>aggregateExpression</name><operator>-&gt;</operator><name>aggorder</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>errorDetail</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorDetail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>AggregateNames</name><index>[<expr><name>type</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorDetail</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>aggregateExpression</name><operator>-&gt;</operator><name>aggorder</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorDetail</name></expr></argument>, <argument><expr><literal type="string">" with order by is unsupported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorDetail</name></expr></argument>, <argument><expr><literal type="string">" (distinct) is unsupported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>, <argument><expr><name><name>errorDetail</name><operator>.</operator><name>data</name></name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfUnsupportedAggregateDistinct checks if we can transform the aggregate
 * (distinct expression) and push it down to the worker node. It handles count
 * (distinct) separately to check if we can use distinct approximations. If we
 * cannot transform the aggregate, this function errors.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfUnsupportedAggregateDistinct</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregateExpression</name></decl></parameter>,
										 <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>logicalPlanNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorDetail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>distinctSupported</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AggregateType</name></type> <name>aggregateType</name> <init>= <expr><call><name>GetAggregateType</name><argument_list>(<argument><expr><name>aggregateExpression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If we're aggregating on coordinator, this becomes simple. */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_CUSTOM_ROW_GATHER</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We partially support count(distinct) in subqueries, other distinct aggregates in
	 * subqueries are not supported yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_COUNT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>aggregateArgument</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>aggregateExpression</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><name>aggregateArgument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>column</argument>, <argument>columnList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"cannot compute count (distinct)"</literal></expr></argument>,
									 <argument><expr><literal type="string">"Non-column references are not supported yet"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>multiTableNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>multiTable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>multiTable</argument>, <argument>multiTableNodeList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>multiTable</name><operator>-&gt;</operator><name>relationId</name></name> <operator>==</operator> <name>SUBQUERY_RELATION_ID</name> <operator>||</operator>
				<name><name>multiTable</name><operator>-&gt;</operator><name>relationId</name></name> <operator>==</operator> <name>SUBQUERY_PUSHDOWN_RELATION_ID</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"cannot compute aggregate (distinct)"</literal></expr></argument>,
									 <argument><expr><literal type="string">"Only count(distinct) aggregate is "</literal>
									 <literal type="string">"supported in subqueries"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* if we have a count(distinct), and distinct approximation is enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_COUNT</name> <operator>&amp;&amp;</operator>
		<name>CountDistinctErrorRate</name> <operator>!=</operator> <name>DISABLE_DISTINCT_APPROXIMATION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>distinctExtensionId</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name>HLL_EXTENSION_NAME</name></expr></argument>, <argument><expr><name>missingOK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if extension for distinct approximation is loaded, we are good */</comment>
		<if_stmt><if>if <condition>(<expr><name>distinctExtensionId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot compute count (distinct) approximation"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><literal type="string">"You need to have the hll extension loaded."</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_COUNT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>aggregateVarList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>aggregateExpression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggregateVarList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>distinctSupported</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"aggregate (distinct) with no columns is unsupported"</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>repartitionNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>repartitionNodeList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>distinctSupported</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"aggregate (distinct) with table repartitioning is unsupported"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>extendedOpNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>logicalPlanNode</name></expr></argument>, <argument><expr><name>T_MultiExtendedOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOpNode</name> <init>= <expr><operator>(</operator><name>MultiExtendedOp</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>extendedOpNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distinctColumn</name> <init>= <expr><call><name>AggregateDistinctColumn</name><argument_list>(<argument><expr><name>aggregateExpression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>distinctSupported</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>distinctColumn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the query has a single table, and table is grouped by partition
			 * column, then we support count distincts even distinct column can
			 * not be identified.
			 */</comment>
			<expr_stmt><expr><name>distinctSupported</name> <operator>=</operator> <call><name>TablePartitioningSupportsDistinct</name><argument_list>(<argument><expr><name>tableNodeList</name></expr></argument>,
																  <argument><expr><name>extendedOpNode</name></expr></argument>,
																  <argument><expr><name>distinctColumn</name></expr></argument>,
																  <argument><expr><name>aggregateType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>distinctSupported</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"aggregate (distinct) on complex expressions is"</literal>
							  <literal type="string">" unsupported"</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_COUNT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>supports</name> <init>= <expr><call><name>TablePartitioningSupportsDistinct</name><argument_list>(<argument><expr><name>tableNodeList</name></expr></argument>,
															  <argument><expr><name>extendedOpNode</name></expr></argument>,
															  <argument><expr><name>distinctColumn</name></expr></argument>,
															  <argument><expr><name>aggregateType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>supports</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>distinctSupported</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"table partitioning is unsuitable for aggregate (distinct)"</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if current aggregate expression isn't supported, error out */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>distinctSupported</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorHint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_COUNT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errorHint</name> <operator>=</operator> <literal type="string">"You can load the hll extension from contrib "</literal>
						<literal type="string">"packages and enable distinct approximations."</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot compute aggregate (distinct)"</literal></expr></argument>,
							 <argument><expr><name>errorDetail</name></expr></argument>, <argument><expr><name>errorHint</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AggregateDistinctColumn checks if the given aggregate expression's distinct
 * clause is on a single column. If it is, the function finds and returns that
 * column. Otherwise, the function returns null.
 * The function expects to find a single column here, no FieldSelect or other
 * expressions are accepted as a column.
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>AggregateDistinctColumn</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregateExpression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* only consider aggregates with distincts */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>aggregateExpression</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>aggregateArgumentCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggregateExpression</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>aggregateArgumentCount</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>aggregateTargetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(
		<argument><expr><name><name>aggregateExpression</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>aggregateTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>aggregateColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>aggregateTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>aggregateColumn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TablePartitioningSupportsDistinct walks over all tables in the given list and
 * checks that each table's partitioning method is suitable for pushing down an
 * aggregate (distinct) expression to worker nodes. For this, the function needs
 * to check that task results do not overlap with one another on the distinct
 * column.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TablePartitioningSupportsDistinct</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNodeList</name></decl></parameter>, <parameter><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>opNode</name></decl></parameter>,
								  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distinctColumn</name></decl></parameter>, <parameter><decl><type><name>AggregateType</name></type> <name>aggregateType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>distinctSupported</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>tableNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>tableNode</argument>, <argument>tableNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>tableNode</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>tableDistinctSupported</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>SUBQUERY_RELATION_ID</name> <operator>||</operator>
			<name>relationId</name> <operator>==</operator> <name>SUBQUERY_PUSHDOWN_RELATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* if table has one shard, task results don't overlap */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name> <init>= <expr><call><name>LoadShardList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We need to check that task results don't overlap. We can only do this
		 * if table is range partitioned.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>tablePartitionColumn</name> <init>= <expr><name><name>tableNode</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>==</operator> <name>AGGREGATE_COUNT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tableDistinctSupported</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* if distinct is on table partition column, we can push it down */</comment>
			<if_stmt><if>if <condition>(<expr><name>distinctColumn</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name><name>tablePartitionColumn</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>distinctColumn</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
				<name><name>tablePartitionColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>distinctColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tableDistinctSupported</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* if results are grouped by partition column, we can push down */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>groupedByPartitionColumn</name> <init>= <expr><call><name>GroupedByColumn</name><argument_list>(<argument><expr><name><name>opNode</name><operator>-&gt;</operator><name>groupClauseList</name></name></expr></argument>,
															<argument><expr><name><name>opNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
															<argument><expr><name>tablePartitionColumn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>groupedByPartitionColumn</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tableDistinctSupported</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tableDistinctSupported</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>distinctSupported</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>distinctSupported</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GroupedByColumn walks over group clauses in the given list, and checks if any
 * of the group clauses is on the given column.
 */</comment>
<function><type><name>bool</name></type>
<name>GroupedByColumn</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>groupedByColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>column</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>groupClause</argument>, <argument>groupClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>groupTargetEntry</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>groupExpression</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>groupTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>groupExpression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>groupColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>groupExpression</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>groupColumn</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>column</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
				<name><name>groupColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>column</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>groupedByColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>groupedByColumn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SubqueryMultiTableList extracts multi tables in the given logical plan tree
 * and returns subquery multi tables in a new list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>SubqueryMultiTableList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subqueryMultiTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>multiTableNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>T_MultiTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>multiTable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>multiTable</argument>, <argument>multiTableNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>multiTable</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>subquery</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subqueryMultiTableList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subqueryMultiTableList</name></expr></argument>, <argument><expr><name>multiTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>subqueryMultiTableList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GroupTargetEntryList walks over group clauses in the given list, finds
 * matching target entries and return them in a new list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GroupTargetEntryList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupTargetEntryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>groupClause</argument>, <argument>groupClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>groupTargetEntry</name> <init>=
			<expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>, <argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>groupTargetEntryList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>groupTargetEntryList</name></expr></argument>, <argument><expr><name>groupTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>groupTargetEntryList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsPartitionColumn returns true if the given column is a partition column.
 * The function uses FindReferencedTableColumn to find the original relation
 * id and column that the column expression refers to. It then checks whether
 * that column is a partition column of the relation.
 *
 * Also, the function returns always false for reference tables given that
 * reference tables do not have partition column. The function does not
 * support queries with CTEs, it would return false if columnExpression
 * refers to a column returned by a CTE.
 *
 * If skipOuterVars is true, then it doesn't process the outervars.
 */</comment>
<function><type><name>bool</name></type>
<name>IsPartitionColumn</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>columnExpression</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipOuterVars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isPartitionColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>relationRTE</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FindReferencedTableColumn</name><argument_list>(<argument><expr><name>columnExpression</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>column</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relationRTE</name></expr></argument>,
							  <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><ternary><condition><expr><name>relationRTE</name></expr> ?</condition><then> <expr><name><name>relationRTE</name><operator>-&gt;</operator><name>relid</name></name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name>column</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* not all distributed tables have partition column */</comment>
		<if_stmt><if>if <condition>(<expr><name>partitionColumn</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>column</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isPartitionColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>isPartitionColumn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindReferencedTableColumn recursively traverses query tree to find actual relation
 * id, and column that columnExpression refers to. If columnExpression is a
 * non-relational or computed/derived expression, the function returns NULL for
 * rte and NULL for column. The caller should provide parent query list from
 * top of the tree to this particular Query's parent. This argument is used to look
 * into CTEs that may be present in the query.
 *
 * If skipOuterVars is true, then it doesn't check vars coming from outer queries.
 * We probably don't need this skipOuterVars check but we wanted to be on the safe side
 * and used it only in UNION path, we can separately work on verifying that it doesn't break
 * anything existing.
 */</comment>
<function><type><name>void</name></type>
<name>FindReferencedTableColumn</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>columnExpression</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>parentQueryList</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
						  <parameter><decl><type><name>Var</name> <modifier>*</modifier><modifier>*</modifier></type><name>column</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>rteContainingReferencedColumn</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>skipOuterVars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>candidateColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>strippedColumnExpression</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>strip_implicit_coercions</name><argument_list>(
		<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>columnExpression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>rteContainingReferencedColumn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>column</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>strippedColumnExpression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>candidateColumn</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>strippedColumnExpression</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>strippedColumnExpression</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>compositeField</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>strippedColumnExpression</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>fieldExpression</name> <init>= <expr><name><name>compositeField</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>fieldExpression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>candidateColumn</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>fieldExpression</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>candidateColumn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>candidateColumn</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>skipOuterVars</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we don't want to process outer vars, so we return early.
			 */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We currently don't support finding partition keys in the subqueries
		 * that reference outer subqueries. For example, in correlated
		 * subqueries in WHERE clause, we don't support use of partition keys
		 * in the subquery that is referred from the outer query.
		 */</comment>

		<decl_stmt><decl><type><name>int</name></type> <name>parentQueryIndex</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>parentQueryList</name></expr></argument>)</argument_list></call> <operator>-</operator>
							   <name><name>candidateColumn</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsIndexInRange</name><argument_list>(<argument><expr><name>parentQueryList</name></expr></argument>, <argument><expr><name>parentQueryIndex</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Before we recurse into the query tree, we should update the candidateColumn and we use copy of it.
		 * As we get the query from varlevelsup up, we reset the varlevelsup.
		 */</comment>
		<expr_stmt><expr><name>candidateColumn</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>candidateColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>candidateColumn</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * We should be careful about these fields because they need to
		 * be updated correctly based on ctelevelsup and varlevelsup.
		 */</comment>
		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>parentQueryList</name></expr></argument>, <argument><expr><name>parentQueryIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentQueryList</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name>parentQueryList</name></expr></argument>, <argument><expr><name>parentQueryIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>candidateColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * varattno can be 0 in case of SELECT table FROM table, but that Var
		 * definitely does not correspond to a specific column.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangetableList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rangeTableEntryIndex</name> <init>= <expr><name><name>candidateColumn</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>rangetableList</name></expr></argument>, <argument><expr><name>rangeTableEntryIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>rteContainingReferencedColumn</name> <operator>=</operator> <name>rangeTableEntry</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>column</name> <operator>=</operator> <name>candidateColumn</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>targetEntryIndex</name> <init>= <expr><name><name>candidateColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>subqueryTargetEntry</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>, <argument><expr><name>targetEntryIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>subColumnExpression</name> <init>= <expr><name><name>subqueryTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* append current query to parent query list */</comment>
		<expr_stmt><expr><name>parentQueryList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>parentQueryList</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FindReferencedTableColumn</name><argument_list>(<argument><expr><name>subColumnExpression</name></expr></argument>, <argument><expr><name>parentQueryList</name></expr></argument>,
								  <argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>rteContainingReferencedColumn</name></expr></argument>,
								  <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinColumnList</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>joinColumnIndex</name> <init>= <expr><name><name>candidateColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>joinColumn</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>joinColumnList</name></expr></argument>, <argument><expr><name>joinColumnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* parent query list stays the same since still in the same query boundary */</comment>
		<expr_stmt><expr><call><name>FindReferencedTableColumn</name><argument_list>(<argument><expr><name>joinColumn</name></expr></argument>, <argument><expr><name>parentQueryList</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>column</name></expr></argument>,
								  <argument><expr><name>rteContainingReferencedColumn</name></expr></argument>, <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When outerVars are considered, we modify parentQueryList, so this
		 * logic might need to change when we support outervars in CTEs.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>cteParentListIndex</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>parentQueryList</name></expr></argument>)</argument_list></call> <operator>-</operator>
								 <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>cteParentQuery</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cteList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * This should have been an error case, not marking it as error at the
		 * moment due to usage from IsPartitionColumn. Callers of that function
		 * do not have access to parent query list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsIndexInRange</name><argument_list>(<argument><expr><name>parentQueryList</name></expr></argument>, <argument><expr><name>cteParentListIndex</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cteParentQuery</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>parentQueryList</name></expr></argument>, <argument><expr><name>cteParentListIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cteList</name> <operator>=</operator> <name><name>cteParentQuery</name><operator>-&gt;</operator><name>cteList</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>candidateCte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>candidateCte</argument>, <argument>cteList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>candidateCte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cte</name> <operator>=</operator> <name>candidateCte</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>cte</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>cteQuery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>cteQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>targetEntryIndex</name> <init>= <expr><name><name>candidateColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>, <argument><expr><name>targetEntryIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>parentQueryList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>parentQueryList</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FindReferencedTableColumn</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>parentQueryList</name></expr></argument>,
									  <argument><expr><name>cteQuery</name></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><name>rteContainingReferencedColumn</name></expr></argument>,
									  <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsIndexInRange returns true if the given index is within the
 * range of the given list.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsIndexInRange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractQueryWalker walks over a query, and finds all queries in the query
 * tree and returns these queries. Note that the function also recurses into
 * the subqueries in WHERE clause.
 */</comment>
<function><type><name>bool</name></type>
<name>ExtractQueryWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>queryList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>queryList</name><operator>)</operator> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>queryList</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>ExtractQueryWalker</name></expr></argument>, <argument><expr><name>queryList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ExtractQueryWalker</name></expr></argument>, <argument><expr><name>queryList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerLimitCount checks if the given input contains a valid limit node, and
 * if that node can be pushed down. For this, the function checks if this limit
 * count or a meaningful approximation of it can be pushed down to worker nodes.
 * If they can, the function returns the limit count.
 *
 * The limit push-down decision tree is as follows:
 *                                         group by?
 *                                       1/         \0
 *                       group by partition column?   (exact pd)
 *                              0/         \1
 *                          order by?        (exact pd)
 *                       1/           \0
 *           has order by agg?          (no pd)
 *            1/           \0
 *     can approximate?    (exact pd)
 *      1/       \0
 * (approx pd)   (no pd)
 *
 * When an offset is present, the offset value is added to limit because for a query
 * with LIMIT x OFFSET y, (x+y) records should be pulled from the workers.
 *
 * If no limit is present or can be pushed down, then WorkerLimitCount
 * returns null.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>WorkerLimitCount</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name></decl></parameter>, <parameter><decl><type><name>OrderByLimitReference</name></type>
				 <name>orderByLimitReference</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>workerLimitNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LimitPushdownable</name></type> <name>canPushDownLimit</name> <init>= <expr><name>LIMIT_CANNOT_PUSHDOWN</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>limitCount</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no limit node to push down */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We only push down constant LIMIT clauses to make sure we get back
		 * the minimum number of rows.
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>limitOffset</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If OFFSET is not a constant then we cannot calculate the LIMIT to
		 * push down.
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * If window functions are computed on coordinator, we cannot push down LIMIT.
	 * If we don't have group by clauses, or we have group by partition column,
	 * or if we have order by clauses without aggregates, we can push down the
	 * original limit. Else if we have order by clauses with commutative aggregates,
	 * we can push down approximate limits.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>orderByLimitReference</name><operator>.</operator><name>onlyPushableWindowFunctions</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>canPushDownLimit</name> <operator>=</operator> <name>LIMIT_CANNOT_PUSHDOWN</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>orderByLimitReference</name><operator>.</operator><name>groupClauseIsEmpty</name></name> <operator>||</operator>
			 <name><name>orderByLimitReference</name><operator>.</operator><name>groupedByDisjointPartitionColumn</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>canPushDownLimit</name> <operator>=</operator> <name>LIMIT_CAN_PUSHDOWN</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>orderByLimitReference</name><operator>.</operator><name>sortClauseIsEmpty</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>canPushDownLimit</name> <operator>=</operator> <name>LIMIT_CANNOT_PUSHDOWN</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>orderByLimitReference</name><operator>.</operator><name>hasOrderByAggregate</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>canPushDownLimit</name> <operator>=</operator> <name>LIMIT_CAN_PUSHDOWN</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>orderByLimitReference</name><operator>.</operator><name>canApproximate</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>canPushDownLimit</name> <operator>=</operator> <name>LIMIT_CAN_APPROXIMATE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* create the workerLimitNode according to the decisions above */</comment>
	<if_stmt><if>if <condition>(<expr><name>canPushDownLimit</name> <operator>==</operator> <name>LIMIT_CAN_PUSHDOWN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>workerLimitNode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>canPushDownLimit</name> <operator>==</operator> <name>LIMIT_CAN_APPROXIMATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>workerLimitConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>workerLimitCount</name> <init>= <expr><operator>(</operator><name>int64</name><operator>)</operator> <name>LimitClauseRowFetchCount</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>workerLimitConst</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>workerLimitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>workerLimitNode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>workerLimitConst</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If offset clause is present and limit can be pushed down (whether exactly or
	 * approximately), add the offset value to limit on workers
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>workerLimitNode</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>limitOffset</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>workerLimitConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>workerLimitNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>workerOffsetConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>limitOffset</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>workerLimitCount</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>workerLimitConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>workerOffsetCount</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>workerOffsetConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>workerLimitCount</name> <operator>=</operator> <name>workerLimitCount</name> <operator>+</operator> <name>workerOffsetCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>workerLimitNode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>MakeIntegerConstInt64</name><argument_list>(<argument><expr><name>workerLimitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* display debug message on limit push down */</comment>
	<if_stmt><if>if <condition>(<expr><name>workerLimitNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>workerLimitConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>workerLimitNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>workerLimitCount</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>workerLimitConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"push down of limit count: "</literal> <name>INT64_FORMAT</name></expr></argument>,
								<argument><expr><name>workerLimitCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>workerLimitNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerSortClauseList first checks if the given input contains a limit
 * or hasDistinctOn that can be pushed down. If it does, the function then
 * checks if we need to add any sorting and grouping clauses to the sort list we
 * push down for the limit. If we do, the function adds these clauses and
 * returns them. Otherwise, the function returns null.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>WorkerSortClauseList</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>,
					 <parameter><decl><type><name>OrderByLimitReference</name></type> <name>orderByLimitReference</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerSortClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if no limit node and no hasDistinctOn, no need to push down sort clauses */</comment>
	<if_stmt><if>if <condition>(<expr><name>limitCount</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>orderByLimitReference</name><operator>.</operator><name>hasDistinctOn</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If window functions are computed on coordinator, we cannot push down sorting. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>orderByLimitReference</name><operator>.</operator><name>onlyPushableWindowFunctions</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>sortClauseList</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>sortClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are pushing down the limit, push down any order by clauses. Also if
	 * we are pushing down the limit because the order by clauses don't have any
	 * aggregates, add group by clauses to the order by list. We do this because
	 * rows that belong to the same grouping may appear in different "offsets"
	 * in different task results. By ordering on the group by clause, we ensure
	 * that query results are consistent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>orderByLimitReference</name><operator>.</operator><name>groupClauseIsEmpty</name></name> <operator>||</operator>
		<name><name>orderByLimitReference</name><operator>.</operator><name>groupedByDisjointPartitionColumn</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>workerSortClauseList</name> <operator>=</operator> <name>sortClauseList</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>sortClauseList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>orderByNonAggregates</name> <init>= <expr><operator>!</operator><name><name>orderByLimitReference</name><operator>.</operator><name>hasOrderByAggregate</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>canApproximate</name> <init>= <expr><name><name>orderByLimitReference</name><operator>.</operator><name>canApproximate</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>orderByNonAggregates</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>workerSortClauseList</name> <operator>=</operator> <name>sortClauseList</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>workerSortClauseList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>workerSortClauseList</name></expr></argument>, <argument><expr><name>groupClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>canApproximate</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>workerSortClauseList</name> <operator>=</operator> <name>sortClauseList</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>workerSortClauseList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CanPushDownLimitApproximate checks if we can push down the limit clause to
 * the worker nodes, and get approximate and meaningful results. We can do this
 * only when: (1) the user has enabled the limit approximation and (2) the query
 * has order by clauses that are commutative.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CanPushDownLimitApproximate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>canApproximate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* user hasn't enabled the limit approximation */</comment>
	<if_stmt><if>if <condition>(<expr><name>LimitClauseRowFetchCount</name> <operator>==</operator> <name>DISABLE_LIMIT_APPROXIMATION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sortClauseList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>orderByNonCommutativeAggregate</name> <init>=
			<expr><call><name>HasOrderByNonCommutativeAggregate</name><argument_list>(<argument><expr><name>sortClauseList</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>orderByComplex</name> <init>= <expr><call><name>HasOrderByComplexExpression</name><argument_list>(<argument><expr><name>sortClauseList</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>orderByNonCommutativeAggregate</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>orderByComplex</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>canApproximate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>canApproximate</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasOrderByAggregate walks over the given order by clauses, and checks if we
 * have an order by an aggregate function. If we do, the function returns true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasOrderByAggregate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasOrderByAggregate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>sortClause</argument>, <argument>sortClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>sortExpression</name> <init>= <expr><call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>containsAggregate</name> <init>= <expr><call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><name>sortExpression</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>containsAggregate</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasOrderByAggregate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>hasOrderByAggregate</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasOrderByNonCommutativeAggregate walks over the given order by clauses,
 * and checks if we have an order by an aggregate which is not commutative.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasOrderByNonCommutativeAggregate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasOrderByNonCommutativeAggregate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>sortClause</argument>, <argument>sortClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>sortExpression</name> <init>= <expr><call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if sort expression is an aggregate, check its type */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>sortExpression</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggregate</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>sortExpression</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>AggregateType</name></type> <name>aggregateType</name> <init>= <expr><call><name>GetAggregateType</name><argument_list>(<argument><expr><name>aggregate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_MIN</name> <operator>&amp;&amp;</operator>
				<name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_MAX</name> <operator>&amp;&amp;</operator>
				<name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_SUM</name> <operator>&amp;&amp;</operator>
				<name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_COUNT</name> <operator>&amp;&amp;</operator>
				<name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_BIT_AND</name> <operator>&amp;&amp;</operator>
				<name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_BIT_OR</name> <operator>&amp;&amp;</operator>
				<name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_EVERY</name> <operator>&amp;&amp;</operator>
				<name>aggregateType</name> <operator>!=</operator> <name>AGGREGATE_ANY_VALUE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>hasOrderByNonCommutativeAggregate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>hasOrderByNonCommutativeAggregate</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasOrderByComplexExpression walks over the given order by clauses, and checks
 * if we have a nested expression that contains an aggregate function within it.
 * If we do, the function returns true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasOrderByComplexExpression</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasOrderByComplexExpression</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>sortClause</argument>, <argument>sortClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>sortExpression</name> <init>= <expr><call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* simple aggregate functions are ok */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>sortExpression</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>nestedAggregate</name> <init>= <expr><call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><name>sortExpression</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>nestedAggregate</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasOrderByComplexExpression</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>hasOrderByComplexExpression</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasOrderByHllType walks over the given order by clauses, and checks if any of
 * those clauses operate on hll data type. If they do, the function returns true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasOrderByHllType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasOrderByHllType</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check whether HLL is loaded */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>hllId</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name>HLL_EXTENSION_NAME</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>hllId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>hasOrderByHllType</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>hllSchemaOid</name> <init>= <expr><call><name>get_extension_schema</name><argument_list>(<argument><expr><name>hllId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>hllTypeId</name> <init>= <expr><call><name>TypeOid</name><argument_list>(<argument><expr><name>hllSchemaOid</name></expr></argument>, <argument><expr><name>HLL_TYPE_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>sortClause</argument>, <argument>sortClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>sortExpression</name> <init>= <expr><call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>sortColumnTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>sortExpression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>sortColumnTypeId</name> <operator>==</operator> <name>hllTypeId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasOrderByHllType</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>hasOrderByHllType</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldProcessDistinctOrderAndLimitForWorker returns whether
 * ProcessDistinctClauseForWorkerQuery should be called. If not,
 * neither should ProcessLimitOrderByForWorkerQuery.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldProcessDistinctOrderAndLimitForWorker</name><parameter_list>(
	<parameter><decl><type><name>ExtendedOpNodeProperties</name> <modifier>*</modifier></type><name>extendedOpNodeProperties</name></decl></parameter>,
	<parameter><decl><type><name>bool</name></type> <name>pushingDownOriginalGrouping</name></decl></parameter>,
	<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>pullUpIntermediateRows</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* window functions must be evaluated beforehand */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>onlyPushableWindowFunctions</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>extendedOpNodeProperties</name><operator>-&gt;</operator><name>pushDownGroupingAndHaving</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If the same GROUP BY is being pushed down and there's no HAVING,
	 * then the push down logic will be able to handle this scenario.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pushingDownOriginalGrouping</name> <operator>&amp;&amp;</operator> <name>havingQual</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerColumnName returns a palloc'd string for being the resname of a TargetEntry.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>WorkerColumnName</name><parameter_list>(<parameter><decl><type><name>AttrNumber</name></type> <name>resno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>name</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><name>WORKER_COLUMN_FORMAT</name></expr></argument>, <argument><expr><name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>name</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsGroupBySubsetOfDistinct checks whether each clause in group clauses also
 * exists in the distinct clauses. Note that, empty group clause is not a subset
 * of distinct clause.
 */</comment>
<function><type><name>bool</name></type>
<name>IsGroupBySubsetOfDistinct</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* There must be a group clause */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>groupClause</argument>, <argument>groupClauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>distinctClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>distinctClause</argument>, <argument>distinctClauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>groupClause</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <name><name>distinctClause</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>isFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If we can't find any member of group clause in the distinct clause,
		 * that means group clause is not a subset of distinct clause.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isFound</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
