<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/planner/multi_logical_planner.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * multi_logical_planner.c
 *
 * Routines for constructing a logical plan tree from the given Query tree
 * structure. This new logical plan is based on multi-relational algebra rules.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_restriction_equivalence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_pushdown_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>


<comment type="block">/* Struct to differentiate different qualifier types in an expression tree walker */</comment>
<typedef>typedef <type><struct>struct <name>QualifierWalkerContext</name>
<block>{
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>baseQualifierList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>outerJoinQualifierList</name></decl>;</decl_stmt>
}</block></struct></type> <name>QualifierWalkerContext</name>;</typedef>


<comment type="block">/* Function pointer type definition for apply join rule functions */</comment>
<typedef>typedef <function_decl><type><name>MultiNode</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>RuleApplyFunction</name>) <parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauses</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>CheckNodeFunc</name>)<parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>RuleApplyFunction</name></type> <name><name>RuleApplyFunctionArray</name><index>[<expr><name>JOIN_RULE_LAST</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt> <comment type="block">/* join rules */</comment>

<comment type="block">/* Local functions forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>FieldSelect</name> <modifier>*</modifier></type> <name>CompositeFieldRecursive</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>NodeTryGetRteRelid</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FullCompositeFieldList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>compositeFieldList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasUnsupportedJoinWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ErrorHintRequired</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorHint</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasComplexRangeTableType</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsReadIntermediateResultFunction</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsReadIntermediateResultArrayFunction</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsCitusExtraDataContainerFunc</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsFunctionWithOid</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsGroupingFunc</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExtractFromExpressionWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										<parameter><decl><type><name>QualifierWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>MultiTableNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableEntryList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>AddMultiCollectNodes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNodeList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>MultiJoinTree</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrderList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>collectTableList</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiCollect</name> <modifier>*</modifier></type> <name>CollectNodeForTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>collectTableList</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>rangeTableId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiSelect</name> <modifier>*</modifier></type> <name>MultiSelectNode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsSelectClause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Local functions forward declarations for applying joins */</comment>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>ApplyJoinRule</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
								 <parameter><decl><type><name>JoinRuleType</name></type> <name>ruleType</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>,
								 <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RuleApplyFunction</name></type> <name>JoinRuleApplyFunction</name><parameter_list>(<parameter><decl><type><name>JoinRuleType</name></type> <name>ruleType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>ApplyReferenceJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
									  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
									  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>ApplyLocalJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>ApplySingleRangePartitionJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>,
												 <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>,
												 <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>ApplySingleHashPartitionJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>,
												<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
												<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>,
												<parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
												<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiJoin</name> <modifier>*</modifier></type> <name>ApplySinglePartitionJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>ApplyDualPartitionJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
										  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
										  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>ApplyCartesianProductReferenceJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>,
													  <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
													  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>,
													  <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
													  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>ApplyCartesianProduct</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauses</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * MultiLogicalPlanCreate takes in both the original query and its corresponding modified
 * query tree yield by the standard planner. It uses helper functions to create logical
 * plan and adds a root node to top of it. The original query is only used for subquery
 * pushdown planning.
 *
 * We also pass queryTree and plannerRestrictionContext to the planner. They
 * are primarily used to decide whether the subquery is safe to pushdown.
 * If not, it helps to produce meaningful error messages for subquery
 * pushdown planning.
 */</comment>
<function><type><name>MultiTreeRoot</name> <modifier>*</modifier></type>
<name>MultiLogicalPlanCreate</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>,
					   <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiQueryNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><call><name>ShouldUseSubqueryPushDown</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>queryTree</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>multiQueryNode</name> <operator>=</operator> <call><name>SubqueryMultiNodeTree</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>queryTree</name></expr></argument>,
											   <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>multiQueryNode</name> <operator>=</operator> <call><name>MultiNodeTree</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* add a root node to serve as the permanent handle to the tree */</comment>
	<decl_stmt><decl><type><name>MultiTreeRoot</name> <modifier>*</modifier></type><name>rootNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiTreeRoot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>rootNode</name></expr></argument>, <argument><expr><name>multiQueryNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rootNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindNodeMatchingCheckFunction finds a node for which the checker function returns true.
 *
 * To call this function directly with an RTE, use:
 * range_table_walker(rte, FindNodeMatchingCheckFunction, checker, QTW_EXAMINE_RTES_BEFORE)
 */</comment>
<function><type><name>bool</name></type>
<name>FindNodeMatchingCheckFunction</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>CheckNodeFunc</name></type> <name>checker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>checker</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* query_tree_walker descends into RTEs */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>FindNodeMatchingCheckFunction</name></expr></argument>, <argument><expr><name>checker</name></expr></argument>,
								 <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FindNodeMatchingCheckFunction</name></expr></argument>, <argument><expr><name>checker</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TargetListOnPartitionColumn checks if at least one target list entry is on
 * partition column.
 */</comment>
<function><type><name>bool</name></type>
<name>TargetListOnPartitionColumn</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>targetListOnPartitionColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>compositeFieldList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>targetEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>targetEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>targetExpression</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>skipOuterVars</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isPartitionColumn</name> <init>= <expr><call><name>IsPartitionColumn</name><argument_list>(<argument><expr><name>targetExpression</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
												   <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FindReferencedTableColumn</name><argument_list>(<argument><expr><name>targetExpression</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>column</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rte</name></expr></argument>,
								  <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><ternary><condition><expr><name>rte</name></expr> ?</condition><then> <expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the expression belongs to a non-distributed table continue searching for
		 * other partition keys.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* append-distributed tables do not have a strict partition column */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>isPartitionColumn</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>compositeField</name> <init>= <expr><call><name>CompositeFieldRecursive</name><argument_list>(<argument><expr><name>targetExpression</name></expr></argument>,
																  <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>compositeField</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>compositeFieldList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>compositeFieldList</name></expr></argument>, <argument><expr><name>compositeField</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>targetListOnPartitionColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* check composite fields */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetListOnPartitionColumn</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>fullCompositeFieldList</name> <init>= <expr><call><name>FullCompositeFieldList</name><argument_list>(<argument><expr><name>compositeFieldList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>fullCompositeFieldList</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>targetListOnPartitionColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We could still behave as if the target list is on partition column if
	 * range table entries don't contain a distributed table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetListOnPartitionColumn</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
														   <argument><expr><name>IsDistributedTableRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>targetListOnPartitionColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>targetListOnPartitionColumn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindNodeMatchingCheckFunctionInRangeTableList finds a node for which the checker
 * function returns true.
 *
 * FindNodeMatchingCheckFunctionInRangeTableList relies on
 * FindNodeMatchingCheckFunction() but only considers the range table entries.
 */</comment>
<function><type><name>bool</name></type>
<name>FindNodeMatchingCheckFunctionInRangeTableList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>, <parameter><decl><type><name>CheckNodeFunc</name></type> <name>checker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>range_table_walker</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>, <argument><expr><name>FindNodeMatchingCheckFunction</name></expr></argument>, <argument><expr><name>checker</name></expr></argument>,
							  <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeTryGetRteRelid returns the relid of the given RTE_RELATION RangeTableEntry.
 * Returns InvalidOid if any of these assumptions fail for given node.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>NodeTryGetRteRelid</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusTableRTE gets a node and returns true if the node is a
 * range table relation entry that points to a distributed relation.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusTableRTE</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>NodeTryGetRteRelid</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>relationId</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsDistributedOrReferenceTableRTE returns true if the given node
 * is eeither a distributed(hash/range/append) or reference table.
 */</comment>
<function><type><name>bool</name></type>
<name>IsDistributedOrReferenceTableRTE</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>NodeTryGetRteRelid</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsDistributedTableRTE gets a node and returns true if the node
 * is a range table relation entry that points to a distributed relation,
 * returning false still if the relation is a reference table.
 */</comment>
<function><type><name>bool</name></type>
<name>IsDistributedTableRTE</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>NodeTryGetRteRelid</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>relationId</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsReferenceTableRTE gets a node and returns true if the node
 * is a range table relation entry that points to a reference table.
 */</comment>
<function><type><name>bool</name></type>
<name>IsReferenceTableRTE</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>NodeTryGetRteRelid</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>relationId</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FullCompositeFieldList gets a composite field list, and checks if all fields
 * of composite type are used in the list.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FullCompositeFieldList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>compositeFieldList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>fullCompositeFieldList</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>compositeFieldArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>compositeFieldCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>fieldSelectCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>fieldSelectCell</argument>, <argument>compositeFieldList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fieldSelect</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fieldSelectCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>fieldExpression</name> <init>= <expr><name><name>fieldSelect</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>fieldExpression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>compositeFieldArray</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>compositeColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>fieldExpression</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>compositeTypeId</name> <init>= <expr><name><name>compositeColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>compositeRelationId</name> <init>= <expr><call><name>get_typ_typrelid</name><argument_list>(<argument><expr><name>compositeTypeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* get composite type attribute count */</comment>
			<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>compositeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>compositeFieldCount</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>compositeFieldArray</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>compositeFieldCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><decl><type><name>uint32</name></type> <name>compositeFieldIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init>
				 <condition><expr><name>compositeFieldIndex</name> <operator>&lt;</operator> <name>compositeFieldCount</name></expr>;</condition>
				 <incr><expr><name>compositeFieldIndex</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>compositeFieldArray</name><index>[<expr><name>compositeFieldIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>uint32</name></type> <name>compositeFieldIndex</name> <init>= <expr><name><name>fieldSelect</name><operator>-&gt;</operator><name>fieldnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>compositeFieldArray</name><index>[<expr><name>compositeFieldIndex</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>

	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>fieldIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>fieldIndex</name> <operator>&lt;</operator> <name>compositeFieldCount</name></expr>;</condition> <incr><expr><name>fieldIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>compositeFieldArray</name><index>[<expr><name>fieldIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fullCompositeFieldList</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>compositeFieldCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fullCompositeFieldList</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>fullCompositeFieldList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompositeFieldRecursive recursively finds composite field in the query tree
 * referred by given expression. If expression does not refer to a composite
 * field, then it returns NULL.
 *
 * If expression is a field select we directly return composite field. If it is
 * a column is referenced from a subquery, then we recursively check that subquery
 * until we reach the source of that column, and find composite field. If this
 * column is referenced from join range table entry, then we resolve which join
 * column it refers and recursively use this column with the same query.
 */</comment>
<function><type><specifier>static</specifier> <name>FieldSelect</name> <modifier>*</modifier></type>
<name>CompositeFieldRecursive</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>compositeField</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangetableList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>candidateColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>compositeField</name> <operator>=</operator> <operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr>;</expr_stmt>
		<return>return <expr><name>compositeField</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>candidateColumn</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>Index</name></type> <name>rangeTableEntryIndex</name> <init>= <expr><name><name>candidateColumn</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>rangetableList</name></expr></argument>, <argument><expr><name>rangeTableEntryIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>targetEntryIndex</name> <init>= <expr><name><name>candidateColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>subqueryTargetEntry</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>, <argument><expr><name>targetEntryIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>subqueryExpression</name> <init>= <expr><name><name>subqueryTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>compositeField</name> <operator>=</operator> <call><name>CompositeFieldRecursive</name><argument_list>(<argument><expr><name>subqueryExpression</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinColumnList</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>joinColumnIndex</name> <init>= <expr><name><name>candidateColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>joinColumn</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>joinColumnList</name></expr></argument>, <argument><expr><name>joinColumnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>compositeField</name> <operator>=</operator> <call><name>CompositeFieldRecursive</name><argument_list>(<argument><expr><name>joinColumn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>compositeField</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SubqueryEntryList finds the subquery nodes in the range table entry list, and
 * builds a list of subquery range table entries from these subquery nodes. Range
 * table entry list also includes subqueries which are pulled up. We don't want
 * to add pulled up subqueries to list, so we walk over join tree indexes and
 * check range table entries referenced in the join tree.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>SubqueryEntryList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subqueryEntryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinTreeTableIndexList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinTreeTableIndexCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Extract all range table indexes from the join tree. Note that here we
	 * only walk over range table entries at this level and do not recurse into
	 * subqueries.
	 */</comment>
	<expr_stmt><expr><call><name>ExtractRangeTableIndexWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>joinTreeTableIndexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>joinTreeTableIndexCell</argument>, <argument>joinTreeTableIndexList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Join tree's range table index starts from 1 in the query tree. But,
		 * list indexes start from 0.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>joinTreeTableIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>joinTreeTableIndexCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rangeTableListIndex</name> <init>= <expr><name>joinTreeTableIndex</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>=
			<expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>rangeTableListIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subqueryEntryList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subqueryEntryList</name></expr></argument>, <argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>subqueryEntryList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MultiNodeTree takes in a parsed query tree and uses that tree to construct a
 * logical plan. This plan is based on multi-relational algebra. This function
 * creates the logical plan in several steps.
 *
 * First, the function checks if there is a subquery. If there is a subquery
 * it recursively creates nested multi trees. If this query has a subquery, the
 * function does not create any join trees and jumps to last step.
 *
 * If there is no subquery, the function calculates the join order using tables
 * in the query and join clauses between the tables. Second, the function
 * starts building the logical plan from the bottom-up, and begins with the table
 * and collect nodes. Third, the function builds the join tree using the join
 * order information and table nodes.
 *
 * In the last step, the function adds the select, project, aggregate, sort,
 * group, and limit nodes if they appear in the original query tree.
 */</comment>
<function><type><name>MultiNode</name> <modifier>*</modifier></type>
<name>MultiNodeTree</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrderList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableEntryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>collectTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>joinTreeNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>currentTopNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* verify we can perform distributed planning on this query */</comment>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>unsupportedQueryError</name> <init>= <expr><call><name>DeferErrorIfQueryNotSupported</name><argument_list>(
		<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>unsupportedQueryError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>unsupportedQueryError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extract where clause qualifiers and verify we can plan for them */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name> <init>= <expr><call><name>WhereClauseList</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>unsupportedQueryError</name> <operator>=</operator> <call><name>DeferErrorIfUnsupportedClause</name><argument_list>(<argument><expr><name>whereClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>unsupportedQueryError</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RaiseDeferredErrorInternal</name><argument_list>(<argument><expr><name>unsupportedQueryError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have a subquery, build a multi table node for the subquery and
	 * add a collect node on top of the multi table node.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subqueryEntryList</name> <init>= <expr><call><name>SubqueryEntryList</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>subqueryEntryList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>subqueryCollectNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>columnCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we only support single subquery in the entry list */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>subqueryEntryList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subqueryRangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(
			<argument><expr><name>subqueryEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subqueryTree</name> <init>= <expr><name><name>subqueryRangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ensure if subquery satisfies preconditions */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>DeferErrorIfUnsupportedSubqueryRepartition</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>subqueryNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>subqueryNode</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name>SUBQUERY_RELATION_ID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subqueryNode</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>=</operator> <name>SUBQUERY_RANGE_TABLE_ID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subqueryNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subqueryNode</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subqueryNode</name><operator>-&gt;</operator><name>referenceNames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We disregard pulled subqueries. This changes order of range table list.
		 * We do not allow subquery joins, so we will have only one range table
		 * entry in range table list after dropping pulled subquery. For this
		 * reason, here we are updating columns in the most outer query for where
		 * clause list and target list accordingly.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>subqueryEntryList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseColumnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>whereClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetListColumnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>whereClauseColumnList</name></expr></argument>, <argument><expr><name>targetListColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>columnCell</argument>, <argument>columnList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>columnCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* recursively create child nested multitree */</comment>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>subqueryExtendedNode</name> <init>= <expr><call><name>MultiNodeTree</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>subqueryCollectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>subqueryNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>subqueryNode</name></expr></argument>, <argument><expr><name>subqueryExtendedNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>currentTopNode</name> <operator>=</operator> <operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>subqueryCollectNode</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We calculate the join order using the list of tables in the query and
		 * the join clauses between them. Note that this function owns the table
		 * entry list's memory, and JoinOrderList() shallow copies the list's
		 * elements.
		 */</comment>
		<expr_stmt><expr><name>joinClauseList</name> <operator>=</operator> <call><name>JoinClauseList</name><argument_list>(<argument><expr><name>whereClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tableEntryList</name> <operator>=</operator> <call><name>UsedTableEntryList</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build the list of multi table nodes */</comment>
		<expr_stmt><expr><name>tableNodeList</name> <operator>=</operator> <call><name>MultiTableNodeList</name><argument_list>(<argument><expr><name>tableEntryList</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* add collect nodes on top of the multi table nodes */</comment>
		<expr_stmt><expr><name>collectTableList</name> <operator>=</operator> <call><name>AddMultiCollectNodes</name><argument_list>(<argument><expr><name>tableNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* find best join order for commutative inner joins */</comment>
		<expr_stmt><expr><name>joinOrderList</name> <operator>=</operator> <call><name>JoinOrderList</name><argument_list>(<argument><expr><name>tableEntryList</name></expr></argument>, <argument><expr><name>joinClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build join tree using the join order and collected tables */</comment>
		<expr_stmt><expr><name>joinTreeNode</name> <operator>=</operator> <call><name>MultiJoinTree</name><argument_list>(<argument><expr><name>joinOrderList</name></expr></argument>, <argument><expr><name>collectTableList</name></expr></argument>, <argument><expr><name>joinClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>currentTopNode</name> <operator>=</operator> <name>joinTreeNode</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>currentTopNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build select node if the query has selection criteria */</comment>
	<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name> <init>= <expr><call><name>MultiSelectNode</name><argument_list>(<argument><expr><name>whereClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>selectNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>selectNode</name></expr></argument>, <argument><expr><name>currentTopNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>currentTopNode</name> <operator>=</operator> <operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>selectNode</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* build project node for the columns to project */</comment>
	<decl_stmt><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>projectNode</name> <init>= <expr><call><name>MultiProjectNode</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>projectNode</name></expr></argument>, <argument><expr><name>currentTopNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentTopNode</name> <operator>=</operator> <operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>projectNode</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We build the extended operator node to capture aggregate functions, group
	 * clauses, sort clauses, limit/offset clauses, and expressions. We need to
	 * distinguish between aggregates and expressions; and we address this later
	 * in the logical optimizer.
	 */</comment>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOpNode</name> <init>= <expr><call><name>MultiExtendedOpNode</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>, <argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>extendedOpNode</name></expr></argument>, <argument><expr><name>currentTopNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentTopNode</name> <operator>=</operator> <operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>extendedOpNode</name></expr>;</expr_stmt>

	<return>return <expr><name>currentTopNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsReadIntermediateResultFunction determines whether an expresion tree contains
 * a call to the read_intermediate_result function.
 */</comment>
<function><type><name>bool</name></type>
<name>ContainsReadIntermediateResultFunction</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IsReadIntermediateResultFunction</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsReadIntermediateResultArrayFunction determines whether an expresion
 * tree contains a call to the read_intermediate_results(result_ids, format)
 * function.
 */</comment>
<function><type><name>bool</name></type>
<name>ContainsReadIntermediateResultArrayFunction</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IsReadIntermediateResultArrayFunction</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsReadIntermediateResultFunction determines whether a given node is a function call
 * to the read_intermediate_result function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsReadIntermediateResultFunction</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsFunctionWithOid</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><call><name>CitusReadIntermediateResultFuncId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsReadIntermediateResultArrayFunction determines whether a given node is a
 * function call to the read_intermediate_results(result_ids, format) function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsReadIntermediateResultArrayFunction</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsFunctionWithOid</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><call><name>CitusReadIntermediateResultArrayFuncId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusExtraDataContainerRelation determines whether a range table entry contains a
 * call to the citus_extradata_container function.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCitusExtraDataContainerRelation</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_FUNCTION</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* avoid more expensive checks below for non-functions */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>,
										 <argument><expr><name>IsCitusExtraDataContainerFunc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCitusExtraDataContainerFunc determines whether a given node is a function call
 * to the citus_extradata_container function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsCitusExtraDataContainerFunc</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsFunctionWithOid</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><call><name>CitusExtraDataContainerFuncId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsFunctionWithOid determines whether a given node is a function call
 * to the read_intermediate_result function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsFunctionWithOid</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcExpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>==</operator> <name>funcOid</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsGroupingFunc returns whether node is a GroupingFunc.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsGroupingFunc</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindIntermediateResultIdIfExists extracts the id of the intermediate result
 * if the given RTE contains a read_intermediate_results function, NULL otherwise
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>FindIntermediateResultIdIfExists</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionList</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rangeTblfunction</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>functionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcExpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rangeTblfunction</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsReadIntermediateResultFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>funcExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultIdConst</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>resultIdConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>resultId</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>resultId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfQueryNotSupported checks that we can perform distributed planning for
 * the given query. The checks in this function will be removed as we support
 * more functionality in our distributed planning.
 */</comment>
<function><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfQueryNotSupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errorMessage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>preconditionsSatisfied</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorHint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>joinHint</name> <init>= <expr><literal type="string">"Consider joining tables on partition column and have "</literal>
						   <literal type="string">"equal filter on joining columns."</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filterHint</name> <init>= <expr><literal type="string">"Consider using an equality filter on the distributed "</literal>
							 <literal type="string">"table's partition column."</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"could not run distributed query with UNION, INTERSECT, or "</literal>
					   <literal type="string">"EXCEPT"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorHint</name> <operator>=</operator> <name>filterHint</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>hasRecursive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"could not run distributed query with RECURSIVE"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorHint</name> <operator>=</operator> <name>filterHint</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"could not run distributed query with common table expressions"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorHint</name> <operator>=</operator> <name>filterHint</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>hasForUpdate</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"could not run distributed query with FOR UPDATE/SHARE commands"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorHint</name> <operator>=</operator> <name>filterHint</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"could not run distributed query with GROUPING SETS, CUBE, "</literal>
					   <literal type="string">"or ROLLUP"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorHint</name> <operator>=</operator> <name>filterHint</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>queryTree</name></expr></argument>, <argument><expr><name>IsGroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"could not run distributed query with GROUPING"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorHint</name> <operator>=</operator> <name>filterHint</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>hasUnsupportedJoin</name> <init>= <expr><call><name>HasUnsupportedJoinWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
													   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasUnsupportedJoin</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"could not run distributed query with join types other than "</literal>
					   <literal type="string">"INNER or OUTER JOINS"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorHint</name> <operator>=</operator> <name>joinHint</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>hasComplexRangeTableType</name> <init>= <expr><call><name>HasComplexRangeTableType</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasComplexRangeTableType</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"could not run distributed query with complex table expressions"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorHint</name> <operator>=</operator> <name>filterHint</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>IsNodeSubquery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"subquery in LIMIT is not supported in multi-shard queries"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>IsNodeSubquery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"subquery in OFFSET is not supported in multi-shard queries"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RTEListProperties</name> <modifier>*</modifier></type><name>queryRteListProperties</name> <init>= <expr><call><name>GetRTEListPropertiesForQuery</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>queryRteListProperties</name><operator>-&gt;</operator><name>hasCitusLocalTable</name></name> <operator>||</operator>
		<name><name>queryRteListProperties</name><operator>-&gt;</operator><name>hasPostgresLocalTable</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <literal type="string">"direct joins between distributed and local tables are "</literal>
					   <literal type="string">"not supported"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorHint</name> <operator>=</operator> <name>LOCAL_TABLE_SUBQUERY_CTE_HINT</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finally check and error out if not satisfied */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preconditionsSatisfied</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>showHint</name> <init>= <expr><call><name>ErrorHintRequired</name><argument_list>(<argument><expr><name>errorHint</name></expr></argument>, <argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>showHint</name></expr> ?</condition><then> <expr><name>errorHint</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasUnsupportedJoinWalker returns tree if the query contains an unsupported
 * join type. We currently support inner, left, right, full and anti joins.
 * Semi joins are not supported. A full description of these join types is
 * included in nodes/nodes.h.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasUnsupportedJoinWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasUnsupportedJoin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinType</name></type> <name>joinType</name> <init>= <expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>outerJoin</name> <init>= <expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>joinType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outerJoin</name> <operator>&amp;&amp;</operator> <name>joinType</name> <operator>!=</operator> <name>JOIN_INNER</name> <operator>&amp;&amp;</operator> <name>joinType</name> <operator>!=</operator> <name>JOIN_SEMI</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasUnsupportedJoin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasUnsupportedJoin</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hasUnsupportedJoin</name> <operator>=</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>HasUnsupportedJoinWalker</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>hasUnsupportedJoin</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorHintRequired returns true if error hint shold be displayed with the
 * query error message. Error hint is valid only for queries involving reference
 * and hash partitioned tables. If more than one hash distributed table is
 * present we display the hint only if the tables are colocated. If the query
 * only has reference table(s), then it is handled by router planner.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ErrorHintRequired</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorHint</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedRelationIdList</name> <init>= <expr><call><name>DistributedRelationIdList</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationIdCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>errorHint</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationIdCell</argument>, <argument>distributedRelationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>relationIdCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>colocationIdList</name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name>colocationIdList</name></expr></argument>, <argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* do not display the hint if there are more than one colocation group */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>colocationIdList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfUnsupportedSubqueryRepartition checks that we can perform distributed planning for
 * the given subquery. If not, a deferred error is returned. The function recursively
 * does this check to all lower levels of the subquery.
 */</comment>
<function><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfUnsupportedSubqueryRepartition</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subqueryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errorDetail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>preconditionsSatisfied</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinTreeTableIndexList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subqueryTree</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Subqueries without aggregates are not supported yet"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Subqueries without group by clause are not supported yet"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Subqueries with order by clause are not supported yet"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Subqueries with limit are not supported yet"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Subqueries with offset are not supported yet"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Subqueries other than from-clause subqueries are unsupported"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finally check and return error if conditions are not satisfied */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preconditionsSatisfied</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot perform distributed planning on this query"</literal></expr></argument>,
							 <argument><expr><name>errorDetail</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Extract all range table indexes from the join tree. Note that sub-queries
	 * that get pulled up by PostgreSQL don't appear in this join tree.
	 */</comment>
	<expr_stmt><expr><call><name>ExtractRangeTableIndexWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subqueryTree</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>joinTreeTableIndexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>joinTreeTableIndexList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* continue with the inner subquery */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>rangeTableIndex</name> <init>= <expr><call><name>linitial_int</name><argument_list>(<argument><expr><name>joinTreeTableIndexList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rangeTableIndex</name></expr></argument>, <argument><expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>innerSubquery</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* recursively continue to the inner subqueries */</comment>
	<return>return <expr><call><name>DeferErrorIfUnsupportedSubqueryRepartition</name><argument_list>(<argument><expr><name>innerSubquery</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasComplexRangeTableType checks if the given query tree contains any complex
 * range table types. For this, the function walks over all range tables in the
 * join tree, and checks if they correspond to simple relations or subqueries.
 * If they don't, the function assumes the query has complex range tables.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasComplexRangeTableType</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinTreeTableIndexList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinTreeTableIndexCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasComplexRangeTableType</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Extract all range table indexes from the join tree. Note that sub-queries
	 * that get pulled up by PostgreSQL don't appear in this join tree.
	 */</comment>
	<expr_stmt><expr><call><name>ExtractRangeTableIndexWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>joinTreeTableIndexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>joinTreeTableIndexCell</argument>, <argument>joinTreeTableIndexList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Join tree's range table index starts from 1 in the query tree. But,
		 * list indexes start from 0.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>joinTreeTableIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>joinTreeTableIndexCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rangeTableListIndex</name> <init>= <expr><name>joinTreeTableIndex</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>=
			<expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>rangeTableListIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check if the range table in the join tree is a simple relation or a
		 * subquery or a function. Note that RTE_FUNCTIONs are handled via (sub)query
		 * pushdown.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator>
			<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_FUNCTION</name> <operator>&amp;&amp;</operator>
			<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_VALUES</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasComplexRangeTableType</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check if the subquery range table entry includes children inheritance.
		 *
		 * Note that PostgreSQL flattens out simple union all queries into an
		 * append relation, sets "inh" field of RangeTblEntry to true and deletes
		 * set operations. Here we check this for subqueries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasComplexRangeTableType</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>hasComplexRangeTableType</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WhereClauseList walks over the FROM expression in the query tree, and builds
 * a list of all clauses from the expression tree. The function checks for both
 * implicitly and explicitly defined clauses, but only selects INNER join
 * explicit clauses, and skips any outer-join clauses. Explicit clauses are
 * expressed as "SELECT ... FROM R1 INNER JOIN R2 ON R1.A = R2.A". Implicit
 * joins differ in that they live in the WHERE clause, and are expressed as
 * "SELECT ... FROM ... WHERE R1.a = R2.a".
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>WhereClauseList</name><parameter_list>(<parameter><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>fromExpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>fromExprCopy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>fromExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualifierWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QualifierWalkerContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractFromExpressionWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fromExprCopy</name></expr></argument>, <argument><expr><name>walkerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name> <init>= <expr><name><name>walkerContext</name><operator>-&gt;</operator><name>baseQualifierList</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>whereClauseList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QualifierList walks over the FROM expression in the query tree, and builds
 * a list of all qualifiers from the expression tree. The function checks for
 * both implicitly and explicitly defined qualifiers. Note that this function
 * is very similar to WhereClauseList(), but QualifierList() also includes
 * outer-join clauses.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>QualifierList</name><parameter_list>(<parameter><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>fromExpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>fromExprCopy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>fromExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualifierWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QualifierWalkerContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qualifierList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractFromExpressionWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fromExprCopy</name></expr></argument>, <argument><expr><name>walkerContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualifierList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>qualifierList</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>baseQualifierList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qualifierList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>qualifierList</name></expr></argument>, <argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>outerJoinQualifierList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>qualifierList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfUnsupportedClause walks over the given list of clauses, and
 * checks that we can recognize all the clauses. This function ensures that
 * we do not drop an unsupported clause type on the floor, and thus prevents
 * erroneous results.
 *
 * Returns a deferred error, caller is responsible for raising the error.
 */</comment>
<function><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfUnsupportedClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>clauseCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>clauseCell</argument>, <argument>clauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>clauseCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsSelectClause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsJoinClause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_orclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"unsupported clause type"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinClauseList finds the join clauses from the given where clause expression
 * list, and returns them. The function does not iterate into nested OR clauses
 * and relies on find_duplicate_ors() in the optimizer to pull up factorizable
 * OR clauses.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>JoinClauseList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>whereClauseCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>whereClauseCell</argument>, <argument>whereClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>whereClause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>whereClauseCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsJoinClause</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>joinClauseList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>joinClauseList</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>joinClauseList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractFromExpressionWalker walks over a FROM expression, and finds all
 * implicit and explicit qualifiers in the expression. The function looks at
 * join and from expression nodes to find qualifiers, and returns these
 * qualifiers.
 *
 * Note that we don't want outer join clauses in regular outer join planning,
 * but we need outer join clauses in subquery pushdown prerequisite checks.
 * Therefore, outer join qualifiers are returned in a different list than other
 * qualifiers inside the given walker context. For this reason, we return two
 * qualifier lists.
 *
 * Note that we check if the qualifier node in join and from expression nodes
 * is a list node. If it is not a list node which is the case for subqueries,
 * then we run eval_const_expressions(), canonicalize_qual() and make_ands_implicit()
 * on the qualifier node and get a list of flattened implicitly AND'ed qualifier
 * list. Actually in the planer phase of PostgreSQL these functions also run on
 * subqueries but differently from the outermost query, they are run on a copy
 * of parse tree and changes do not get persisted as modifications to the original
 * query tree.
 *
 * Also this function adds SubLinks to the baseQualifierList when they appear on
 * the query's WHERE clause. The callers of the function should consider processing
 * Sublinks as well.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExtractFromExpressionWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>QualifierWalkerContext</name> <modifier>*</modifier></type><name>walkerContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get qualifier lists of join and from expression nodes. Note that in the
	 * case of subqueries, PostgreSQL can skip simplifying, flattening and
	 * making ANDs implicit. If qualifiers node is not a list, then we run these
	 * preprocess routines on qualifiers node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinQualifierList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpression</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinQualifiersNode</name> <init>= <expr><name><name>joinExpression</name><operator>-&gt;</operator><name>quals</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinType</name></type> <name>joinType</name> <init>= <expr><name><name>joinExpression</name><operator>-&gt;</operator><name>jointype</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>joinQualifiersNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>joinQualifiersNode</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>joinQualifierList</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>joinQualifiersNode</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* this part of code only run for subqueries */</comment>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinClause</name> <init>= <expr><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>joinQualifiersNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>joinClause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>joinClause</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>joinQualifierList</name> <operator>=</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>joinClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* return outer join clauses in a separate list */</comment>
		<if_stmt><if>if <condition>(<expr><name>joinType</name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator> <name>joinType</name> <operator>==</operator> <name>JOIN_SEMI</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>baseQualifierList</name></name> <operator>=</operator>
				<call><name>list_concat</name><argument_list>(<argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>baseQualifierList</name></name></expr></argument>, <argument><expr><name>joinQualifierList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>joinType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>outerJoinQualifierList</name></name> <operator>=</operator>
				<call><name>list_concat</name><argument_list>(<argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>outerJoinQualifierList</name></name></expr></argument>, <argument><expr><name>joinQualifierList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fromQualifierList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>fromExpression</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>fromQualifiersNode</name> <init>= <expr><name><name>fromExpression</name><operator>-&gt;</operator><name>quals</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>fromQualifiersNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>fromQualifiersNode</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fromQualifierList</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>fromQualifiersNode</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* this part of code only run for subqueries */</comment>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>fromClause</name> <init>= <expr><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fromQualifiersNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>fromClause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>fromClause</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fromQualifierList</name> <operator>=</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>fromClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>baseQualifierList</name></name> <operator>=</operator>
				<call><name>list_concat</name><argument_list>(<argument><expr><name><name>walkerContext</name><operator>-&gt;</operator><name>baseQualifierList</name></name></expr></argument>, <argument><expr><name>fromQualifierList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>walkerResult</name> <init>= <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ExtractFromExpressionWalker</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>walkerContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>walkerResult</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsJoinClause determines if the given node is a join clause according to our
 * criteria. Our criteria defines a join clause as an equi join operator between
 * two columns that belong to two different tables.
 */</comment>
<function><type><name>bool</name></type>
<name>IsJoinClause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * take all column references from the clause, if we find 2 column references from a
	 * different relation we assume this is a join clause
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>varList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>varList</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no column references in query, not describing a join */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>initialVar</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>varList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>var</argument>, <argument>varList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name><name>initialVar</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * this column reference comes from a different relation, hence describing a
			 * join
			 */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* all column references were to the same relation, no join */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TableEntryList finds the regular relation nodes in the range table entry
 * list, and builds a list of table entries from these regular relation nodes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>TableEntryList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableEntryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>tableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* range table indices start at 1 */</comment>

	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><operator>(</operator><name>TableEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>tableEntry</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tableEntry</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>=</operator> <name>tableId</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>tableEntryList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableEntryList</name></expr></argument>, <argument><expr><name>tableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Increment tableId regardless so that table entry's tableId remains
		 * congruent with column's range table reference (varno).
		 */</comment>
		<expr_stmt><expr><name>tableId</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>tableEntryList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UsedTableEntryList returns list of relation range table entries
 * that are referenced within the query. Unused entries due to query
 * flattening or re-rewriting are ignored.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>UsedTableEntryList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableEntryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinTreeTableIndexList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinTreeTableIndexCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractRangeTableIndexWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>joinTreeTableIndexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>joinTreeTableIndexCell</argument>, <argument>joinTreeTableIndexList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>joinTreeTableIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>joinTreeTableIndexCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>joinTreeTableIndex</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><operator>(</operator><name>TableEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>tableEntry</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tableEntry</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>=</operator> <name>joinTreeTableIndex</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>tableEntryList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableEntryList</name></expr></argument>, <argument><expr><name>tableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>tableEntryList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MultiTableNodeList builds a list of MultiTable nodes from the given table
 * entry list. A multi table node represents one entry from the range table
 * list. These entries may belong to the same physical relation in the case of
 * self-joins.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>MultiTableNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableEntryList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tableEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tableEntryCell</argument>, <argument>tableEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><operator>(</operator><name>TableEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tableEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>tableEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>rangeTableId</name> <init>= <expr><name><name>tableEntry</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>rangeTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rangeTableId</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>tableNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>tableNode</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tableNode</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tableNode</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>=</operator> <name>rangeTableId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tableNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>partitionColumn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tableNode</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>alias</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tableNode</name><operator>-&gt;</operator><name>referenceNames</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>eref</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tableNode</name><operator>-&gt;</operator><name>includePartitions</name></name> <operator>=</operator> <call><name>GetOriginalInh</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tableNode</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>tablesample</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>tableNodeList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableNodeList</name></expr></argument>, <argument><expr><name>tableNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>tableNodeList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Adds a MultiCollect node on top of each MultiTable node in the given list. */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>AddMultiCollectNodes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>collectTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tableNodeCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tableNodeCell</argument>, <argument>tableNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>tableNode</name> <init>= <expr><operator>(</operator><name>MultiTable</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tableNodeCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>collectNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>tableNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>collectTableList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>collectTableList</name></expr></argument>, <argument><expr><name>collectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>collectTableList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MultiJoinTree takes in the join order information and the list of tables, and
 * builds a join tree by applying the corresponding join rules. The function
 * builds a left deep tree, as expressed by the join order list.
 *
 * The function starts by setting the first table as the top node in the join
 * tree. Then, the function iterates over the list of tables, and builds a new
 * join node between the top of the join tree and the next table in the list.
 * At each iteration, the function sets the top of the join tree to the newly
 * built list. This results in a left deep join tree, and the function returns
 * this tree after every table in the list has been joined.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>MultiJoinTree</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrderList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>collectTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinWhereClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>currentTopNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinOrderCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>firstJoinNode</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>joinOrderCell</argument>, <argument>joinOrderList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinOrderNode</name> <init>= <expr><operator>(</operator><name>JoinOrderNode</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>joinOrderCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>joinTableId</name> <init>= <expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>tableEntry</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>collectNode</name> <init>= <expr><call><name>CollectNodeForTable</name><argument_list>(<argument><expr><name>collectTableList</name></expr></argument>, <argument><expr><name>joinTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>firstJoinNode</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>currentTopNode</name> <operator>=</operator> <operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>firstJoinNode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>JoinRuleType</name></type> <name>joinRuleType</name> <init>= <expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>joinRuleType</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>JoinType</name></type> <name>joinType</name> <init>= <expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>joinType</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name> <init>= <expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>partitionColumnList</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name> <init>= <expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>joinClauseList</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Build a join node between the top of our join tree and the next
			 * table in the join order.
			 */</comment>
			<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>newJoinNode</name> <init>= <expr><call><name>ApplyJoinRule</name><argument_list>(<argument><expr><name>currentTopNode</name></expr></argument>,
												   <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>,
												   <argument><expr><name>joinRuleType</name></expr></argument>, <argument><expr><name>partitionColumnList</name></expr></argument>,
												   <argument><expr><name>joinType</name></expr></argument>,
												   <argument><expr><name>joinClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* the new join node becomes the top of our join tree */</comment>
			<expr_stmt><expr><name>currentTopNode</name> <operator>=</operator> <name>newJoinNode</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* current top node points to the entire left deep join tree */</comment>
	<return>return <expr><name>currentTopNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CollectNodeForTable finds the MultiCollect node whose MultiTable node has the
 * given range table identifier. Note that this function expects each collect
 * node in the given list to have one table node as its child.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiCollect</name> <modifier>*</modifier></type>
<name>CollectNodeForTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>collectTableList</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>rangeTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>collectNodeForTable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>collectTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>collectTableCell</argument>, <argument>collectTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>collectNode</name> <init>= <expr><operator>(</operator><name>MultiCollect</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>collectTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name> <init>= <expr><call><name>OutputTableIdList</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>tableId</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name>tableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableIdList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>tableId</name> <operator>==</operator> <name>rangeTableId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>collectNodeForTable</name> <operator>=</operator> <name>collectNode</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>collectNodeForTable</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>collectNodeForTable</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MultiSelectNode extracts the select clauses from the given where clause list,
 * and builds a MultiSelect node from these clauses. If the expression tree does
 * not have any select clauses, the function return null.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiSelect</name> <modifier>*</modifier></type>
<name>MultiSelectNode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>whereClauseCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>whereClauseCell</argument>, <argument>whereClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>whereClause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>whereClauseCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsSelectClause</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>selectClauseList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>selectClauseList</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>selectClauseList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>selectNode</name> <operator>=</operator> <call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>selectNode</name><operator>-&gt;</operator><name>selectClauseList</name></name> <operator>=</operator> <name>selectClauseList</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>selectNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsSelectClause determines if the given node is a select clause according to
 * our criteria. Our criteria defines a select clause as an expression that has
 * zero or more columns belonging to only one table. The function assumes that
 * no sublinks exists in the clause.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsSelectClause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>columnCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isSelectClause</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* extract columns from the clause */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>columnList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get first column's tableId */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>firstColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>columnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>firstColumnTableId</name> <init>= <expr><name><name>firstColumn</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check if all columns are from the same table */</comment>
	<macro><name>foreach</name><argument_list>(<argument>columnCell</argument>, <argument>columnList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>columnCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>firstColumnTableId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isSelectClause</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>isSelectClause</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MultiProjectNode builds the project node using the target entry information
 * from the query tree. The project node only encapsulates projected columns,
 * and does not include aggregates, group clauses, or project expressions.
 */</comment>
<function><type><name>MultiProject</name> <modifier>*</modifier></type>
<name>MultiProjectNode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>uniqueColumnList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>columnCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* extract the list of columns and remove any duplicates */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>columnCell</argument>, <argument>columnList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>columnCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>uniqueColumnList</name> <operator>=</operator> <call><name>list_append_unique</name><argument_list>(<argument><expr><name>uniqueColumnList</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* create project node with list of columns to project */</comment>
	<decl_stmt><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>projectNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiProject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>projectNode</name><operator>-&gt;</operator><name>columnList</name></name> <operator>=</operator> <name>uniqueColumnList</name></expr>;</expr_stmt>

	<return>return <expr><name>projectNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Builds the extended operator node using fields from the given query tree. */</comment>
<function><type><name>MultiExtendedOp</name> <modifier>*</modifier></type>
<name>MultiExtendedOpNode</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOpNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiExtendedOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>groupClauseList</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>sortClauseList</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>sortClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>limitCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>limitOption</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>limitOption</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>havingQual</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>windowClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>onlyPushableWindowFunctions</name></name> <operator>=</operator>
		<operator>!</operator><name><name>queryTree</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
		<call><name>SafeToPushdownWindowFunction</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>extendedOpNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Helper function to return the parent node of the given node. */</comment>
<function><type><name>MultiNode</name> <modifier>*</modifier></type>
<name>ParentNode</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name> <init>= <expr><name><name>multiNode</name><operator>-&gt;</operator><name>parentNode</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>parentNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Helper function to return the child of the given unary node. */</comment>
<function><type><name>MultiNode</name> <modifier>*</modifier></type>
<name>ChildNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><name><name>multiNode</name><operator>-&gt;</operator><name>childNode</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>childNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Helper function to return the grand child of the given unary node. */</comment>
<function><type><name>MultiNode</name> <modifier>*</modifier></type>
<name>GrandChildNode</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>grandChildNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>grandChildNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Sets the given child node as a child of the given unary parent node. */</comment>
<function><type><name>void</name></type>
<name>SetChild</name><parameter_list>(<parameter><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>childNode</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>parentNode</name></name> <operator>=</operator> <operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>parent</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Sets the given child node as a left child of the given parent node. */</comment>
<function><type><name>void</name></type>
<name>SetLeftChild</name><parameter_list>(<parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftChild</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>leftChildNode</name></name> <operator>=</operator> <name>leftChild</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>leftChild</name><operator>-&gt;</operator><name>parentNode</name></name> <operator>=</operator> <operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>parent</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Sets the given child node as a right child of the given parent node. */</comment>
<function><type><name>void</name></type>
<name>SetRightChild</name><parameter_list>(<parameter><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightChild</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>rightChildNode</name></name> <operator>=</operator> <name>rightChild</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rightChild</name><operator>-&gt;</operator><name>parentNode</name></name> <operator>=</operator> <operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>parent</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Returns true if the given node is a unary operator. */</comment>
<function><type><name>bool</name></type>
<name>UnaryOperator</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>unaryOperator</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MultiTreeRoot</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CitusIsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MultiTable</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>CitusIsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CitusIsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MultiSelect</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>CitusIsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MultiProject</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CitusIsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>CitusIsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MultiExtendedOp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>unaryOperator</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>unaryOperator</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Returns true if the given node is a binary operator. */</comment>
<function><type><name>bool</name></type>
<name>BinaryOperator</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>binaryOperator</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MultiJoin</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CitusIsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MultiCartesianProduct</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>binaryOperator</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>binaryOperator</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OutputTableIdList finds all table identifiers that are output by the given
 * multi node, and returns these identifiers in a new list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>OutputTableIdList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>T_MultiTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tableNodeCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tableNodeCell</argument>, <argument>tableNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>tableNode</name> <init>= <expr><operator>(</operator><name>MultiTable</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tableNodeCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>tableId</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>tableNode</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>tableId</name> <operator>!=</operator> <name>SUBQUERY_RANGE_TABLE_ID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tableIdList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>tableIdList</name></expr></argument>, <argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>tableIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindNodesOfType takes in a given logical plan tree, and recursively traverses
 * the tree in preorder. The function finds all nodes of requested type during
 * the traversal, and returns them in a list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>FindNodesOfType</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* terminal condition for recursion */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* current node has expected node type */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nodeType</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>nodeType</name> <operator>==</operator> <name>type</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nodeList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><operator>(</operator><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>childNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>childNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nodeList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>childNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>BinaryOperator</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftChildNode</name> <init>= <expr><operator>(</operator><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>leftChildNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightChildNode</name> <init>= <expr><operator>(</operator><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>rightChildNode</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>leftChildNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>leftChildNode</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightChildNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>rightChildNode</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nodeList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>leftChildNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nodeList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>rightChildNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>nodeList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pull_var_clause_default calls pull_var_clause with the most commonly used
 * arguments for distributed planning.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>pull_var_clause_default</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * PVC_REJECT_PLACEHOLDERS is implicit if PVC_INCLUDE_PLACEHOLDERS
	 * isn't specified.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
									   <name>PVC_RECURSE_WINDOWFUNCS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>columnList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplyJoinRule finds the join rule application function that corresponds to
 * the given join rule, and calls this function to create a new join node that
 * joins the left and right nodes together.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>ApplyJoinRule</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>, <parameter><decl><type><name>JoinRuleType</name></type> <name>ruleType</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>leftTableIdList</name> <init>= <expr><call><name>OutputTableIdList</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightTableIdList</name> <init>= <expr><call><name>OutputTableIdList</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <name>rightTableIdCount</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rightTableIdCount</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rightTableIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rightTableIdCount</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* find applicable join clauses between the left and right data sources */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rightTableId</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name>rightTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name> <init>= <expr><call><name>ApplicableJoinClauses</name><argument_list>(<argument><expr><name>leftTableIdList</name></expr></argument>, <argument><expr><name>rightTableId</name></expr></argument>,
														<argument><expr><name>joinClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* call the join rule application function to create the new join node */</comment>
	<decl_stmt><decl><type><name>RuleApplyFunction</name></type> <name>ruleApplyFunction</name> <init>= <expr><call><name>JoinRuleApplyFunction</name><argument_list>(<argument><expr><name>ruleType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name> <init>= <expr><call>(<modifier>*</modifier><name>ruleApplyFunction</name>)<argument_list>(<argument><expr><name>leftNode</name></expr></argument>, <argument><expr><name>rightNode</name></expr></argument>, <argument><expr><name>partitionColumnList</name></expr></argument>,
												<argument><expr><name>joinType</name></expr></argument>, <argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>joinType</name> <operator>!=</operator> <name>JOIN_INNER</name> <operator>&amp;&amp;</operator> <call><name>CitusIsA</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>MultiJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>= <expr><operator>(</operator><name>MultiJoin</name> <operator>*</operator><operator>)</operator> <name>multiNode</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* preserve non-join clauses for OUTER joins */</comment>
		<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinClauseList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>joinClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>multiNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinRuleApplyFunction returns a function pointer for the rule application
 * function; this rule application function corresponds to the given rule type.
 * This function also initializes the rule application function array in a
 * static code block, if the array has not been initialized.
 */</comment>
<function><type><specifier>static</specifier> <name>RuleApplyFunction</name></type>
<name>JoinRuleApplyFunction</name><parameter_list>(<parameter><decl><type><name>JoinRuleType</name></type> <name>ruleType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ruleApplyFunctionInitialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ruleApplyFunctionInitialized</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>RuleApplyFunctionArray</name><index>[<expr><name>REFERENCE_JOIN</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>ApplyReferenceJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleApplyFunctionArray</name><index>[<expr><name>LOCAL_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>ApplyLocalJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleApplyFunctionArray</name><index>[<expr><name>SINGLE_HASH_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator>
			<operator>&amp;</operator><name>ApplySingleHashPartitionJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleApplyFunctionArray</name><index>[<expr><name>SINGLE_RANGE_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator>
			<operator>&amp;</operator><name>ApplySingleRangePartitionJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleApplyFunctionArray</name><index>[<expr><name>DUAL_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>ApplyDualPartitionJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleApplyFunctionArray</name><index>[<expr><name>CARTESIAN_PRODUCT_REFERENCE_JOIN</name></expr>]</index></name> <operator>=</operator>
			<operator>&amp;</operator><name>ApplyCartesianProductReferenceJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleApplyFunctionArray</name><index>[<expr><name>CARTESIAN_PRODUCT</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>ApplyCartesianProduct</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ruleApplyFunctionInitialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RuleApplyFunction</name></type> <name>ruleApplyFunction</name> <init>= <expr><name><name>RuleApplyFunctionArray</name><index>[<expr><name>ruleType</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ruleApplyFunction</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ruleApplyFunction</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplyBroadcastJoin creates a new MultiJoin node that joins the left and the
 * right node. The new node uses the broadcast join rule to perform the join.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>ApplyReferenceJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>=</operator> <name>REFERENCE_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinType</name></name> <operator>=</operator> <name>joinType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinClauseList</name></name> <operator>=</operator> <name>applicableJoinClauses</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetLeftChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetRightChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplyCartesianProductReferenceJoin creates a new MultiJoin node that joins
 * the left and the right node. The new node uses the broadcast join rule to
 * perform the join.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>ApplyCartesianProductReferenceJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>=</operator> <name>CARTESIAN_PRODUCT_REFERENCE_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinType</name></name> <operator>=</operator> <name>joinType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinClauseList</name></name> <operator>=</operator> <name>applicableJoinClauses</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetLeftChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetRightChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplyLocalJoin creates a new MultiJoin node that joins the left and the right
 * node. The new node uses the local join rule to perform the join.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>ApplyLocalJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>=</operator> <name>LOCAL_PARTITION_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinType</name></name> <operator>=</operator> <name>joinType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinClauseList</name></name> <operator>=</operator> <name>applicableJoinClauses</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetLeftChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetRightChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplySingleRangePartitionJoin is a wrapper around ApplySinglePartitionJoin()
 * which sets the joinRuleType properly.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>ApplySingleRangePartitionJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>=
		<expr><call><name>ApplySinglePartitionJoin</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>, <argument><expr><name>rightNode</name></expr></argument>, <argument><expr><name>partitionColumnList</name></expr></argument>, <argument><expr><name>joinType</name></expr></argument>,
								 <argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>=</operator> <name>SINGLE_RANGE_PARTITION_JOIN</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplySingleHashPartitionJoin is a wrapper around ApplySinglePartitionJoin()
 * which sets the joinRuleType properly.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>ApplySingleHashPartitionJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>=
		<expr><call><name>ApplySinglePartitionJoin</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>, <argument><expr><name>rightNode</name></expr></argument>, <argument><expr><name>partitionColumnList</name></expr></argument>, <argument><expr><name>joinType</name></expr></argument>,
								 <argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>=</operator> <name>SINGLE_HASH_PARTITION_JOIN</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplySinglePartitionJoin creates a new MultiJoin node that joins the left and
 * right node. The function also adds a MultiPartition node on top of the node
 * (left or right) that is not partitioned on the join column.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiJoin</name> <modifier>*</modifier></type>
<name>ApplySinglePartitionJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>partitionColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>partitionTableId</name> <init>= <expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create all operator structures up front */</comment>
	<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>collectNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiPartition</name> <modifier>*</modifier></type><name>partitionNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We first find the appropriate join clause. Then, we compare the partition
	 * column against the join clause's columns. If one of the columns matches,
	 * we introduce a (re-)partition operator for the other column.
	 */</comment>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>joinClause</name> <init>= <expr><call><name>SinglePartitionJoinClause</name><argument_list>(<argument><expr><name>partitionColumnList</name></expr></argument>,
												   <argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>joinClause</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* both are verified in SinglePartitionJoinClause to not be NULL, assert is to guard */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>leftColumn</name> <init>= <expr><call><name>LeftColumnOrNULL</name><argument_list>(<argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>rightColumn</name> <init>= <expr><call><name>RightColumnOrNULL</name><argument_list>(<argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftColumn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rightColumn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>partitionColumn</name></expr></argument>, <argument><expr><name>leftColumn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>partitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>rightColumn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partitionNode</name><operator>-&gt;</operator><name>splitPointTableId</name></name> <operator>=</operator> <name>partitionTableId</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>partitionColumn</name></expr></argument>, <argument><expr><name>rightColumn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>partitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>leftColumn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>partitionNode</name><operator>-&gt;</operator><name>splitPointTableId</name></name> <operator>=</operator> <name>partitionTableId</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* determine the node the partition operator goes on top of */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightTableIdList</name> <init>= <expr><call><name>OutputTableIdList</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rightTableId</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name>rightTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>rightTableIdList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the right child node is partitioned on the partition key column, we
	 * add the partition operator on the left child node; and vice versa. Then,
	 * we add a collect operator on top of the partition operator, and always
	 * make sure that we have at most one relation on the right-hand side.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partitionTableId</name> <operator>==</operator> <name>rightTableId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr></argument>, <argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetLeftChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetRightChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr></argument>, <argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetLeftChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetRightChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>collectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* finally set join operator fields */</comment>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinType</name></name> <operator>=</operator> <name>joinType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinClauseList</name></name> <operator>=</operator> <name>applicableJoinClauses</name></expr>;</expr_stmt>

	<return>return <expr><name>joinNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplyDualPartitionJoin creates a new MultiJoin node that joins the left and
 * right node. The function also adds two MultiPartition operators on top of
 * both nodes to repartition these nodes' data on the join clause columns.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>ApplyDualPartitionJoin</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* find the appropriate join clause */</comment>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>joinClause</name> <init>= <expr><call><name>DualPartitionJoinClause</name><argument_list>(<argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>joinClause</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* both are verified in DualPartitionJoinClause to not be NULL, assert is to guard */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>leftColumn</name> <init>= <expr><call><name>LeftColumnOrNULL</name><argument_list>(<argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>rightColumn</name> <init>= <expr><call><name>RightColumnOrNULL</name><argument_list>(<argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftColumn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rightColumn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightTableIdList</name> <init>= <expr><call><name>OutputTableIdList</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rightTableId</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name>rightTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>rightTableIdList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiPartition</name> <modifier>*</modifier></type><name>leftPartitionNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiPartition</name> <modifier>*</modifier></type><name>rightPartitionNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* find the partition node each join clause column belongs to */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>leftColumn</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>rightTableId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>leftPartitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>rightColumn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rightPartitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>leftColumn</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>leftPartitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>leftColumn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rightPartitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>rightColumn</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* add partition operators on top of left and right nodes */</comment>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>leftPartitionNode</name></expr></argument>, <argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>rightPartitionNode</name></expr></argument>, <argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add collect operators on top of the two partition operators */</comment>
	<decl_stmt><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>leftCollectNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>rightCollectNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>leftCollectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>leftPartitionNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>rightCollectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>rightPartitionNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add join operator on top of the two collect operators */</comment>
	<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>=</operator> <name>DUAL_PARTITION_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinType</name></name> <operator>=</operator> <name>joinType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinClauseList</name></name> <operator>=</operator> <name>applicableJoinClauses</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetLeftChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>leftCollectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetRightChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>rightCollectNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Creates a cartesian product node that joins the left and the right node. */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>ApplyCartesianProduct</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftNode</name></decl></parameter>, <parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightNode</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiCartesianProduct</name> <modifier>*</modifier></type><name>cartesianNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiCartesianProduct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetLeftChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>cartesianNode</name></expr></argument>, <argument><expr><name>leftNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetRightChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>cartesianNode</name></expr></argument>, <argument><expr><name>rightNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>cartesianNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OperatorImplementsEquality returns true if the given opno represents an
 * equality operator. The function retrieves btree interpretation list for this
 * opno and check if BTEqualStrategyNumber strategy is present.
 */</comment>
<function><type><name>bool</name></type>
<name>OperatorImplementsEquality</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>equalityOperator</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>btreeIntepretationList</name> <init>= <expr><call><name>get_op_btree_interpretation</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>btreeInterpretationCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>btreeInterpretationCell</argument>, <argument>btreeIntepretationList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpBtreeInterpretation</name> <modifier>*</modifier></type><name>btreeIntepretation</name> <init>= <expr><operator>(</operator><name>OpBtreeInterpretation</name> <operator>*</operator><operator>)</operator>
													<call><name>lfirst</name><argument_list>(<argument><expr><name>btreeInterpretationCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>btreeIntepretation</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>equalityOperator</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>equalityOperator</name></expr>;</return>
</block_content>}</block></function>
</unit>
