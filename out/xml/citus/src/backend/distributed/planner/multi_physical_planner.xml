<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/planner/multi_physical_planner.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * multi_physical_planner.c
 *	  Routines for creating physical plans from given multi-relational algebra
 *	  trees.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_results.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_shard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_pushdown_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/recursive_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_pruning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<comment type="block">/* RepartitionJoinBucketCountPerNode determines bucket amount during repartitions */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>RepartitionJoinBucketCountPerNode</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Policy to use when assigning tasks to worker nodes */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>TaskAssignmentPolicy</name> <init>= <expr><name>TASK_ASSIGNMENT_GREEDY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableUniqueJobIds</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * OperatorCache is used for caching operator identifiers for given typeId,
 * accessMethodId and strategyNumber. It is initialized to empty list as
 * there are no items in the cache.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>OperatorCache</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* context passed down in AddAnyValueAggregates mutator */</comment>
<typedef>typedef <type><struct>struct <name>AddAnyValueAggregatesContext</name>
<block>{
	<comment type="block">/* SortGroupClauses corresponding to the GROUP BY clause */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl>;</decl_stmt>

	<comment type="block">/* TargetEntry's to which the GROUP BY clauses refer */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupByTargetEntryList</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * haveNonVarGrouping is true if there are expressions in the
	 * GROUP BY target entries. We use this as an optimisation to
	 * skip expensive checks when possible.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>haveNonVarGrouping</name></decl>;</decl_stmt>
}</block></struct></type> <name>AddAnyValueAggregatesContext</name>;</typedef>


<comment type="block">/* Local functions forward declarations for job creation */</comment>
<function_decl><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type> <name>BuildJobTree</name><parameter_list>(<parameter><decl><type><name>MultiTreeRoot</name> <modifier>*</modifier></type><name>multiTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>LeftMostNode</name><parameter_list>(<parameter><decl><type><name>MultiTreeRoot</name> <modifier>*</modifier></type><name>multiTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>RangePartitionJoinBaseRelationId</name><parameter_list>(<parameter><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiTable</name> <modifier>*</modifier></type> <name>FindTableNode</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangeTableId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type> <name>BuildJobQuery</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>BaseRangeTableList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>QueryTargetList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>TargetEntryList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>expressionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>AddAnyValueAggregates</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>AddAnyValueAggregatesContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>QueryGroupClauseList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>QuerySelectClauseList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>QueryFromList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>QueryJoinTree</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetJoinRelatedColumnsCompat</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>leftRelId</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>rightRelId</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>leftColumnVars</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rightColumnVars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type> <name>JoinRangeTableEntry</name><parameter_list>(<parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ExtractRangeTableId</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExtractColumns</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>callingRTE</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangeTableId</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnNames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnVars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type> <name>ConstructCallingRTE</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type> <name>BuildSubqueryJobQuery</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateAllColumnAttributes</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>columnContainer</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>,
									  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateColumnAttributes</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Index</name></type> <name>NewTableId</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>originalTableId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AttrNumber</name></type> <name>NewColumnId</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>originalTableId</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>originalColumnId</name></decl></parameter>,
							  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newRangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type> <name>JobForRangeTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>jobList</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type> <name>JobForTableIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>jobList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>searchedTableIdList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ChildNodeList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type> <name>BuildJob</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MapMergeJob</name> <modifier>*</modifier></type> <name>BuildMapMergeJob</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>,
									  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionKey</name></decl></parameter>, <parameter><decl><type><name>PartitionType</name></type> <name>partitionType</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name></type> <name>baseRelationId</name></decl></parameter>,
									  <parameter><decl><type><name>BoundaryNodeJobType</name></type> <name>boundaryNodeJobType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>HashPartitionCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Local functions forward declarations for task list creation and helper functions */</comment>
<function_decl><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type> <name>BuildJobTreeTaskList</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>jobTree</name></decl></parameter>,
								  <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsInnerTableOfOuterJoin</name><parameter_list>(<parameter><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedShardDistribution</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type> <name>QueryPushdownTaskCreate</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardIndex</name></decl></parameter>,
									  <parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>,
									  <parameter><decl><type><name>uint32</name></type> <name>taskId</name></decl></parameter>,
									  <parameter><decl><type><name>TaskType</name></type> <name>taskType</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>modifyRequiresCoordinatorEvaluation</name></decl></parameter>,
									  <parameter><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>planningError</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>SqlTaskList</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DependsOnHashPartitionJob</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>AnchorRangeTableId</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>BaseRangeTableIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>AnchorRangeTableIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>baseRangeTableIdList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdjustColumnOldAttributes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>expressionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>RangeTableFragmentsList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>,
									  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OperatorCacheEntry</name> <modifier>*</modifier></type> <name>LookupOperatorByType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>,
												 <parameter><decl><type><name>int16</name></type> <name>strategyNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>GetOperatorByType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>strategyNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FragmentCombinationList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableFragmentsList</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name></decl></parameter>,
									  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JoinSequenceNode</name> <modifier>*</modifier></type> <name>JoinSequenceArray</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableFragmentsList</name></decl></parameter>,
											<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>PartitionedOnColumn</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckJoinBetweenColumns</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>joinClause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FindRangeTableFragmentsList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableFragmentsList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>taskId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>JoinPrunable</name><parameter_list>(<parameter><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>leftFragment</name></decl></parameter>,
						 <parameter><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>rightFragment</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ShardInterval</name> <modifier>*</modifier></type> <name>FragmentInterval</name><parameter_list>(<parameter><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>fragment</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>FragmentIntervalString</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>fragmentInterval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>DataFetchTaskList</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>taskIdIndex</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>BuildRelationShardList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateRangeTableAlias</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Alias</name> <modifier>*</modifier></type> <name>FragmentAlias</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
							 <parameter><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>fragment</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FetchTaskResultNameList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mapOutputFetchTaskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>AnchorShardId</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>anchorRangeTableId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>PruneSqlTaskDependencies</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sqlTaskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>AssignTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sqlTaskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasMergeTaskDependencies</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sqlTaskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GreedyAssignTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type> <name>GreedyAssignTask</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeShardPlacementLists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ReorderAndAssignTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>,
									   <parameter><decl><type><name>ReorderFunction</name></type> <name>reorderFunction</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareTasksByShardId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ActiveShardPlacementLists</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>LeftRotateList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>rotateCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FindDependentMergeTaskList</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>sqlTask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>AssignDualHashTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AssignDataFetchDependencies</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>TaskListHighestTaskId</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>MapTaskList</name><parameter_list>(<parameter><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>filterTaskList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>CreateMapQueryString</name><parameter_list>(<parameter><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name></decl></parameter>, <parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>filterTask</name></decl></parameter>,
									   <parameter><decl><type><name>uint32</name></type> <name>partitionColumnIndex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useBinaryFormat</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>PartitionResultNamePrefix</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>taskId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>PartitionResultName</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>taskId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>partitionId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type> <name>RangeIntervalArrayWithNullBucket</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>intervalArray</name></decl></parameter>,
														 <parameter><decl><type><name>int</name></type> <name>intervalCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>MergeTaskList</name><parameter_list>(<parameter><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mapTaskList</name></decl></parameter>,
							<parameter><decl><type><name>uint32</name></type> <name>taskIdIndex</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FetchEqualityAttrNumsForRTEOpExpr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>opExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FetchEqualityAttrNumsForRTEBoolExpr</name><parameter_list>(<parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>boolExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FetchEqualityAttrNumsForList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>PartitionColumnIndex</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetVar</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetColumnOriginalIndexes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * CreatePhysicalDistributedPlan is the entry point for physical plan generation. The
 * function builds the physical plan; this plan includes the list of tasks to be
 * executed on worker nodes, and the final query to run on the master node.
 */</comment>
<function><type><name>DistributedPlan</name> <modifier>*</modifier></type>
<name>CreatePhysicalDistributedPlan</name><parameter_list>(<parameter><decl><type><name>MultiTreeRoot</name> <modifier>*</modifier></type><name>multiTree</name></decl></parameter>,
							  <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* build the worker job tree and check that we only have one job in the tree */</comment>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>workerJob</name> <init>= <expr><call><name>BuildJobTree</name><argument_list>(<argument><expr><name>multiTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create the tree of executable tasks for the worker job */</comment>
	<expr_stmt><expr><name>workerJob</name> <operator>=</operator> <call><name>BuildJobTreeTaskList</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build the final merge query to execute on the master */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>masterDependentJobList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>workerJob</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>combineQuery</name> <init>= <expr><call><name>BuildJobQuery</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>multiTree</name></expr></argument>, <argument><expr><name>masterDependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>DistributedPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>workerJob</name></name> <operator>=</operator> <name>workerJob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>combineQuery</name></name> <operator>=</operator> <name>combineQuery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>modLevel</name></name> <operator>=</operator> <name>ROW_MODIFY_READONLY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>expectResults</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>distributedPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ModifyLocalTableJob returns true if the given task contains
 * a modification of local table.
 */</comment>
<function><type><name>bool</name></type>
<name>ModifyLocalTableJob</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>job</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>singleTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>singleTask</name><operator>-&gt;</operator><name>isLocalTableModification</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildJobTree builds the physical job tree from the given logical plan tree.
 * The function walks over the logical plan from the bottom up, finds boundaries
 * for jobs, and creates the query structure for each job. The function also
 * sets dependencies between jobs, and then returns the top level worker job.
 */</comment>
<function><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type>
<name>BuildJobTree</name><parameter_list>(<parameter><decl><type><name>MultiTreeRoot</name> <modifier>*</modifier></type><name>multiTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* start building the tree from the deepest left node */</comment>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftMostNode</name> <init>= <expr><call><name>LeftMostNode</name><argument_list>(<argument><expr><name>multiTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>currentNode</name> <init>= <expr><name>leftMostNode</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name> <init>= <expr><call><name>ParentNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>loopDependentJobList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>topLevelJob</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>parentNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>currentNodeType</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>parentNodeType</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>parentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BoundaryNodeJobType</name></type> <name>boundaryNodeJobType</name> <init>= <expr><name>JOB_INVALID_FIRST</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we first check if this node forms the boundary for a remote job */</comment>
		<if_stmt><if>if <condition>(<expr><name>currentNodeType</name> <operator>==</operator> <name>T_MultiJoin</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>= <expr><operator>(</operator><name>MultiJoin</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>==</operator> <name>SINGLE_HASH_PARTITION_JOIN</name> <operator>||</operator>
				<name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>==</operator> <name>SINGLE_RANGE_PARTITION_JOIN</name> <operator>||</operator>
				<name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>==</operator> <name>DUAL_PARTITION_JOIN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>boundaryNodeJobType</name> <operator>=</operator> <name>JOIN_MAP_MERGE_JOB</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>currentNodeType</name> <operator>==</operator> <name>T_MultiPartition</name> <operator>&amp;&amp;</operator>
				 <name>parentNodeType</name> <operator>==</operator> <name>T_MultiExtendedOp</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>boundaryNodeJobType</name> <operator>=</operator> <name>SUBQUERY_MAP_MERGE_JOB</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>currentNodeType</name> <operator>==</operator> <name>T_MultiCollect</name> <operator>&amp;&amp;</operator>
				 <name>parentNodeType</name> <operator>!=</operator> <name>T_MultiPartition</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>boundaryNodeJobType</name> <operator>=</operator> <name>TOP_LEVEL_WORKER_JOB</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If this node is at the boundary for a repartition or top level worker
		 * job, we build the corresponding job(s) and set their dependencies.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>boundaryNodeJobType</name> <operator>==</operator> <name>JOIN_MAP_MERGE_JOB</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>= <expr><operator>(</operator><name>MultiJoin</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftChildNode</name> <init>= <expr><name><name>joinNode</name><operator>-&gt;</operator><name>binaryNode</name><operator>.</operator><name>leftChildNode</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightChildNode</name> <init>= <expr><name><name>joinNode</name><operator>-&gt;</operator><name>binaryNode</name><operator>.</operator><name>rightChildNode</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>PartitionType</name></type> <name>partitionType</name> <init>= <expr><name>PARTITION_INVALID_FIRST</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>baseRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>==</operator> <name>SINGLE_RANGE_PARTITION_JOIN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>partitionType</name> <operator>=</operator> <name>RANGE_PARTITION_TYPE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>baseRelationId</name> <operator>=</operator> <call><name>RangePartitionJoinBaseRelationId</name><argument_list>(<argument><expr><name>joinNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>==</operator> <name>SINGLE_HASH_PARTITION_JOIN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>partitionType</name> <operator>=</operator> <name>SINGLE_HASH_PARTITION_TYPE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>baseRelationId</name> <operator>=</operator> <call><name>RangePartitionJoinBaseRelationId</name><argument_list>(<argument><expr><name>joinNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>==</operator> <name>DUAL_PARTITION_JOIN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>partitionType</name> <operator>=</operator> <name>DUAL_HASH_PARTITION_TYPE</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>leftChildNode</name></expr></argument>, <argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MultiPartition</name> <modifier>*</modifier></type><name>partitionNode</name> <init>= <expr><operator>(</operator><name>MultiPartition</name> <operator>*</operator><operator>)</operator> <name>leftChildNode</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>queryNode</name> <init>= <expr><call><name>GrandChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionKey</name> <init>= <expr><name><name>partitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* build query and partition job */</comment>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>loopDependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name> <init>= <expr><call><name>BuildJobQuery</name><argument_list>(<argument><expr><name>queryNode</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name> <init>= <expr><call><name>BuildMapMergeJob</name><argument_list>(<argument><expr><name>jobQuery</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>,
															<argument><expr><name>partitionKey</name></expr></argument>, <argument><expr><name>partitionType</name></expr></argument>,
															<argument><expr><name>baseRelationId</name></expr></argument>,
															<argument><expr><name>JOIN_MAP_MERGE_JOB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* reset dependent job list */</comment>
				<expr_stmt><expr><name>loopDependentJobList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>loopDependentJobList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>mapMergeJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>rightChildNode</name></expr></argument>, <argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MultiPartition</name> <modifier>*</modifier></type><name>partitionNode</name> <init>= <expr><operator>(</operator><name>MultiPartition</name> <operator>*</operator><operator>)</operator> <name>rightChildNode</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>queryNode</name> <init>= <expr><call><name>GrandChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>partitionNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionKey</name> <init>= <expr><name><name>partitionNode</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * The right query and right partition job do not depend on any
				 * jobs since our logical plan tree is left deep.
				 */</comment>
				<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name> <init>= <expr><call><name>BuildJobQuery</name><argument_list>(<argument><expr><name>queryNode</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name> <init>= <expr><call><name>BuildMapMergeJob</name><argument_list>(<argument><expr><name>jobQuery</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
															<argument><expr><name>partitionKey</name></expr></argument>, <argument><expr><name>partitionType</name></expr></argument>,
															<argument><expr><name>baseRelationId</name></expr></argument>,
															<argument><expr><name>JOIN_MAP_MERGE_JOB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* append to the dependent job list for on-going dependencies */</comment>
				<expr_stmt><expr><name>loopDependentJobList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>loopDependentJobList</name></expr></argument>, <argument><expr><name>mapMergeJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>boundaryNodeJobType</name> <operator>==</operator> <name>TOP_LEVEL_WORKER_JOB</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>loopDependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>subqueryPushdown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subqueryMultiTableList</name> <init>= <expr><call><name>SubqueryMultiTableList</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>subqueryCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>subqueryMultiTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>subqueryCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>subqueryPushdown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Build top level query. If subquery pushdown is set, we use
			 * sligthly different version of BuildJobQuery(). They are similar
			 * but we don't need some parts of BuildJobQuery() for subquery
			 * pushdown such as updating column attributes etc.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>subqueryPushdown</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>topLevelQuery</name> <init>= <expr><call><name>BuildSubqueryJobQuery</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>topLevelJob</name> <operator>=</operator> <call><name>BuildJob</name><argument_list>(<argument><expr><name>topLevelQuery</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>topLevelJob</name><operator>-&gt;</operator><name>subqueryPushdown</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>topLevelQuery</name> <init>= <expr><call><name>BuildJobQuery</name><argument_list>(<argument><expr><name>childNode</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>topLevelJob</name> <operator>=</operator> <call><name>BuildJob</name><argument_list>(<argument><expr><name>topLevelQuery</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* walk up the tree */</comment>
		<expr_stmt><expr><name>currentNode</name> <operator>=</operator> <name>parentNode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parentNode</name> <operator>=</operator> <call><name>ParentNode</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>topLevelJob</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LeftMostNode finds the deepest left node in the left-deep logical plan tree.
 * We build the physical plan by traversing the logical plan from the bottom up;
 * and this function helps us find the bottom of the logical tree.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>LeftMostNode</name><parameter_list>(<parameter><decl><type><name>MultiTreeRoot</name> <modifier>*</modifier></type><name>multiTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>currentNode</name> <init>= <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>multiTree</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftChildNode</name> <init>= <expr><call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>multiTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>leftChildNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>currentNode</name> <operator>=</operator> <name>leftChildNode</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>leftChildNode</name> <operator>=</operator> <call><name>ChildNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>BinaryOperator</name><argument_list>(<argument><expr><name>currentNode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name> <init>= <expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>currentNode</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>leftChildNode</name> <operator>=</operator> <name><name>binaryNode</name><operator>-&gt;</operator><name>leftChildNode</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>currentNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RangePartitionJoinBaseRelationId finds partition node from join node, and
 * returns base relation id of this node. Note that this function assumes that
 * given join node is range partition join type.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>RangePartitionJoinBaseRelationId</name><parameter_list>(<parameter><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiPartition</name> <modifier>*</modifier></type><name>partitionNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>leftChildNode</name> <init>= <expr><name><name>joinNode</name><operator>-&gt;</operator><name>binaryNode</name><operator>.</operator><name>leftChildNode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>rightChildNode</name> <init>= <expr><name><name>joinNode</name><operator>-&gt;</operator><name>binaryNode</name><operator>.</operator><name>rightChildNode</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>leftChildNode</name></expr></argument>, <argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionNode</name> <operator>=</operator> <operator>(</operator><name>MultiPartition</name> <operator>*</operator><operator>)</operator> <name>leftChildNode</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>rightChildNode</name></expr></argument>, <argument><expr><name>MultiPartition</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionNode</name> <operator>=</operator> <operator>(</operator><name>MultiPartition</name> <operator>*</operator><operator>)</operator> <name>rightChildNode</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>Index</name></type> <name>baseTableId</name> <init>= <expr><name><name>partitionNode</name><operator>-&gt;</operator><name>splitPointTableId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>baseTable</name> <init>= <expr><call><name>FindTableNode</name><argument_list>(<argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></argument>, <argument><expr><name>baseTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>baseRelationId</name> <init>= <expr><name><name>baseTable</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>baseRelationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindTableNode walks over the given logical plan tree, and returns the table
 * node that corresponds to the given range tableId.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiTable</name> <modifier>*</modifier></type>
<name>FindTableNode</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangeTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>foundTableNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>T_MultiTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tableNodeCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tableNodeCell</argument>, <argument>tableNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>tableNode</name> <init>= <expr><operator>(</operator><name>MultiTable</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tableNodeCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tableNode</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>==</operator> <name>rangeTableId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>foundTableNode</name> <operator>=</operator> <name>tableNode</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>foundTableNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>foundTableNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildJobQuery traverses the given logical plan tree, determines the job that
 * corresponds to this part of the tree, and builds the query structure for that
 * particular job. The function assumes that jobs this particular job depends on
 * have already been built, as their output is needed to build the query.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>BuildJobQuery</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>updateColumnAttributes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LimitOption</name></type> <name>limitOption</name> <init>= <expr><name>LIMIT_OPTION_DEFAULT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasDistinctOn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctClause</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isRepartitionJoin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasWindowFuncs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>windowClause</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we start building jobs from below the collect node */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>CitusIsA</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First check if we are building a master/worker query. If we are building
	 * a worker query, we update the column attributes for target entries, select
	 * and join columns. Because if underlying query includes repartition joins,
	 * then we create multiple queries from a join. In this case, range table lists
	 * and column lists are subject to change.
	 *
	 * Note that we don't do this for master queries, as column attributes for
	 * master target entries are already set during the master/worker split.
	 */</comment>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>parentNode</name> <init>= <expr><call><name>ParentNode</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>parentNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>updateColumnAttributes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we are building this query on a repartitioned subquery job then we
	 * don't need to update column attributes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dependentJobList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><operator>(</operator><name>Job</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>MapMergeJob</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isRepartitionJoin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have an extended operator, then we copy the operator's target list.
	 * Otherwise, we use the target list based on the MultiProject node at this
	 * level in the query tree.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>extendedOpNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>T_MultiExtendedOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extendedOpNodeList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOp</name> <init>= <expr><operator>(</operator><name>MultiExtendedOp</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>extendedOpNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>extendedOp</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>distinctClause</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasDistinctOn</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasWindowFuncs</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>windowClause</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>windowClause</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>QueryTargetList</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* build the join tree and the range table list */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><call><name>BaseRangeTableList</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinRoot</name> <init>= <expr><call><name>QueryJoinTree</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* update the column attributes for target entries */</comment>
	<if_stmt><if>if <condition>(<expr><name>updateColumnAttributes</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UpdateAllColumnAttributes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extract limit count/offset and sort clauses */</comment>
	<if_stmt><if>if <condition>(<expr><name>extendedOpNodeList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOp</name> <init>= <expr><operator>(</operator><name>MultiExtendedOp</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>extendedOpNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>limitCount</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>limitCount</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>limitOffset</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>limitOption</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>limitOption</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortClauseList</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>sortClauseList</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>havingQual</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>havingQual</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* build group clauses */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name> <init>= <expr><call><name>QueryGroupClauseList</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<comment type="block">/* build the where clause list using select predicates */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name> <init>= <expr><call><name>QuerySelectClauseList</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set correct column attributes for select and having clauses */</comment>
	<if_stmt><if>if <condition>(<expr><name>updateColumnAttributes</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UpdateAllColumnAttributes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>selectClauseList</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>,
								  <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UpdateAllColumnAttributes</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Group by on primary key allows all columns to appear in the target
	 * list, but after re-partitioning we will be querying an intermediate
	 * table that does not have the primary key. We therefore wrap all the
	 * columns that do not appear in the GROUP BY in an any_value aggregate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>groupClauseList</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>isRepartitionJoin</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>targetList</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>WrapUngroupedVarsInAnyValueAggregate</name><argument_list>(
			<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr></argument>, <argument><expr><name>groupClauseList</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>havingQual</name> <operator>=</operator> <call><name>WrapUngroupedVarsInAnyValueAggregate</name><argument_list>(
			<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>havingQual</name></expr></argument>, <argument><expr><name>groupClauseList</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build the From/Where construct. We keep the where-clause list implicitly
	 * AND'd, since both partition and join pruning depends on the clauses being
	 * expressed as a list.
	 */</comment>
	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>joinTree</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>joinTree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>selectClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinTree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>joinRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build the query structure for this job */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>querySource</name></name> <operator>=</operator> <name>QSRC_ORIGINAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name>rangeTableList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>targetList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <name>joinTree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name>sortClauseList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>groupClauseList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name>limitOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>limitCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>limitOption</name></name> <operator>=</operator> <name>limitOption</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <name>havingQual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
						<call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>havingQual</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>distinctClause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>hasDistinctOn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name>windowClause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name>hasWindowFuncs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>jobQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>==</operator> <call><name>contain_window_function</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>jobQuery</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>jobQuery</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BaseRangeTableList returns the list of range table entries for base tables in
 * the query. These base tables stand in contrast to derived tables generated by
 * repartition jobs. Note that this function only considers base tables relevant
 * to the current query, and does not visit nodes under the collect node.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>BaseRangeTableList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>baseRangeTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pendingNodeList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>pendingNodeList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>currMultiNode</name> <init>= <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pendingNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>nodeType</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>currMultiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>pendingNodeList</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>pendingNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nodeType</name> <operator>==</operator> <name>T_MultiTable</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We represent subqueries as MultiTables, and so for base table
			 * entries we skip the subquery ones.
			 */</comment>
			<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>multiTable</name> <init>= <expr><operator>(</operator><name>MultiTable</name> <operator>*</operator><operator>)</operator> <name>currMultiNode</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>multiTable</name><operator>-&gt;</operator><name>relationId</name></name> <operator>!=</operator> <name>SUBQUERY_RELATION_ID</name> <operator>&amp;&amp;</operator>
				<name><name>multiTable</name><operator>-&gt;</operator><name>relationId</name></name> <operator>!=</operator> <name>SUBQUERY_PUSHDOWN_RELATION_ID</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name><name>multiTable</name><operator>-&gt;</operator><name>referenceNames</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name><name>multiTable</name><operator>-&gt;</operator><name>alias</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>multiTable</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name><name>multiTable</name><operator>-&gt;</operator><name>includePartitions</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <name><name>multiTable</name><operator>-&gt;</operator><name>tablesample</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SetRangeTblExtraData</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>CITUS_RTE_RELATION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>multiTable</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>baseRangeTableList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>baseRangeTableList</name></expr></argument>, <argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* do not visit nodes that belong to remote queries */</comment>
		<if_stmt><if>if <condition>(<expr><name>nodeType</name> <operator>!=</operator> <name>T_MultiCollect</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>childNodeList</name> <init>= <expr><call><name>ChildNodeList</name><argument_list>(<argument><expr><name>currMultiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>pendingNodeList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>pendingNodeList</name></expr></argument>, <argument><expr><name>childNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>baseRangeTableList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DerivedRangeTableEntry builds a range table entry for the derived table. This
 * derived table either represents the output of a repartition job; or the data
 * on worker nodes in case of the master node query.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>DerivedRangeTableEntry</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnNames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnTypes</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnTypeMods</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>funcCollations</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>columnList</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetRangeTblExtraData</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>CITUS_RTE_REMOTE_QUERY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tableIdList</name></expr></argument>,
						 <argument><expr><name>funcColumnNames</name></expr></argument>, <argument><expr><name>funcColumnTypes</name></expr></argument>, <argument><expr><name>funcColumnTypeMods</name></expr></argument>,
						 <argument><expr><name>funcCollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rangeTableEntry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DerivedColumnNameList builds a column name list for derived (intermediate)
 * tables. These column names are then used when building the create stament
 * query string for derived tables.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>DerivedColumnNameList</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>generatingJobId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>columnName</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>, <argument><expr><literal type="string">"intermediate_column_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>, <argument><expr><name>UINT64_FORMAT</name> <literal type="string">"_"</literal></expr></argument>, <argument><expr><name>generatingJobId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>columnValue</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>columnName</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>columnNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columnNameList</name></expr></argument>, <argument><expr><name>columnValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>columnNameList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QueryTargetList returns the target entry list for the projected columns
 * needed to evaluate the operators above the given multiNode. To do this,
 * the function retrieves a list of all MultiProject nodes below the given
 * node and picks the columns from the top-most MultiProject node, as this
 * will be the minimal list of columns needed. Note that this function relies
 * on a pre-order traversal of the operator tree by the function FindNodesOfType.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>QueryTargetList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>projectNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>T_MultiProject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>projectNodeList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The physical planner assumes that all worker queries would have
		 * target list entries based on the fact that at least the column
		 * on the JOINs have to be on the target list. However, there is
		 * an exception to that if there is a cartesian product join and
		 * there is no additional target list entries belong to one side
		 * of the JOIN. Once we support cartesian product join, we should
		 * remove this error.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform distributed planning on this query"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cartesian products are currently unsupported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>topProjectNode</name> <init>= <expr><operator>(</operator><name>MultiProject</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>projectNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><name><name>topProjectNode</name><operator>-&gt;</operator><name>columnList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>queryTargetList</name> <init>= <expr><call><name>TargetEntryList</name><argument_list>(<argument><expr><name>columnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryTargetList</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>queryTargetList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TargetEntryList creates a target entry for each expression in the given list,
 * and returns the newly created target entries in a list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>TargetEntryList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>expressionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>expressionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>expressionCell</argument>, <argument>expressionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>expressionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>columnNumber</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>columnName</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>, <argument><expr><literal type="string">"column%d"</literal></expr></argument>, <argument><expr><name>columnNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>columnNumber</name></expr></argument>,
												   <argument><expr><name><name>columnName</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>targetEntryList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>, <argument><expr><name>targetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>targetEntryList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WrapUngroupedVarsInAnyValueAggregate finds Var nodes in the expression
 * that do not refer to any GROUP BY column and wraps them in an any_value
 * aggregate. These columns are allowed when the GROUP BY is on a primary
 * key of a relation, but not if we wrap the relation in a subquery.
 * However, since we still know the value is unique, any_value gives the
 * right result.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>WrapUngroupedVarsInAnyValueAggregate</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkExpressionEquality</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>expression</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AddAnyValueAggregatesContext</name></type> <name>context</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>groupClauseList</name></name> <operator>=</operator> <name>groupClauseList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>groupByTargetEntryList</name></name> <operator>=</operator> <call><name>GroupTargetEntryList</name><argument_list>(<argument><expr><name>groupClauseList</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>haveNonVarGrouping</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>checkExpressionEquality</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the GROUP BY contains non-Var expressions, we need to do an expensive
		 * subexpression equality check.
		 */</comment>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>context.groupByTargetEntryList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>haveNonVarGrouping</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* put the result in the same memory context */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>nodeContext</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>nodeContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>AddAnyValueAggregates</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddAnyValueAggregates wraps all vars that do not appear in the GROUP BY
 * clause or are inside an aggregate function in an any_value aggregate
 * function. This is needed because postgres allows columns that are not
 * in the GROUP BY to appear on the target list as long as the primary key
 * of the table is in the GROUP BY, but we sometimes wrap the join tree
 * in a subquery in which case the primary key information is lost.
 *
 * This function copies parts of the node tree, but may contain references
 * to the original node tree.
 *
 * The implementation is derived from / inspired by
 * check_ungrouped_columns_walker.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>AddAnyValueAggregates</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>AddAnyValueAggregatesContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* any column is allowed to appear in an aggregate or grouping */</comment>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check whether this Var appears in the GROUP BY.
		 */</comment>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>groupByTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>groupByTargetEntry</argument>, <argument>context-&gt;groupByTargetEntryList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>groupByTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>groupByVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>groupByTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* we should only be doing this at the top level of the query */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>groupByVar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>groupByVar</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
				<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>groupByVar</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* this Var is in the GROUP BY, do not wrap it */</comment>
				<return>return <expr><name>node</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * We have found a Var that does not appear in the GROUP BY.
		 * Wrap it in an any_value aggregate.
		 */</comment>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <call><name>CitusAnyValueFunctionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggcollid</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>agg</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>haveNonVarGrouping</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The GROUP BY contains at least one expression. Check whether the
		 * current expression is equal to one of the GROUP BY expressions.
		 * Otherwise, continue to descend into subexpressions.
		 */</comment>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>groupByTargetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>groupByTargetEntry</argument>, <argument>context-&gt;groupByTargetEntryList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>groupByTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* do not descend into mutator, all Vars are safe */</comment>
				<return>return <expr><name>node</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AddAnyValueAggregates</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QueryGroupClauseList extracts the group clause list from the logical plan. If
 * no grouping clauses exist, the function returns an empty list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>QueryGroupClauseList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pendingNodeList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>pendingNodeList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>currMultiNode</name> <init>= <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pendingNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>nodeType</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>currMultiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>pendingNodeList</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>pendingNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* extract the group clause list from the extended operator */</comment>
		<if_stmt><if>if <condition>(<expr><name>nodeType</name> <operator>==</operator> <name>T_MultiExtendedOp</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOpNode</name> <init>= <expr><operator>(</operator><name>MultiExtendedOp</name> <operator>*</operator><operator>)</operator> <name>currMultiNode</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>groupClauseList</name> <operator>=</operator> <name><name>extendedOpNode</name><operator>-&gt;</operator><name>groupClauseList</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* add children only if this node isn't a multi collect and multi table */</comment>
		<if_stmt><if>if <condition>(<expr><name>nodeType</name> <operator>!=</operator> <name>T_MultiCollect</name> <operator>&amp;&amp;</operator> <name>nodeType</name> <operator>!=</operator> <name>T_MultiTable</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>childNodeList</name> <init>= <expr><call><name>ChildNodeList</name><argument_list>(<argument><expr><name>currMultiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>pendingNodeList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>pendingNodeList</name></expr></argument>, <argument><expr><name>childNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>groupClauseList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QuerySelectClauseList traverses the given logical plan tree, and extracts all
 * select clauses from the select nodes. Note that this function does not walk
 * below a collect node; the clauses below the collect node apply to a remote
 * query, and they would have been captured by the remote job we depend upon.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>QuerySelectClauseList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>selectClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pendingNodeList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>pendingNodeList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>currMultiNode</name> <init>= <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pendingNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>nodeType</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>currMultiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>pendingNodeList</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>pendingNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* extract select clauses from the multi select node */</comment>
		<if_stmt><if>if <condition>(<expr><name>nodeType</name> <operator>==</operator> <name>T_MultiSelect</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiSelect</name> <modifier>*</modifier></type><name>selectNode</name> <init>= <expr><operator>(</operator><name>MultiSelect</name> <operator>*</operator><operator>)</operator> <name>currMultiNode</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>clauseList</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>selectNode</name><operator>-&gt;</operator><name>selectClauseList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>selectClauseList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>selectClauseList</name></expr></argument>, <argument><expr><name>clauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* add children only if this node isn't a multi collect */</comment>
		<if_stmt><if>if <condition>(<expr><name>nodeType</name> <operator>!=</operator> <name>T_MultiCollect</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>childNodeList</name> <init>= <expr><call><name>ChildNodeList</name><argument_list>(<argument><expr><name>currMultiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>pendingNodeList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>pendingNodeList</name></expr></argument>, <argument><expr><name>childNodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>selectClauseList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Create a tree of JoinExpr and RangeTblRef nodes for the job query from
 * a given multiNode. If the tree contains MultiCollect or MultiJoin nodes,
 * add corresponding entries to the range table list. We need to construct
 * the entries at the same time as the tree to know the appropriate rtindex.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>QueryJoinTree</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusNodeTag</name></type> <name>nodeType</name> <init>= <expr><call><name>CitusNodeTag</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>nodeType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_MultiJoin</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiJoin</name> <modifier>*</modifier></type><name>joinNode</name> <init>= <expr><operator>(</operator><name>MultiJoin</name> <operator>*</operator><operator>)</operator> <name>multiNode</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name> <init>= <expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>multiNode</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>columnCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name><name>joinNode</name><operator>-&gt;</operator><name>joinType</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>QueryJoinTree</name><argument_list>(<argument><expr><name><name>binaryNode</name><operator>-&gt;</operator><name>leftChildNode</name></name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>,
										   <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>QueryJoinTree</name><argument_list>(<argument><expr><name><name>binaryNode</name><operator>-&gt;</operator><name>rightChildNode</name></name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>,
										   <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>rangeTableList</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * PostgreSQL's optimizer may mark left joins as anti-joins, when there
			 * is a right-hand-join-key-is-null restriction, but there is no logic
			 * in ruleutils to deparse anti-joins, so we cannot construct a task
			 * query containing anti-joins. We therefore translate anti-joins back
			 * into left-joins. At some point, we may also want to use different
			 * join pruning logic for anti-joins.
			 *
			 * This approach would not work for anti-joins introduced via NOT EXISTS
			 * sublinks, but currently such queries are prevented by error checks in
			 * the logical planner.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_LEFT</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* fix the column attributes in ON (...) clauses */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>joinNode</name><operator>-&gt;</operator><name>joinClauseList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>foreach</name><argument_list>(<argument>columnCell</argument>, <argument>columnList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>columnCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>UpdateColumnAttributes</name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><operator>*</operator><name>rangeTableList</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* adjust our column old attributes for partition pruning to work */</comment>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/* make AND clauses explicit after fixing them */</comment>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_explicit</name><argument_list>(<argument><expr><name><name>joinNode</name><operator>-&gt;</operator><name>joinClauseList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>JoinRangeTableEntry</name><argument_list>(<argument><expr><name>joinExpr</name></expr></argument>,
																 <argument><expr><name>dependentJobList</name></expr></argument>,
																 <argument><expr><operator>*</operator><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>*</operator><name>rangeTableList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>rangeTableList</name></expr></argument>, <argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinExpr</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>T_MultiTable</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>rangeTableNode</name> <init>= <expr><operator>(</operator><name>MultiTable</name> <operator>*</operator><operator>)</operator> <name>multiNode</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryNode</name> <init>= <expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>multiNode</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>unaryNode</name><operator>-&gt;</operator><name>childNode</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* MultiTable is actually a subquery, return the query tree below */</comment>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><call><name>QueryJoinTree</name><argument_list>(<argument><expr><name><name>unaryNode</name><operator>-&gt;</operator><name>childNode</name></name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>,
												<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<return>return <expr><name>childNode</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>uint32</name></type> <name>rangeTableId</name> <init>= <expr><name><name>rangeTableNode</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>rangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>NewTableId</name><argument_list>(<argument><expr><name>rangeTableId</name></expr></argument>, <argument><expr><operator>*</operator><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rangeTableRef</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<case>case <expr><name>T_MultiCollect</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name> <init>= <expr><call><name>OutputTableIdList</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>dependentJob</name> <init>= <expr><call><name>JobForTableIdList</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>, <argument><expr><name>tableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentTargetList</name> <init>= <expr><name><name>dependentJob</name><operator>-&gt;</operator><name>jobQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* compute column names for the derived table */</comment>
			<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>dependentTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><call><name>DerivedColumnNameList</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>,
														 <argument><expr><name><name>dependentJob</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnNames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnTypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColumnTypeMods</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcCollations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>dependentTargetList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"unnamed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>funcColumnNames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>funcColumnNames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>funcColumnTypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>funcColumnTypes</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>funcColumnTypeMods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>funcColumnTypeMods</name></expr></argument>, <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>funcCollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>funcCollations</name></expr></argument>, <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>DerivedRangeTableEntry</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>,
																	<argument><expr><name>columnNameList</name></expr></argument>,
																	<argument><expr><name>tableIdList</name></expr></argument>,
																	<argument><expr><name>funcColumnNames</name></expr></argument>,
																	<argument><expr><name>funcColumnTypes</name></expr></argument>,
																	<argument><expr><name>funcColumnTypeMods</name></expr></argument>,
																	<argument><expr><name>funcCollations</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>rangeTableList</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rangeTableList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>rangeTableList</name></expr></argument>, <argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rangeTableRef</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>T_MultiCartesianProduct</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name> <init>= <expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>multiNode</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>QueryJoinTree</name><argument_list>(<argument><expr><name><name>binaryNode</name><operator>-&gt;</operator><name>leftChildNode</name></name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>,
										   <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>QueryJoinTree</name><argument_list>(<argument><expr><name><name>binaryNode</name><operator>-&gt;</operator><name>rightChildNode</name></name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>,
										   <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>rangeTableList</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>JoinRangeTableEntry</name><argument_list>(<argument><expr><name>joinExpr</name></expr></argument>,
																 <argument><expr><name>dependentJobList</name></expr></argument>,
																 <argument><expr><operator>*</operator><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><operator>*</operator><name>rangeTableList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>rangeTableList</name></expr></argument>, <argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinExpr</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>T_MultiTreeRoot</name></expr>:</case>
		<case>case <expr><name>T_MultiSelect</name></expr>:</case>
		<case>case <expr><name>T_MultiProject</name></expr>:</case>
		<case>case <expr><name>T_MultiExtendedOp</name></expr>:</case>
		<case>case <expr><name>T_MultiPartition</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryNode</name> <init>= <expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>multiNode</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>childNode</name> <init>= <expr><call><name>QueryJoinTree</name><argument_list>(<argument><expr><name><name>unaryNode</name><operator>-&gt;</operator><name>childNode</name></name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>,
											<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<return>return <expr><name>childNode</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized multi-node type: %d"</literal></expr></argument>, <argument><expr><name>nodeType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * JoinRangeTableEntry builds a range table entry for a fully initialized JoinExpr node.
 * The column names and vars are determined using expandRTE, analogous to
 * transformFromClauseItem.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>JoinRangeTableEntry</name><parameter_list>(<parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>leftColumnNames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>leftColumnVars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinedColumnNames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinedColumnVars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>leftRangeTableId</name> <init>= <expr><call><name>ExtractRangeTableId</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>leftRTE</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>leftRangeTableId</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightColumnNames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightColumnVars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rightRangeTableId</name> <init>= <expr><call><name>ExtractRangeTableId</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rightRTE</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rightRangeTableId</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name><name>joinExpr</name><operator>-&gt;</operator><name>alias</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"unnamed_join"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>leftCallingRTE</name> <init>= <expr><call><name>ConstructCallingRTE</name><argument_list>(<argument><expr><name>leftRTE</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rightCallingRte</name> <init>= <expr><call><name>ConstructCallingRTE</name><argument_list>(<argument><expr><name>rightRTE</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExtractColumns</name><argument_list>(<argument><expr><name>leftCallingRTE</name></expr></argument>, <argument><expr><name>leftRangeTableId</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>leftColumnNames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftColumnVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExtractColumns</name><argument_list>(<argument><expr><name>rightCallingRte</name></expr></argument>, <argument><expr><name>rightRangeTableId</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>rightColumnNames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightColumnVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>leftRelId</name> <init>= <expr><name><name>leftCallingRTE</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>rightRelId</name> <init>= <expr><name><name>rightCallingRte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>joinedColumnNames</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>joinedColumnNames</name></expr></argument>, <argument><expr><name>leftColumnNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>joinedColumnNames</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>joinedColumnNames</name></expr></argument>, <argument><expr><name>rightColumnNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>joinedColumnVars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>joinedColumnVars</name></expr></argument>, <argument><expr><name>leftColumnVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>joinedColumnVars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>joinedColumnVars</name></expr></argument>, <argument><expr><name>rightColumnVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>joinedColumnNames</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>=</operator> <name>joinedColumnVars</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetJoinRelatedColumnsCompat</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>leftRelId</name></expr></argument>, <argument><expr><name>rightRelId</name></expr></argument>, <argument><expr><name>leftColumnVars</name></expr></argument>,
								<argument><expr><name>rightColumnVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rangeTableEntry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetJoinRelatedColumnsCompat sets join related fields on the given range table entry.
 * Currently it sets joinleftcols/joinrightcols which are introduced with postgres 13.
 * For more info see postgres commit: 9ce77d75c5ab094637cc4a446296dc3be6e3c221
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetJoinRelatedColumnsCompat</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>leftRelId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rightRelId</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>leftColumnVars</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rightColumnVars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We don't have any merged columns so set it to 0 */</comment>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>joinmergedcols</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>leftRelId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>joinleftcols</name></name> <operator>=</operator> <call><name>GetColumnOriginalIndexes</name><argument_list>(<argument><expr><name>leftRelId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>leftColsSize</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>leftColumnVars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>joinleftcols</name></name> <operator>=</operator> <call><name>GeneratePositiveIntSequenceList</name><argument_list>(<argument><expr><name>leftColsSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rightRelId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>joinrightcols</name></name> <operator>=</operator> <call><name>GetColumnOriginalIndexes</name><argument_list>(<argument><expr><name>rightRelId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>rightColsSize</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>rightColumnVars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>joinrightcols</name></name> <operator>=</operator> <call><name>GeneratePositiveIntSequenceList</name><argument_list>(<argument><expr><name>rightColsSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetColumnOriginalIndexes gets the original indexes of columns by taking column drops into account.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetColumnOriginalIndexes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>originalIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>currentColumn</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>originalIndexes</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>originalIndexes</name></expr></argument>, <argument><expr><name>columnIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>originalIndexes</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractRangeTableId gets the range table id from a node that could
 * either be a JoinExpr or RangeTblRef.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ExtractRangeTableId</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rangeTableId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>rangeTableId</name> <operator>=</operator> <name><name>joinExpr</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>rangeTableId</name> <operator>=</operator> <name><name>rangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rangeTableId</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rangeTableId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractColumns gets a list of column names and vars for a given range
 * table entry using expandRTE.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExtractColumns</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>callingRTE</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangeTableId</name></decl></parameter>,
			   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnNames</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnVars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>subLevelsUp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>location</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>includeDroppedColumns</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>callingRTE</name></expr></argument>, <argument><expr><name>rangeTableId</name></expr></argument>, <argument><expr><name>subLevelsUp</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>includeDroppedColumns</name></expr></argument>,
			  <argument><expr><name>columnNames</name></expr></argument>, <argument><expr><name>columnVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ConstructCallingRTE constructs a calling RTE from the given range table entry and
 * dependentJobList in case of repartition joins. Since the range table entries in a job
 * query are mocked RTE_FUNCTION entries, this construction is needed to form an RTE
 * that expandRTE can handle.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>ConstructCallingRTE</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>callingRTE</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusRTEKind</name></type> <name>rangeTableKind</name> <init>= <expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rangeTableKind</name> <operator>==</operator> <name>CITUS_RTE_JOIN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For joins, we can call expandRTE directly.
		 */</comment>
		<expr_stmt><expr><name>callingRTE</name> <operator>=</operator> <name>rangeTableEntry</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rangeTableKind</name> <operator>==</operator> <name>CITUS_RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For distributed tables, we construct a regular table RTE to call
		 * expandRTE, which will extract columns from the distributed table
		 * schema.
		 */</comment>
		<expr_stmt><expr><name>callingRTE</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callingRTE</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callingRTE</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>eref</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callingRTE</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callingRTE</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inh</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rangeTableKind</name> <operator>==</operator> <name>CITUS_RTE_REMOTE_QUERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>dependentJob</name> <init>= <expr><call><name>JobForRangeTable</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>, <argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name> <init>= <expr><name><name>dependentJob</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For re-partition jobs, we construct a subquery RTE to call expandRTE,
		 * which will extract the columns from the target list of the job query.
		 */</comment>
		<expr_stmt><expr><name>callingRTE</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callingRTE</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callingRTE</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>eref</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>callingRTE</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>jobQuery</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported Citus RTE kind: %d"</literal></expr></argument>, <argument><expr><name>rangeTableKind</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>callingRTE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QueryFromList creates the from list construct that is used for building the
 * query's join tree. The function creates the from list by making a range table
 * reference for each entry in the given range table list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>QueryFromList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fromList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rangeTableCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>Index</name></type> <name>rangeTableIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>rangeTableIndex</name> <operator>&lt;=</operator> <name>rangeTableCount</name></expr>;</condition> <incr><expr><name>rangeTableIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableReference</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rangeTableReference</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rangeTableIndex</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>fromList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fromList</name></expr></argument>, <argument><expr><name>rangeTableReference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>fromList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildSubqueryJobQuery traverses the given logical plan tree, finds MultiTable
 * which represents the subquery. It builds the query structure by adding this
 * subquery as it is to range table list of the query.
 *
 * Such as if user runs a query like this;
 *
 * SELECT avg(id) FROM (
 *     SELECT ... FROM ()
 * )
 *
 * then this function will build this worker query as keeping subquery as it is;
 *
 * SELECT sum(id), count(id) FROM (
 *     SELECT ... FROM ()
 * )
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>BuildSubqueryJobQuery</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasAggregates</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctClause</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasDistinctOn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasWindowFuncs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>windowClause</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we start building jobs from below the collect node */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>CitusIsA</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subqueryMultiTableList</name> <init>= <expr><call><name>SubqueryMultiTableList</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>subqueryMultiTableList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>multiTable</name> <init>= <expr><operator>(</operator><name>MultiTable</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>subqueryMultiTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>multiTable</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  build subquery range table list */</comment>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name><name>multiTable</name><operator>-&gt;</operator><name>referenceNames</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name><name>multiTable</name><operator>-&gt;</operator><name>alias</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>subquery</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we have an extended operator, then we copy the operator's target list.
	 * Otherwise, we use the target list based on the MultiProject node at this
	 * level in the query tree.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>extendedOpNodeList</name> <init>= <expr><call><name>FindNodesOfType</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>T_MultiExtendedOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extendedOpNodeList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOp</name> <init>= <expr><operator>(</operator><name>MultiExtendedOp</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>extendedOpNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>extendedOp</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>QueryTargetList</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* extract limit count/offset, sort and having clauses */</comment>
	<if_stmt><if>if <condition>(<expr><name>extendedOpNodeList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOp</name> <init>= <expr><operator>(</operator><name>MultiExtendedOp</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>extendedOpNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>limitCount</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>limitCount</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>limitOffset</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sortClauseList</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>sortClauseList</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>havingQual</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>havingQual</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>distinctClause</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasDistinctOn</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>hasDistinctOn</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasWindowFuncs</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>windowClause</name> <operator>=</operator> <name><name>extendedOp</name><operator>-&gt;</operator><name>windowClause</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* build group clauses */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name> <init>= <expr><call><name>QueryGroupClauseList</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build the where clause list using select predicates */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name> <init>= <expr><call><name>QuerySelectClauseList</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>havingQual</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hasAggregates</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* distinct is not sent to worker query if there are top level aggregates */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasAggregates</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hasDistinctOn</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>distinctClause</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * Build the From/Where construct. We keep the where-clause list implicitly
	 * AND'd, since both partition and join pruning depends on the clauses being
	 * expressed as a list.
	 */</comment>
	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>joinTree</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>joinTree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>whereClauseList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinTree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator> <call><name>QueryFromList</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build the query structure for this job */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>querySource</name></name> <operator>=</operator> <name>QSRC_ORIGINAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name>rangeTableList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>targetList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <name>joinTree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name>sortClauseList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>groupClauseList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name>limitOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>limitCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <name>havingQual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name>hasAggregates</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>hasDistinctOn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>distinctClause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name>hasWindowFuncs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name>windowClause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>jobQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>==</operator> <call><name>contain_window_function</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>jobQuery</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>jobQuery</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateAllColumnAttributes extracts column references from provided columnContainer
 * and calls UpdateColumnAttributes to updates the column's range table reference (varno) and
 * column attribute number for the range table (varattno).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateAllColumnAttributes</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>columnContainer</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>columnCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><name>columnContainer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>columnCell</argument>, <argument>columnList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>columnCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>UpdateColumnAttributes</name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateColumnAttributes updates the column's range table reference (varno) and
 * column attribute number for the range table (varattno). The function uses the
 * newly built range table list to update the given column's attributes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateColumnAttributes</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type> <name>originalTableId</name> <init>= <expr><name><name>column</name><operator>-&gt;</operator><name>varnosyn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>originalColumnId</name> <init>= <expr><name><name>column</name><operator>-&gt;</operator><name>varattnosyn</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* find the new table identifier */</comment>
	<decl_stmt><decl><type><name>Index</name></type> <name>newTableId</name> <init>= <expr><call><name>NewTableId</name><argument_list>(<argument><expr><name>originalTableId</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>newColumnId</name> <init>= <expr><name>originalColumnId</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if this is a derived table, find the new column identifier */</comment>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newRangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>newTableId</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>newRangeTableEntry</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CITUS_RTE_REMOTE_QUERY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newColumnId</name> <operator>=</operator> <call><name>NewColumnId</name><argument_list>(<argument><expr><name>originalTableId</name></expr></argument>, <argument><expr><name>originalColumnId</name></expr></argument>,
								  <argument><expr><name>newRangeTableEntry</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>newTableId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>newColumnId</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * NewTableId determines the new tableId for the query that is currently being
 * built. In this query, the original tableId represents the order of the table
 * in the initial parse tree. When queries involve repartitioning, we re-order
 * tables; and the new tableId corresponds to this new table order.
 */</comment>
<function><type><specifier>static</specifier> <name>Index</name></type>
<name>NewTableId</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>originalTableId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type> <name>rangeTableIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>originalTableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExtractRangeTblExtraData</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>originalTableIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>listMember</name> <init>= <expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>originalTableIdList</name></expr></argument>, <argument><expr><name>originalTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>listMember</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>rangeTableIndex</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rangeTableIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unrecognized range table id %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>originalTableId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NewColumnId determines the new columnId for the query that is currently being
 * built. In this query, the original columnId corresponds to the column in base
 * tables. When the current query is a partition job and generates intermediate
 * tables, the columns have a different order and the new columnId corresponds
 * to this order. Please note that this function assumes columnIds for dependent
 * jobs have already been updated.
 */</comment>
<function><type><specifier>static</specifier> <name>AttrNumber</name></type>
<name>NewColumnId</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>originalTableId</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>originalColumnId</name></decl></parameter>,
			<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newRangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>newColumnId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>dependentJob</name> <init>= <expr><call><name>JobForRangeTable</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>, <argument><expr><name>newRangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>dependentJob</name><operator>-&gt;</operator><name>jobQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>targetEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>targetEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check against the *old* values for this column, as the new values
		 * would have been updated already.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>==</operator> <name>originalTableId</name> <operator>&amp;&amp;</operator>
			<name><name>column</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>==</operator> <name>originalColumnId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newColumnId</name> <operator>=</operator> <name>columnIndex</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>columnIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>newColumnId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JobForRangeTable returns the job that corresponds to the given range table
 * entry. The function walks over jobs in the given job list, and compares each
 * job's table list against the given range table entry's table list. When two
 * table lists match, the function returns the matching job. Note that we call
 * this function in practice when we need to determine which one of the jobs we
 * depend upon corresponds to given range table entry.
 */</comment>
<function><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type>
<name>JobForRangeTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>jobList</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>searchedTableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusRTEKind</name></type> <name>rangeTableKind</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractRangeTblExtraData</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rangeTableKind</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>searchedTableIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rangeTableKind</name> <operator>==</operator> <name>CITUS_RTE_REMOTE_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>searchedJob</name> <init>= <expr><call><name>JobForTableIdList</name><argument_list>(<argument><expr><name>jobList</name></expr></argument>, <argument><expr><name>searchedTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>searchedJob</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JobForTableIdList returns the job that corresponds to the given
 * tableIdList. The function walks over jobs in the given job list, and
 * compares each job's table list against the given table list. When the
 * two table lists match, the function returns the matching job.
 */</comment>
<function><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type>
<name>JobForTableIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>jobList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>searchedTableIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>searchedJob</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>jobCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>jobCell</argument>, <argument>jobList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><operator>(</operator><name>Job</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>jobCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobRangeTableList</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>jobQuery</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobTableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>jobRangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>jobRangeTableCell</argument>, <argument>jobRangeTableList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>jobRangeTable</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>jobRangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ExtractRangeTblExtraData</name><argument_list>(<argument><expr><name>jobRangeTable</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tableIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* copy the list since list_concat is destructive */</comment>
			<expr_stmt><expr><name>tableIdList</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>tableIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>jobTableIdList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>jobTableIdList</name></expr></argument>, <argument><expr><name>tableIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Check if the searched range table's tableIds and the current job's
		 * tableIds are the same.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>lhsDiff</name> <init>= <expr><call><name>list_difference_int</name><argument_list>(<argument><expr><name>jobTableIdList</name></expr></argument>, <argument><expr><name>searchedTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rhsDiff</name> <init>= <expr><call><name>list_difference_int</name><argument_list>(<argument><expr><name>searchedTableIdList</name></expr></argument>, <argument><expr><name>jobTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>lhsDiff</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>rhsDiff</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>searchedJob</name> <operator>=</operator> <name>job</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>searchedJob</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>searchedJob</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Returns the list of children for the given multi node. */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ChildNodeList</name><parameter_list>(<parameter><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>childNodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isUnaryNode</name> <init>= <expr><call><name>UnaryOperator</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isBinaryNode</name> <init>= <expr><call><name>BinaryOperator</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* relation table nodes don't have any children */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>multiNode</name></expr></argument>, <argument><expr><name>MultiTable</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>multiTable</name> <init>= <expr><operator>(</operator><name>MultiTable</name> <operator>*</operator><operator>)</operator> <name>multiNode</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>multiTable</name><operator>-&gt;</operator><name>relationId</name></name> <operator>!=</operator> <name>SUBQUERY_RELATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isUnaryNode</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiUnaryNode</name> <modifier>*</modifier></type><name>unaryNode</name> <init>= <expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>multiNode</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>childNodeList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>unaryNode</name><operator>-&gt;</operator><name>childNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>isBinaryNode</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiBinaryNode</name> <modifier>*</modifier></type><name>binaryNode</name> <init>= <expr><operator>(</operator><name>MultiBinaryNode</name> <operator>*</operator><operator>)</operator> <name>multiNode</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>childNodeList</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name><name>binaryNode</name><operator>-&gt;</operator><name>leftChildNode</name></name></expr></argument>,
								   <argument><expr><name><name>binaryNode</name><operator>-&gt;</operator><name>rightChildNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>childNodeList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UniqueJobId allocates and returns a unique jobId for the job to be executed.
 *
 * The resulting job ID is built up as:
 * &lt;16-bit group ID&gt;&lt;24-bit process ID&gt;&lt;1-bit secondary flag&gt;&lt;23-bit local counter&gt;
 *
 * When citus.enable_unique_job_ids is off then only the local counter is
 * included to get repeatable results.
 */</comment>
<function><type><name>uint64</name></type>
<name>UniqueJobId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>jobIdCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>processId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>localGroupId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>jobIdCounter</name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>EnableUniqueJobIds</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Add the local group id information to the jobId to
		 * prevent concurrent jobs on different groups to conflict.
		 */</comment>
		<expr_stmt><expr><name>localGroupId</name> <operator>=</operator> <call><name>GetLocalGroupId</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>jobId</name> <operator>=</operator> <name>jobId</name> <operator>|</operator> <operator>(</operator><name>localGroupId</name> <operator>&lt;&lt;</operator> <literal type="number">48</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add the current process ID to distinguish jobs by this
		 * backends from jobs started by other backends. Process
		 * IDs can have at most 24-bits on platforms supported by
		 * Citus.
		 */</comment>
		<expr_stmt><expr><name>processId</name> <operator>=</operator> <name>MyProcPid</name> <operator>&amp;</operator> <literal type="number">0xFFFFFF</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>jobId</name> <operator>=</operator> <name>jobId</name> <operator>|</operator> <operator>(</operator><name>processId</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add an extra bit for secondaries to distinguish their
		 * jobs from primaries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>jobId</name> <operator>=</operator> <name>jobId</name> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">23</literal><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Use the remaining 23 bits to distinguish jobs by the
	 * same backend.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobIdNumber</name> <init>= <expr><name>jobIdCounter</name> <operator>&amp;</operator> <literal type="number">0x1FFFFFF</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>jobId</name> <operator>=</operator> <name>jobId</name> <operator>|</operator> <name>jobIdNumber</name></expr>;</expr_stmt>

	<return>return <expr><name>jobId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Builds a job from the given job query and dependent job list. */</comment>
<function><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type>
<name>BuildJob</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <call><name>UniqueJobId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>jobQuery</name></name> <operator>=</operator> <name>jobQuery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>dependentJobList</name></name> <operator>=</operator> <name>dependentJobList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>requiresCoordinatorEvaluation</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>job</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildMapMergeJob builds a MapMerge job from the given query and dependent job
 * list. The function then copies and updates the logical plan's partition
 * column, and uses the join rule type to determine the physical repartitioning
 * method to apply.
 */</comment>
<function><type><specifier>static</specifier> <name>MapMergeJob</name> <modifier>*</modifier></type>
<name>BuildMapMergeJob</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionKey</name></decl></parameter>,
				 <parameter><decl><type><name>PartitionType</name></type> <name>partitionType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>baseRelationId</name></decl></parameter>,
				 <parameter><decl><type><name>BoundaryNodeJobType</name></type> <name>boundaryNodeJobType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>jobQuery</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>partitionKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* update the logical partition key's table and column identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><name>boundaryNodeJobType</name> <operator>!=</operator> <name>SUBQUERY_MAP_MERGE_JOB</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UpdateColumnAttributes</name><argument_list>(<argument><expr><name>partitionColumn</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MapMergeJob</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>job</name><operator>.</operator><name>jobId</name></name> <operator>=</operator> <call><name>UniqueJobId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>job</name><operator>.</operator><name>jobQuery</name></name> <operator>=</operator> <name>jobQuery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>job</name><operator>.</operator><name>dependentJobList</name></name> <operator>=</operator> <name>dependentJobList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <name>partitionColumn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>sortedShardIntervalArrayLength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * We assume dual partition join defaults to hash partitioning, and single
	 * partition join defaults to range partitioning. In practice, the join type
	 * should have no impact on the physical repartitioning (hash/range) method.
	 * If join type is not set, this means this job represents a subquery, and
	 * uses hash partitioning.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partitionType</name> <operator>==</operator> <name>DUAL_HASH_PARTITION_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>partitionCount</name> <init>= <expr><call><name>HashPartitionCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionType</name></name> <operator>=</operator> <name>DUAL_HASH_PARTITION_TYPE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionCount</name></name> <operator>=</operator> <name>partitionCount</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>partitionType</name> <operator>==</operator> <name>SINGLE_HASH_PARTITION_TYPE</name> <operator>||</operator> <name>partitionType</name> <operator>==</operator>
			 <name>RANGE_PARTITION_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>baseRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name><name>cache</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>cachedSortedShardIntervalArray</name> <init>=
			<expr><name><name>cache</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>hasUninitializedShardInterval</name> <init>=
			<expr><name><name>cache</name><operator>-&gt;</operator><name>hasUninitializedShardInterval</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>sortedShardIntervalArray</name> <init>=
			<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardInterval</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>shardCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name>shardCount</name></expr>;</condition> <incr><expr><name>shardIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name> <operator>=</operator>
				<call><name>CopyShardInterval</name><argument_list>(<argument><expr><name><name>cachedSortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>hasUninitializedShardInterval</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot range repartition shard with "</literal>
								   <literal type="string">"missing min/max values"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionType</name></name> <operator>=</operator> <name>partitionType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionCount</name></name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>shardCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name> <operator>=</operator> <name>sortedShardIntervalArray</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>sortedShardIntervalArrayLength</name></name> <operator>=</operator> <name>shardCount</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>mapMergeJob</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HashPartitionCount returns the number of partition files we create for a hash
 * partition task. The function follows Hadoop's method for picking the number
 * of reduce tasks: 0.95 or 1.75 * node count * max reduces per node. We choose
 * the lower constant 0.95 so that all tasks can start immediately, but round it
 * to 1.0 so that we have a smooth number of partition tasks.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>HashPartitionCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>groupCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>ActiveReadableNodeList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>maxReduceTasksPerNode</name> <init>= <expr><name>RepartitionJoinBucketCountPerNode</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>partitionCount</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>groupCount</name> <operator>*</operator> <name>maxReduceTasksPerNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>partitionCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ------------------------------------------------------------
 * Functions that relate to building and assigning tasks follow
 * ------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * BuildJobTreeTaskList takes in the given job tree and walks over jobs in this
 * tree bottom up. The function then creates tasks for each job in the tree,
 * sets dependencies between tasks and their downstream dependencies and assigns
 * tasks to worker nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type>
<name>BuildJobTreeTaskList</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>jobTree</name></decl></parameter>, <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>flattenedJobList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We traverse the job tree in preorder, and append each visited job to our
	 * flattened list. This way, each job in our list appears before the jobs it
	 * depends on.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jobStack</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>jobTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>jobStack</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><operator>(</operator><name>Job</name> <operator>*</operator><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><name>jobStack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>flattenedJobList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>flattenedJobList</name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* pop top element and push its children to the stack */</comment>
		<expr_stmt><expr><name>jobStack</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>jobStack</name></expr></argument>, <argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>jobStack</name> <operator>=</operator> <call><name>list_union_ptr</name><argument_list>(<argument><expr><name>jobStack</name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>dependentJobList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * We walk the job list in reverse order to visit jobs bottom up. This way,
	 * we can create dependencies between tasks bottom up, and assign them to
	 * worker nodes accordingly.
	 */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>flattenedJobCount</name> <init>= <expr><operator>(</operator><name>int32</name><operator>)</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>flattenedJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int32</name></type> <name>jobIndex</name> <init>= <expr><operator>(</operator><name>flattenedJobCount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</init> <condition><expr><name>jobIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>jobIndex</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><operator>(</operator><name>Job</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>flattenedJobList</name></expr></argument>, <argument><expr><name>jobIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sqlTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>assignedSqlTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* create sql tasks for the job, and prune redundant data fetch tasks */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>job</name><operator>-&gt;</operator><name>subqueryPushdown</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>isMultiShardQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedRelationShardList</name> <init>=
				<expr><call><name>TargetShardIntervalsForRestrictInfo</name><argument_list>(<argument><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator>
													<name>relationRestrictionContext</name></name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>isMultiShardQuery</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>deferredErrorMessage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>sqlTaskList</name> <operator>=</operator> <call><name>QueryPushdownSqlTaskList</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>,
												   <argument><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator>
												   <name>relationRestrictionContext</name></name></expr></argument>,
												   <argument><expr><name>prunedRelationShardList</name></expr></argument>, <argument><expr><name>READ_TASK</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>deferredErrorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>deferredErrorMessage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RaiseDeferredErrorInternal</name><argument_list>(<argument><expr><name>deferredErrorMessage</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sqlTaskList</name> <operator>=</operator> <call><name>SqlTaskList</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>sqlTaskList</name> <operator>=</operator> <call><name>PruneSqlTaskDependencies</name><argument_list>(<argument><expr><name>sqlTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We first assign sql and merge tasks to worker nodes. Next, we assign
		 * sql tasks' data fetch dependencies.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>assignedSqlTaskList</name> <init>= <expr><call><name>AssignTaskList</name><argument_list>(<argument><expr><name>sqlTaskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AssignDataFetchDependencies</name><argument_list>(<argument><expr><name>assignedSqlTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if the parameters has not been resolved, record it */</comment>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>parametersInJobQueryResolved</name></name> <operator>=</operator>
			<operator>!</operator><call><name>HasUnresolvedExternParamsWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>job</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make final adjustments for the assigned tasks.
		 *
		 * First, update SELECT tasks' parameters resolved field.
		 *
		 * Second, assign merge task's data fetch dependencies.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>assignedSqlTaskCell</argument>, <argument>assignedSqlTaskList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>assignedSqlTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>assignedSqlTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* we don't support parameters in the physical planner */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>assignedSqlTask</name><operator>-&gt;</operator><name>taskType</name></name> <operator>==</operator> <name>READ_TASK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>assignedSqlTask</name><operator>-&gt;</operator><name>parametersInQueryStringResolved</name></name> <operator>=</operator>
					<name><name>job</name><operator>-&gt;</operator><name>parametersInJobQueryResolved</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>assignedMergeTaskList</name> <init>= <expr><call><name>FindDependentMergeTaskList</name><argument_list>(<argument><expr><name>assignedSqlTask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>AssignDataFetchDependencies</name><argument_list>(<argument><expr><name>assignedMergeTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If we have a MapMerge job, the map tasks in this job wrap around the
		 * SQL tasks and their assignments.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>MapMergeJob</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name> <init>= <expr><operator>(</operator><name>MapMergeJob</name> <operator>*</operator><operator>)</operator> <name>job</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type> <name>taskIdIndex</name> <init>= <expr><call><name>TaskListHighestTaskId</name><argument_list>(<argument><expr><name>assignedSqlTaskList</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mapTaskList</name> <init>= <expr><call><name>MapTaskList</name><argument_list>(<argument><expr><name>mapMergeJob</name></expr></argument>, <argument><expr><name>assignedSqlTaskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeTaskList</name> <init>= <expr><call><name>MergeTaskList</name><argument_list>(<argument><expr><name>mapMergeJob</name></expr></argument>, <argument><expr><name>mapTaskList</name></expr></argument>, <argument><expr><name>taskIdIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>mapTaskList</name></name> <operator>=</operator> <name>mapTaskList</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>mergeTaskList</name></name> <operator>=</operator> <name>mergeTaskList</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>assignedSqlTaskList</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>jobTree</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QueryPushdownSqlTaskList creates a list of SQL tasks to execute the given subquery
 * pushdown job. For this, it is being checked whether the query is router
 * plannable per target shard interval. For those router plannable worker
 * queries, we create a SQL task and append the task to the task list that is going
 * to be executed.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>QueryPushdownSqlTaskList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>,
						 <parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>relationRestrictionContext</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedRelationShardList</name></decl></parameter>, <parameter><decl><type><name>TaskType</name></type> <name>taskType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
						 <name>modifyRequiresCoordinatorEvaluation</name></decl></parameter>,
						 <parameter><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>planningError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sqlTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>taskIdIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 0 is reserved for invalid taskId */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>taskRequiredForShardIndex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* error if shards are not co-partitioned */</comment>
	<expr_stmt><expr><call><name>ErrorIfUnsupportedShardDistribution</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>relationRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>planningError</name> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									   <argument><expr><literal type="string">"cannot handle complex subqueries when the "</literal>
									   <literal type="string">"router executor is disabled"</literal></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* defaults to be used if this is a reference table-only query */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>minShardOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>maxShardOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>forboth_ptr</name><argument_list>(<argument>prunedShardList</argument>, <argument>prunedRelationShardList</argument>,
				<argument>relationRestriction</argument>, <argument>relationRestrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we expect distributed tables to have the same shard count */</comment>
		<if_stmt><if>if <condition>(<expr><name>shardCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>shardCount</name> <operator>!=</operator> <name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>planningError</name> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
										   <argument><expr><literal type="string">"shard counts of co-located tables do not "</literal>
										   <literal type="string">"match"</literal></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>taskRequiredForShardIndex</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>shardCount</name> <operator>=</operator> <name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>taskRequiredForShardIndex</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* there is a distributed table, find the shard range */</comment>
			<expr_stmt><expr><name>minShardOffset</name> <operator>=</operator> <name>shardCount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxShardOffset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For left joins we don't care about the shards pruned for the right hand side.
		 * If the right hand side would prune to a smaller set we should still send it to
		 * all tables of the left hand side. However if the right hand side is bigger than
		 * the left hand side we don't have to send the query to any shard that is not
		 * matching anything on the left hand side.
		 *
		 * Instead we will simply skip any RelationRestriction if it is an OUTER join and
		 * the table is part of the non-outer side of the join.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsInnerTableOfOuterJoin</name><argument_list>(<argument><expr><name>relationRestriction</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>prunedShardList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardIndex</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>taskRequiredForShardIndex</name><index>[<expr><name>shardIndex</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>minShardOffset</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minShardOffset</name></expr></argument>, <argument><expr><name>shardIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxShardOffset</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxShardOffset</name></expr></argument>, <argument><expr><name>shardIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/*
	 * To avoid iterating through all shards indexes we keep the minimum and maximum
	 * offsets of shards that were not pruned away. This optimisation is primarily
	 * relevant for queries on range-distributed tables that, due to range filters,
	 * prune to a small number of adjacent shards.
	 *
	 * In other cases, such as an OR condition on a hash-distributed table, we may
	 * still visit most or all shards even if some of them were pruned away. However,
	 * given that hash-distributed tables typically only have a few shards the
	 * iteration is still very fast.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardOffset</name> <init>= <expr><name>minShardOffset</name></expr></init></decl>;</init> <condition><expr><name>shardOffset</name> <operator>&lt;=</operator> <name>maxShardOffset</name></expr>;</condition> <incr><expr><name>shardOffset</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>taskRequiredForShardIndex</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>taskRequiredForShardIndex</name><index>[<expr><name>shardOffset</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* this shard index is pruned away for all relations */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>subqueryTask</name> <init>= <expr><call><name>QueryPushdownTaskCreate</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>shardOffset</name></expr></argument>,
													 <argument><expr><name>relationRestrictionContext</name></expr></argument>,
													 <argument><expr><name>taskIdIndex</name></expr></argument>,
													 <argument><expr><name>taskType</name></expr></argument>,
													 <argument><expr><name>modifyRequiresCoordinatorEvaluation</name></expr></argument>,
													 <argument><expr><name>planningError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>planningError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>subqueryTask</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sqlTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sqlTaskList</name></expr></argument>, <argument><expr><name>subqueryTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>++</operator><name>taskIdIndex</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If it is a modify task with multiple tables */</comment>
	<if_stmt><if>if <condition>(<expr><name>taskType</name> <operator>==</operator> <name>MODIFY_TASK</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(
			<argument><expr><name><name>relationRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>sqlTaskList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>modifyWithSubquery</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>sqlTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsInnerTableOfOuterJoin tests based on the join information envoded in a
 * RelationRestriction if the table accessed for this relation is
 *   a) in an outer join
 *   b) on the inner part of said join
 *
 * The function returns true only if both conditions above hold true
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsInnerTableOfOuterJoin</name><parameter_list>(<parameter><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>joinInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>joinInfo</argument>, <argument>relationRestriction-&gt;relOptInfo-&gt;joininfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>joinInfo</name><operator>-&gt;</operator><name>outer_relids</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not an outer join */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * This join restriction info describes an outer join, we need to figure out if
		 * our table is in the non outer part of this join. If that is the case this is a
		 * non outer table of an outer join.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>isInOuter</name> <init>= <expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relOptInfo</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
									   <argument><expr><name><name>joinInfo</name><operator>-&gt;</operator><name>outer_relids</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isInOuter</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* this table is joined in the inner part of an outer join */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* we have not found any join clause that satisfies both requirements */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedShardDistribution gets list of relations in the given query
 * and checks if two conditions below hold for them, otherwise it errors out.
 * a. Every relation is distributed by range or hash. This means shards are
 * disjoint based on the partition column.
 * b. All relations have 1-to-1 shard partitioning between them. This means
 * shard count for every relation is same and for every shard in a relation
 * there is exactly one shard in other relations with same min/max values.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedShardDistribution</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>firstTableRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><call><name>DistributedRelationIdList</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nonReferenceRelations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationIdCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>relationIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rangeDistributedRelationCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashDistributedRelationCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>appendDistributedRelationCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationIdCell</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>relationIdCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rangeDistributedRelationCount</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>nonReferenceRelations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>nonReferenceRelations</name></expr></argument>,
												<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hashDistributedRelationCount</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>nonReferenceRelations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>nonReferenceRelations</name></expr></argument>,
												<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* do not need to handle non-distributed tables */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>appendDistributedRelationCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rangeDistributedRelationCount</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>hashDistributedRelationCount</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A query including both range and hash "</literal>
								  <literal type="string">"partitioned relations are unsupported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>rangeDistributedRelationCount</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>appendDistributedRelationCount</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A query including both range and append "</literal>
								  <literal type="string">"partitioned relations are unsupported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>appendDistributedRelationCount</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>hashDistributedRelationCount</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A query including both append and hash "</literal>
								  <literal type="string">"partitioned relations are unsupported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationIdCell</argument>, <argument>nonReferenceRelations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>relationIdCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>currentRelationId</name> <init>= <expr><name>relationId</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* get shard list of first relation and continue for the next relation */</comment>
		<if_stmt><if>if <condition>(<expr><name>relationIndex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>firstTableRelationId</name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>relationIndex</name><operator>++</operator></expr>;</expr_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check if this table has 1-1 shard partitioning with first table */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>coPartitionedTables</name> <init>= <expr><call><name>CoPartitionedTables</name><argument_list>(<argument><expr><name>firstTableRelationId</name></expr></argument>,
													   <argument><expr><name>currentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>coPartitionedTables</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Shards of relations in subquery need to "</literal>
									  <literal type="string">"have 1-to-1 shard partitioning"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SubqueryTaskCreate creates a sql task by replacing the target
 * shardInterval's boundary value.
 */</comment>
<function><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type>
<name>QueryPushdownTaskCreate</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardIndex</name></decl></parameter>,
						<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>taskId</name></decl></parameter>,
						<parameter><decl><type><name>TaskType</name></type> <name>taskType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>modifyRequiresCoordinatorEvaluation</name></decl></parameter>,
						<parameter><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>planningError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>taskQuery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>queryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>restrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>anchorShardId</name> <init>= <expr><name>INVALID_SHARD_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>modifyWithSubselect</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>resultRangeTable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>resultRelationOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If it is a modify query with sub-select, we need to set result relation shard's id
	 * as anchor shard id.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>UpdateOrDeleteQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>resultRangeTable</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>originalQuery</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>originalQuery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultRelationOid</name> <operator>=</operator> <name><name>resultRangeTable</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>modifyWithSubselect</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find the relevant shard out of each relation for this task.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>restrictionCell</argument>, <argument>restrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>=
			<expr><operator>(</operator><name>RelationRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>restrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* non-distributed tables have only one shard */</comment>
			<expr_stmt><expr><name>shardInterval</name> <operator>=</operator> <name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* only use reference table as anchor shard if none exists yet */</comment>
			<if_stmt><if>if <condition>(<expr><name>anchorShardId</name> <operator>==</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>anchorShardId</name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>UpdateOrDeleteQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>shardInterval</name> <operator>=</operator> <name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>modifyWithSubselect</name> <operator>||</operator> <name>relationId</name> <operator>==</operator> <name>resultRelationOid</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* for UPDATE/DELETE the shard in the result relation becomes the anchor shard */</comment>
				<expr_stmt><expr><name>anchorShardId</name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* for SELECT we pick an arbitrary shard as the anchor shard */</comment>
			<expr_stmt><expr><name>shardInterval</name> <operator>=</operator> <name><name>cacheEntry</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>anchorShardId</name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>copiedShardInterval</name> <init>= <expr><call><name>CopyShardInterval</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>taskShardList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskShardList</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>copiedShardInterval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>RelationShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>copiedShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>copiedShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>relationShardList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relationShardList</name></expr></argument>, <argument><expr><name>relationShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>anchorShardId</name> <operator>!=</operator> <name>INVALID_SHARD_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskPlacementList</name> <init>= <expr><call><name>PlacementsForWorkersContainingAllShards</name><argument_list>(<argument><expr><name>taskShardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskPlacementList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>planningError</name> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									   <argument><expr><literal type="string">"cannot find a worker that has active placements for all "</literal>
									   <literal type="string">"shards in the query"</literal></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Augment the relations in the query with the shard IDs.
	 */</comment>
	<expr_stmt><expr><call><name>UpdateRelationToShardNames</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>taskQuery</name></expr></argument>, <argument><expr><name>relationShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ands are made implicit during shard pruning, as predicate comparison and
	 * refutation depend on it being so. We need to make them explicit again so
	 * that the query string is generated as (...) AND (...) as opposed to
	 * (...), (...).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>taskQuery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>taskQuery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>taskQuery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_explicit</name><argument_list>(
			<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>taskQuery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>subqueryTask</name> <init>= <expr><call><name>CreateBasicTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskId</name></expr></argument>, <argument><expr><name>taskType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>taskType</name> <operator>==</operator> <name>MODIFY_TASK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>modifyRequiresCoordinatorEvaluation</name><operator>)</operator> <operator>||</operator>
		<name>taskType</name> <operator>==</operator> <name>READ_TASK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_get_query_def</name><argument_list>(<argument><expr><name>taskQuery</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributed statement: %s"</literal></expr></argument>,
								<argument><expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>subqueryTask</name></expr></argument>, <argument><expr><name><name>queryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>subqueryTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTask</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>anchorShardId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name>taskPlacementList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTask</name><operator>-&gt;</operator><name>relationShardList</name></name> <operator>=</operator> <name>relationShardList</name></expr>;</expr_stmt>

	<return>return <expr><name>subqueryTask</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CoPartitionedTables checks if given two distributed tables are co-located.
 */</comment>
<function><type><name>bool</name></type>
<name>CoPartitionedTables</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>firstRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>secondRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>firstTableCache</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>firstRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>secondTableCache</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>secondRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>firstTableCache</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <name>DISTRIBUTE_BY_APPEND</name> <operator>||</operator>
		<name><name>secondTableCache</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <name>DISTRIBUTE_BY_APPEND</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Append-distributed tables can have overlapping shards. Therefore they are
		 * never co-partitioned, not even with themselves.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if the tables have the same colocation ID - if so, we know
	 * they're colocated.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>firstTableCache</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name> <operator>&amp;&amp;</operator>
		<name><name>firstTableCache</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>==</operator> <name><name>secondTableCache</name><operator>-&gt;</operator><name>colocationId</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>firstRelationId</name> <operator>==</operator> <name>secondRelationId</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Even without an explicit co-location ID, non-append tables can be considered
		 * co-located with themselves.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SqlTaskList creates a list of SQL tasks to execute the given job. For this,
 * the function walks over each range table in the job's range table list, gets
 * each range table's table fragments, and prunes unneeded table fragments. The
 * function then joins table fragments from different range tables, and creates
 * all fragment combinations. For each created combination, the function builds
 * a SQL task, and appends this task to a task list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>SqlTaskList</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sqlTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>taskIdIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 0 is reserved for invalid taskId */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>jobId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>anchorRangeTableBasedAssignment</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>anchorRangeTableId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>jobQuery</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>jobQuery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>dependentJobList</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we don't depend on a hash partition, then we determine the largest
	 * table around which we build our queries. This reduces data fetching.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>dependsOnHashPartitionJob</name> <init>= <expr><call><name>DependsOnHashPartitionJob</name><argument_list>(<argument><expr><name>job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dependsOnHashPartitionJob</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>anchorRangeTableBasedAssignment</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>anchorRangeTableId</name> <operator>=</operator> <call><name>AnchorRangeTableId</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>anchorRangeTableId</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>anchorRangeTableId</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* adjust our column old attributes for partition pruning to work */</comment>
	<expr_stmt><expr><call><name>AdjustColumnOldAttributes</name><argument_list>(<argument><expr><name>whereClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AdjustColumnOldAttributes</name><argument_list>(<argument><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ands are made implicit during shard pruning, as predicate comparison and
	 * refutation depend on it being so. We need to make them explicit again so
	 * that the query string is generated as (...) AND (...) as opposed to
	 * (...), (...).
	 */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>whereClauseTree</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_explicit</name><argument_list>(
		<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>jobQuery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>whereClauseTree</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each range table, we first get a list of their shards or merge tasks.
	 * We also apply partition pruning based on the selection criteria. If all
	 * range table fragments are pruned away, we return an empty task list.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableFragmentsList</name> <init>= <expr><call><name>RangeTableFragmentsList</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>,
															<argument><expr><name>whereClauseList</name></expr></argument>,
															<argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rangeTableFragmentsList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We then generate fragment combinations according to how range tables join
	 * with each other (and apply join pruning). Each fragment combination then
	 * represents one SQL task's dependencies.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentCombinationList</name> <init>= <expr><call><name>FragmentCombinationList</name><argument_list>(<argument><expr><name>rangeTableFragmentsList</name></expr></argument>,
															<argument><expr><name>jobQuery</name></expr></argument>, <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>fragmentCombinationCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>fragmentCombinationCell</argument>, <argument>fragmentCombinationList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentCombination</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fragmentCombinationCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* create tasks to fetch fragments required for the sql task */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dataFetchTaskList</name> <init>= <expr><call><name>DataFetchTaskList</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskIdIndex</name></expr></argument>,
													<argument><expr><name>fragmentCombination</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>dataFetchTaskCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>dataFetchTaskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>taskIdIndex</name> <operator>+=</operator> <name>dataFetchTaskCount</name></expr>;</expr_stmt>

		<comment type="block">/* update range table entries with fragment aliases (in place) */</comment>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>taskQuery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>jobQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentRangeTableList</name> <init>= <expr><name><name>taskQuery</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>UpdateRangeTableAlias</name><argument_list>(<argument><expr><name>fragmentRangeTableList</name></expr></argument>, <argument><expr><name>fragmentCombination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* transform the updated task query to a SQL query string */</comment>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>sqlQueryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pg_get_query_def</name><argument_list>(<argument><expr><name>taskQuery</name></expr></argument>, <argument><expr><name>sqlQueryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>sqlTask</name> <init>= <expr><call><name>CreateBasicTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskIdIndex</name></expr></argument>, <argument><expr><name>READ_TASK</name></expr></argument>,
										<argument><expr><name><name>sqlQueryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>sqlTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>dataFetchTaskList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sqlTask</name><operator>-&gt;</operator><name>relationShardList</name></name> <operator>=</operator> <call><name>BuildRelationShardList</name><argument_list>(<argument><expr><name>fragmentRangeTableList</name></expr></argument>,
															<argument><expr><name>fragmentCombination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* log the query string we generated */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"generated sql query for task %d"</literal></expr></argument>, <argument><expr><name><name>sqlTask</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"query string: \"%s\""</literal></expr></argument>,
								   <argument><expr><name><name>sqlQueryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sqlTask</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>INVALID_SHARD_ID</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>anchorRangeTableBasedAssignment</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>sqlTask</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <call><name>AnchorShardId</name><argument_list>(<argument><expr><name>fragmentCombination</name></expr></argument>,
												   <argument><expr><name>anchorRangeTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>taskIdIndex</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>sqlTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sqlTaskList</name></expr></argument>, <argument><expr><name>sqlTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>sqlTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelabelTypeToCollateExpr converts RelabelType's into CollationExpr's.
 * With that, we will be able to pushdown COLLATE's.
 */</comment>
<function><type><name>CollateExpr</name> <modifier>*</modifier></type>
<name>RelabelTypeToCollateExpr</name><parameter_list>(<parameter><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>relabelType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>relabelType</name><operator>-&gt;</operator><name>resultcollid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>collateExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>collateExpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name><name>relabelType</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>collateExpr</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>relabelType</name><operator>-&gt;</operator><name>resultcollid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>collateExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>relabelType</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><name>collateExpr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DependsOnHashPartitionJob checks if the given job depends on a hash
 * partitioning job.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DependsOnHashPartitionJob</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>dependsOnHashPartitionJob</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>dependentJobList</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>dependentJobCount</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>dependentJobCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>dependentJob</name> <init>= <expr><operator>(</operator><name>Job</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>dependentJob</name></expr></argument>, <argument><expr><name>MapMergeJob</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name> <init>= <expr><operator>(</operator><name>MapMergeJob</name> <operator>*</operator><operator>)</operator> <name>dependentJob</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionType</name></name> <operator>==</operator> <name>DUAL_HASH_PARTITION_TYPE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>dependsOnHashPartitionJob</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>dependsOnHashPartitionJob</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AnchorRangeTableId determines the table around which we build our queries,
 * and returns this table's range table id. We refer to this table as the anchor
 * table, and make sure that the anchor table's shards are moved or cached only
 * when absolutely necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>AnchorRangeTableId</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>anchorRangeTableId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>maxTableSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We first filter anything but ordinary tables. Then, we pick the table(s)
	 * with the most number of shards as our anchor table. If multiple tables
	 * have the most number of shards, we have a draw.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>baseTableIdList</name> <init>= <expr><call><name>BaseRangeTableIdList</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>anchorTableIdList</name> <init>= <expr><call><name>AnchorRangeTableIdList</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>baseTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>anchorTableIdCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>anchorTableIdCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>anchorTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>anchorTableIdCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>anchorTableIdCount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>anchorRangeTableId</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name>anchorTableIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>anchorRangeTableId</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If more than one table has the most number of shards, we break the draw
	 * by comparing table sizes and picking the table with the largest size.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>anchorTableIdCell</argument>, <argument>anchorTableIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>anchorTableId</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>anchorTableIdCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>anchorTableId</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>tableSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name> <init>= <expr><call><name>LoadShardList</name><argument_list>(<argument><expr><name><name>tableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>shardCell</argument>, <argument>shardList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name> <modifier>*</modifier></type><name>shardIdPointer</name> <init>= <expr><operator>(</operator><name>uint64</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><operator>(</operator><operator>*</operator><name>shardIdPointer</name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>shardSize</name> <init>= <expr><call><name>ShardLength</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>tableSize</name> <operator>+=</operator> <name>shardSize</name></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>tableSize</name> <operator>&gt;</operator> <name>maxTableSize</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>maxTableSize</name> <operator>=</operator> <name>tableSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>anchorRangeTableId</name> <operator>=</operator> <name>anchorTableId</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>anchorRangeTableId</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* all tables have the same shard count and size 0, pick the first */</comment>
		<expr_stmt><expr><name>anchorRangeTableId</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name>anchorTableIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>anchorRangeTableId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BaseRangeTableIdList walks over range tables in the given range table list,
 * finds range tables that correspond to base (non-repartitioned) tables, and
 * returns these range tables' identifiers in a new list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>BaseRangeTableIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>baseRangeTableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rangeTableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CITUS_RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>baseRangeTableIdList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>baseRangeTableIdList</name></expr></argument>, <argument><expr><name>rangeTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rangeTableId</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>baseRangeTableIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AnchorRangeTableIdList finds ordinary table(s) with the most number of shards
 * and returns the corresponding range table id(s) in a list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>AnchorRangeTableIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>baseRangeTableIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>anchorTableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>maxShardCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>baseRangeTableIdCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>baseRangeTableCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>baseRangeTableIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>baseRangeTableCount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>baseRangeTableIdList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>baseRangeTableIdCell</argument>, <argument>baseRangeTableIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>baseRangeTableId</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>baseRangeTableIdCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>baseRangeTableId</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name> <init>= <expr><call><name>LoadShardList</name><argument_list>(<argument><expr><name><name>tableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>uint32</name></type> <name>shardCount</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>shardCount</name> <operator>&gt;</operator> <name>maxShardCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>anchorTableIdList</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>baseRangeTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxShardCount</name> <operator>=</operator> <name>shardCount</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>shardCount</name> <operator>==</operator> <name>maxShardCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>anchorTableIdList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>anchorTableIdList</name></expr></argument>, <argument><expr><name>baseRangeTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>anchorTableIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AdjustColumnOldAttributes adjust the old tableId (varnosyn) and old columnId
 * (varattnosyn), and sets them equal to the new values. We need this adjustment
 * for partition pruning where we compare these columns with partition columns
 * loaded from system catalogs. Since columns loaded from system catalogs always
 * have the same old and new values, we also need to adjust column values here.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustColumnOldAttributes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>expressionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expressionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>columnCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>columnCell</argument>, <argument>columnList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>columnCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * RangeTableFragmentsList walks over range tables in the given range table list
 * and for each table, the function creates a list of its fragments. A fragment
 * in this list represents either a regular shard or a merge task. Once a list
 * for each range table is constructed, the function applies partition pruning
 * using the given where clause list. Then, the function appends the fragment
 * list for each range table to a list of lists, and returns this list of lists.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>RangeTableFragmentsList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableFragmentsList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rangeTableIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint32</name></type> <name>fragmentSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeTableFragment</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>tableId</name> <init>= <expr><name>rangeTableIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* tableId starts from 1 */</comment>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusRTEKind</name></type> <name>rangeTableKind</name> <init>= <expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>rangeTableKind</name> <operator>==</operator> <name>CITUS_RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardIntervalCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardFragmentList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardIntervalList</name> <init>= <expr><call><name>PruneShards</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>tableId</name></expr></argument>,
														<argument><expr><name>whereClauseList</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we prune all shards for one table, query results will be empty.
			 * We can therefore return NIL for the task list here.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>prunedShardIntervalList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>NIL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>shardIntervalCell</argument>, <argument>prunedShardIntervalList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>=
					<expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardIntervalCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>shardFragment</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>fragmentSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>shardFragment</name><operator>-&gt;</operator><name>fragmentReference</name></name> <operator>=</operator> <name>shardInterval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>shardFragment</name><operator>-&gt;</operator><name>fragmentType</name></name> <operator>=</operator> <name>CITUS_RTE_RELATION</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>shardFragment</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>=</operator> <name>tableId</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>shardFragmentList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shardFragmentList</name></expr></argument>, <argument><expr><name>shardFragment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name>rangeTableFragmentsList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rangeTableFragmentsList</name></expr></argument>,
											  <argument><expr><name>shardFragmentList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>rangeTableKind</name> <operator>==</operator> <name>CITUS_RTE_REMOTE_QUERY</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeTaskFragmentList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>mergeTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>dependentJob</name> <init>= <expr><call><name>JobForRangeTable</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>, <argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>dependentJob</name></expr></argument>, <argument><expr><name>MapMergeJob</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>dependentMapMergeJob</name> <init>= <expr><operator>(</operator><name>MapMergeJob</name> <operator>*</operator><operator>)</operator> <name>dependentJob</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeTaskList</name> <init>= <expr><name><name>dependentMapMergeJob</name><operator>-&gt;</operator><name>mergeTaskList</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* if there are no tasks for the dependent job, just return NIL */</comment>
			<if_stmt><if>if <condition>(<expr><name>mergeTaskList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>NIL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>mergeTaskCell</argument>, <argument>mergeTaskList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mergeTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>mergeTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>mergeTaskFragment</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>fragmentSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>mergeTaskFragment</name><operator>-&gt;</operator><name>fragmentReference</name></name> <operator>=</operator> <name>mergeTask</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mergeTaskFragment</name><operator>-&gt;</operator><name>fragmentType</name></name> <operator>=</operator> <name>CITUS_RTE_REMOTE_QUERY</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mergeTaskFragment</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>=</operator> <name>tableId</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>mergeTaskFragmentList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>mergeTaskFragmentList</name></expr></argument>, <argument><expr><name>mergeTaskFragment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name>rangeTableFragmentsList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rangeTableFragmentsList</name></expr></argument>,
											  <argument><expr><name>mergeTaskFragmentList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rangeTableIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>rangeTableFragmentsList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildBaseConstraint builds and returns a base constraint. This constraint
 * implements an expression in the form of (column &lt;= max &amp;&amp; column &gt;= min),
 * where column is the partition key, and min and max values represent a shard's
 * min and max values. These shard values are filled in after the constraint is
 * built.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>BuildBaseConstraint</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Build these expressions with only one argument for now */</comment>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>lessThanExpr</name> <init>= <expr><call><name>MakeOpExpression</name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>greaterThanExpr</name> <init>= <expr><call><name>MakeOpExpression</name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Build base constaint as an and of two qual conditions */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>baseConstraint</name> <init>= <expr><call><name>make_and_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>lessThanExpr</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>greaterThanExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>baseConstraint</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MakeOpExpression builds an operator expression node. This operator expression
 * implements the operator clause as defined by the variable and the strategy
 * number.
 */</comment>
<function><type><name>OpExpr</name> <modifier>*</modifier></type>
<name>MakeOpExpression</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>strategyNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeId</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>vartype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeModId</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>collationId</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>varcollid</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>accessMethodId</name> <init>= <expr><name>BTREE_AM_OID</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>OperatorCacheEntry</name> <modifier>*</modifier></type><name>operatorCacheEntry</name> <init>= <expr><call><name>LookupOperatorByType</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>,
																  <argument><expr><name>strategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorId</name> <init>= <expr><name><name>operatorCacheEntry</name><operator>-&gt;</operator><name>operatorId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorClassInputType</name> <init>= <expr><name><name>operatorCacheEntry</name><operator>-&gt;</operator><name>operatorClassInputType</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>typeType</name> <init>= <expr><name><name>operatorCacheEntry</name><operator>-&gt;</operator><name>typeType</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Relabel variable if input type of default operator class is not equal to
	 * the variable type. Note that we don't relabel the variable if the default
	 * operator class variable type is a pseudo-type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>operatorClassInputType</name> <operator>!=</operator> <name>typeId</name> <operator>&amp;&amp;</operator> <name>typeType</name> <operator>!=</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>variable</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>makeRelabelType</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>variable</name></expr></argument>, <argument><expr><name>operatorClassInputType</name></expr></argument>,
										   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>collationId</name></expr></argument>, <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>constantValue</name> <init>= <expr><call><name>makeNullConst</name><argument_list>(<argument><expr><name>operatorClassInputType</name></expr></argument>, <argument><expr><name>typeModId</name></expr></argument>, <argument><expr><name>collationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Now make the expression with the given variable and a null constant */</comment>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>operatorId</name></expr></argument>,
												  <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no result type yet */</comment>
												  <argument><expr><name>false</name></expr></argument>, <comment type="block">/* no return set */</comment>
												  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>variable</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>constantValue</name></expr></argument>,
												  <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>collationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set implementing function id and result type */</comment>
	<expr_stmt><expr><name><name>expression</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>operatorId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>expression</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name><name>expression</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>expression</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupOperatorByType is a wrapper around GetOperatorByType(),
 * operatorClassInputType() and get_typtype() functions that uses a cache to avoid
 * multiple lookups of operators and its related fields within a single session by
 * their types, access methods and strategy numbers.
 * LookupOperatorByType function errors out if it cannot find corresponding
 * default operator class with the given parameters on the system catalogs.
 */</comment>
<function><type><specifier>static</specifier> <name>OperatorCacheEntry</name> <modifier>*</modifier></type>
<name>LookupOperatorByType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>strategyNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OperatorCacheEntry</name> <modifier>*</modifier></type><name>matchingCacheEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cacheEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* search the cache */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cacheEntryCell</argument>, <argument>OperatorCache</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OperatorCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cacheEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cacheEntry</name><operator>-&gt;</operator><name>typeId</name></name> <operator>==</operator> <name>typeId</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>cacheEntry</name><operator>-&gt;</operator><name>accessMethodId</name></name> <operator>==</operator> <name>accessMethodId</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>cacheEntry</name><operator>-&gt;</operator><name>strategyNumber</name></name> <operator>==</operator> <name>strategyNumber</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>matchingCacheEntry</name> <operator>=</operator> <name>cacheEntry</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* if not found in the cache, call GetOperatorByType and put the result in cache */</comment>
	<if_stmt><if>if <condition>(<expr><name>matchingCacheEntry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>operatorClassId</name> <init>= <expr><call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>operatorClassId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if operatorId is invalid, error out */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot find default operator class for type:%d,"</literal>
								   <literal type="string">" access method: %d"</literal></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* fill the other fields to the cache */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>operatorId</name> <init>= <expr><call><name>GetOperatorByType</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>, <argument><expr><name>strategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>operatorClassInputType</name> <init>= <expr><call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name>operatorClassId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name>typeType</name> <init>= <expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>operatorClassInputType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* make sure we've initialized CacheMemoryContext */</comment>
		<if_stmt><if>if <condition>(<expr><name>CacheMemoryContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>matchingCacheEntry</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OperatorCacheEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>matchingCacheEntry</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>typeId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>matchingCacheEntry</name><operator>-&gt;</operator><name>accessMethodId</name></name> <operator>=</operator> <name>accessMethodId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>matchingCacheEntry</name><operator>-&gt;</operator><name>strategyNumber</name></name> <operator>=</operator> <name>strategyNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>matchingCacheEntry</name><operator>-&gt;</operator><name>operatorId</name></name> <operator>=</operator> <name>operatorId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>matchingCacheEntry</name><operator>-&gt;</operator><name>operatorClassInputType</name></name> <operator>=</operator> <name>operatorClassInputType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>matchingCacheEntry</name><operator>-&gt;</operator><name>typeType</name></name> <operator>=</operator> <name>typeType</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>OperatorCache</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>OperatorCache</name></expr></argument>, <argument><expr><name>matchingCacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>matchingCacheEntry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetOperatorByType returns the operator oid for the given type, access method,
 * and strategy number.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>GetOperatorByType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>strategyNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Get default operator class from pg_opclass */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorClassId</name> <init>= <expr><call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorFamily</name> <init>= <expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name>operatorClassId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorClassInputType</name> <init>= <expr><call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name>operatorClassId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Lookup for the operator with the desired input type in the family */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorId</name> <init>= <expr><call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>operatorFamily</name></expr></argument>, <argument><expr><name>operatorClassInputType</name></expr></argument>,
										 <argument><expr><name>operatorClassInputType</name></expr></argument>, <argument><expr><name>strategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>operatorId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BinaryOpExpression checks that a given expression is a binary operator. If
 * this is the case it returns true and sets leftOperand and rightOperand to
 * the left and right hand side of the operator. left/rightOperand will be
 * stripped of implicit coercions by strip_implicit_coercions.
 */</comment>
<function><type><name>bool</name></type>
<name>BinaryOpExpression</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>leftOperand</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>rightOperand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>leftOperand</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>leftOperand</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>rightOperand</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>leftOperand</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>leftOperand</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>leftOperand</name> <operator>=</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>leftOperand</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>leftOperand</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>*</operator><name>leftOperand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rightOperand</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>rightOperand</name> <operator>=</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>rightOperand</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>rightOperand</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>*</operator><name>rightOperand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MakeInt4Column creates a column of int4 type with invalid table id and max
 * attribute number.
 */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>MakeInt4Column</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type> <name>tableId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>columnAttributeNumber</name> <init>= <expr><name>RESERVED_HASHED_COLUMN_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>columnType</name> <init>= <expr><name>INT4OID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>columnTypeMod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>columnCollationOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>columnLevelSup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>int4Column</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>columnAttributeNumber</name></expr></argument>, <argument><expr><name>columnType</name></expr></argument>,
							  <argument><expr><name>columnTypeMod</name></expr></argument>, <argument><expr><name>columnCollationOid</name></expr></argument>, <argument><expr><name>columnLevelSup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>int4Column</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Updates the base constraint with the given min/max values. */</comment>
<function><type><name>void</name></type>
<name>UpdateConstraint</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>baseConstraint</name></decl></parameter>, <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>andExpr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>baseConstraint</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>lessThanExpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>andExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>greaterThanExpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>andExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>minNode</name> <init>= <expr><call><name>get_rightop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>greaterThanExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* right op */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>maxNode</name> <init>= <expr><call><name>get_rightop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lessThanExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>    <comment type="block">/* right op */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shardInterval</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>minNode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>maxNode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>minConstant</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>minNode</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>maxConstant</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>maxNode</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>minConstant</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>,
										<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>valueByVal</name></name></expr></argument>,
										<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>valueTypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>maxConstant</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>,
										<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>valueByVal</name></name></expr></argument>,
										<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>valueTypeLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>minConstant</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>maxConstant</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FragmentCombinationList first builds an ordered sequence of range tables that
 * join together. The function then iteratively adds fragments from each joined
 * range table, and forms fragment combinations (lists) that cover all tables.
 * While doing so, the function also performs join pruning to remove unnecessary
 * fragment pairs. Last, the function adds each fragment combination (list) to a
 * list, and returns this list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FragmentCombinationList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableFragmentsList</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentCombinationList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentCombinationQueue</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>emptyList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* find a sequence that joins the range tables in the list */</comment>
	<decl_stmt><decl><type><name>JoinSequenceNode</name> <modifier>*</modifier></type><name>joinSequenceArray</name> <init>= <expr><call><name>JoinSequenceArray</name><argument_list>(<argument><expr><name>rangeTableFragmentsList</name></expr></argument>,
															<argument><expr><name>jobQuery</name></expr></argument>,
															<argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use breadth-first search with pruning to create fragment combinations.
	 * For this, we first queue the root node (an empty combination), and then
	 * start traversing our search space.
	 */</comment>
	<expr_stmt><expr><name>fragmentCombinationQueue</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fragmentCombinationQueue</name></expr></argument>, <argument><expr><name>emptyList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>fragmentCombinationQueue</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tableFragmentCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>joiningTableSequenceIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* pop first element from the fragment queue */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentCombination</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>fragmentCombinationQueue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>fragmentCombinationQueue</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>fragmentCombinationQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this combination covered all range tables in a join sequence, add
		 * this combination to our result set.
		 */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>joinSequenceIndex</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>fragmentCombination</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>rangeTableCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>rangeTableFragmentsList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>joinSequenceIndex</name> <operator>==</operator> <name>rangeTableCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fragmentCombinationList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fragmentCombinationList</name></expr></argument>,
											  <argument><expr><name>fragmentCombination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* find the next range table to add to our search space */</comment>
		<decl_stmt><decl><type><name>uint32</name></type> <name>tableId</name> <init>= <expr><name><name>joinSequenceArray</name><index>[<expr><name>joinSequenceIndex</name></expr>]</index></name><operator>.</operator><name>rangeTableId</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableFragments</name> <init>= <expr><call><name>FindRangeTableFragmentsList</name><argument_list>(<argument><expr><name>rangeTableFragmentsList</name></expr></argument>,
														   <argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* resolve sequence index for the previous range table we join against */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>joiningTableId</name> <init>= <expr><name><name>joinSequenceArray</name><index>[<expr><name>joinSequenceIndex</name></expr>]</index></name><operator>.</operator><name>joiningRangeTableId</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>joiningTableId</name> <operator>!=</operator> <name>NON_PRUNABLE_JOIN</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><decl><type><name>int32</name></type> <name>sequenceIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>sequenceIndex</name> <operator>&lt;</operator> <name>rangeTableCount</name></expr>;</condition>
				 <incr><expr><name>sequenceIndex</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinSequenceNode</name> <modifier>*</modifier></type><name>joinSequenceNode</name> <init>= <expr><operator>&amp;</operator><name><name>joinSequenceArray</name><index>[<expr><name>sequenceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>joinSequenceNode</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>==</operator> <name>joiningTableId</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>joiningTableSequenceIndex</name> <operator>=</operator> <name>sequenceIndex</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>joiningTableSequenceIndex</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We walk over each range table fragment, and check if we can prune out
		 * this fragment joining with the existing fragment combination. If we
		 * can't prune away, we create a new fragment combination and add it to
		 * our search space.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>tableFragmentCell</argument>, <argument>tableFragments</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>tableFragment</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>tableFragmentCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>joinPrunable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>joiningTableId</name> <operator>!=</operator> <name>NON_PRUNABLE_JOIN</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>joiningTableFragment</name> <init>=
					<expr><call><name>list_nth</name><argument_list>(<argument><expr><name>fragmentCombination</name></expr></argument>, <argument><expr><name>joiningTableSequenceIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>joinPrunable</name> <operator>=</operator> <call><name>JoinPrunable</name><argument_list>(<argument><expr><name>joiningTableFragment</name></expr></argument>, <argument><expr><name>tableFragment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* if join can't be pruned, extend fragment combination and search */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>joinPrunable</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newFragmentCombination</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>fragmentCombination</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>newFragmentCombination</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newFragmentCombination</name></expr></argument>, <argument><expr><name>tableFragment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>fragmentCombinationQueue</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fragmentCombinationQueue</name></expr></argument>,
												   <argument><expr><name>newFragmentCombination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></while>

	<return>return <expr><name>fragmentCombinationList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeIsRangeTblRefReferenceTable checks if the node is a RangeTblRef that
 * points to a reference table in the rangeTableList.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NodeIsRangeTblRefReferenceTable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>tableRef</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>tableRef</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusRTEKind</name></type> <name>rangeTableType</name> <init>= <expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rangeTableType</name> <operator>!=</operator> <name>CITUS_RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FetchEqualityAttrNumsForRTE fetches the attribute numbers from quals
 * which have an equality operator
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>FetchEqualityAttrNumsForRTE</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>FetchEqualityAttrNumsForList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>FetchEqualityAttrNumsForRTEOpExpr</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>FetchEqualityAttrNumsForRTEBoolExpr</name><argument_list>(<argument><expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FetchEqualityAttrNumsForList fetches the attribute numbers of expression
 * of the form "= constant" from the given node list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FetchEqualityAttrNumsForList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeNums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasAtLeastOneEquality</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>node</argument>, <argument>nodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fetchedEqualityAttrNums</name> <init>=
			<expr><call><name>FetchEqualityAttrNumsForRTE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>hasAtLeastOneEquality</name> <operator>|=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>fetchedEqualityAttrNums</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>attributeNums</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>attributeNums</name></expr></argument>, <argument><expr><name>fetchedEqualityAttrNums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * the given list is in the form of AND'ed expressions
	 * hence if we have one equality then it is enough.
	 * E.g: dist.a = 5 AND dist.a &gt; 10
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasAtLeastOneEquality</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>attributeNums</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FetchEqualityAttrNumsForRTEOpExpr fetches the attribute numbers of expression
 * of the form "= constant" from the given opExpr.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FetchEqualityAttrNumsForRTEOpExpr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>opExpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OperatorImplementsEquality</name><argument_list>(<argument><expr><name><name>opExpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeNums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>VarConstOpExprClause</name><argument_list>(<argument><expr><name>opExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>var</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>attributeNums</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attributeNums</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>attributeNums</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FetchEqualityAttrNumsForRTEBoolExpr fetches the attribute numbers of expression
 * of the form "= constant" from the given boolExpr.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FetchEqualityAttrNumsForRTEBoolExpr</name><parameter_list>(<parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>boolExpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>boolExpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>!=</operator> <name>AND_EXPR</name> <operator>&amp;&amp;</operator> <name><name>boolExpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>!=</operator> <name>OR_EXPR</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeNums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasEquality</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>arg</argument>, <argument>boolExpr-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeNumsInSubExpression</name> <init>= <expr><call><name>FetchEqualityAttrNumsForRTE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>boolExpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>AND_EXPR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasEquality</name> <operator>|=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attributeNumsInSubExpression</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>boolExpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>OR_EXPR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasEquality</name> <operator>&amp;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>attributeNumsInSubExpression</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>attributeNums</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>attributeNums</name></expr></argument>, <argument><expr><name>attributeNumsInSubExpression</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>hasEquality</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>attributeNums</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinSequenceArray walks over the join nodes in the job query and constructs a join
 * sequence containing an entry for each joined table. The function then returns an
 * array of join sequence nodes, in which each node contains the id of a table in the
 * range table list and the id of a preceding table with which it is joined, if any.
 */</comment>
<function><type><specifier>static</specifier> <name>JoinSequenceNode</name> <modifier>*</modifier></type>
<name>JoinSequenceArray</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableFragmentsList</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>jobQuery</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>jobQuery</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rangeTableCount</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>sequenceNodeSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>JoinSequenceNode</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>joinedTableCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinExprCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>firstRangeTableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinSequenceNode</name> <modifier>*</modifier></type><name>joinSequenceArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>rangeTableCount</name> <operator>*</operator> <name>sequenceNodeSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinExprList</name> <init>= <expr><call><name>JoinExprList</name><argument_list>(<argument><expr><name><name>jobQuery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* pick first range table as starting table for the join sequence */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>joinExprList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>firstExpr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>joinExprList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>leftTableRef</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name><name>firstExpr</name><operator>-&gt;</operator><name>larg</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>firstRangeTableId</name> <operator>=</operator> <name><name>leftTableRef</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* when there are no joins, the join sequence contains a node for the table */</comment>
		<expr_stmt><expr><name>firstRangeTableId</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>joinSequenceArray</name><index>[<expr><name>joinedTableCount</name></expr>]</index></name><operator>.</operator><name>rangeTableId</name> <operator>=</operator> <name>firstRangeTableId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinSequenceArray</name><index>[<expr><name>joinedTableCount</name></expr>]</index></name><operator>.</operator><name>joiningRangeTableId</name> <operator>=</operator> <name>NON_PRUNABLE_JOIN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>joinedTableCount</name><operator>++</operator></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>joinExprCell</argument>, <argument>joinExprList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>joinExprCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rightTableRef</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>, <argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>nextRangeTableId</name> <init>= <expr><name><name>rightTableRef</name><operator>-&gt;</operator><name>rtindex</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>existingRangeTableId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>applyJoinPruning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nextJoinClauseList</name> <init>= <expr><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>joinExpr</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>leftIsReferenceTable</name> <init>= <expr><call><name>NodeIsRangeTblRefReferenceTable</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
																	<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>rightIsReferenceTable</name> <init>= <expr><call><name>NodeIsRangeTblRefReferenceTable</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
																	 <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isReferenceJoin</name> <init>= <expr><call><name>IsSupportedReferenceJoin</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
														<argument><expr><name>leftIsReferenceTable</name></expr></argument>,
														<argument><expr><name>rightIsReferenceTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If next join clause list is empty, the user tried a cartesian product
		 * between tables. We don't support this functionality for non
		 * reference joins, and error out.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nextJoinClauseList</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isReferenceJoin</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform distributed planning on this query"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cartesian products are currently unsupported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We now determine if we can apply join pruning between existing range
		 * tables and this new one.
		 */</comment>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>nextJoinClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>nextJoinClause</argument>, <argument>nextJoinClauseList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NodeIsEqualsOpExpr</name><argument_list>(<argument><expr><name>nextJoinClause</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>nextJoinClauseOpExpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>nextJoinClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsJoinClause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>nextJoinClauseOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>leftColumn</name> <init>= <expr><call><name>LeftColumnOrNULL</name><argument_list>(<argument><expr><name>nextJoinClauseOpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>rightColumn</name> <init>= <expr><call><name>RightColumnOrNULL</name><argument_list>(<argument><expr><name>nextJoinClauseOpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>leftColumn</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>rightColumn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>Index</name></type> <name>leftRangeTableId</name> <init>= <expr><name><name>leftColumn</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Index</name></type> <name>rightRangeTableId</name> <init>= <expr><name><name>rightColumn</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We have a table from the existing join list joining with the next
			 * table. First resolve the existing table's range table id.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>leftRangeTableId</name> <operator>==</operator> <name>nextRangeTableId</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>existingRangeTableId</name> <operator>=</operator> <name>rightRangeTableId</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>existingRangeTableId</name> <operator>=</operator> <name>leftRangeTableId</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Then, we check if we can apply join pruning between the existing
			 * range table and this new one. For this, columns need to have the
			 * same type and be the partition column for their respective tables.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>leftColumn</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name><name>rightColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>leftPartitioned</name> <init>= <expr><call><name>PartitionedOnColumn</name><argument_list>(<argument><expr><name>leftColumn</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>,
													   <argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>rightPartitioned</name> <init>= <expr><call><name>PartitionedOnColumn</name><argument_list>(<argument><expr><name>rightColumn</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>,
														<argument><expr><name>dependentJobList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>leftPartitioned</name> <operator>&amp;&amp;</operator> <name>rightPartitioned</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* make sure this join clause references only simple columns */</comment>
				<expr_stmt><expr><call><name>CheckJoinBetweenColumns</name><argument_list>(<argument><expr><name>nextJoinClauseOpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>applyJoinPruning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* set next joining range table's info in the join sequence */</comment>
		<decl_stmt><decl><type><name>JoinSequenceNode</name> <modifier>*</modifier></type><name>nextJoinSequenceNode</name> <init>= <expr><operator>&amp;</operator><name><name>joinSequenceArray</name><index>[<expr><name>joinedTableCount</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>applyJoinPruning</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>nextJoinSequenceNode</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>=</operator> <name>nextRangeTableId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nextJoinSequenceNode</name><operator>-&gt;</operator><name>joiningRangeTableId</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>existingRangeTableId</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>nextJoinSequenceNode</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>=</operator> <name>nextRangeTableId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nextJoinSequenceNode</name><operator>-&gt;</operator><name>joiningRangeTableId</name></name> <operator>=</operator> <name>NON_PRUNABLE_JOIN</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>joinedTableCount</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>joinSequenceArray</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionedOnColumn finds the given column's range table entry, and checks if
 * that range table is partitioned on the given column. Note that since reference
 * tables do not have partition columns, the function returns false when the distributed
 * relation is a reference table.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PartitionedOnColumn</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentJobList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>partitionedOnColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>rangeTableId</name> <init>= <expr><name><name>column</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rangeTableId</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusRTEKind</name></type> <name>rangeTableType</name> <init>= <expr><call><name>GetRangeTblKind</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rangeTableType</name> <operator>==</operator> <name>CITUS_RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>rangeTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* non-distributed tables do not have partition columns */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>column</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>partitionedOnColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rangeTableType</name> <operator>==</operator> <name>CITUS_RTE_REMOTE_QUERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>JobForRangeTable</name><argument_list>(<argument><expr><name>dependentJobList</name></expr></argument>, <argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name> <init>= <expr><operator>(</operator><name>MapMergeJob</name> <operator>*</operator><operator>)</operator> <name>job</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The column's current attribute number is it's location in the target
		 * list for the table represented by the remote query. We retrieve this
		 * value from the target list to compare against the partition column
		 * as stored in the job.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>jobQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>columnIndex</name> <init>= <expr><name><name>column</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>columnIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>columnIndex</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>remoteRelationColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>remoteRelationColumn</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* retrieve the partition column for the job */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>remoteRelationColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>partitionedOnColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>partitionedOnColumn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Checks that the join clause references only simple columns. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckJoinBetweenColumns</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>joinClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>argumentList</name> <init>= <expr><name><name>joinClause</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>leftArgument</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rightArgument</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>strippedLeftArgument</name> <init>= <expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>leftArgument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>strippedRightArgument</name> <init>= <expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>rightArgument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>NodeTag</name></type> <name>leftArgumentType</name> <init>= <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>strippedLeftArgument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeTag</name></type> <name>rightArgumentType</name> <init>= <expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>strippedRightArgument</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>leftArgumentType</name> <operator>!=</operator> <name>T_Var</name> <operator>||</operator> <name>rightArgumentType</name> <operator>!=</operator> <name>T_Var</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform local joins that involve expressions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"local joins can be performed between columns only"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FindRangeTableFragmentsList walks over the given list of range table fragments
 * and, returns the one with the given table id.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FindRangeTableFragmentsList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableFragmentsList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foundTableFragments</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableFragmentsCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rangeTableFragmentsCell</argument>, <argument>rangeTableFragmentsList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableFragments</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableFragmentsCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>tableFragments</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>tableFragment</name> <init>=
				<expr><operator>(</operator><name>RangeTableFragment</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>tableFragments</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tableFragment</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>==</operator> <name>tableId</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foundTableFragments</name> <operator>=</operator> <name>tableFragments</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>foundTableFragments</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinPrunable checks if a join between the given left and right fragments can
 * be pruned away, without performing the actual join. To do this, the function
 * checks if we have a hash repartition join. If we do, the function determines
 * pruning based on partitionIds. Else if we have a merge repartition join, the
 * function checks if the two fragments have disjoint intervals.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>JoinPrunable</name><parameter_list>(<parameter><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>leftFragment</name></decl></parameter>, <parameter><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>rightFragment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If both range tables are remote queries, we then have a hash repartition
	 * join. In that case, we can just prune away this join if left and right
	 * hand side fragments have the same partitionId.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>leftFragment</name><operator>-&gt;</operator><name>fragmentType</name></name> <operator>==</operator> <name>CITUS_RTE_REMOTE_QUERY</name> <operator>&amp;&amp;</operator>
		<name><name>rightFragment</name><operator>-&gt;</operator><name>fragmentType</name></name> <operator>==</operator> <name>CITUS_RTE_REMOTE_QUERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>leftMergeTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <name><name>leftFragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>rightMergeTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <name><name>rightFragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></init></decl>;</decl_stmt>


		<if_stmt><if>if <condition>(<expr><name><name>leftMergeTask</name><operator>-&gt;</operator><name>partitionId</name></name> <operator>!=</operator> <name><name>rightMergeTask</name><operator>-&gt;</operator><name>partitionId</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"join prunable for task partitionId %u and %u"</literal></expr></argument>,
									<argument><expr><name><name>leftMergeTask</name><operator>-&gt;</operator><name>partitionId</name></name></expr></argument>,
									<argument><expr><name><name>rightMergeTask</name><operator>-&gt;</operator><name>partitionId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * We have a single (re)partition join. We now get shard intervals for both
	 * fragments, and then check if these intervals overlap.
	 */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftFragmentInterval</name> <init>= <expr><call><name>FragmentInterval</name><argument_list>(<argument><expr><name>leftFragment</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightFragmentInterval</name> <init>= <expr><call><name>FragmentInterval</name><argument_list>(<argument><expr><name>rightFragment</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>overlap</name> <init>= <expr><call><name>ShardIntervalsOverlap</name><argument_list>(<argument><expr><name>leftFragmentInterval</name></expr></argument>, <argument><expr><name>rightFragmentInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>overlap</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsLoggableLevel</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>leftString</name> <init>= <expr><call><name>FragmentIntervalString</name><argument_list>(<argument><expr><name>leftFragmentInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>rightString</name> <init>= <expr><call><name>FragmentIntervalString</name><argument_list>(<argument><expr><name>rightFragmentInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"join prunable for intervals %s and %s"</literal></expr></argument>,
									<argument><expr><name><name>leftString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>rightString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FragmentInterval takes the given fragment, and determines the range of data
 * covered by this fragment. The function then returns this range (interval).
 */</comment>
<function><type><specifier>static</specifier> <name>ShardInterval</name> <modifier>*</modifier></type>
<name>FragmentInterval</name><parameter_list>(<parameter><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>fragment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>fragmentInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fragment</name><operator>-&gt;</operator><name>fragmentType</name></name> <operator>==</operator> <name>CITUS_RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name><name>fragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></argument>, <argument><expr><name>ShardInterval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fragmentInterval</name> <operator>=</operator> <operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <name><name>fragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fragment</name><operator>-&gt;</operator><name>fragmentType</name></name> <operator>==</operator> <name>CITUS_RTE_REMOTE_QUERY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name><name>fragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></argument>, <argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mergeTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <name><name>fragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>fragmentInterval</name> <operator>=</operator> <name><name>mergeTask</name><operator>-&gt;</operator><name>shardInterval</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>fragmentInterval</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Checks if the given shard intervals have overlapping ranges. */</comment>
<function><type><name>bool</name></type>
<name>ShardIntervalsOverlap</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>firstInterval</name></decl></parameter>, <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>secondInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>intervalRelation</name> <init>=
		<expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name><name>firstInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>intervalRelation</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>firstInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>&amp;&amp;</operator> <name><name>firstInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name> <operator>&amp;&amp;</operator>
		  <name><name>secondInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>&amp;&amp;</operator> <name><name>secondInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>firstMin</name> <init>= <expr><name><name>firstInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>firstMax</name> <init>= <expr><name><name>firstInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>secondMin</name> <init>= <expr><name><name>secondInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>secondMax</name> <init>= <expr><name><name>secondInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>comparisonFunction</name> <init>= <expr><name><name>intervalRelation</name><operator>-&gt;</operator><name>shardIntervalCompareFunction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>collation</name> <init>= <expr><name><name>intervalRelation</name><operator>-&gt;</operator><name>partitionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ShardIntervalsOverlapWithParams</name><argument_list>(<argument><expr><name>firstMin</name></expr></argument>, <argument><expr><name>firstMax</name></expr></argument>, <argument><expr><name>secondMin</name></expr></argument>, <argument><expr><name>secondMax</name></expr></argument>,
										   <argument><expr><name>comparisonFunction</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardIntervalsOverlapWithParams is a helper function which compares the input
 * shard min/max values, and returns true if the shards overlap.
 * The caller is responsible to ensure the input shard min/max values are not NULL.
 */</comment>
<function><type><name>bool</name></type>
<name>ShardIntervalsOverlapWithParams</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>firstMin</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>firstMax</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>secondMin</name></decl></parameter>,
								<parameter><decl><type><name>Datum</name></type> <name>secondMax</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>comparisonFunction</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We need to have min/max values for both intervals first. Then, we assume
	 * two intervals i1 = [min1, max1] and i2 = [min2, max2] do not overlap if
	 * (max1 &lt; min2) or (max2 &lt; min1). For details, please see the explanation
	 * on overlapping intervals at http://www.rgrjr.com/emacs/overlap.html.
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>firstDatum</name> <init>= <expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>comparisonFunction</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>firstMax</name></expr></argument>,
										 <argument><expr><name>secondMin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>secondDatum</name> <init>= <expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>comparisonFunction</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>secondMax</name></expr></argument>,
										  <argument><expr><name>firstMin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>firstComparison</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>firstDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>secondComparison</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>secondDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>firstComparison</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>secondComparison</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FragmentIntervalString takes the given fragment interval, and converts this
 * interval into its string representation for use in debug messages.
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>FragmentIntervalString</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>fragmentInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeId</name> <init>= <expr><name><name>fragmentInterval</name><operator>-&gt;</operator><name>valueTypeId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>outputFunctionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typeVariableLength</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fragmentInterval</name><operator>-&gt;</operator><name>minValueExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fragmentInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>outputFunction</name> <init>= <expr><operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outputFunctionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeVariableLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>outputFunctionId</name></expr></argument>, <argument><expr><name>outputFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>minValueString</name> <init>= <expr><call><name>OutputFunctionCall</name><argument_list>(<argument><expr><name>outputFunction</name></expr></argument>, <argument><expr><name><name>fragmentInterval</name><operator>-&gt;</operator><name>minValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>maxValueString</name> <init>= <expr><call><name>OutputFunctionCall</name><argument_list>(<argument><expr><name>outputFunction</name></expr></argument>, <argument><expr><name><name>fragmentInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>fragmentIntervalString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>fragmentIntervalString</name></expr></argument>, <argument><expr><literal type="string">"[%s,%s]"</literal></expr></argument>, <argument><expr><name>minValueString</name></expr></argument>, <argument><expr><name>maxValueString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>fragmentIntervalString</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DataFetchTaskList builds a merge fetch task for every remote query result
 * in the given fragment list, appends these merge fetch tasks into a list,
 * and returns this list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>DataFetchTaskList</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>taskIdIndex</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dataFetchTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>fragmentCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>fragmentCell</argument>, <argument>fragmentList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>fragment</name> <init>= <expr><operator>(</operator><name>RangeTableFragment</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fragmentCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fragment</name><operator>-&gt;</operator><name>fragmentType</name></name> <operator>==</operator> <name>CITUS_RTE_REMOTE_QUERY</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mergeTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <name><name>fragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>undefinedQueryString</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* create merge fetch task and have it depend on the merge task */</comment>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mergeFetchTask</name> <init>= <expr><call><name>CreateBasicTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskIdIndex</name></expr></argument>, <argument><expr><name>MERGE_FETCH_TASK</name></expr></argument>,
												   <argument><expr><name>undefinedQueryString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>mergeFetchTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>mergeTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>dataFetchTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dataFetchTaskList</name></expr></argument>, <argument><expr><name>mergeFetchTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>taskIdIndex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>dataFetchTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateBasicTask creates a task, initializes fields that are common to each task,
 * and returns the created task.
 */</comment>
<function><type><name>Task</name> <modifier>*</modifier></type>
<name>CreateBasicTask</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>taskId</name></decl></parameter>, <parameter><decl><type><name>TaskType</name></type> <name>taskType</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>taskType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>task</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildRelationShardList builds a list of RelationShard pairs for a task.
 * This represents the mapping of range table entries to shard IDs for a
 * task for the purposes of locking, deparsing, and connection management.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>BuildRelationShardList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>fragmentCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>fragmentCell</argument>, <argument>fragmentList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>fragment</name> <init>= <expr><operator>(</operator><name>RangeTableFragment</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fragmentCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>rangeTableId</name> <init>= <expr><name><name>fragment</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rangeTableId</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CitusRTEKind</name></type> <name>fragmentType</name> <init>= <expr><name><name>fragment</name><operator>-&gt;</operator><name>fragmentType</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>fragmentType</name> <operator>==</operator> <name>CITUS_RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <name><name>fragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>RelationShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>relationShardList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relationShardList</name></expr></argument>, <argument><expr><name>relationShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>relationShardList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateRangeTableAlias walks over each fragment in the given fragment list,
 * and creates an alias that represents the fragment name to be used in the
 * query. The function then updates the corresponding range table entry with
 * this alias.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateRangeTableAlias</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>fragmentCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>fragmentCell</argument>, <argument>fragmentList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>fragment</name> <init>= <expr><operator>(</operator><name>RangeTableFragment</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fragmentCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>rangeTableId</name> <init>= <expr><name><name>fragment</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rangeTableId</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>fragmentAlias</name> <init>= <expr><call><name>FragmentAlias</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>fragment</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>fragmentAlias</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * FragmentAlias creates an alias structure that captures the table fragment's
 * name on the worker node. Each fragment represents either a regular shard, or
 * a merge task.
 */</comment>
<function><type><specifier>static</specifier> <name>Alias</name> <modifier>*</modifier></type>
<name>FragmentAlias</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>fragment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aliasName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fragmentName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusRTEKind</name></type> <name>fragmentType</name> <init>= <expr><name><name>fragment</name><operator>-&gt;</operator><name>fragmentType</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>fragmentType</name> <operator>==</operator> <name>CITUS_RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <name><name>fragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>schemaName</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>aliasName</name> <operator>=</operator> <name>relationName</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set shard name in alias to &lt;relation_name&gt;_&lt;shard_id&gt;.
		 */</comment>
		<expr_stmt><expr><name>fragmentName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fragmentName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>fragmentType</name> <operator>==</operator> <name>CITUS_RTE_REMOTE_QUERY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mergeTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <name><name>fragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mapOutputFetchTaskList</name> <init>= <expr><name><name>mergeTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>resultNameList</name> <init>= <expr><call><name>FetchTaskResultNameList</name><argument_list>(<argument><expr><name>mapOutputFetchTaskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mapJobTargetList</name> <init>= <expr><name><name>mergeTask</name><operator>-&gt;</operator><name>mapJobTargetList</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* determine whether all types have binary input/output functions */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>useBinaryFormat</name> <init>= <expr><call><name>CanUseBinaryCopyFormatForTargetList</name><argument_list>(<argument><expr><name>mapJobTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* generate the query on the intermediate result */</comment>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>fragmentSetQuery</name> <init>= <expr><call><name>BuildReadIntermediateResultsArrayQuery</name><argument_list>(<argument><expr><name>mapJobTargetList</name></expr></argument>,
																		 <argument><expr><name>NIL</name></expr></argument>,
																		 <argument><expr><name>resultNameList</name></expr></argument>,
																		 <argument><expr><name>useBinaryFormat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we only really care about the function RTE */</comment>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>readIntermediateResultsRTE</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>fragmentSetQuery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* crudely override the fragment RTE */</comment>
		<expr_stmt><expr><operator>*</operator><name>rangeTableEntry</name> <operator>=</operator> <operator>*</operator><name>readIntermediateResultsRTE</name></expr>;</expr_stmt>

		<return>return <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>alias</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We need to set the aliasname to relation name, as pg_get_query_def() uses
	 * the relation name to disambiguate column names from different tables.
	 */</comment>
	<decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>alias</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>alias</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name> <operator>=</operator> <name>aliasName</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ModifyRangeTblExtraData</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>CITUS_RTE_SHARD</name></expr></argument>,
							<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>fragmentName</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>alias</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FetchTaskResultNameList builds a list of result names that reflect
 * the output of map-fetch tasks.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FetchTaskResultNameList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mapOutputFetchTaskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>resultNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mapOutputFetchTask</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>mapOutputFetchTask</argument>, <argument>mapOutputFetchTaskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mapTask</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>mapOutputFetchTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>partitionId</name> <init>= <expr><name><name>mapOutputFetchTask</name><operator>-&gt;</operator><name>partitionId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultName</name> <init>=
			<expr><call><name>PartitionResultName</name><argument_list>(<argument><expr><name><name>mapTask</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>, <argument><expr><name><name>mapTask</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>, <argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>resultNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>resultNameList</name></expr></argument>, <argument><expr><name>resultName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>resultNameList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AnchorShardId walks over each fragment in the given fragment list, finds the
 * fragment that corresponds to the given anchor range tableId, and returns this
 * fragment's shard identifier. Note that the given tableId must correspond to a
 * base relation.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>AnchorShardId</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fragmentList</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>anchorRangeTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>anchorShardId</name> <init>= <expr><name>INVALID_SHARD_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>fragmentCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>fragmentCell</argument>, <argument>fragmentList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTableFragment</name> <modifier>*</modifier></type><name>fragment</name> <init>= <expr><operator>(</operator><name>RangeTableFragment</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fragmentCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fragment</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>==</operator> <name>anchorRangeTableId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fragment</name><operator>-&gt;</operator><name>fragmentType</name></name> <operator>==</operator> <name>CITUS_RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name><name>fragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></argument>, <argument><expr><name>ShardInterval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <name><name>fragment</name><operator>-&gt;</operator><name>fragmentReference</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>anchorShardId</name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>anchorShardId</name> <operator>!=</operator> <name>INVALID_SHARD_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>anchorShardId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PruneSqlTaskDependencies iterates over each sql task from the given sql task
 * list, and prunes away merge-fetch tasks, as the task assignment algorithm
 * ensures co-location of these tasks.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>PruneSqlTaskDependencies</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sqlTaskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>sqlTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>sqlTaskCell</argument>, <argument>sqlTaskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>sqlTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>sqlTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentTaskList</name> <init>= <expr><name><name>sqlTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedDependendTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>dependentTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>dependentTaskCell</argument>, <argument>dependentTaskList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>dataFetchTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>dependentTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we have a merge fetch task, our task assignment algorithm makes
			 * sure that the sql task is colocated with the anchor shard / merge
			 * task. We can therefore prune out this data fetch task.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dataFetchTask</name><operator>-&gt;</operator><name>taskType</name></name> <operator>==</operator> <name>MERGE_FETCH_TASK</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeFetchDependencyList</name> <init>= <expr><name><name>dataFetchTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>mergeFetchDependencyList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mergeTaskReference</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>mergeFetchDependencyList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>prunedDependendTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prunedDependendTaskList</name></expr></argument>,
												  <argument><expr><name>mergeTaskReference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pruning merge fetch taskId %d"</literal></expr></argument>,
										<argument><expr><name><name>dataFetchTask</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Creating dependency on merge taskId %d"</literal></expr></argument>,
										   <argument><expr><name><name>mergeTaskReference</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>sqlTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>prunedDependendTaskList</name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>sqlTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MapTaskList creates a list of map tasks for the given MapMerge job. For this,
 * the function walks over each filter task (sql task) in the given filter task
 * list, and wraps this task with a map function call. The map function call
 * repartitions the filter task's output according to MapMerge job's parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>MapTaskList</name><parameter_list>(<parameter><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>filterTaskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mapTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>filterQuery</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>job</name><operator>.</operator><name>jobQuery</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>filterTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>partitionColumnResNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name> <init>= <expr><name><name>filterQuery</name><operator>-&gt;</operator><name>groupClause</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>groupClauseList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>filterQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupTargetEntryList</name> <init>= <expr><call><name>GroupTargetEntryList</name><argument_list>(<argument><expr><name>groupClauseList</name></expr></argument>,
														  <argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>groupByTargetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>groupTargetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>partitionColumnResNo</name> <operator>=</operator> <name><name>groupByTargetEntry</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>partitionColumnResNo</name> <operator>=</operator> <call><name>PartitionColumnIndex</name><argument_list>(<argument><expr><name>partitionColumn</name></expr></argument>,
													<argument><expr><name><name>filterQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* determine whether all types have binary input/output functions */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>useBinaryFormat</name> <init>= <expr><call><name>CanUseBinaryCopyFormatForTargetList</name><argument_list>(<argument><expr><name><name>filterQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>filterTaskCell</argument>, <argument>filterTaskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>filterTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>filterTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>mapQueryString</name> <init>= <expr><call><name>CreateMapQueryString</name><argument_list>(<argument><expr><name>mapMergeJob</name></expr></argument>, <argument><expr><name>filterTask</name></expr></argument>,
														 <argument><expr><name>partitionColumnResNo</name></expr></argument>,
														 <argument><expr><name>useBinaryFormat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* convert filter query task into map task */</comment>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mapTask</name> <init>= <expr><name>filterTask</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>mapTask</name></expr></argument>, <argument><expr><name><name>mapQueryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mapTask</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>MAP_TASK</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We do not support fail-over in case of map tasks, since we would also
		 * have to fail over the corresponding merge tasks. We therefore truncate
		 * the list down to the first element.
		 */</comment>
		<expr_stmt><expr><name><name>mapTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name><name>mapTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>mapTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>mapTaskList</name></expr></argument>, <argument><expr><name>mapTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>mapTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionColumnIndex finds the index of the given target var.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>PartitionColumnIndex</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetVar</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>resNo</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>candidateVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>candidateVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>targetVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
				<name><name>candidateVar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>targetVar</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>resNo</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>resNo</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected state: %d varno %d varattno couldn't be found"</literal></expr></argument>,
						   <argument><expr><name><name>targetVar</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>targetVar</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>resNo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateMapQueryString creates and returns the map query string for the given filterTask.
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>CreateMapQueryString</name><parameter_list>(<parameter><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name></decl></parameter>, <parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>filterTask</name></decl></parameter>,
					 <parameter><decl><type><name>uint32</name></type> <name>partitionColumnIndex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useBinaryFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name><name>filterTask</name><operator>-&gt;</operator><name>jobId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>taskId</name> <init>= <expr><name><name>filterTask</name><operator>-&gt;</operator><name>taskId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultNamePrefix</name> <init>= <expr><call><name>PartitionResultNamePrefix</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* wrap repartition query string around filter query string */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>mapQueryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filterQueryString</name> <init>= <expr><call><name>TaskQueryString</name><argument_list>(<argument><expr><name>filterTask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionType</name></type> <name>partitionType</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionType</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>partitionColumnType</name> <init>= <expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>intervalArray</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>intervalCount</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionCount</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>partitionType</name> <operator>==</operator> <name>DUAL_HASH_PARTITION_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionColumnType</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>intervalArray</name> <operator>=</operator> <call><name>GenerateSyntheticShardIntervalArray</name><argument_list>(<argument><expr><name>intervalCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>partitionType</name> <operator>==</operator> <name>SINGLE_HASH_PARTITION_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionColumnType</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>partitionType</name> <operator>==</operator> <name>RANGE_PARTITION_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* add a partition for NULL values at index 0 */</comment>
		<expr_stmt><expr><name>intervalArray</name> <operator>=</operator> <call><name>RangeIntervalArrayWithNullBucket</name><argument_list>(<argument><expr><name>intervalArray</name></expr></argument>, <argument><expr><name>intervalCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>intervalCount</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>intervalTypeOutFunc</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>intervalTypeVarlena</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>minValueArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>maxValueArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>partitionColumnType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intervalTypeOutFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intervalTypeVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ShardMinMaxValueArrays</name><argument_list>(<argument><expr><name>intervalArray</name></expr></argument>, <argument><expr><name>intervalCount</name></expr></argument>, <argument><expr><name>intervalTypeOutFunc</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>minValueArray</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxValueArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>minValuesString</name> <init>= <expr><call><name>ArrayObjectToString</name><argument_list>(<argument><expr><name>minValueArray</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
													 <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>maxValuesString</name> <init>= <expr><call><name>ArrayObjectToString</name><argument_list>(<argument><expr><name>maxValueArray</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
													 <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionMethodString</name> <init>= <expr><ternary><condition><expr><name>partitionType</name> <operator>==</operator> <name>RANGE_PARTITION_TYPE</name></expr> ?</condition><then>
								  <expr><literal type="string">"range"</literal></expr> </then><else>: <expr><literal type="string">"hash"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Non-partition columns can easily contain NULL values, so we allow NULL
	 * values in the column by which we re-partition. They will end up in the
	 * first partition.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>allowNullPartitionColumnValue</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We currently generate empty results for each partition and fetch all of them.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>generateEmptyResults</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>mapQueryString</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT partition_index"</literal>
					 <literal type="string">", %s || '_' || partition_index::text "</literal>
					 <literal type="string">", rows_written "</literal>
					 <literal type="string">"FROM pg_catalog.worker_partition_query_result"</literal>
					 <literal type="string">"(%s,%s,%d,%s,%s,%s,%s,%s,%s) WHERE rows_written &gt; 0"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>resultNamePrefix</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>resultNamePrefix</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>filterQueryString</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>partitionColumnIndex</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>partitionMethodString</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>minValuesString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><name><name>maxValuesString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>useBinaryFormat</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>allowNullPartitionColumnValue</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>generateEmptyResults</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mapQueryString</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionResultNamePrefix returns the prefix we use for worker_partition_query_result
 * results. Each result will have a _&lt;partition index&gt; suffix.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>PartitionResultNamePrefix</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>taskId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>resultNamePrefix</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>resultNamePrefix</name></expr></argument>, <argument><expr><literal type="string">"repartition_"</literal> <name>UINT64_FORMAT</name> <literal type="string">"_%u"</literal></expr></argument>, <argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>resultNamePrefix</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionResultName returns the name of a worker_partition_query_result result for
 * a specific partition.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>PartitionResultName</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>taskId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>partitionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>resultName</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultNamePrefix</name> <init>= <expr><call><name>PartitionResultNamePrefix</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>resultName</name></expr></argument>, <argument><expr><literal type="string">"%s_%d"</literal></expr></argument>, <argument><expr><name>resultNamePrefix</name></expr></argument>, <argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>resultName</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateSyntheticShardIntervalArray returns a shard interval pointer array
 * which has a uniform hash distribution for the given input partitionCount.
 *
 * The function only fills the min/max values of shard the intervals. Thus, should
 * not be used for general purpose operations.
 */</comment>
<function><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>GenerateSyntheticShardIntervalArray</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>partitionCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>shardIntervalArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>partitionCount</name> <operator>*</operator>
												 <sizeof>sizeof<argument_list>(<argument><expr><name>ShardInterval</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>hashTokenIncrement</name> <init>= <expr><name>HASH_TOKEN_COUNT</name> <operator>/</operator> <name>partitionCount</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name>partitionCount</name></expr>;</condition> <incr><expr><operator>++</operator><name>shardIndex</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* calculate the split of the hash space */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMinHashToken</name> <init>= <expr><name>PG_INT32_MIN</name> <operator>+</operator> <operator>(</operator><name>shardIndex</name> <operator>*</operator> <name>hashTokenIncrement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMaxHashToken</name> <init>= <expr><name>shardMinHashToken</name> <operator>+</operator> <operator>(</operator><name>hashTokenIncrement</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

		<comment type="block">/* extend the last range to cover the full range of integers */</comment>
		<if_stmt><if>if <condition>(<expr><name>shardIndex</name> <operator>==</operator> <operator>(</operator><name>partitionCount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>shardMaxHashToken</name> <operator>=</operator> <name>PG_INT32_MAX</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValue</name></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>shardMinHashToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValue</name></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>shardMaxHashToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name>INVALID_SHARD_ID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>valueTypeId</name></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>shardIntervalArray</name><index>[<expr><name>shardIndex</name></expr>]</index></name> <operator>=</operator> <name>shardInterval</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>shardIntervalArray</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RangeIntervalArrayWithNullBucket prepends an additional bucket for NULL values
 * to intervalArray and returns the result.
 *
 * When we support NULL values in (range-partitioned) shards, we will need to revise
 * this logic, since there may already be an interval for NULL values.
 */</comment>
<function><type><specifier>static</specifier> <name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>RangeIntervalArrayWithNullBucket</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>intervalArray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>intervalCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>fullIntervalCount</name> <init>= <expr><name>intervalCount</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>fullIntervalArray</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><name>fullIntervalCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ShardInterval</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>fullIntervalArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fullIntervalArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>minValueExists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fullIntervalArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>maxValueExists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fullIntervalArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>valueTypeId</name> <operator>=</operator> <name><name>intervalArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>valueTypeId</name></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>intervalIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>intervalIndex</name> <operator>&lt;</operator> <name>fullIntervalCount</name></expr>;</condition> <incr><expr><name>intervalIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fullIntervalArray</name><index>[<expr><name>intervalIndex</name></expr>]</index></name> <operator>=</operator> <name><name>intervalArray</name><index>[<expr><name>intervalIndex</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>fullIntervalArray</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Determine RowModifyLevel required for given query
 */</comment>
<function><type><name>RowModifyLevel</name></type>
<name>RowModifyLevelForQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CmdType</name></type> <name>commandType</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip checking for INSERT as those CTEs are recursively planned */</comment>
			<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>cte</argument>, <argument>query-&gt;cteList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>cteQuery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>cteQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
					<name><name>cteQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>ROW_MODIFY_NONCOMMUTATIVE</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>ROW_MODIFY_READONLY</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>ROW_MODIFY_COMMUTATIVE</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>ROW_MODIFY_NONCOMMUTATIVE</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
		<name>commandType</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>ROW_MODIFY_NONCOMMUTATIVE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ROW_MODIFY_NONE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ArrayObjectToString converts an SQL object to its string representation.
 */</comment>
<function><type><name>StringInfo</name></type>
<name>ArrayObjectToString</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>arrayObject</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>columnType</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>columnTypeMod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>arrayDatum</name> <init>= <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>arrayObject</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>outputFunctionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typeVariableLength</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>arrayOutType</name> <init>= <expr><call><name>get_array_type</name><argument_list>(<argument><expr><name>columnType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>arrayOutType</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnTypeName</name> <init>= <expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>columnType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot range repartition table on column type %s"</literal></expr></argument>,
							   <argument><expr><name>columnTypeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>arrayOutFunction</name> <init>= <expr><operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>arrayOutType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outputFunctionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeVariableLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>outputFunctionId</name></expr></argument>, <argument><expr><name>arrayOutFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arrayOutputText</name> <init>= <expr><call><name>OutputFunctionCall</name><argument_list>(<argument><expr><name>arrayOutFunction</name></expr></argument>, <argument><expr><name>arrayDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arrayOutputEscapedText</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>arrayOutputText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* add an explicit cast to array's string representation */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arrayOutTypeName</name> <init>= <expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>arrayOutType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>arrayString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>arrayString</name></expr></argument>, <argument><expr><literal type="string">"%s::%s"</literal></expr></argument>,
					 <argument><expr><name>arrayOutputEscapedText</name></expr></argument>, <argument><expr><name>arrayOutTypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>arrayString</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MergeTaskList creates a list of merge tasks for the given MapMerge job. While
 * doing this, the function also establishes dependencies between each merge
 * task and its downstream map task dependencies by creating "map fetch" tasks.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>MergeTaskList</name><parameter_list>(<parameter><decl><type><name>MapMergeJob</name> <modifier>*</modifier></type><name>mapMergeJob</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mapTaskList</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>taskIdIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>job</name><operator>.</operator><name>jobId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>partitionCount</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionCount</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build column name and column type arrays (table schema) */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>filterQuery</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>job</name><operator>.</operator><name>jobQuery</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>filterQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if all map tasks were pruned away, return NIL for merge tasks */</comment>
	<if_stmt><if>if <condition>(<expr><name>mapTaskList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * XXX: We currently ignore the 0th partition bucket that range partitioning
	 * generates. This bucket holds all values less than the minimum value or
	 * NULLs, both of which we can currently ignore. However, when we support
	 * range re-partitioned OUTER joins, we will need these rows for the
	 * relation whose rows are retained in the OUTER join.
	 */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>initialPartitionId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionType</name></name> <operator>==</operator> <name>RANGE_PARTITION_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>initialPartitionId</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>partitionCount</name> <operator>=</operator> <name>partitionCount</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionType</name></name> <operator>==</operator> <name>SINGLE_HASH_PARTITION_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>initialPartitionId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* build merge tasks and their associated "map output fetch" tasks */</comment>
	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>partitionId</name> <init>= <expr><name>initialPartitionId</name></expr></init></decl>;</init> <condition><expr><name>partitionId</name> <operator>&lt;</operator> <name>partitionCount</name></expr>;</condition>
		 <incr><expr><name>partitionId</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mapOutputFetchTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>mapTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>mergeTaskId</name> <init>= <expr><name>taskIdIndex</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* create logical merge task (not executed, but useful for bookkeeping) */</comment>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mergeTask</name> <init>= <expr><call><name>CreateBasicTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>mergeTaskId</name></expr></argument>, <argument><expr><name>MERGE_TASK</name></expr></argument>,
										  <argument><expr><literal type="string">"&lt;merge&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>mergeTask</name><operator>-&gt;</operator><name>partitionId</name></name> <operator>=</operator> <name>partitionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>taskIdIndex</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* create tasks to fetch map outputs to this merge task */</comment>
		<macro><name>foreach</name><argument_list>(<argument>mapTaskCell</argument>, <argument>mapTaskList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mapTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>mapTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* find the node name/port for map task's execution */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mapTaskPlacementList</name> <init>= <expr><name><name>mapTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>mapTaskPlacement</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>mapTaskPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionResultName</name> <init>=
				<expr><call><name>PartitionResultName</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name><name>mapTask</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>, <argument><expr><name>partitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* we currently only fetch a single fragment at a time */</comment>
			<decl_stmt><decl><type><name>DistributedResultFragment</name></type> <name>singleFragmentTransfer</name></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>singleFragmentTransfer</name><operator>.</operator><name>resultId</name></name> <operator>=</operator> <name>partitionResultName</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>singleFragmentTransfer</name><operator>.</operator><name>nodeId</name></name> <operator>=</operator> <name><name>mapTaskPlacement</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>singleFragmentTransfer</name><operator>.</operator><name>rowCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>singleFragmentTransfer</name><operator>.</operator><name>targetShardId</name></name> <operator>=</operator> <name>INVALID_SHARD_ID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>singleFragmentTransfer</name><operator>.</operator><name>targetShardIndex</name></name> <operator>=</operator> <name>partitionId</name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>NodeToNodeFragmentsTransfer</name></type> <name>fragmentsTransfer</name></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>fragmentsTransfer</name><operator>.</operator><name>nodes</name><operator>.</operator><name>sourceNodeId</name></name> <operator>=</operator> <name><name>mapTaskPlacement</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Target node is not yet decided, and not necessary for
			 * QueryStringForFragmentsTransfer.
			 */</comment>
			<expr_stmt><expr><name><name>fragmentsTransfer</name><operator>.</operator><name>nodes</name><operator>.</operator><name>targetNodeId</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fragmentsTransfer</name><operator>.</operator><name>fragmentList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>singleFragmentTransfer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fetchQueryString</name> <init>= <expr><call><name>QueryStringForFragmentsTransfer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fragmentsTransfer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mapOutputFetchTask</name> <init>= <expr><call><name>CreateBasicTask</name><argument_list>(<argument><expr><name>jobId</name></expr></argument>, <argument><expr><name>taskIdIndex</name></expr></argument>,
													   <argument><expr><name>MAP_OUTPUT_FETCH_TASK</name></expr></argument>,
													   <argument><expr><name>fetchQueryString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>mapOutputFetchTask</name><operator>-&gt;</operator><name>partitionId</name></name> <operator>=</operator> <name>partitionId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mapOutputFetchTask</name><operator>-&gt;</operator><name>upstreamTaskId</name></name> <operator>=</operator> <name>mergeTaskId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mapOutputFetchTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>mapTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>taskIdIndex</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>mapOutputFetchTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>mapOutputFetchTaskList</name></expr></argument>, <argument><expr><name>mapOutputFetchTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* merge task depends on completion of fetch tasks */</comment>
		<expr_stmt><expr><name><name>mergeTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>mapOutputFetchTaskList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mergeTask</name><operator>-&gt;</operator><name>mapJobTargetList</name></name> <operator>=</operator> <name>targetEntryList</name></expr>;</expr_stmt>

		<comment type="block">/* if single repartitioned, each merge task represents an interval */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionType</name></name> <operator>==</operator> <name>RANGE_PARTITION_TYPE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type> <name>mergeTaskIntervalId</name> <init>= <expr><name>partitionId</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>mergeTaskIntervals</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mergeTaskIntervalId</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>mergeTask</name><operator>-&gt;</operator><name>shardInterval</name></name> <operator>=</operator> <name><name>mergeTaskIntervals</name><index>[<expr><name>mergeTaskIntervalId</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>partitionType</name></name> <operator>==</operator> <name>SINGLE_HASH_PARTITION_TYPE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type> <name>mergeTaskIntervalId</name> <init>= <expr><name>partitionId</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier><modifier>*</modifier></type><name>mergeTaskIntervals</name> <init>= <expr><name><name>mapMergeJob</name><operator>-&gt;</operator><name>sortedShardIntervalArray</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mergeTaskIntervalId</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>mergeTask</name><operator>-&gt;</operator><name>shardInterval</name></name> <operator>=</operator> <name><name>mergeTaskIntervals</name><index>[<expr><name>mergeTaskIntervalId</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>mergeTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>mergeTaskList</name></expr></argument>, <argument><expr><name>mergeTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>mergeTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssignTaskList assigns locations to given tasks based on dependencies between
 * tasks and configured task assignment policies. The function also handles the
 * case where multiple SQL tasks depend on the same merge task, and makes sure
 * that this group of multiple SQL tasks and the merge task are assigned to the
 * same location.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>AssignTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sqlTaskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>assignedSqlTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasAnchorShardId</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>sqlTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>primarySqlTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>primarySqlTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>constrainedSqlTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* no tasks to assign */</comment>
	<if_stmt><if>if <condition>(<expr><name>sqlTaskList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>firstSqlTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>sqlTaskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>firstSqlTask</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>!=</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hasAnchorShardId</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If these SQL tasks don't depend on any merge tasks, we can assign each
	 * one independently of the other. We therefore go ahead and assign these
	 * SQL tasks using the "anchor shard based" assignment algorithms.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasMergeTaskDependencies</name> <init>= <expr><call><name>HasMergeTaskDependencies</name><argument_list>(<argument><expr><name>sqlTaskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasMergeTaskDependencies</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hasAnchorShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>assignedSqlTaskList</name> <operator>=</operator> <call><name>AssignAnchorShardTaskList</name><argument_list>(<argument><expr><name>sqlTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>assignedSqlTaskList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * SQL tasks can depend on merge tasks in one of two ways: (1) each SQL task
	 * depends on merge task(s) that no other SQL task depends upon, (2) several
	 * SQL tasks depend on the same merge task(s) and all need to be assigned to
	 * the same worker node. To handle the second case, we first pick a primary
	 * SQL task among those that depend on the same merge task, and assign it.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>sqlTaskCell</argument>, <argument>sqlTaskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>sqlTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>sqlTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeTaskList</name> <init>= <expr><call><name>FindDependentMergeTaskList</name><argument_list>(<argument><expr><name>sqlTask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>firstMergeTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>mergeTaskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>firstMergeTask</name><operator>-&gt;</operator><name>assignmentConstrained</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>firstMergeTask</name><operator>-&gt;</operator><name>assignmentConstrained</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>primarySqlTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>primarySqlTaskList</name></expr></argument>, <argument><expr><name>sqlTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>hasAnchorShardId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>primarySqlTaskList</name> <operator>=</operator> <call><name>AssignAnchorShardTaskList</name><argument_list>(<argument><expr><name>primarySqlTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>primarySqlTaskList</name> <operator>=</operator> <call><name>AssignDualHashTaskList</name><argument_list>(<argument><expr><name>primarySqlTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* propagate SQL task assignments to the merge tasks we depend upon */</comment>
	<macro><name>foreach</name><argument_list>(<argument>primarySqlTaskCell</argument>, <argument>primarySqlTaskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>sqlTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>primarySqlTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeTaskList</name> <init>= <expr><call><name>FindDependentMergeTaskList</name><argument_list>(<argument><expr><name>sqlTask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>mergeTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>mergeTaskCell</argument>, <argument>mergeTaskList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mergeTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>mergeTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>mergeTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>mergeTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>sqlTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>assignedSqlTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>assignedSqlTaskList</name></expr></argument>, <argument><expr><name>sqlTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If we had a set of SQL tasks depending on the same merge task, we only
	 * assigned one SQL task from that set. We call the assigned SQL task the
	 * primary, and note that the remaining SQL tasks are constrained by the
	 * primary's task assignment. We propagate the primary's task assignment in
	 * each set to the remaining (constrained) tasks.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>constrainedSqlTaskList</name> <init>= <expr><call><name>TaskListDifference</name><argument_list>(<argument><expr><name>sqlTaskList</name></expr></argument>, <argument><expr><name>primarySqlTaskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>constrainedSqlTaskCell</argument>, <argument>constrainedSqlTaskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>sqlTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>constrainedSqlTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeTaskList</name> <init>= <expr><call><name>FindDependentMergeTaskList</name><argument_list>(<argument><expr><name>sqlTask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeTaskPlacementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>mergeTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>mergeTaskCell</argument>, <argument>mergeTaskList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>mergeTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>mergeTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If we have more than one merge task, both of them should have the
			 * same task placement list.
			 */</comment>
			<expr_stmt><expr><name>mergeTaskPlacementList</name> <operator>=</operator> <name><name>mergeTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mergeTaskPlacementList</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"propagating assignment from merge task %d "</literal>
									<literal type="string">"to constrained sql task %d"</literal></expr></argument>,
									<argument><expr><name><name>mergeTask</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>, <argument><expr><name><name>sqlTask</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>sqlTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>mergeTaskPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>assignedSqlTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>assignedSqlTaskList</name></expr></argument>, <argument><expr><name>sqlTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>assignedSqlTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasMergeTaskDependencies checks if sql tasks in the given sql task list have
 * any dependencies on merge tasks. If they do, the function returns true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasMergeTaskDependencies</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sqlTaskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasMergeTaskDependencies</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>sqlTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>sqlTaskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentTaskList</name> <init>= <expr><name><name>sqlTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>dependentTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>dependentTaskCell</argument>, <argument>dependentTaskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>dependentTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>dependentTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dependentTask</name><operator>-&gt;</operator><name>taskType</name></name> <operator>==</operator> <name>MERGE_TASK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasMergeTaskDependencies</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>hasMergeTaskDependencies</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Return true if two tasks are equal, false otherwise. */</comment>
<function><type><name>bool</name></type>
<name>TasksEqual</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Task</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Task</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>taskType</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>taskType</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>jobId</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>jobId</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>taskId</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>taskId</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Is the passed in Task a member of the list. */</comment>
<function><type><name>bool</name></type>
<name>TaskListMember</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TasksEqual</name><argument_list>(<argument><expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TaskListDifference returns a list that contains all the tasks in taskList1
 * that are not in taskList2. The returned list is freshly allocated via
 * palloc(), but the cells themselves point to the same objects as the cells
 * of the input lists.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>TaskListDifference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>resultList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>list2</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>list1</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>list1</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TaskListMember</name><argument_list>(<argument><expr><name>list2</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>resultList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>resultList</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>resultList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssignAnchorShardTaskList assigns locations to the given tasks based on the
 * configured task assignment policy. The distributed executor later sends these
 * tasks to their assigned locations for remote execution.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AssignAnchorShardTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>assignedTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* choose task assignment policy based on config value */</comment>
	<if_stmt><if>if <condition>(<expr><name>TaskAssignmentPolicy</name> <operator>==</operator> <name>TASK_ASSIGNMENT_GREEDY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>assignedTaskList</name> <operator>=</operator> <call><name>GreedyAssignTaskList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>TaskAssignmentPolicy</name> <operator>==</operator> <name>TASK_ASSIGNMENT_FIRST_REPLICA</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>assignedTaskList</name> <operator>=</operator> <call><name>FirstReplicaAssignTaskList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>TaskAssignmentPolicy</name> <operator>==</operator> <name>TASK_ASSIGNMENT_ROUND_ROBIN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>assignedTaskList</name> <operator>=</operator> <call><name>RoundRobinAssignTaskList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>assignedTaskList</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>assignedTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GreedyAssignTaskList uses a greedy algorithm similar to Hadoop's, and assigns
 * locations to the given tasks. The ideal assignment algorithm balances three
 * properties: (a) determinism, (b) even load distribution, and (c) consistency
 * across similar task lists. To maintain these properties, the algorithm sorts
 * all its input lists.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GreedyAssignTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>assignedTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>assignedTaskCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>taskCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get the worker node list and sort the list */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActiveReadableNodeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>workerNodeList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>CompareWorkerNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We first sort tasks by their anchor shard id. We then walk over each task
	 * in the sorted list, get the task's anchor shard id, and look up the shard
	 * placements (locations) for this shard id. Next, we sort the placements by
	 * their insertion time, and append them to a new list.
	 */</comment>
	<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>CompareTasksByShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeShardPlacementLists</name> <init>= <expr><call><name>ActiveShardPlacementLists</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>assignedTaskCount</name> <operator>&lt;</operator> <name>taskCount</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>workerNodeCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>loopStartTaskCount</name> <init>= <expr><name>assignedTaskCount</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* walk over each node and check if we can assign a task to it */</comment>
		<macro><name>foreach</name><argument_list>(<argument>workerNodeCell</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>workerNodeCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>assignedTask</name> <init>= <expr><call><name>GreedyAssignTask</name><argument_list>(<argument><expr><name>workerNode</name></expr></argument>, <argument><expr><name>taskList</name></expr></argument>,
												  <argument><expr><name>activeShardPlacementLists</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>assignedTask</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>assignedTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>assignedTaskList</name></expr></argument>, <argument><expr><name>assignedTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>assignedTaskCount</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* if we could not assign any new tasks, avoid looping forever */</comment>
		<if_stmt><if>if <condition>(<expr><name>assignedTaskCount</name> <operator>==</operator> <name>loopStartTaskCount</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> <name>remainingTaskCount</name> <init>= <expr><name>taskCount</name> <operator>-</operator> <name>assignedTaskCount</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to assign %u task(s) to worker nodes"</literal></expr></argument>,
								   <argument><expr><name>remainingTaskCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>assignedTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GreedyAssignTask tries to assign a task to the given worker node. To do this,
 * the function walks over tasks' anchor shard ids, and finds the first set of
 * nodes the shards were replicated to. If any of these replica nodes and the
 * given worker node match, the corresponding task is assigned to that node. If
 * not, the function goes on to search the second set of replicas and so forth.
 *
 * Note that this function has side-effects; when the function assigns a new
 * task, it overwrites the corresponding task list pointer.
 */</comment>
<function><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type>
<name>GreedyAssignTask</name><parameter_list>(<parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeShardPlacementLists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>assignedTask</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskPlacementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>primaryPlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rotatePlacementListBy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>replicaIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>replicaCount</name> <init>= <expr><name>ShardReplicationFactor</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>workerName</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint32</name></type> <name>workerPort</name> <init>= <expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>assignedTask</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>replicaIndex</name> <operator>&lt;</operator> <name>replicaCount</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* walk over all tasks and try to assign one */</comment>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>placementListCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>forboth</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>, <argument>placementListCell</argument>, <argument>activeShardPlacementLists</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>placementListCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* check if we already assigned this task */</comment>
			<if_stmt><if>if <condition>(<expr><name>task</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* check if we have enough replicas */</comment>
			<decl_stmt><decl><type><name>uint32</name></type> <name>placementCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>placementCount</name> <operator>&lt;=</operator> <name>replicaIndex</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>,
																	<argument><expr><name>replicaIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>placement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>, <argument><expr><name>workerName</name></expr></argument>, <argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>placement</name><operator>-&gt;</operator><name>nodePort</name></name> <operator>==</operator> <name>workerPort</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we found a task to assign to the given worker node */</comment>
				<expr_stmt><expr><name>assignedTask</name> <operator>=</operator> <name>task</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>taskPlacementList</name> <operator>=</operator> <name>placementList</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotatePlacementListBy</name> <operator>=</operator> <name>replicaIndex</name></expr>;</expr_stmt>

				<comment type="block">/* overwrite task list to signal that this task is assigned */</comment>
				<expr_stmt><expr><call><name>SetListCellPtr</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* go over the next set of shard replica placements */</comment>
		<expr_stmt><expr><name>replicaIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* if we found a task placement list, rotate and assign task placements */</comment>
	<if_stmt><if>if <condition>(<expr><name>assignedTask</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>taskPlacementList</name> <operator>=</operator> <call><name>LeftRotateList</name><argument_list>(<argument><expr><name>taskPlacementList</name></expr></argument>, <argument><expr><name>rotatePlacementListBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>assignedTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name>taskPlacementList</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>primaryPlacement</name> <operator>=</operator> <operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>assignedTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"assigned task %u to node %s:%u"</literal></expr></argument>, <argument><expr><name><name>assignedTask</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>,
								<argument><expr><name><name>primaryPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
								<argument><expr><name><name>primaryPlacement</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>assignedTask</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FirstReplicaAssignTaskList assigns locations to the given tasks simply by
 * looking at placements for a given shard. A particular task's assignments are
 * then ordered by the insertion order of the relevant placements rows. In other
 * words, a task for a specific shard is simply assigned to the first replica
 * for that shard. This algorithm is extremely simple and intended for use when
 * a customer has placed shards carefully and wants strong guarantees about
 * which shards will be used by what nodes (i.e. for stronger memory residency
 * guarantees).
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>FirstReplicaAssignTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* No additional reordering need take place for this algorithm */</comment>
	<decl_stmt><decl><type><name>ReorderFunction</name></type> <name>reorderFunction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>ReorderAndAssignTaskList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>reorderFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RoundRobinAssignTaskList uses a round-robin algorithm to assign locations to
 * the given tasks. An ideal round-robin implementation requires keeping shared
 * state for task assignments; and we instead approximate our implementation by
 * relying on the sequentially increasing jobId. For each task, we mod its jobId
 * by the number of active shard placements, and ensure that we rotate between
 * these placements across subsequent queries.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RoundRobinAssignTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>ReorderAndAssignTaskList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>RoundRobinReorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RoundRobinReorder implements the core of the round-robin assignment policy.
 * It takes a placement list and rotates a copy of it based on the latest stable
 * transaction id provided by PostgreSQL.
 *
 * We prefer to use transactionId as the seed for the rotation to use the replicas
 * in the same worker node within the same transaction. This becomes more important
 * when we're reading from (the same or multiple) reference tables within a
 * transaction. With this approach, we can prevent reads to expand the worker nodes
 * that participate in a distributed transaction.
 *
 * Note that we prefer PostgreSQL's transactionId over distributed transactionId that
 * Citus generates since the distributed transactionId is generated during the execution
 * where as task-assignment happens duing the planning.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RoundRobinReorder</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>transactionId</name> <init>= <expr><call><name>GetMyProcLocalTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>activePlacementCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>roundRobinIndex</name> <init>= <expr><operator>(</operator><name>transactionId</name> <operator>%</operator> <name>activePlacementCount</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>placementList</name> <operator>=</operator> <call><name>LeftRotateList</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>, <argument><expr><name>roundRobinIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>placementList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReorderAndAssignTaskList finds the placements for a task based on its anchor
 * shard id and then sorts them by insertion time. If reorderFunction is given,
 * it is used to reorder the placements list in a custom fashion (for instance,
 * by rotation or shuffling). Returns the task list with placements assigned.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ReorderAndAssignTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>, <parameter><decl><type><name>ReorderFunction</name></type> <name>reorderFunction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>assignedTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>placementListCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>unAssignedTaskCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>taskList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We first sort tasks by their anchor shard id. We then sort placements for
	 * each anchor shard by the placement's insertion time. Note that we sort
	 * these lists just to make our policy more deterministic.
	 */</comment>
	<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>CompareTasksByShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeShardPlacementLists</name> <init>= <expr><call><name>ActiveShardPlacementLists</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>forboth</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>, <argument>placementListCell</argument>, <argument>activeShardPlacementLists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>placementListCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* inactive placements are already filtered out */</comment>
		<decl_stmt><decl><type><name>uint32</name></type> <name>activePlacementCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>activePlacementCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>reorderFunction</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>placementList</name> <operator>=</operator> <call><name>reorderFunction</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name>placementList</name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>primaryPlacement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(
				<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"assigned task %u to node %s:%u"</literal></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>,
									<argument><expr><name><name>primaryPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
									<argument><expr><name><name>primaryPlacement</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>assignedTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>assignedTaskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>unAssignedTaskCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* if we have unassigned tasks, error out */</comment>
	<if_stmt><if>if <condition>(<expr><name>unAssignedTaskCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to assign %u task(s) to worker nodes"</literal></expr></argument>,
							   <argument><expr><name>unAssignedTaskCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>assignedTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Helper function to compare two tasks by their anchor shardId. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareTasksByShardId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Task</name> <modifier>*</modifier></type><name>leftTask</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Task</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Task</name> <modifier>*</modifier></type><name>rightTask</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Task</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>leftShardId</name> <init>= <expr><name><name>leftTask</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>rightShardId</name> <init>= <expr><name><name>rightTask</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we compare 64-bit integers, instead of casting their difference to int */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftShardId</name> <operator>&gt;</operator> <name>rightShardId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>leftShardId</name> <operator>&lt;</operator> <name>rightShardId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ActiveShardPlacementLists finds the active shard placement list for each task in
 * the given task list, sorts each shard placement list by shard creation time,
 * and adds the sorted placement list into a new list of lists. The function also
 * ensures a one-to-one mapping between each placement list in the new list of
 * lists and each task in the given task list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ActiveShardPlacementLists</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementLists</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>anchorShardId</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activeShardPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>anchorShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>activeShardPlacementList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no active placements were found for shard "</literal> <name>UINT64_FORMAT</name></expr></argument>,
							<argument><expr><name>anchorShardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* sort shard placements by their creation time */</comment>
		<expr_stmt><expr><name>activeShardPlacementList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>activeShardPlacementList</name></expr></argument>,
											<argument><expr><name>CompareShardPlacements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>shardPlacementLists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shardPlacementLists</name></expr></argument>, <argument><expr><name>activeShardPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>shardPlacementLists</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareShardPlacements compares two shard placements by their tuple oid; this
 * oid reflects the tuple's insertion order into pg_dist_placement.
 */</comment>
<function><type><name>int</name></type>
<name>CompareShardPlacements</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type><name>leftPlacement</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ShardPlacement</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type><name>rightPlacement</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>ShardPlacement</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>leftPlacementId</name> <init>= <expr><name><name>leftPlacement</name><operator>-&gt;</operator><name>placementId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>rightPlacementId</name> <init>= <expr><name><name>rightPlacement</name><operator>-&gt;</operator><name>placementId</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>leftPlacementId</name> <operator>&lt;</operator> <name>rightPlacementId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>leftPlacementId</name> <operator>&gt;</operator> <name>rightPlacementId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LeftRotateList returns a copy of the given list that has been cyclically
 * shifted to the left by the given rotation count. For this, the function
 * repeatedly moves the list's first element to the end of the list, and
 * then returns the newly rotated list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>LeftRotateList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>rotateCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rotatedList</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>rotateIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>rotateIndex</name> <operator>&lt;</operator> <name>rotateCount</name></expr>;</condition> <incr><expr><name>rotateIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>firstElement</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>rotatedList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>rotatedList</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>rotatedList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rotatedList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rotatedList</name></expr></argument>, <argument><expr><name>firstElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>rotatedList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindDependentMergeTaskList walks over the given task's dependent task list,
 * finds the merge tasks in the list, and returns those found tasks in a new
 * list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FindDependentMergeTaskList</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>sqlTask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentMergeTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentTaskList</name> <init>= <expr><name><name>sqlTask</name><operator>-&gt;</operator><name>dependentTaskList</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>dependentTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>dependentTaskCell</argument>, <argument>dependentTaskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>dependentTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>dependentTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>dependentTask</name><operator>-&gt;</operator><name>taskType</name></name> <operator>==</operator> <name>MERGE_TASK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dependentMergeTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dependentMergeTaskList</name></expr></argument>, <argument><expr><name>dependentTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>dependentMergeTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssignDualHashTaskList uses a round-robin algorithm to assign locations to
 * tasks; these tasks don't have any anchor shards and instead operate on (hash
 * repartitioned) merged tables.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>AssignDualHashTaskList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>assignedTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>firstTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name><name>firstTask</name><operator>-&gt;</operator><name>jobId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>assignedTaskIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We start assigning tasks at an index determined by the jobId. This way,
	 * if subsequent jobs have a small number of tasks, we won't allocate the
	 * tasks to the same worker repeatedly.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActiveReadableNodeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>workerNodeCount</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>beginningNodeIndex</name> <init>= <expr><name>jobId</name> <operator>%</operator> <name>workerNodeCount</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* sort worker node list and task list for deterministic results */</comment>
	<expr_stmt><expr><name>workerNodeList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>CompareWorkerNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>CompareTasksByTaskId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskPlacementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>uint32</name></type> <name>replicaIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>replicaIndex</name> <operator>&lt;</operator> <name>ShardReplicationFactor</name></expr>;</condition>
			 <incr><expr><name>replicaIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> <name>assignmentOffset</name> <init>= <expr><name>beginningNodeIndex</name> <operator>+</operator> <name>assignedTaskIndex</name> <operator>+</operator>
									  <name>replicaIndex</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type> <name>assignmentIndex</name> <init>= <expr><name>assignmentOffset</name> <operator>%</operator> <name>workerNodeCount</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>assignmentIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SetPlacementNodeMetadata</name><argument_list>(<argument><expr><name>taskPlacement</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>taskPlacementList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskPlacementList</name></expr></argument>, <argument><expr><name>taskPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name>taskPlacementList</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>primaryPlacement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(
			<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"assigned task %u to node %s:%u"</literal></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>,
								<argument><expr><name><name>primaryPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
								<argument><expr><name><name>primaryPlacement</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>assignedTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>assignedTaskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>assignedTaskIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>assignedTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetPlacementNodeMetadata sets nodename, nodeport, nodeid and groupid for the placement.
 */</comment>
<function><type><name>void</name></type>
<name>SetPlacementNodeMetadata</name><parameter_list>(<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>, <parameter><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>nodeName</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>nodePort</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>placement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CompareTasksByTaskId is a helper function to compare two tasks by their taskId.
 */</comment>
<function><type><name>int</name></type>
<name>CompareTasksByTaskId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Task</name> <modifier>*</modifier></type><name>leftTask</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Task</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Task</name> <modifier>*</modifier></type><name>rightTask</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Task</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>leftTaskId</name> <init>= <expr><name><name>leftTask</name><operator>-&gt;</operator><name>taskId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rightTaskId</name> <init>= <expr><name><name>rightTask</name><operator>-&gt;</operator><name>taskId</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>taskIdDiff</name> <init>= <expr><name>leftTaskId</name> <operator>-</operator> <name>rightTaskId</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>taskIdDiff</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AssignDataFetchDependencies walks over tasks in the given sql or merge task
 * list. The function then propagates worker node assignments from each sql or
 * merge task to the task's data fetch dependencies.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AssignDataFetchDependencies</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependentTaskList</name> <init>= <expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>dependentTaskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>==</operator> <name>READ_TASK</name> <operator>||</operator> <name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>==</operator> <name>MERGE_TASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>dependentTaskCell</argument>, <argument>dependentTaskList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>dependentTask</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>dependentTaskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>dependentTask</name><operator>-&gt;</operator><name>taskType</name></name> <operator>==</operator> <name>MAP_OUTPUT_FETCH_TASK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>dependentTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * TaskListHighestTaskId walks over tasks in the given task list, finds the task
 * that has the largest taskId, and returns that taskId.
 *
 * Note: This function assumes that the dependent taskId's are set before the
 * taskId's for the given task list.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>TaskListHighestTaskId</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>highestTaskId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>taskCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>taskCell</argument>, <argument>taskList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>taskCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>&gt;</operator> <name>highestTaskId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>highestTaskId</name> <operator>=</operator> <name><name>task</name><operator>-&gt;</operator><name>taskId</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>highestTaskId</name></expr>;</return>
</block_content>}</block></function>
</unit>
