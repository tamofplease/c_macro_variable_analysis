<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/planner/relation_restriction_equivalence.c"><comment type="block">/*
 * relation_restriction_equivalence.c
 *
 * This file contains functions helper functions for planning
 * queries with colocated tables and subqueries.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_restriction_equivalence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_pruning.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>AttributeEquivalenceId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * AttributeEquivalenceClass
 *
 * Whenever we find an equality clause A = B, where both A and B originates from
 * relation attributes (i.e., not random expressions), we create an
 * AttributeEquivalenceClass to record this knowledge. If we later find another
 * equivalence B = C, we create another AttributeEquivalenceClass. Finally, we can
 * apply transitivity rules and generate a new AttributeEquivalenceClass which includes
 * A, B and C.
 *
 * Note that equality among the members are identified by the varattno and rteIdentity.
 */</comment>
<typedef>typedef <type><struct>struct <name>AttributeEquivalenceClass</name>
<block>{
	<decl_stmt><decl><type><name>uint32</name></type> <name>equivalenceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>equivalentAttributes</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Index</name></type> <name>unionQueryPartitionKeyIndex</name></decl>;</decl_stmt>
}</block></struct></type> <name>AttributeEquivalenceClass</name>;</typedef>

<typedef>typedef <type><struct>struct <name>FindQueryContainingRteIdentityContext</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>targetRTEIdentity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
}</block></struct></type><name>FindQueryContainingRteIdentityContext</name>;</typedef>

<comment type="block">/*
 *  AttributeEquivalenceClassMember - one member expression of an
 *  AttributeEquivalenceClass. The important thing to consider is that
 *  the class member contains "rteIndentity" field. Note that each RTE_RELATION
 *  is assigned a unique rteIdentity in AssignRTEIdentities() function.
 *
 *  "varno" and "varattno" is directly used from a Var clause that is being added
 *  to the attribute equivalence. Since we only use this class for relations, the member
 *  also includes the relation id field.
 */</comment>
<typedef>typedef <type><struct>struct <name>AttributeEquivalenceClassMember</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rteIdentity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>varno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl>;</decl_stmt>
}</block></struct></type> <name>AttributeEquivalenceClassMember</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContextContainsLocalRelation</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContextContainsAppendRelation</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>RangeTableOffsetCompat</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appendRelInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type> <name>FindUnionAllVar</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>translatedVars</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>,
							 <parameter><decl><type><name>Index</name></type> <name>relationRteIndex</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>partitionKeyIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsMultipleDistributedRelations</name><parameter_list>(<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
												 <name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateAttributeEquivalencesForRelationRestrictions</name><parameter_list>(
	<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AttributeEquivalenceClass</name> <modifier>*</modifier></type> <name>AttributeEquivalenceClassForEquivalenceClass</name><parameter_list>(
	<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>plannerEqClass</name></decl></parameter>, <parameter><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddToAttributeEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
										   <name>attributeEquivalenceClass</name></decl></parameter>,
										   <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddRteSubqueryToAttributeEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
													  <name>attributeEquivalenceClass</name></decl></parameter>,
													  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
													  <name>rangeTableEntry</name></decl></parameter>,
													  <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
													  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type> <name>GetTargetSubquery</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
								 <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddUnionAllSetOperationsToAttributeEquivalenceClass</name><parameter_list>(
	<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
	<name>attributeEquivalenceClass</name></decl></parameter>,
	<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
	<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddUnionSetOperationsToAttributeEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
															 <name>attributeEquivalenceClass</name></decl></parameter>,
															 <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
															 <parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type>
															 <name>setOperation</name></decl></parameter>,
															 <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddRteRelationToAttributeEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
													  <name>attrEquivalenceClass</name></decl></parameter>,
													  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
													  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type> <name>GetVarFromAssignedParam</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outerPlanParamsList</name></decl></parameter>, <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>plannerParam</name></decl></parameter>,
									 <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>rootContainingVar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type> <name>SearchPlannerParamList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plannerParamList</name></decl></parameter>, <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>plannerParam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateAttributeEquivalencesForJoinRestrictions</name><parameter_list>(<parameter><decl><type><name>JoinRestrictionContext</name>
															   <modifier>*</modifier></type><name>joinRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AttributeClassContainsAttributeClassMember</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClassMember</name> <modifier>*</modifier></type>
													   <name>inputMember</name></decl></parameter>,
													   <parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
													   <name>attributeEquivalenceClass</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>AddAttributeClassToAttributeClassList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeEquivalenceList</name></decl></parameter>,
													<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
													<name>attributeEquivalence</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AttributeEquivalencesAreEqual</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
										  <name>firstAttributeEquivalence</name></decl></parameter>,
										  <parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
										  <name>secondAttributeEquivalence</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AttributeEquivalenceClass</name> <modifier>*</modifier></type> <name>GenerateCommonEquivalence</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type>
															 <name>attributeEquivalenceList</name></decl></parameter>,
															 <parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type>
															 <name>relationRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AttributeEquivalenceClass</name> <modifier>*</modifier></type> <name>GenerateEquivalenceClassForRelationRestriction</name><parameter_list>(
	<parameter><decl><type><name>RelationRestrictionContext</name>
	<modifier>*</modifier></type>
	<name>relationRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ListConcatUniqueAttributeClassMemberLists</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
													  <name>firstClass</name></decl></parameter>,
													  <parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
													  <name>secondClass</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type> <name>PartitionKeyForRTEIdentityInQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetRTEIndex</name></decl></parameter>,
											   <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>partitionKeyIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AllRelationsInRestrictionContextColocated</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type>
													  <name>restrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsNotSafeRestrictionToRecursivelyPlan</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JoinRestrictionContext</name> <modifier>*</modifier></type> <name>FilterJoinRestrictionContext</name><parameter_list>(
	<parameter><decl><type><name>JoinRestrictionContext</name> <modifier>*</modifier></type><name>joinRestrictionContext</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type>
	<name>queryRteIdentities</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RangeTableArrayContainsAnyRTEIdentities</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>rangeTableEntries</name></decl></parameter>, <parameter><decl><type><name>int</name></type>
													<name>rangeTableArrayLength</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type>
													<name>queryRteIdentities</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Relids</name></type> <name>QueryRteIdentities</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type> <name>FindQueryContainingRTEIdentity</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>mainQuery</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rteIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FindQueryContainingRTEIdentityInternal</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
												   <parameter><decl><type><name>FindQueryContainingRteIdentityContext</name> <modifier>*</modifier></type>
												   <name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ParentCountPriorToAppendRel</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>appendRelList</name></decl></parameter>, <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appendRelInfo</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * AllDistributionKeysInQueryAreEqual returns true if either
 *    (i)  there exists join in the query and all relations joined on their
 *         partition keys
 *    (ii) there exists only union set operations and all relations has
 *         partition keys in the same ordinal position in the query
 */</comment>
<function><type><name>bool</name></type>
<name>AllDistributionKeysInQueryAreEqual</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
								   <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* we don't support distribution key equality checks for CTEs yet */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>originalQuery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we don't support distribution key equality checks for local tables */</comment>
	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ContextContainsLocalRelation</name><argument_list>(<argument><expr><name>restrictionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>restrictionEquivalenceForPartitionKeys</name> <init>=
		<expr><call><name>RestrictionEquivalenceForPartitionKeys</name><argument_list>(<argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>restrictionEquivalenceForPartitionKeys</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>originalQuery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>||</operator> <call><name>ContainsUnionSubquery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>SafeToPushdownUnionSubquery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContextContainsLocalRelation determines whether the given
 * RelationRestrictionContext contains any local tables.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContextContainsLocalRelation</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationRestrictionCell</argument>, <argument>restrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>relationRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>relationRestriction</name><operator>-&gt;</operator><name>citusTable</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContextContainsAppendRelation determines whether the given
 * RelationRestrictionContext contains any append-distributed tables.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContextContainsAppendRelation</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationRestrictionCell</argument>, <argument>restrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>relationRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SafeToPushdownUnionSubquery returns true if all the relations are returns
 * partition keys in the same ordinal position and there is no reference table
 * exists.
 *
 * Note that the function expects (and asserts) the input query to be a top
 * level union query defined by TopLevelUnionQuery().
 *
 * Lastly, the function fails to produce correct output if the target lists contains
 * multiple partition keys on the target list such as the following:
 *
 *   select count(*) from (
 *       select user_id, user_id from users_table
 *   union
 *       select 2, user_id from users_table) u;
 *
 * For the above query, although the second item in the target list make this query
 * safe to push down, the function would fail to return true.
 */</comment>
<function><type><name>bool</name></type>
<name>SafeToPushdownUnionSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
							<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinRestrictionContext</name> <modifier>*</modifier></type><name>joinRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>attributeEquivalence</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttributeEquivalenceClass</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>attributeEquivalence</name><operator>-&gt;</operator><name>equivalenceId</name></name> <operator>=</operator> <name>AttributeEquivalenceId</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure that the partition column is in the same place across all
	 * leaf queries in the UNION and construct an equivalence class for
	 * these columns.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>relationRestrictionCell</argument>, <argument>restrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>relationRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>partitionKeyIndex</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>relationPlannerRoot</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>plannerInfo</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>targetRTEIndex</name> <init>= <expr><call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>rte</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name> <init>=
			<expr><call><name>PartitionKeyForRTEIdentityInQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>targetRTEIndex</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>partitionKeyIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* union does not have partition key in the target list */</comment>
		<if_stmt><if>if <condition>(<expr><name>partitionKeyIndex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * This should never happen but to be on the safe side, we have this
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relationPlannerRoot</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>&lt;</operator> <name><name>relationRestriction</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We update the varno because we use the original parse tree for finding the
		 * var. However the rest of the code relies on a query tree that might be different
		 * than the original parse tree because of postgres optimizations.
		 * That's why we update the varno to reflect the rteIndex in the modified query tree.
		 */</comment>
		<expr_stmt><expr><name><name>varToBeAdded</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>relationRestriction</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>


		<comment type="block">/*
		 * The current relation does not have its partition key in the target list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>partitionKeyIndex</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We find the first relations partition key index in the target list. Later,
		 * we check whether all the relations have partition keys in the
		 * same position.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attributeEquivalence</name><operator>-&gt;</operator><name>unionQueryPartitionKeyIndex</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>attributeEquivalence</name><operator>-&gt;</operator><name>unionQueryPartitionKeyIndex</name></name> <operator>=</operator> <name>partitionKeyIndex</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>attributeEquivalence</name><operator>-&gt;</operator><name>unionQueryPartitionKeyIndex</name></name> <operator>!=</operator> <name>partitionKeyIndex</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varToBeAdded</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AddToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalence</name></expr></argument>, <argument><expr><name>relationPlannerRoot</name></expr></argument>,
									   <argument><expr><name>varToBeAdded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * For queries of the form:
	 * (SELECT ... FROM a JOIN b ...) UNION (SELECT .. FROM c JOIN d ... )
	 *
	 * we determine whether all relations are joined on the partition column
	 * by adding the equivalence classes that can be inferred from joins.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationRestrictionAttributeEquivalenceList</name> <init>=
		<expr><call><name>GenerateAttributeEquivalencesForRelationRestrictions</name><argument_list>(<argument><expr><name>restrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinRestrictionAttributeEquivalenceList</name> <init>=
		<expr><call><name>GenerateAttributeEquivalencesForJoinRestrictions</name><argument_list>(<argument><expr><name>joinRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allAttributeEquivalenceList</name> <init>=
		<expr><call><name>list_concat</name><argument_list>(<argument><expr><name>relationRestrictionAttributeEquivalenceList</name></expr></argument>,
					<argument><expr><name>joinRestrictionAttributeEquivalenceList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>allAttributeEquivalenceList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>allAttributeEquivalenceList</name></expr></argument>,
										  <argument><expr><name>attributeEquivalence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EquivalenceListContainsRelationsEquality</name><argument_list>(<argument><expr><name>allAttributeEquivalenceList</name></expr></argument>,
												  <argument><expr><name>restrictionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cannot confirm equality for all distribution colums */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllRelationsInRestrictionContextColocated</name><argument_list>(<argument><expr><name>restrictionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* distribution columns are equal, but tables are not co-located */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RangeTableOffsetCompat returns the range table offset(in glob-&gt;finalrtable) for the appendRelInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>RangeTableOffsetCompat</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appendRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>parentCount</name> <init>= <expr><call><name>ParentCountPriorToAppendRel</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>, <argument><expr><name>appendRelInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>skipParentCount</name> <init>= <expr><name>parentCount</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We skip the previous parents because we want to find the offset
			 * for the given append rel info.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>skipParentCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>skipParentCount</name><operator>--</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<decl_stmt><decl><type><name>int</name></type> <name>indexInRtable</name> <init>= <expr><operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Postgres adds the global rte array size to parent_relid as an offset.
	 * Here we do the reverse operation: Commit on postgres side:
	 * 6ef77cf46e81f45716ec981cb08781d426181378
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>parentRelIndex</name> <init>= <expr><name><name>appendRelInfo</name><operator>-&gt;</operator><name>parent_relid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>parentRelIndex</name> <operator>-</operator> <name>indexInRtable</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindUnionAllVar finds the variable used in union all for the side that has
 * relationRteIndex as its index and the same varattno as the partition key of
 * the given relation with relationOid.
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>FindUnionAllVar</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>translatedVars</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>,
				<parameter><decl><type><name>Index</name></type> <name>relationRteIndex</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>partitionKeyIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>, <argument><expr><name>STRICTLY_PARTITIONED_DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we only care about hash and range partitioned tables */</comment>
		<expr_stmt><expr><operator>*</operator><name>partitionKeyIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>relationPartitionKey</name> <init>= <expr><call><name>DistPartitionKeyOrError</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>childAttrNumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>partitionKeyIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>translatedVarCell</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>translatedVarCell</argument>, <argument>translatedVars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>targetNode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>translatedVarCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>childAttrNumber</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>targetNode</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>translatedVarCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>targetVar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>relationRteIndex</name> <operator>&amp;&amp;</operator>
			<name><name>targetVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>relationPartitionKey</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>partitionKeyIndex</name> <operator>=</operator> <name>childAttrNumber</name></expr>;</expr_stmt>

			<return>return <expr><name>targetVar</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RestrictionEquivalenceForPartitionKeys aims to deduce whether each of the RTE_RELATION
 * is joined with at least one another RTE_RELATION on their partition keys. If each
 * RTE_RELATION follows the above rule, we can conclude that all RTE_RELATIONs are
 * joined on their partition keys.
 *
 * Before doing the expensive equality checks, we do a cheaper check to understand
 * whether there are more than one distributed relations. Otherwise, we exit early.
 *
 * The function returns true if all relations are joined on their partition keys.
 * Otherwise, the function returns false. We ignore reference tables at all since
 * they don't have partition keys.
 *
 * In order to do that, we invented a new equivalence class namely:
 * AttributeEquivalenceClass. In very simple words, a AttributeEquivalenceClass is
 * identified by an unique id and consists of a list of AttributeEquivalenceMembers.
 *
 * Each AttributeEquivalenceMember is designed to identify attributes uniquely within the
 * whole query. The necessity of this arise since varno attributes are defined within
 * a single level of a query. Instead, here we want to identify each RTE_RELATION uniquely
 * and try to find equality among each RTE_RELATION's partition key.
 *
 * Each equality among RTE_RELATION is saved using an AttributeEquivalenceClass where
 * each member attribute is identified by a AttributeEquivalenceMember. In the final
 * step, we try generate a common attribute equivalence class that holds as much as
 * AttributeEquivalenceMembers whose attributes are a partition keys.
 *
 * RestrictionEquivalenceForPartitionKeys uses both relation restrictions and join restrictions
 * to find as much as information that Postgres planner provides to extensions. For the
 * details of the usage, please see GenerateAttributeEquivalencesForRelationRestrictions()
 * and GenerateAttributeEquivalencesForJoinRestrictions().
 */</comment>
<function><type><name>bool</name></type>
<name>RestrictionEquivalenceForPartitionKeys</name><parameter_list>(<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ContextContainsLocalRelation</name><argument_list>(<argument><expr><name><name>restrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ContainsMultipleDistributedRelations</name><argument_list>(<argument><expr><name>restrictionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there is a single distributed relation, no need to continue */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>ContextContainsAppendRelation</name><argument_list>(
				 <argument><expr><name><name>restrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we never consider append-distributed tables co-located */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeEquivalenceList</name> <init>= <expr><call><name>GenerateAllAttributeEquivalences</name><argument_list>(<argument><expr><name>restrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>RestrictionEquivalenceForPartitionKeysViaEquivalences</name><argument_list>(<argument><expr><name>restrictionContext</name></expr></argument>,
																 <argument><expr><name>attributeEquivalenceList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RestrictionEquivalenceForPartitionKeysViaEquivalences follows the same rules
 * with RestrictionEquivalenceForPartitionKeys(). The only difference is that
 * this function allows passing pre-computed attribute equivalences along with
 * the planner restriction context.
 */</comment>
<function><type><name>bool</name></type>
<name>RestrictionEquivalenceForPartitionKeysViaEquivalences</name><parameter_list>(<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
													  <name>plannerRestrictionContext</name></decl></parameter>,
													  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>allAttributeEquivalenceList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* there is a single distributed relation, no need to continue */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ContainsMultipleDistributedRelations</name><argument_list>(<argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>EquivalenceListContainsRelationsEquality</name><argument_list>(<argument><expr><name>allAttributeEquivalenceList</name></expr></argument>,
													<argument><expr><name>restrictionContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsMultipleDistributedRelations returns true if the input planner
 * restriction context contains more than one distributed relation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsMultipleDistributedRelations</name><parameter_list>(<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
									 <name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>distributedRelationCount</name> <init>=
		<expr><call><name>UniqueRelationCount</name><argument_list>(<argument><expr><name>restrictionContext</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the query includes a single relation which is not a reference table,
	 * we should not check the partition column equality.
	 * Consider two example cases:
	 *   (i)   The query includes only a single colocated relation
	 *   (ii)  A colocated relation is joined with a (or multiple) reference
	 *         table(s) where colocated relation is not joined on the partition key
	 *
	 * For the above two cases, we don't need to execute the partition column equality
	 * algorithm. The reason is that the essence of this function is to ensure that the
	 * tasks that are going to be created should not need data from other tasks. In both
	 * cases mentioned above, the necessary data per task would be on available.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>distributedRelationCount</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateAllAttributeEquivalences gets the planner restriction context and returns
 * the list of all attribute equivalences based on both join restrictions and relation
 * restrictions.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GenerateAllAttributeEquivalences</name><parameter_list>(<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>relationRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinRestrictionContext</name> <modifier>*</modifier></type><name>joinRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* reset the equivalence id counter per call to prevent overflows */</comment>
	<expr_stmt><expr><name>AttributeEquivalenceId</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationRestrictionAttributeEquivalenceList</name> <init>=
		<expr><call><name>GenerateAttributeEquivalencesForRelationRestrictions</name><argument_list>(<argument><expr><name>relationRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinRestrictionAttributeEquivalenceList</name> <init>=
		<expr><call><name>GenerateAttributeEquivalencesForJoinRestrictions</name><argument_list>(<argument><expr><name>joinRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allAttributeEquivalenceList</name> <init>= <expr><call><name>list_concat</name><argument_list>(
		<argument><expr><name>relationRestrictionAttributeEquivalenceList</name></expr></argument>,
		<argument><expr><name>joinRestrictionAttributeEquivalenceList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>allAttributeEquivalenceList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UniqueRelationCount iterates over the relations and returns the
 * unique relation count. We use RTEIdentity as the identifiers, so if
 * the same relation appears twice in the restrictionContext, we count
 * it as a single item.
 */</comment>
<function><type><name>uint32</name></type>
<name>UniqueRelationCount</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>, <parameter><decl><type><name>CitusTableType</name></type>
					<name>tableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rteIdentityList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationRestrictionCell</argument>, <argument>restrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>=
			<expr><operator>(</operator><name>RelationRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>relationRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>LookupCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>cacheEntry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we  don't expect non-distributed tables, still be no harm to skip */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>tableType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>rteIdentity</name> <init>= <expr><call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>rte</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>rteIdentityList</name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name>rteIdentityList</name></expr></argument>, <argument><expr><name>rteIdentity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>rteIdentityList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EquivalenceListContainsRelationsEquality gets a list of attributed equivalence
 * list and a relation restriction context. The function first generates a common
 * equivalence class out of the attributeEquivalenceList. Later, the function checks
 * whether all the relations exists in the common equivalence class.
 *
 */</comment>
<function><type><name>bool</name></type>
<name>EquivalenceListContainsRelationsEquality</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeEquivalenceList</name></decl></parameter>,
										 <parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>commonEqClassCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type> <name>commonRteIdentities</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In general we're trying to expand existing the equivalence classes to find a
	 * common equivalence class. The main goal is to test whether this main class
	 * contains all partition keys of the existing relations.
	 */</comment>
	<decl_stmt><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>commonEquivalenceClass</name> <init>= <expr><call><name>GenerateCommonEquivalence</name><argument_list>(
		<argument><expr><name>attributeEquivalenceList</name></expr></argument>,
		<argument><expr><name>restrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* add the rte indexes of relations to a bitmap */</comment>
	<macro><name>foreach</name><argument_list>(<argument>commonEqClassCell</argument>, <argument>commonEquivalenceClass-&gt;equivalentAttributes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttributeEquivalenceClassMember</name> <modifier>*</modifier></type><name>classMember</name> <init>=
			<expr><operator>(</operator><name>AttributeEquivalenceClassMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>commonEqClassCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rteIdentity</name> <init>= <expr><name><name>classMember</name><operator>-&gt;</operator><name>rteIdentity</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>commonRteIdentities</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>commonRteIdentities</name></expr></argument>, <argument><expr><name>rteIdentity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* check whether all relations exists in the main restriction list */</comment>
	<macro><name>foreach</name><argument_list>(<argument>relationRestrictionCell</argument>, <argument>restrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>=
			<expr><operator>(</operator><name>RelationRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>relationRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rteIdentity</name> <init>= <expr><call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>rte</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we shouldn't check for the equality of non-distributed tables */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
							 <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rteIdentity</name></expr></argument>, <argument><expr><name>commonRteIdentities</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateAttributeEquivalencesForRelationRestrictions gets a relation restriction
 * context and returns a list of AttributeEquivalenceClass.
 *
 * The algorithm followed can be summarized as below:
 *
 * - Per relation restriction
 *     - Per plannerInfo's eq_class
 *         - Create an AttributeEquivalenceClass
 *         - Add all Vars that appear in the plannerInfo's
 *           eq_class to the AttributeEquivalenceClass
 *               - While doing that, consider LATERAL vars as well.
 *                 See GetVarFromAssignedParam() for the details. Note
 *                 that we're using parentPlannerInfo while adding the
 *                 LATERAL vars given that we rely on that plannerInfo.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GenerateAttributeEquivalencesForRelationRestrictions</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name>
													 <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeEquivalenceList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>restrictionContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>attributeEquivalenceList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationRestrictionCell</argument>, <argument>restrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>=
			<expr><operator>(</operator><name>RelationRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>relationRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>equivalenceClasses</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>plannerInfo</name><operator>-&gt;</operator><name>eq_classes</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>equivalenceClassCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>equivalenceClassCell</argument>, <argument>equivalenceClasses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>plannerEqClass</name> <init>=
				<expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>equivalenceClassCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>attributeEquivalence</name> <init>=
				<expr><call><name>AttributeEquivalenceClassForEquivalenceClass</name><argument_list>(<argument><expr><name>plannerEqClass</name></expr></argument>,
															 <argument><expr><name>relationRestriction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>attributeEquivalenceList</name> <operator>=</operator>
				<call><name>AddAttributeClassToAttributeClassList</name><argument_list>(<argument><expr><name>attributeEquivalenceList</name></expr></argument>,
													  <argument><expr><name>attributeEquivalence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>attributeEquivalenceList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AttributeEquivalenceClassForEquivalenceClass is a helper function for
 * GenerateAttributeEquivalencesForRelationRestrictions. The function takes an
 * EquivalenceClass and the relation restriction that the equivalence class
 * belongs to. The function returns an AttributeEquivalenceClass that is composed
 * of ec_members that are simple Var references.
 *
 * The function also takes case of LATERAL joins by simply replacing the PARAM_EXEC
 * with the corresponding expression.
 */</comment>
<function><type><specifier>static</specifier> <name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
<name>AttributeEquivalenceClassForEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>plannerEqClass</name></decl></parameter>,
											 <parameter><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>attributeEquivalence</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttributeEquivalenceClass</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>equivilanceMemberCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>plannerInfo</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>plannerInfo</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>attributeEquivalence</name><operator>-&gt;</operator><name>equivalenceId</name></name> <operator>=</operator> <name>AttributeEquivalenceId</name><operator>++</operator></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>equivilanceMemberCell</argument>, <argument>plannerEqClass-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>equivalenceMember</name> <init>=
			<expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>equivilanceMemberCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>equivalenceNode</name> <init>= <expr><call><name>strip_implicit_coercions</name><argument_list>(
			<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>equivalenceMember</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>strippedEquivalenceExpr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>equivalenceNode</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>expressionVar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>strippedEquivalenceExpr</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>outerNodeRoot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>equivalenceParam</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>strippedEquivalenceExpr</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>expressionVar</name> <operator>=</operator>
				<call><name>GetVarFromAssignedParam</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>outerPlanParamsList</name></name></expr></argument>,
										<argument><expr><name>equivalenceParam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outerNodeRoot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>expressionVar</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>AddToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalence</name></expr></argument>, <argument><expr><name>outerNodeRoot</name></expr></argument>,
											   <argument><expr><name>expressionVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>strippedEquivalenceExpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>expressionVar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>strippedEquivalenceExpr</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AddToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalence</name></expr></argument>, <argument><expr><name>plannerInfo</name></expr></argument>,
										   <argument><expr><name>expressionVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>attributeEquivalence</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetVarFromAssignedParam returns the Var that is assigned to the given
 * plannerParam if its kind is PARAM_EXEC.
 *
 * If the paramkind is not equal to PARAM_EXEC the function returns NULL. Similarly,
 * if there is no Var corresponding to the given param is, the function returns NULL.
 *
 * Rationale behind this function:
 *
 *   While iterating through the equivalence classes of RTE_RELATIONs, we
 *   observe that there are PARAM type of equivalence member expressions for
 *   the RTE_RELATIONs which actually belong to lateral vars from the other query
 *   levels.
 *
 *   We're also keeping track of the RTE_RELATION's outer nodes'
 *   plan_params lists which is expected to hold the parameters that are required
 *   for its lower level queries as it is documented:
 *
 *        plan_params contains the expressions that this query level needs to
 *        make available to a lower query level that is currently being planned.
 *
 *   This function is a helper function to iterate through the outer node's query's
 *   plan_params and looks for the param that the equivalence member has. The
 *   comparison is done via the "paramid" field. Finally, if the found parameter's
 *   item is a Var, we conclude that Postgres standard_planner replaced the Var
 *   with the Param on assign_param_for_var() function
 *   @src/backend/optimizer/plan/subselect.c.
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>GetVarFromAssignedParam</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outerPlanParamsList</name></decl></parameter>, <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>plannerParam</name></decl></parameter>,
						<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>rootContainingVar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>assignedVar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rootPlanParamsCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>plannerParam</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we're only interested in parameters that Postgres added for execution */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>plannerParam</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>!=</operator> <name>PARAM_EXEC</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rootPlanParamsCell</argument>, <argument>outerPlanParamsList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RootPlanParams</name> <modifier>*</modifier></type><name>outerPlanParams</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>rootPlanParamsCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>assignedVar</name> <operator>=</operator> <call><name>SearchPlannerParamList</name><argument_list>(<argument><expr><name><name>outerPlanParams</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>,
											 <argument><expr><name>plannerParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>assignedVar</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>rootContainingVar</name> <operator>=</operator> <name><name>outerPlanParams</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>assignedVar</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SearchPlannerParamList searches in plannerParamList and returns the Var that
 * corresponds to the given plannerParam. If there is no Var corresponding to the
 * given param is, the function returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>SearchPlannerParamList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plannerParamList</name></decl></parameter>, <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>plannerParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>assignedVar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>plannerParameterCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>plannerParameterCell</argument>, <argument>plannerParamList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>plannerParamItem</name> <init>=
			<expr><operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>plannerParameterCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>plannerParamItem</name><operator>-&gt;</operator><name>paramId</name></name> <operator>!=</operator> <name><name>plannerParam</name><operator>-&gt;</operator><name>paramid</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* TODO: Should we consider PlaceHolderVar? */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>plannerParamItem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>assignedVar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>plannerParamItem</name><operator>-&gt;</operator><name>item</name></name></expr>;</expr_stmt>

		<break>break;</break>
	</block_content>}</block>

	<return>return <expr><name>assignedVar</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateCommonEquivalence gets a list of unrelated AttributeEquiavalenceClass
 * whose all members are partition keys.
 *
 * With the equivalence classes, the function follows the algorithm
 * outlined below:
 *
 *     - Add the first equivalence class to the common equivalence class
 *     - Then, iterate on the remaining equivalence classes
 *          - If any of the members equal to the common equivalence class
 *            add all the members of the equivalence class to the common
 *            class
 *          - Start the iteration from the beginning. The reason is that
 *            in case any of the classes we've passed is equivalent to the
 *            newly added one. To optimize the algorithm, we utilze the
 *            equivalence class ids and skip the ones that are already added.
 *      - Finally, return the common equivalence class.
 */</comment>
<function><type><specifier>static</specifier> <name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
<name>GenerateCommonEquivalence</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeEquivalenceList</name></decl></parameter>,
						  <parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>relationRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>addedEquivalenceIds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>equivalenceListSize</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>attributeEquivalenceList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>equivalenceClassIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>commonEquivalenceClass</name> <init>= <expr><call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttributeEquivalenceClass</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>commonEquivalenceClass</name><operator>-&gt;</operator><name>equivalenceId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * We seed the common equivalence class with a the first distributed
	 * table since we always want the input distributed relations to be
	 * on the common class.
	 */</comment>
	<decl_stmt><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>firstEquivalenceClass</name> <init>=
		<expr><call><name>GenerateEquivalenceClassForRelationRestriction</name><argument_list>(<argument><expr><name>relationRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we skip the calculation if there are not enough information */</comment>
	<if_stmt><if>if <condition>(<expr><name>equivalenceListSize</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>firstEquivalenceClass</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>commonEquivalenceClass</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>commonEquivalenceClass</name><operator>-&gt;</operator><name>equivalentAttributes</name></name> <operator>=</operator>
		<name><name>firstEquivalenceClass</name><operator>-&gt;</operator><name>equivalentAttributes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>addedEquivalenceIds</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>addedEquivalenceIds</name></expr></argument>,
										 <argument><expr><name><name>firstEquivalenceClass</name><operator>-&gt;</operator><name>equivalenceId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>equivalenceClassIndex</name> <operator>&lt;</operator> <name>equivalenceListSize</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>equivalenceMemberCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>restartLoop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>currentEquivalenceClass</name> <init>= <expr><call><name>list_nth</name><argument_list>(
			<argument><expr><name>attributeEquivalenceList</name></expr></argument>,
			<argument><expr><name>equivalenceClassIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * This is an optimization. If we already added the same equivalence class,
		 * we could skip it since we've already added all the relevant equivalence
		 * members.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>currentEquivalenceClass</name><operator>-&gt;</operator><name>equivalenceId</name></name></expr></argument>, <argument><expr><name>addedEquivalenceIds</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>equivalenceClassIndex</name><operator>++</operator></expr>;</expr_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>equivalenceMemberCell</argument>, <argument>currentEquivalenceClass-&gt;equivalentAttributes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttributeEquivalenceClassMember</name> <modifier>*</modifier></type><name>attributeEquialanceMember</name> <init>=
				<expr><operator>(</operator><name>AttributeEquivalenceClassMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>equivalenceMemberCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>AttributeClassContainsAttributeClassMember</name><argument_list>(<argument><expr><name>attributeEquialanceMember</name></expr></argument>,
														   <argument><expr><name>commonEquivalenceClass</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ListConcatUniqueAttributeClassMemberLists</name><argument_list>(<argument><expr><name>commonEquivalenceClass</name></expr></argument>,
														  <argument><expr><name>currentEquivalenceClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>addedEquivalenceIds</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>addedEquivalenceIds</name></expr></argument>,
													 <argument><expr><name><name>currentEquivalenceClass</name><operator>-&gt;</operator>
													 <name>equivalenceId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * It seems inefficient to start from the beginning.
				 * But, we should somehow restart from the beginning to test that
				 * whether the already skipped ones are equal or not.
				 */</comment>
				<expr_stmt><expr><name>restartLoop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>restartLoop</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>equivalenceClassIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>++</operator><name>equivalenceClassIndex</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>commonEquivalenceClass</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateEquivalenceClassForRelationRestriction generates an AttributeEquivalenceClass
 * with a single AttributeEquivalenceClassMember.
 */</comment>
<function><type><specifier>static</specifier> <name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
<name>GenerateEquivalenceClassForRelationRestriction</name><parameter_list>(
	<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>relationRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttributeEquivalenceClassMember</name> <modifier>*</modifier></type><name>eqMember</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>eqClassForRelation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationRestrictionCell</argument>, <argument>relationRestrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>=
			<expr><operator>(</operator><name>RelationRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>relationRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>relationPartitionKey</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>relationPartitionKey</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>eqClassForRelation</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttributeEquivalenceClass</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>eqMember</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttributeEquivalenceClassMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>eqMember</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>relationRestriction</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>eqMember</name><operator>-&gt;</operator><name>rteIdentity</name></name> <operator>=</operator> <call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>rte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>eqMember</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>relationRestriction</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>eqMember</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>relationPartitionKey</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>eqClassForRelation</name><operator>-&gt;</operator><name>equivalentAttributes</name></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>eqClassForRelation</name><operator>-&gt;</operator><name>equivalentAttributes</name></name></expr></argument>, <argument><expr><name>eqMember</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>eqClassForRelation</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ListConcatUniqueAttributeClassMemberLists gets two attribute equivalence classes. It
 * basically concatenates attribute equivalence member lists uniquely and updates the
 * firstClass' member list with the list.
 *
 * Basically, the function iterates over the secondClass' member list and checks whether
 * it already exists in the firstClass' member list. If not, the member is added to the
 * firstClass.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ListConcatUniqueAttributeClassMemberLists</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>firstClass</name></decl></parameter>,
										  <parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>secondClass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>equivalenceClassMemberCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>equivalenceMemberList</name> <init>= <expr><name><name>secondClass</name><operator>-&gt;</operator><name>equivalentAttributes</name></name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>equivalenceClassMemberCell</argument>, <argument>equivalenceMemberList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttributeEquivalenceClassMember</name> <modifier>*</modifier></type><name>newEqMember</name> <init>=
			<expr><operator>(</operator><name>AttributeEquivalenceClassMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>equivalenceClassMemberCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>AttributeClassContainsAttributeClassMember</name><argument_list>(<argument><expr><name>newEqMember</name></expr></argument>, <argument><expr><name>firstClass</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>firstClass</name><operator>-&gt;</operator><name>equivalentAttributes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>firstClass</name><operator>-&gt;</operator><name>equivalentAttributes</name></name></expr></argument>,
												   <argument><expr><name>newEqMember</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateAttributeEquivalencesForJoinRestrictions gets a join restriction
 * context and returns a list of AttrributeEquivalenceClass.
 *
 * The algorithm followed can be summarized as below:
 *
 * - Per join restriction
 *     - Per RestrictInfo of the join restriction
 *     - Check whether the join restriction is in the form of (Var1 = Var2)
 *         - Create an AttributeEquivalenceClass
 *         - Add both Var1 and Var2 to the AttributeEquivalenceClass
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GenerateAttributeEquivalencesForJoinRestrictions</name><parameter_list>(<parameter><decl><type><name>JoinRestrictionContext</name> <modifier>*</modifier></type>
												 <name>joinRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeEquivalenceList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>joinRestrictionContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>attributeEquivalenceList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>joinRestrictionCell</argument>, <argument>joinRestrictionContext-&gt;joinRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinRestriction</name> <modifier>*</modifier></type><name>joinRestriction</name> <init>=
			<expr><operator>(</operator><name>JoinRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>joinRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>restrictionInfoList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>restrictionInfoList</argument>, <argument>joinRestriction-&gt;joinRestrictInfoList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>restrictionInfoList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>restrictionClause</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>restrictionClause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>restrictionOpExpr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>restrictionClause</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>restrictionOpExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OperatorImplementsEquality</name><argument_list>(<argument><expr><name><name>restrictionOpExpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>leftNode</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>restrictionOpExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rightNode</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>restrictionOpExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* we also don't want implicit coercions */</comment>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>strippedLeftExpr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>leftNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>strippedRightExpr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>strip_implicit_coercions</name><argument_list>(
				<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rightNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>strippedLeftExpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>strippedRightExpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>leftVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>strippedLeftExpr</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>rightVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>strippedRightExpr</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>attributeEquivalence</name> <init>= <expr><call><name>palloc0</name><argument_list>(
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttributeEquivalenceClass</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>attributeEquivalence</name><operator>-&gt;</operator><name>equivalenceId</name></name> <operator>=</operator> <name>AttributeEquivalenceId</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AddToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalence</name></expr></argument>,
										   <argument><expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>plannerInfo</name></name></expr></argument>, <argument><expr><name>leftVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AddToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalence</name></expr></argument>,
										   <argument><expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>plannerInfo</name></name></expr></argument>, <argument><expr><name>rightVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>attributeEquivalenceList</name> <operator>=</operator>
				<call><name>AddAttributeClassToAttributeClassList</name><argument_list>(<argument><expr><name>attributeEquivalenceList</name></expr></argument>,
													  <argument><expr><name>attributeEquivalence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>attributeEquivalenceList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddToAttributeEquivalenceClass is a key function for building the attribute
 * equivalences. The function gets a plannerInfo, var and attribute equivalence
 * class. It searches for the RTE_RELATION(s) that the input var belongs to and
 * adds the found Var(s) to the input attribute equivalence class.
 *
 * Note that the input var could come from a subquery (i.e., not directly from an
 * RTE_RELATION). That's the reason we recursively call the function until the
 * RTE_RELATION found.
 *
 * The algorithm could be summarized as follows:
 *
 *    - If the RTE that corresponds to a relation
 *        - Generate an AttributeEquivalenceMember and add to the input
 *          AttributeEquivalenceClass
 *    - If the RTE that corresponds to a subquery
 *        - If the RTE that corresponds to a UNION ALL subquery
 *            - Iterate on each of the appendRels (i.e., each of the UNION ALL query)
 *            - Recursively add all children of the set operation's
 *              corresponding target entries
 *        - If the corresponding subquery entry is a UNION set operation
 *             - Recursively add all children of the set operation's
 *               corresponding target entries
 *        - If the corresponding subquery is a regular subquery (i.e., No set operations)
 *             - Recursively try to add the corresponding target entry to the
 *               equivalence class
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddToAttributeEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>attributeEquivalenceClass</name></decl></parameter>,
							   <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* punt if it's a whole-row var rather than a plain column reference */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>varToBeAdded</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we also don't want to process ctid, tableoid etc */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>varToBeAdded</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>varToBeAdded</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AddRteRelationToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalenceClass</name></expr></argument>,
												  <argument><expr><name>rangeTableEntry</name></expr></argument>,
												  <argument><expr><name>varToBeAdded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AddRteSubqueryToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalenceClass</name></expr></argument>,
												  <argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
												  <argument><expr><name>varToBeAdded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AddRteSubqueryToAttributeEquivalenceClass adds the given var to the given
 * attribute equivalence class.
 *
 * The main algorithm is outlined in AddToAttributeEquivalenceClass().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddRteSubqueryToAttributeEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name>
										  <modifier>*</modifier></type><name>attributeEquivalenceClass</name></decl></parameter>,
										  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
										  <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baseRelOptInfo</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>varToBeAdded</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>targetSubquery</name> <init>= <expr><call><name>GetTargetSubquery</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>varToBeAdded</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We might not always get the subquery because the subquery might be a
	 * referencing to RELOPT_DEADREL such that the corresponding join is
	 * removed via join_is_removable().
	 *
	 * Returning here implies that PostgreSQL doesn't need to plan the
	 * subquery because it doesn't contribute to the query result at all.
	 * Since the relations in the subquery does not appear in the query
	 * plan as well, Citus would simply ignore the subquery and treat that
	 * as a safe-to-pushdown subquery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetSubquery</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>subqueryTargetEntry</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>targetSubquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
														<argument><expr><name><name>varToBeAdded</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if we fail to find corresponding target entry, do not proceed */</comment>
	<if_stmt><if>if <condition>(<expr><name>subqueryTargetEntry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>subqueryTargetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we're only interested in Vars */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>subqueryTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>varToBeAdded</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>subqueryTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 *  "inh" flag is set either when inheritance or "UNION ALL" exists in the
	 *  subquery. Here we're only interested in the "UNION ALL" case.
	 *
	 *  Else, we check one more thing: Does the subquery contain a "UNION" query.
	 *  If so, we recursively traverse all "UNION" tree and add the corresponding
	 *  target list elements to the attribute equivalence.
	 *
	 *  Finally, if it is a regular subquery (i.e., does not contain UNION or UNION ALL),
	 *  we simply recurse to find the corresponding RTE_RELATION to add to the
	 *  equivalence class.
	 *
	 *  Note that we're treating "UNION" and "UNION ALL" clauses differently given
	 *  that postgres planner process/plans them separately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AddUnionAllSetOperationsToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalenceClass</name></expr></argument>,
															<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varToBeAdded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>targetSubquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AddUnionSetOperationsToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalenceClass</name></expr></argument>,
														 <argument><expr><name><name>baseRelOptInfo</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>,
														 <argument><expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator>
														 <name><name>targetSubquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>,
														 <argument><expr><name>varToBeAdded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>varToBeAdded</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>varToBeAdded</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>varToBeAdded</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AddToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalenceClass</name></expr></argument>,
									   <argument><expr><name><name>baseRelOptInfo</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name>varToBeAdded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetTargetSubquery returns the corresponding subquery for the given planner root,
 * range table entry and the var.
 *
 * The aim of this function is to simplify extracting the subquery in case of "UNION ALL"
 * queries.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>GetTargetSubquery</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>targetSubquery</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For subqueries other than "UNION ALL", find the corresponding targetSubquery. See
	 * the details of how we process subqueries in the below comments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baseRelOptInfo</name> <init>= <expr><call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>varToBeAdded</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If the targetSubquery was not planned, we have to punt */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>baseRelOptInfo</name><operator>-&gt;</operator><name>subroot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>baseRelOptInfo</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>targetSubquery</name> <operator>=</operator> <name><name>baseRelOptInfo</name><operator>-&gt;</operator><name>subroot</name><operator>-&gt;</operator><name>parse</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>targetSubquery</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>targetSubquery</name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>targetSubquery</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddUnionAllSetOperationsToAttributeEquivalenceClass recursively iterates on all the
 * append rels, sets the varno's accordingly and adds the
 * var the given equivalence class.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddUnionAllSetOperationsToAttributeEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
													<name>attributeEquivalenceClass</name></decl></parameter>,
													<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
													<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>appendRelList</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>appendRelCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate on the queries that are part of UNION ALL subqueries */</comment>
	<macro><name>foreach</name><argument_list>(<argument>appendRelCell</argument>, <argument>appendRelList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appendRelInfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>appendRelCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We're only interested in UNION ALL clauses and parent_reloid is invalid
		 * only for UNION ALL (i.e., equals to a legitimate Oid for inheritance)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>appendRelInfo</name><operator>-&gt;</operator><name>parent_reloid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rtoffset</name> <init>= <expr><call><name>RangeTableOffsetCompat</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>appendRelInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>childRelId</name> <init>= <expr><name><name>appendRelInfo</name><operator>-&gt;</operator><name>child_relid</name></name> <operator>-</operator> <name>rtoffset</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>&lt;=</operator> <name>childRelId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we prefer to return over an Assert or error to be defensive */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>childRelId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This code-path may require improvements. If a leaf of a UNION ALL
			 * (e.g., an entry in appendRelList) itself is another UNION ALL
			 * (e.g., rte-&gt;inh = true), the logic here might get into an infinite
			 * recursion.
			 *
			 * The downside of "continue" here is that certain UNION ALL queries
			 * that are safe to pushdown may not be pushed down.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Index</name></type> <name>partitionKeyIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>translatedVars</name> <init>= <expr><call><name>TranslatedVarsForRteIdentity</name><argument_list>(<argument><expr><call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAddedOnUnionAllSubquery</name> <init>=
				<expr><call><name>FindUnionAllVar</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>translatedVars</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>childRelId</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>partitionKeyIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>partitionKeyIndex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no partition key on the target list */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attributeEquivalenceClass</name><operator>-&gt;</operator><name>unionQueryPartitionKeyIndex</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* the first partition key index we found */</comment>
				<expr_stmt><expr><name><name>attributeEquivalenceClass</name><operator>-&gt;</operator><name>unionQueryPartitionKeyIndex</name></name> <operator>=</operator>
					<name>partitionKeyIndex</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>attributeEquivalenceClass</name><operator>-&gt;</operator><name>unionQueryPartitionKeyIndex</name></name> <operator>!=</operator>
					 <name>partitionKeyIndex</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Partition keys on the leaves of the UNION ALL queries on
				 * different ordinal positions. We cannot pushdown, so skip.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>varToBeAddedOnUnionAllSubquery</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>AddToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalenceClass</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>varToBeAddedOnUnionAllSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* set the varno accordingly for this specific child */</comment>
			<expr_stmt><expr><name><name>varToBeAdded</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>childRelId</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AddToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalenceClass</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>varToBeAdded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ParentCountPriorToAppendRel returns the number of parents that come before
 * the given append rel info.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ParentCountPriorToAppendRel</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>appendRelList</name></decl></parameter>, <parameter><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>targetAppendRelInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>targetParentIndex</name> <init>= <expr><name><name>targetAppendRelInfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>parent_ids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appendRelInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>appendRelInfo</argument>, <argument>appendRelList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>curParentIndex</name> <init>= <expr><name><name>appendRelInfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>curParentIndex</name> <operator>&lt;=</operator> <name>targetParentIndex</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>parent_ids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>parent_ids</name></expr></argument>, <argument><expr><name>curParentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>parent_ids</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddUnionSetOperationsToAttributeEquivalenceClass recursively iterates on all the
 * setOperations and adds each corresponding target entry to the given equivalence
 * class.
 *
 * Although the function silently accepts INTERSECT and EXPECT set operations, they are
 * rejected later in the planning. We prefer this behavior to provide better error
 * messages.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddUnionSetOperationsToAttributeEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
												 <name>attributeEquivalenceClass</name></decl></parameter>,
												 <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
												 <parameter><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOperation</name></decl></parameter>,
												 <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableIndexList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableIndexCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractRangeTableIndexWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>setOperation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rangeTableIndexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rangeTableIndexCell</argument>, <argument>rangeTableIndexList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>rangeTableIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>rangeTableIndexCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>varToBeAdded</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>rangeTableIndex</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AddToAttributeEquivalenceClass</name><argument_list>(<argument><expr><name>attributeEquivalenceClass</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>varToBeAdded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * AddRteRelationToAttributeEquivalenceClass adds the given var to the given equivalence
 * class using the rteIdentity provided by the rangeTableEntry. Note that
 * rteIdentities are only assigned to RTE_RELATIONs and this function asserts
 * the input rte to be an RTE_RELATION.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddRteRelationToAttributeEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
										  <name>attrEquivalenceClass</name></decl></parameter>,
										  <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
										  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>varToBeAdded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't consider local tables in the equality on columns */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>relationPartitionKey</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we don't need reference tables in the equality on columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationPartitionKey</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we're only interested in distribution columns */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relationPartitionKey</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name><name>varToBeAdded</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AttributeEquivalenceClassMember</name> <modifier>*</modifier></type><name>attributeEqMember</name> <init>= <expr><call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttributeEquivalenceClassMember</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>attributeEqMember</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>varToBeAdded</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attributeEqMember</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>varToBeAdded</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attributeEqMember</name><operator>-&gt;</operator><name>rteIdentity</name></name> <operator>=</operator> <call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>attributeEqMember</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>attrEquivalenceClass</name><operator>-&gt;</operator><name>equivalentAttributes</name></name> <operator>=</operator>
		<call><name>lappend</name><argument_list>(<argument><expr><name><name>attrEquivalenceClass</name><operator>-&gt;</operator><name>equivalentAttributes</name></name></expr></argument>,
				<argument><expr><name>attributeEqMember</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AttributeClassContainsAttributeClassMember returns true if it the input class member
 * is already exists in the attributeEquivalenceClass. An equality is identified by the
 * varattno and rteIdentity.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AttributeClassContainsAttributeClassMember</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClassMember</name> <modifier>*</modifier></type><name>inputMember</name></decl></parameter>,
										   <parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type>
										   <name>attributeEquivalenceClass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>classCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>classCell</argument>, <argument>attributeEquivalenceClass-&gt;equivalentAttributes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttributeEquivalenceClassMember</name> <modifier>*</modifier></type><name>memberOfClass</name> <init>=
			<expr><operator>(</operator><name>AttributeEquivalenceClassMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>classCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>memberOfClass</name><operator>-&gt;</operator><name>rteIdentity</name></name> <operator>==</operator> <name><name>inputMember</name><operator>-&gt;</operator><name>rteIdentity</name></name> <operator>&amp;&amp;</operator>
			<name><name>memberOfClass</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>inputMember</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddAttributeClassToAttributeClassList checks for certain properties of the
 * input attributeEquivalence before adding it to the attributeEquivalenceList.
 *
 * Firstly, the function skips adding NULL attributeEquivalence to the list.
 * Secondly, since an attribute equivalence class with a single member does
 * not contribute to our purposes, we skip such classed adding to the list.
 * Finally, we don't want to add an equivalence class whose exact equivalent
 * already exists in the list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>AddAttributeClassToAttributeClassList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeEquivalenceList</name></decl></parameter>,
									  <parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>attributeEquivalence</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>attributeEquivalenceCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>attributeEquivalence</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>attributeEquivalenceList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Note that in some cases we allow having equivalentAttributes with zero or
	 * one elements. For the details, see AddToAttributeEquivalenceClass().
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>equivalentAttributes</name> <init>= <expr><name><name>attributeEquivalence</name><operator>-&gt;</operator><name>equivalentAttributes</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>equivalentAttributes</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>attributeEquivalenceList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we don't want to add an attributeEquivalence which already exists */</comment>
	<macro><name>foreach</name><argument_list>(<argument>attributeEquivalenceCell</argument>, <argument>attributeEquivalenceList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>currentAttributeEquivalence</name> <init>=
			<expr><operator>(</operator><name>AttributeEquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>attributeEquivalenceCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>AttributeEquivalencesAreEqual</name><argument_list>(<argument><expr><name>currentAttributeEquivalence</name></expr></argument>,
										  <argument><expr><name>attributeEquivalence</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>attributeEquivalenceList</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>attributeEquivalenceList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>attributeEquivalenceList</name></expr></argument>,
									   <argument><expr><name>attributeEquivalence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>attributeEquivalenceList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *  AttributeEquivalencesAreEqual returns true if both input attribute equivalence
 *  classes contains exactly the same members.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AttributeEquivalencesAreEqual</name><parameter_list>(<parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>firstAttributeEquivalence</name></decl></parameter>,
							  <parameter><decl><type><name>AttributeEquivalenceClass</name> <modifier>*</modifier></type><name>secondAttributeEquivalence</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>firstEquivalenceMemberList</name> <init>=
		<expr><name><name>firstAttributeEquivalence</name><operator>-&gt;</operator><name>equivalentAttributes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>secondEquivalenceMemberList</name> <init>=
		<expr><name><name>secondAttributeEquivalence</name><operator>-&gt;</operator><name>equivalentAttributes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>firstAttributeEquivalenceCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>secondAttributeEquivalenceCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>firstEquivalenceMemberList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(
			<argument><expr><name>secondEquivalenceMemberList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>firstAttributeEquivalenceCell</argument>, <argument>firstEquivalenceMemberList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttributeEquivalenceClassMember</name> <modifier>*</modifier></type><name>firstEqMember</name> <init>=
			<expr><operator>(</operator><name>AttributeEquivalenceClassMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>firstAttributeEquivalenceCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>foundAnEquivalentMember</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>secondAttributeEquivalenceCell</argument>, <argument>secondEquivalenceMemberList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttributeEquivalenceClassMember</name> <modifier>*</modifier></type><name>secondEqMember</name> <init>=
				<expr><operator>(</operator><name>AttributeEquivalenceClassMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(
					<argument><expr><name>secondAttributeEquivalenceCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>firstEqMember</name><operator>-&gt;</operator><name>rteIdentity</name></name> <operator>==</operator> <name><name>secondEqMember</name><operator>-&gt;</operator><name>rteIdentity</name></name> <operator>&amp;&amp;</operator>
				<name><name>firstEqMember</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>secondEqMember</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foundAnEquivalentMember</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* we couldn't find an equivalent member */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundAnEquivalentMember</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsUnionSubquery gets a queryTree and returns true if the query
 * contains
 *      - a subquery with UNION set operation
 *      - no joins above the UNION set operation in the query tree
 *
 * Note that the function allows top level unions being wrapped into aggregations
 * queries and/or simple projection queries that only selects some fields from
 * the lower level queries.
 *
 * If there exists joins before the set operations, the function returns false.
 * Similarly, if the query does not contain any union set operations, the
 * function returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>ContainsUnionSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinTreeTableIndexList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractRangeTableIndexWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>joinTreeTableIndexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>joiningRangeTableCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>joinTreeTableIndexList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* don't allow joins on top of unions */</comment>
	<if_stmt><if>if <condition>(<expr><name>joiningRangeTableCount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* subquery without FROM */</comment>
	<if_stmt><if>if <condition>(<expr><name>joiningRangeTableCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Index</name></type> <name>subqueryRteIndex</name> <init>= <expr><call><name>linitial_int</name><argument_list>(<argument><expr><name>joinTreeTableIndexList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>subqueryRteIndex</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subqueryTree</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>setOperations</name> <init>= <expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>setOperations</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>setOperations</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOperationStatement</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>setOperations</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note that the set operation tree is traversed elsewhere for ensuring
		 * that we only support UNIONs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>setOperationStatement</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_UNION</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>ContainsUnionSubquery</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionKeyForRTEIdentityInQuery finds the partition key var(if exists),
 * in the given original query for the rte that has targetRTEIndex.
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>PartitionKeyForRTEIdentityInQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>targetRTEIndex</name></decl></parameter>,
								  <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>partitionKeyIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQueryContainingRTEIdentity</name> <init>=
		<expr><call><name>FindQueryContainingRTEIdentity</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>targetRTEIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>originalQueryContainingRTEIdentity</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We should always find the query but we have this check for sanity.
		 * This check makes sure that if there is a bug while finding the query,
		 * we don't get a crash etc. and the only downside will be we might be recursively
		 * planning a query that could be pushed down.
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This approach fails to detect when
	 * the top level query might have the column indexes in different order:
	 * explain
	 * SELECT count(*) FROM
	 * (
	 * SELECT user_id,value_2 FROM events_table
	 * UNION
	 * SELECT value_2, user_id FROM (SELECT user_id, value_2, random() FROM events_table) as foo
	 * ) foobar;
	 * So we hit https://github.com/citusdata/citus/issues/5093.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationTargetList</name> <init>= <expr><name><name>originalQueryContainingRTEIdentity</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>targetEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>partitionKeyTargetAttrIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>relationTargetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>targetExpression</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>partitionKeyTargetAttrIndex</name><operator>++</operator></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>skipOuterVars</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>targetEntry</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name>targetExpression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>IsPartitionColumn</name><argument_list>(<argument><expr><name>targetExpression</name></expr></argument>, <argument><expr><name>originalQueryContainingRTEIdentity</name></expr></argument>,
							  <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetColumn</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>targetExpression</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We find the referenced table column to support distribution
			 * columns that are correlated.
			 */</comment>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rteContainingPartitionKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>FindReferencedTableColumn</name><argument_list>(<argument><expr><name>targetExpression</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
									  <argument><expr><name>originalQueryContainingRTEIdentity</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>targetColumn</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>rteContainingPartitionKey</name></expr></argument>,
									  <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rteContainingPartitionKey</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
				<call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name>rteContainingPartitionKey</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>targetRTEIndex</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>partitionKeyIndex</name> <operator>=</operator> <name>partitionKeyTargetAttrIndex</name></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>targetColumn</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindQueryContainingRTEIdentity finds the query/subquery that has an RTE
 * with rteIndex in its rtable.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>FindQueryContainingRTEIdentity</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rteIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FindQueryContainingRteIdentityContext</name> <modifier>*</modifier></type><name>findRteIdentityContext</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FindQueryContainingRteIdentityContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>findRteIdentityContext</name><operator>-&gt;</operator><name>targetRTEIdentity</name></name> <operator>=</operator> <name>rteIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FindQueryContainingRTEIdentityInternal</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><name>findRteIdentityContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>findRteIdentityContext</name><operator>-&gt;</operator><name>query</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindQueryContainingRTEIdentityInternal walks on the given node to find a query
 * which has an RTE that has a given rteIdentity.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FindQueryContainingRTEIdentityInternal</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
									   <parameter><decl><type><name>FindQueryContainingRteIdentityContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parentQuery</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>query</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>FindQueryContainingRTEIdentityInternal</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
							  <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <name>parentQuery</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FindQueryContainingRTEIdentityInternal</name></expr></argument>,
									  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>targetRTEIdentity</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AllRelationsInRestrictionContextColocated determines whether all of the relations in the
 * given relation restrictions list are co-located.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AllRelationsInRestrictionContextColocated</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>initialColocationId</name> <init>= <expr><name>INVALID_COLOCATION_ID</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check whether all relations exists in the main restriction list */</comment>
	<macro><name>foreach_ptr</name><argument_list>(<argument>relationRestriction</argument>, <argument>restrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we got to this point, it means there are multiple distributed
			 * relations and at least one of them is append-distributed. Since
			 * we do not consider append-distributed tables to be co-located,
			 * we can immediately return false.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>initialColocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>initialColocationId</name> <operator>=</operator> <name>colocationId</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>colocationId</name> <operator>!=</operator> <name>initialColocationId</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationIdList returns list of unique relation ids in query tree.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>DistributedRelationIdList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tableEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractRangeTableRelationWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableEntryList</name> <init>= <expr><call><name>TableEntryList</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tableEntryCell</argument>, <argument>tableEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><operator>(</operator><name>TableEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tableEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>tableEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>relationIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FilterPlannerRestrictionForQuery gets a planner restriction context and
 * set of rte identities. It returns the restrictions that that appear
 * in the queryRteIdentities and returns a newly allocated
 * PlannerRestrictionContext. The function also sets all the other fields of
 * the PlannerRestrictionContext with respect to the filtered restrictions.
 */</comment>
<function><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
<name>FilterPlannerRestrictionForQuery</name><parameter_list>(<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>,
								 <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type> <name>queryRteIdentities</name> <init>= <expr><call><name>QueryRteIdentities</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>relationRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinRestrictionContext</name> <modifier>*</modifier></type><name>joinRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>filteredRelationRestrictionContext</name> <init>=
		<expr><call><name>FilterRelationRestrictionContext</name><argument_list>(<argument><expr><name>relationRestrictionContext</name></expr></argument>, <argument><expr><name>queryRteIdentities</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>JoinRestrictionContext</name> <modifier>*</modifier></type><name>filtererdJoinRestrictionContext</name> <init>=
		<expr><call><name>FilterJoinRestrictionContext</name><argument_list>(<argument><expr><name>joinRestrictionContext</name></expr></argument>, <argument><expr><name>queryRteIdentities</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* allocate the filtered planner restriction context and set all the fields */</comment>
	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>filteredPlannerRestrictionContext</name> <init>= <expr><call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>filteredPlannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FastPathRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>filteredPlannerRestrictionContext</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator>
		<name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>memoryContext</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>totalRelationCount</name> <init>= <expr><call><name>UniqueRelationCount</name><argument_list>(
		<argument><expr><name>filteredRelationRestrictionContext</name></expr></argument>, <argument><expr><name>ANY_CITUS_TABLE_TYPE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>referenceRelationCount</name> <init>= <expr><call><name>UniqueRelationCount</name><argument_list>(
		<argument><expr><name>filteredRelationRestrictionContext</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>filteredRelationRestrictionContext</name><operator>-&gt;</operator><name>allReferenceTables</name></name> <operator>=</operator>
		<operator>(</operator><name>totalRelationCount</name> <operator>==</operator> <name>referenceRelationCount</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* finally set the relation and join restriction contexts */</comment>
	<expr_stmt><expr><name><name>filteredPlannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name> <operator>=</operator>
		<name>filteredRelationRestrictionContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filteredPlannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name> <operator>=</operator>
		<name>filtererdJoinRestrictionContext</name></expr>;</expr_stmt>

	<return>return <expr><name>filteredPlannerRestrictionContext</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRestrictInfoListForRelation gets a range table entry and planner
 * restriction context. The function returns a list of expressions that
 * appear in the restriction context for only the given relation. And,
 * all the varnos are set to 1.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetRestrictInfoListForRelation</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTblEntry</name></decl></parameter>,
							   <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>=
		<expr><call><name>RelationRestrictionForRelation</name><argument_list>(<argument><expr><name>rangeTblEntry</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relationRestriction</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relOptInfo</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relOptInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>baseRestrictInfo</name> <init>= <expr><name><name>relOptInfo</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>joinConditionIsOnFalse</name> <init>= <expr><call><name>JoinConditionIsOnFalse</name><argument_list>(<argument><expr><name><name>relOptInfo</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>joinConditionIsOnFalse</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* found WHERE false, no need  to continue, we just return a false clause */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>value</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>falseClause</name> <init>= <expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>falseClause</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>


	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictExprList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>restrictInfo</argument>, <argument>baseRestrictInfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>restrictionClause</name> <init>= <expr><name><name>restrictInfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * we cannot process some restriction clauses because they are not
		 * safe to recursively plan.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>restrictionClause</name></expr></argument>,
										  <argument><expr><name>IsNotSafeRestrictionToRecursivelyPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the restriction involves multiple tables, we cannot add it to
		 * input relation's expression list.
		 */</comment>
		<decl_stmt><decl><type><name>Relids</name></type> <name>varnos</name> <init>= <expr><call><name>pull_varnos_compat</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>plannerInfo</name></name></expr></argument>,
										   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>restrictionClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>varnos</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We're going to add this restriction expression to a subquery
		 * which consists of only one relation in its jointree. Thus,
		 * simply set the varnos accordingly.
		 */</comment>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>copyOfRestrictClause</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>restrictionClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>varClauses</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>copyOfRestrictClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>column</argument>, <argument>varClauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>SINGLE_RTE_INDEX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <name>SINGLE_RTE_INDEX</name></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name>restrictExprList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>restrictExprList</name></expr></argument>, <argument><expr><name>copyOfRestrictClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>restrictExprList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationRestrictionForRelation gets the relation restriction for the given
 * range table entry.
 */</comment>
<function><type><name>RelationRestriction</name> <modifier>*</modifier></type>
<name>RelationRestrictionForRelation</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
							   <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rteIdentity</name> <init>= <expr><call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>relationRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type> <name>queryRteIdentities</name> <init>= <expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>rteIdentity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>filteredRelationRestrictionContext</name> <init>=
		<expr><call><name>FilterRelationRestrictionContext</name><argument_list>(<argument><expr><name>relationRestrictionContext</name></expr></argument>, <argument><expr><name>queryRteIdentities</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>filteredRelationRestrictionList</name> <init>=
		<expr><name><name>filteredRelationRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionList</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>filteredRelationRestrictionList</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>=
		<expr><operator>(</operator><name>RelationRestriction</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>filteredRelationRestrictionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>relationRestriction</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsNotSafeRestrictionToRecursivelyPlan returns true if the given node
 * is not a safe restriction to be recursivelly planned.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsNotSafeRestrictionToRecursivelyPlan</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
																			<argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FilterRelationRestrictionContext gets a relation restriction context and
 * set of rte identities. It returns the relation restrictions that that appear
 * in the queryRteIdentities and returns a newly allocated
 * RelationRestrictionContext.
 */</comment>
<function><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type>
<name>FilterRelationRestrictionContext</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>relationRestrictionContext</name></decl></parameter>,
								 <parameter><decl><type><name>Relids</name></type> <name>queryRteIdentities</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>filteredRestrictionContext</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationRestrictionCell</argument>, <argument>relationRestrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>=
			<expr><operator>(</operator><name>RelationRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>relationRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>rteIdentity</name> <init>= <expr><call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>rte</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rteIdentity</name></expr></argument>, <argument><expr><name>queryRteIdentities</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>filteredRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionList</name></name> <operator>=</operator>
				<call><name>lappend</name><argument_list>(<argument><expr><name><name>filteredRestrictionContext</name><operator>-&gt;</operator><name>relationRestrictionList</name></name></expr></argument>,
						<argument><expr><name>relationRestriction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>filteredRestrictionContext</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FilterJoinRestrictionContext gets a join restriction context and
 * set of rte identities. It returns the join restrictions that that appear
 * in the queryRteIdentities and returns a newly allocated
 * JoinRestrictionContext.
 *
 * Note that the join restriction is added to the return context as soon as
 * any range table entry that appear in the join belongs to queryRteIdentities.
 */</comment>
<function><type><specifier>static</specifier> <name>JoinRestrictionContext</name> <modifier>*</modifier></type>
<name>FilterJoinRestrictionContext</name><parameter_list>(<parameter><decl><type><name>JoinRestrictionContext</name> <modifier>*</modifier></type><name>joinRestrictionContext</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type>
							 <name>queryRteIdentities</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinRestrictionContext</name> <modifier>*</modifier></type><name>filtererdJoinRestrictionContext</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JoinRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>joinRestrictionCell</argument>, <argument>joinRestrictionContext-&gt;joinRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinRestriction</name> <modifier>*</modifier></type><name>joinRestriction</name> <init>=
			<expr><operator>(</operator><name>JoinRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>joinRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>rangeTableEntries</name> <init>=
			<expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>plannerInfo</name><operator>-&gt;</operator><name>simple_rte_array</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rangeTableArrayLength</name> <init>= <expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>plannerInfo</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RangeTableArrayContainsAnyRTEIdentities</name><argument_list>(<argument><expr><name>rangeTableEntries</name></expr></argument>,
													<argument><expr><name>rangeTableArrayLength</name></expr></argument>,
													<argument><expr><name>queryRteIdentities</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>filtererdJoinRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(
				<argument><expr><name><name>filtererdJoinRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionList</name></name></expr></argument>,
				<argument><expr><name>joinRestriction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * No need to re calculate has join fields as we are still operating on
	 * the same query and as these values are calculated per-query basis.
	 */</comment>
	<expr_stmt><expr><name><name>filtererdJoinRestrictionContext</name><operator>-&gt;</operator><name>hasSemiJoin</name></name> <operator>=</operator> <name><name>joinRestrictionContext</name><operator>-&gt;</operator><name>hasSemiJoin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>filtererdJoinRestrictionContext</name><operator>-&gt;</operator><name>hasOuterJoin</name></name> <operator>=</operator> <name><name>joinRestrictionContext</name><operator>-&gt;</operator><name>hasOuterJoin</name></name></expr>;</expr_stmt>

	<return>return <expr><name>filtererdJoinRestrictionContext</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RangeTableArrayContainsAnyRTEIdentities returns true if any of the range table entries
 * int rangeTableEntries array is an range table relation specified in queryRteIdentities.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RangeTableArrayContainsAnyRTEIdentities</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>rangeTableEntries</name></decl></parameter>, <parameter><decl><type><name>int</name></type>
										<name>rangeTableArrayLength</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>queryRteIdentities</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* simple_rte_array starts from 1, see plannerInfo struct */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>rteIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>rteIndex</name> <operator>&lt;</operator> <name>rangeTableArrayLength</name></expr>;</condition> <incr><expr><operator>++</operator><name>rteIndex</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name><name>rangeTableEntries</name><index>[<expr><name>rteIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableRelationList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rteRelationCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get list of all RTE_RELATIONs in the given range table entry
		 * (i.e.,rangeTableEntry could be a subquery where we're interested
		 * in relations).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExtractRangeTableRelationWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>rangeTableRelationList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExtractRangeTableRelationWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rangeTableEntry</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>rangeTableRelationList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* we currently do not accept any other RTE types here */</comment>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>rteRelationCell</argument>, <argument>rangeTableRelationList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rteRelation</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rteRelationCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rteRelation</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>int</name></type> <name>rteIdentity</name> <init>= <expr><call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name>rteRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rteIdentity</name></expr></argument>, <argument><expr><name>queryRteIdentities</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QueryRteIdentities gets a queryTree, find get all the rte identities assigned by
 * us.
 */</comment>
<function><type><specifier>static</specifier> <name>Relids</name></type>
<name>QueryRteIdentities</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type> <name>queryRteIdentities</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* extract range table entries for simple relations only */</comment>
	<expr_stmt><expr><call><name>ExtractRangeTableRelationWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>queryTree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we're only interested in relations */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>rteIdentity</name> <init>= <expr><call><name>GetRTEIdentity</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>queryRteIdentities</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>queryRteIdentities</name></expr></argument>, <argument><expr><name>rteIdentity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>queryRteIdentities</name></expr>;</return>
</block_content>}</block></function>
</unit>
