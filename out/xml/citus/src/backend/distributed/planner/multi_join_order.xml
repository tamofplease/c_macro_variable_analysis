<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/planner/multi_join_order.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * multi_join_order.c
 *
 * Routines for constructing the join order list using a rule-based approach.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/* Config variables managed via guc.c */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>LogMultiJoinOrder</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* print join order as a debugging aid */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableSingleHashRepartitioning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Function pointer type definition for join rule evaluation functions */</comment>
<typedef>typedef <function_decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>RuleEvalFunction</name>) <parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>currentJoinNode</name></decl></parameter>,
											<parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>,
											<parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>RuleNameArray</name><index>[<expr><name>JOIN_RULE_LAST</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt> <comment type="block">/* ordered join rule names */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>RuleEvalFunction</name></type> <name><name>RuleEvalFunctionArray</name><index>[<expr><name>JOIN_RULE_LAST</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt> <comment type="block">/* join rules */</comment>


<comment type="block">/* Local functions forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>JoinExprListWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>joinList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExtractLeftMostRangeTableIndex</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rangeTableIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>JoinOrderForTable</name><parameter_list>(<parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>firstTable</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableEntryList</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>BestJoinOrder</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>candidateJoinOrders</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FewestOfJoinRuleType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>candidateJoinOrders</name></decl></parameter>, <parameter><decl><type><name>JoinRuleType</name></type> <name>ruleType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>JoinRuleTypeCount</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrder</name></decl></parameter>, <parameter><decl><type><name>JoinRuleType</name></type> <name>ruleTypeToCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>LatestLargeDataTransfer</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>candidateJoinOrders</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PrintJoinOrderList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrder</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>LargeDataTransferLocation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrder</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>TableEntryListDifference</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>lhsTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rhsTableList</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Local functions forward declarations for join evaluations */</comment>
<function_decl><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type> <name>EvaluateJoinRules</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinedTableList</name></decl></parameter>,
										 <parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>currentJoinNode</name></decl></parameter>,
										 <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>RangeTableIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RuleEvalFunction</name></type> <name>JoinRuleEvalFunction</name><parameter_list>(<parameter><decl><type><name>JoinRuleType</name></type> <name>ruleType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>JoinRuleName</name><parameter_list>(<parameter><decl><type><name>JoinRuleType</name></type> <name>ruleType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type> <name>ReferenceJoin</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinNode</name></decl></parameter>, <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type> <name>CartesianProductReferenceJoin</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinNode</name></decl></parameter>,
													 <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
													 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>,
													 <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type> <name>LocalJoin</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinNode</name></decl></parameter>, <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>JoinOnColumns</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>currentPartitionColumnList</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>candidatePartitionColumn</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type> <name>SinglePartitionJoin</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinNode</name></decl></parameter>,
										   <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
										   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>,
										   <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type> <name>DualPartitionJoin</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinNode</name></decl></parameter>,
										 <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>,
										 <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type> <name>CartesianProduct</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinNode</name></decl></parameter>,
										<parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>,
										<parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type> <name>MakeJoinOrderNode</name><parameter_list>(<parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>tableEntry</name></decl></parameter>,
										 <parameter><decl><type><name>JoinRuleType</name></type> <name>joinRuleType</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>partitionMethod</name></decl></parameter>,
										 <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>anchorTable</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * JoinExprList flattens the JoinExpr nodes in the FROM expression and translate implicit
 * joins to inner joins. This function does not consider (right-)nested joins.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>JoinExprList</name><parameter_list>(<parameter><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>fromExpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fromList</name> <init>= <expr><name><name>fromExpr</name><operator>-&gt;</operator><name>fromlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>fromCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>fromCell</argument>, <argument>fromList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>nextNode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fromCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>joinList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* multiple nodes in from clause, add an explicit join between them */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>nextRangeTableIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* find the left most range table in this node */</comment>
			<expr_stmt><expr><call><name>ExtractLeftMostRangeTableIndex</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fromExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextRangeTableIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>nextRangeTableRef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>nextRangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>nextRangeTableIndex</name></expr>;</expr_stmt>

			<comment type="block">/* join the previous node with nextRangeTableRef */</comment>
			<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>newJoinExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>newJoinExpr</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newJoinExpr</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>nextRangeTableRef</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newJoinExpr</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>joinList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>joinList</name></expr></argument>, <argument><expr><name>newJoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>JoinExprListWalker</name><argument_list>(<argument><expr><name>nextNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>joinList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>joinList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinExprListWalker the JoinExpr nodes in a join tree in the order in which joins are
 * to be executed. If there are no joins then no elements are added to joinList.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>JoinExprListWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>joinList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>walkerResult</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>walkerResult</name> <operator>=</operator> <call><name>JoinExprListWalker</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>joinList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>joinList</name><operator>)</operator> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>joinList</name></expr></argument>, <argument><expr><name>joinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>walkerResult</name> <operator>=</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExprListWalker</name></expr></argument>,
											  <argument><expr><name>joinList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>walkerResult</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractLeftMostRangeTableIndex extracts the range table index of the left-most
 * leaf in a join tree.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExtractLeftMostRangeTableIndex</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rangeTableIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>walkerResult</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>walkerResult</name> <operator>=</operator> <call><name>ExtractLeftMostRangeTableIndex</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>rangeTableIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>rangeTableIndex</name> <operator>=</operator> <name><name>rangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>walkerResult</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>walkerResult</name> <operator>=</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ExtractLeftMostRangeTableIndex</name></expr></argument>,
											  <argument><expr><name>rangeTableIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>walkerResult</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinOnColumns determines whether two columns are joined by a given join clause list.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>JoinOnColumns</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>currentPartitionColumnList</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>candidateColumn</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>candidateColumn</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>currentPartitionColumnList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * LocalJoin can only be happening if we have both a current column and a target
		 * column, otherwise we are not joining two local tables
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>currentColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>currentColumn</argument>, <argument>currentPartitionColumnList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>joinClause</argument>, <argument>joinClauseList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NodeIsEqualsOpExpr</name><argument_list>(<argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>joinClauseOpExpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>leftColumn</name> <init>= <expr><call><name>LeftColumnOrNULL</name><argument_list>(<argument><expr><name>joinClauseOpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>rightColumn</name> <init>= <expr><call><name>RightColumnOrNULL</name><argument_list>(<argument><expr><name>joinClauseOpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Check if both join columns and both partition key columns match, since the
			 * current and candidate column's can't be NULL we know they won't match if either
			 * of the columns resolved to NULL above.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>leftColumn</name></expr></argument>, <argument><expr><name>currentColumn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name>rightColumn</name></expr></argument>, <argument><expr><name>candidateColumn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>leftColumn</name></expr></argument>, <argument><expr><name>candidateColumn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name>rightColumn</name></expr></argument>, <argument><expr><name>currentColumn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeIsEqualsOpExpr checks if the node is an OpExpr, where the operator
 * matches OperatorImplementsEquality.
 */</comment>
<function><type><name>bool</name></type>
<name>NodeIsEqualsOpExpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>opExpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>OperatorImplementsEquality</name><argument_list>(<argument><expr><name><name>opExpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinOrderList calculates the best join order and join rules that apply given
 * the list of tables and join clauses. First, the function generates a set of
 * candidate join orders, each with a different table as its first table. Then,
 * the function chooses among these candidates the join order that transfers the
 * least amount of data across the network, and returns this join order.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>JoinOrderList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableEntryList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>candidateJoinOrderList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tableEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tableEntryCell</argument>, <argument>tableEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>startingTable</name> <init>= <expr><operator>(</operator><name>TableEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tableEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* each candidate join order starts with a different table */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>candidateJoinOrder</name> <init>= <expr><call><name>JoinOrderForTable</name><argument_list>(<argument><expr><name>startingTable</name></expr></argument>, <argument><expr><name>tableEntryList</name></expr></argument>,
													 <argument><expr><name>joinClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>candidateJoinOrder</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>candidateJoinOrderList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>candidateJoinOrderList</name></expr></argument>, <argument><expr><name>candidateJoinOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>candidateJoinOrderList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there are no plans that we can create, time to error */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"complex joins are only supported when all distributed "</literal>
							   <literal type="string">"tables are joined on their distribution columns with "</literal>
							   <literal type="string">"equal operator"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>bestJoinOrder</name> <init>= <expr><call><name>BestJoinOrder</name><argument_list>(<argument><expr><name>candidateJoinOrderList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if logging is enabled, print join order */</comment>
	<if_stmt><if>if <condition>(<expr><name>LogMultiJoinOrder</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PrintJoinOrderList</name><argument_list>(<argument><expr><name>bestJoinOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>bestJoinOrder</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinOrderForTable creates a join order whose first element is the given first
 * table. To determine each subsequent element in the join order, the function
 * then chooses the table that has the lowest ranking join rule, and with which
 * it can join the table to the previous table in the join order. The function
 * repeats this until it determines all elements in the join order list, and
 * returns this list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>JoinOrderForTable</name><parameter_list>(<parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>firstTable</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableEntryList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinRuleType</name></type> <name>firstJoinRule</name> <init>= <expr><name>JOIN_RULE_INVALID_FIRST</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>joinedTableCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>totalTableCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create join node for the first table */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>firstRelationId</name> <init>= <expr><name><name>firstTable</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>firstTableId</name> <init>= <expr><name><name>firstTable</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>firstPartitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>firstRelationId</name></expr></argument>, <argument><expr><name>firstTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>firstPartitionMethod</name> <init>= <expr><call><name>PartitionMethod</name><argument_list>(<argument><expr><name>firstRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>firstJoinNode</name> <init>= <expr><call><name>MakeJoinOrderNode</name><argument_list>(<argument><expr><name>firstTable</name></expr></argument>, <argument><expr><name>firstJoinRule</name></expr></argument>,
													 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>firstPartitionColumn</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>firstPartitionMethod</name></expr></argument>,
													 <argument><expr><name>firstTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* add first node to the join order */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrderList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>firstJoinNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinedTableList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>firstTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>currentJoinNode</name> <init>= <expr><name>firstJoinNode</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* loop until we join all remaining tables */</comment>
	<while>while <condition>(<expr><name>joinedTableCount</name> <operator>&lt;</operator> <name>totalTableCount</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>pendingTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>nextJoinNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinRuleType</name></type> <name>nextJoinRuleType</name> <init>= <expr><name>JOIN_RULE_LAST</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pendingTableList</name> <init>= <expr><call><name>TableEntryListDifference</name><argument_list>(<argument><expr><name>tableEntryList</name></expr></argument>,
														  <argument><expr><name>joinedTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Iterate over all pending tables, and find the next best table to
		 * join. The best table is the one whose join rule requires the least
		 * amount of data transfer.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>pendingTableCell</argument>, <argument>pendingTableList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>pendingTable</name> <init>= <expr><operator>(</operator><name>TableEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>pendingTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>JoinType</name></type> <name>joinType</name> <init>= <expr><name>JOIN_INNER</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* evaluate all join rules for this pending table */</comment>
			<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>pendingJoinNode</name> <init>= <expr><call><name>EvaluateJoinRules</name><argument_list>(<argument><expr><name>joinedTableList</name></expr></argument>,
															   <argument><expr><name>currentJoinNode</name></expr></argument>,
															   <argument><expr><name>pendingTable</name></expr></argument>,
															   <argument><expr><name>joinClauseList</name></expr></argument>, <argument><expr><name>joinType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>pendingJoinNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no join order could be generated, we try our next pending table */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* if this rule is better than previous ones, keep it */</comment>
			<decl_stmt><decl><type><name>JoinRuleType</name></type> <name>pendingJoinRuleType</name> <init>= <expr><name><name>pendingJoinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>pendingJoinRuleType</name> <operator>&lt;</operator> <name>nextJoinRuleType</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nextJoinNode</name> <operator>=</operator> <name>pendingJoinNode</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nextJoinRuleType</name> <operator>=</operator> <name>pendingJoinRuleType</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>nextJoinNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * There is no next join node found, this will repeat indefinitely hence we
			 * bail and let JoinOrderList try a new initial table
			 */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nextJoinNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>nextJoinedTable</name> <init>= <expr><name><name>nextJoinNode</name><operator>-&gt;</operator><name>tableEntry</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* add next node to the join order */</comment>
		<expr_stmt><expr><name>joinOrderList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>joinOrderList</name></expr></argument>, <argument><expr><name>nextJoinNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>joinedTableList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>joinedTableList</name></expr></argument>, <argument><expr><name>nextJoinedTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>currentJoinNode</name> <operator>=</operator> <name>nextJoinNode</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>joinedTableCount</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>joinOrderList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BestJoinOrder takes in a list of candidate join orders, and determines the
 * best join order among these candidates. The function uses two heuristics for
 * this. First, the function chooses join orders that have the fewest number of
 * join operators that cause large data transfers. Second, the function chooses
 * join orders where large data transfers occur later in the execution.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>BestJoinOrder</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>candidateJoinOrders</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>highestValidIndex</name> <init>= <expr><name>JOIN_RULE_LAST</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name> <name>candidateCount</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We start with the highest ranking rule type (cartesian product), and walk
	 * over these rules in reverse order. For each rule type, we then keep join
	 * orders that only contain the fewest number of join rules of that type.
	 *
	 * For example, the algorithm chooses join orders like the following:
	 * (a) The algorithm prefers join orders with 2 cartesian products (CP) to
	 * those that have 3 or more, if there isn't a join order with fewer CPs.
	 * (b) Assuming that all join orders have the same number of CPs, the
	 * algorithm prefers join orders with 2 dual partitions (DP) to those that
	 * have 3 or more, if there isn't a join order with fewer DPs; and so
	 * forth.
	 */</comment>
	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>ruleTypeIndex</name> <init>= <expr><name>highestValidIndex</name></expr></init></decl>;</init> <condition><expr><name>ruleTypeIndex</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>ruleTypeIndex</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinRuleType</name></type> <name>ruleType</name> <init>= <expr><operator>(</operator><name>JoinRuleType</name><operator>)</operator> <name>ruleTypeIndex</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>candidateJoinOrders</name> <operator>=</operator> <call><name>FewestOfJoinRuleType</name><argument_list>(<argument><expr><name>candidateJoinOrders</name></expr></argument>, <argument><expr><name>ruleType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If there is a tie, we pick candidate join orders where large data
	 * transfers happen at later stages of query execution. This results in more
	 * data being filtered via joins, selections, and projections earlier on.
	 */</comment>
	<expr_stmt><expr><name>candidateJoinOrders</name> <operator>=</operator> <call><name>LatestLargeDataTransfer</name><argument_list>(<argument><expr><name>candidateJoinOrders</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we should have at least one join order left after optimizations */</comment>
	<expr_stmt><expr><name>candidateCount</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>candidateJoinOrders</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>candidateCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there still is a tie, we pick the join order whose relation appeared
	 * earliest in the query's range table entry list.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>bestJoinOrder</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>candidateJoinOrders</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>bestJoinOrder</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FewestOfJoinRuleType finds join orders that have the fewest number of times
 * the given join rule occurs in the candidate join orders, and filters all
 * other join orders. For example, if four candidate join orders have a join
 * rule appearing 3, 5, 3, and 6 times, only two join orders that have the join
 * rule appearing 3 times will be returned.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FewestOfJoinRuleType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>candidateJoinOrders</name></decl></parameter>, <parameter><decl><type><name>JoinRuleType</name></type> <name>ruleType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fewestJoinOrders</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>fewestRuleCount</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinOrderCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>joinOrderCell</argument>, <argument>candidateJoinOrders</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrder</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>joinOrderCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>ruleTypeCount</name> <init>= <expr><call><name>JoinRuleTypeCount</name><argument_list>(<argument><expr><name>joinOrder</name></expr></argument>, <argument><expr><name>ruleType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ruleTypeCount</name> <operator>==</operator> <name>fewestRuleCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fewestJoinOrders</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fewestJoinOrders</name></expr></argument>, <argument><expr><name>joinOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ruleTypeCount</name> <operator>&lt;</operator> <name>fewestRuleCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fewestJoinOrders</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>joinOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fewestRuleCount</name> <operator>=</operator> <name>ruleTypeCount</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>fewestJoinOrders</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Counts the number of times the given join rule occurs in the join order. */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>JoinRuleTypeCount</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrder</name></decl></parameter>, <parameter><decl><type><name>JoinRuleType</name></type> <name>ruleTypeToCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>ruleTypeCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinOrderNodeCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>joinOrderNodeCell</argument>, <argument>joinOrder</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinOrderNode</name> <init>= <expr><operator>(</operator><name>JoinOrderNode</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>joinOrderNodeCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>JoinRuleType</name></type> <name>ruleType</name> <init>= <expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>joinRuleType</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>ruleType</name> <operator>==</operator> <name>ruleTypeToCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ruleTypeCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>ruleTypeCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LatestLargeDataTransfer finds and returns join orders where a large data
 * transfer join rule occurs as late as possible in the join order. Late large
 * data transfers result in more data being filtered before data gets shuffled
 * in the network.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>LatestLargeDataTransfer</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>candidateJoinOrders</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>latestJoinOrders</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>latestJoinLocation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinOrderCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>joinOrderCell</argument>, <argument>candidateJoinOrders</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrder</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>joinOrderCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>joinRuleLocation</name> <init>= <expr><call><name>LargeDataTransferLocation</name><argument_list>(<argument><expr><name>joinOrder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>joinRuleLocation</name> <operator>==</operator> <name>latestJoinLocation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>latestJoinOrders</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>latestJoinOrders</name></expr></argument>, <argument><expr><name>joinOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>joinRuleLocation</name> <operator>&gt;</operator> <name>latestJoinLocation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>latestJoinOrders</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>joinOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>latestJoinLocation</name> <operator>=</operator> <name>joinRuleLocation</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>latestJoinOrders</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LargeDataTransferLocation finds the first location of a large data transfer
 * join rule, and returns that location. If the join order does not have any
 * large data transfer rules, the function returns one location past the end of
 * the join order list.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>LargeDataTransferLocation</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>joinRuleLocation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinOrderNodeCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>joinOrderNodeCell</argument>, <argument>joinOrder</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinOrderNode</name> <init>= <expr><operator>(</operator><name>JoinOrderNode</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>joinOrderNodeCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinRuleType</name></type> <name>joinRuleType</name> <init>= <expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>joinRuleType</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we consider the following join rules to cause large data transfers */</comment>
		<if_stmt><if>if <condition>(<expr><name>joinRuleType</name> <operator>==</operator> <name>SINGLE_HASH_PARTITION_JOIN</name> <operator>||</operator>
			<name>joinRuleType</name> <operator>==</operator> <name>SINGLE_RANGE_PARTITION_JOIN</name> <operator>||</operator>
			<name>joinRuleType</name> <operator>==</operator> <name>DUAL_PARTITION_JOIN</name> <operator>||</operator>
			<name>joinRuleType</name> <operator>==</operator> <name>CARTESIAN_PRODUCT</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>joinRuleLocation</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>joinRuleLocation</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Prints the join order list and join rules for debugging purposes. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintJoinOrderList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinOrder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>printBuffer</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinOrderNodeCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>firstJoinNode</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>joinOrderNodeCell</argument>, <argument>joinOrder</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinOrderNode</name> <init>= <expr><operator>(</operator><name>JoinOrderNode</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>joinOrderNodeCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>tableEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>firstJoinNode</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>printBuffer</name></expr></argument>, <argument><expr><literal type="string">"[ \"%s\" ]"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>firstJoinNode</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>JoinRuleType</name></type> <name>ruleType</name> <init>= <expr><operator>(</operator><name>JoinRuleType</name><operator>)</operator> <name><name>joinOrderNode</name><operator>-&gt;</operator><name>joinRuleType</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ruleName</name> <init>= <expr><call><name>JoinRuleName</name><argument_list>(<argument><expr><name>ruleType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>printBuffer</name></expr></argument>, <argument><expr><literal type="string">"[ %s "</literal></expr></argument>, <argument><expr><name>ruleName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>printBuffer</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" ]"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"join order: %s"</literal></expr></argument>,
						 <argument><expr><name><name>printBuffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TableEntryListDifference returns a list containing table entries that are in
 * the left-hand side table list, but not in the right-hand side table list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>TableEntryListDifference</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>lhsTableList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rhsTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableListDifference</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lhsTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lhsTableCell</argument>, <argument>lhsTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>lhsTableEntry</name> <init>= <expr><operator>(</operator><name>TableEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lhsTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rhsTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>lhsTableEntryExists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>rhsTableCell</argument>, <argument>rhsTableList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>rhsTableEntry</name> <init>= <expr><operator>(</operator><name>TableEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rhsTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lhsTableEntry</name><operator>-&gt;</operator><name>relationId</name></name> <operator>==</operator> <name><name>rhsTableEntry</name><operator>-&gt;</operator><name>relationId</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>lhsTableEntry</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>==</operator> <name><name>rhsTableEntry</name><operator>-&gt;</operator><name>rangeTableId</name></name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>lhsTableEntryExists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lhsTableEntryExists</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tableListDifference</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableListDifference</name></expr></argument>, <argument><expr><name>lhsTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>tableListDifference</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EvaluateJoinRules takes in a list of already joined tables and a candidate
 * next table, evaluates different join rules between the two tables, and finds
 * the best join rule that applies. The function returns the applicable join
 * order node which includes the join rule and the partition information.
 */</comment>
<function><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type>
<name>EvaluateJoinRules</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinedTableList</name></decl></parameter>, <parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>currentJoinNode</name></decl></parameter>,
				  <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>,
				  <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>nextJoinNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>lowestValidIndex</name> <init>= <expr><name>JOIN_RULE_INVALID_FIRST</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>highestValidIndex</name> <init>= <expr><name>JOIN_RULE_LAST</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We first find all applicable join clauses between already joined tables
	 * and the candidate table.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinedTableIdList</name> <init>= <expr><call><name>RangeTableIdList</name><argument_list>(<argument><expr><name>joinedTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>candidateTableId</name> <init>= <expr><name><name>candidateTable</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name> <init>= <expr><call><name>ApplicableJoinClauses</name><argument_list>(<argument><expr><name>joinedTableIdList</name></expr></argument>,
														<argument><expr><name>candidateTableId</name></expr></argument>,
														<argument><expr><name>joinClauseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we then evaluate all join rules in order */</comment>
	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>ruleIndex</name> <init>= <expr><name>lowestValidIndex</name></expr></init></decl>;</init> <condition><expr><name>ruleIndex</name> <operator>&lt;=</operator> <name>highestValidIndex</name></expr>;</condition> <incr><expr><name>ruleIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinRuleType</name></type> <name>ruleType</name> <init>= <expr><operator>(</operator><name>JoinRuleType</name><operator>)</operator> <name>ruleIndex</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RuleEvalFunction</name></type> <name>ruleEvalFunction</name> <init>= <expr><call><name>JoinRuleEvalFunction</name><argument_list>(<argument><expr><name>ruleType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextJoinNode</name> <operator>=</operator> <call>(<modifier>*</modifier><name>ruleEvalFunction</name>)<argument_list>(<argument><expr><name>currentJoinNode</name></expr></argument>,
										   <argument><expr><name>candidateTable</name></expr></argument>,
										   <argument><expr><name>applicableJoinClauses</name></expr></argument>,
										   <argument><expr><name>joinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* break after finding the first join rule that applies */</comment>
		<if_stmt><if>if <condition>(<expr><name>nextJoinNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>nextJoinNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nextJoinNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nextJoinNode</name><operator>-&gt;</operator><name>joinType</name></name> <operator>=</operator> <name>joinType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nextJoinNode</name><operator>-&gt;</operator><name>joinClauseList</name></name> <operator>=</operator> <name>applicableJoinClauses</name></expr>;</expr_stmt>
	<return>return <expr><name>nextJoinNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Extracts range table identifiers from the given table list, and returns them. */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>RangeTableIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>tableCell</argument>, <argument>tableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>tableEntry</name> <init>= <expr><operator>(</operator><name>TableEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>uint32</name></type> <name>rangeTableId</name> <init>= <expr><name><name>tableEntry</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>rangeTableIdList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>rangeTableIdList</name></expr></argument>, <argument><expr><name>rangeTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>rangeTableIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinRuleEvalFunction returns a function pointer for the rule evaluation
 * function; this rule evaluation function corresponds to the given rule type.
 * The function also initializes the rule evaluation function array in a static
 * code block, if the array has not been initialized.
 */</comment>
<function><type><specifier>static</specifier> <name>RuleEvalFunction</name></type>
<name>JoinRuleEvalFunction</name><parameter_list>(<parameter><decl><type><name>JoinRuleType</name></type> <name>ruleType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ruleEvalFunctionsInitialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ruleEvalFunctionsInitialized</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>RuleEvalFunctionArray</name><index>[<expr><name>REFERENCE_JOIN</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>ReferenceJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleEvalFunctionArray</name><index>[<expr><name>LOCAL_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>LocalJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleEvalFunctionArray</name><index>[<expr><name>SINGLE_RANGE_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>SinglePartitionJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleEvalFunctionArray</name><index>[<expr><name>SINGLE_HASH_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>SinglePartitionJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleEvalFunctionArray</name><index>[<expr><name>DUAL_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>DualPartitionJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleEvalFunctionArray</name><index>[<expr><name>CARTESIAN_PRODUCT_REFERENCE_JOIN</name></expr>]</index></name> <operator>=</operator>
			<operator>&amp;</operator><name>CartesianProductReferenceJoin</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleEvalFunctionArray</name><index>[<expr><name>CARTESIAN_PRODUCT</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>CartesianProduct</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ruleEvalFunctionsInitialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RuleEvalFunction</name></type> <name>ruleEvalFunction</name> <init>= <expr><name><name>RuleEvalFunctionArray</name><index>[<expr><name>ruleType</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ruleEvalFunction</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ruleEvalFunction</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Returns a string name for the given join rule type. */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>JoinRuleName</name><parameter_list>(<parameter><decl><type><name>JoinRuleType</name></type> <name>ruleType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ruleNamesInitialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ruleNamesInitialized</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use strdup() to be independent of memory contexts */</comment>
		<expr_stmt><expr><name><name>RuleNameArray</name><index>[<expr><name>REFERENCE_JOIN</name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"reference join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleNameArray</name><index>[<expr><name>LOCAL_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"local partition join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleNameArray</name><index>[<expr><name>SINGLE_HASH_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator>
			<call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"single hash partition join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleNameArray</name><index>[<expr><name>SINGLE_RANGE_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator>
			<call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"single range partition join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleNameArray</name><index>[<expr><name>DUAL_PARTITION_JOIN</name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"dual partition join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleNameArray</name><index>[<expr><name>CARTESIAN_PRODUCT_REFERENCE_JOIN</name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(
			<argument><expr><literal type="string">"cartesian product reference join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RuleNameArray</name><index>[<expr><name>CARTESIAN_PRODUCT</name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"cartesian product"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ruleNamesInitialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ruleName</name> <init>= <expr><name><name>RuleNameArray</name><index>[<expr><name>ruleType</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ruleName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ruleName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReferenceJoin evaluates if the candidate table is a reference table for inner,
 * left and anti join. For right join, current join node must be represented by
 * a reference table. For full join, both of them must be a reference table.
 */</comment>
<function><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type>
<name>ReferenceJoin</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>currentJoinNode</name></decl></parameter>, <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>applicableJoinCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>applicableJoinCount</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>leftIsReferenceTable</name> <init>= <expr><call><name>IsCitusTableType</name><argument_list>(
		<argument><expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>tableEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
		<argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>rightIsReferenceTable</name> <init>= <expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>candidateTable</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
												  <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSupportedReferenceJoin</name><argument_list>(<argument><expr><name>joinType</name></expr></argument>, <argument><expr><name>leftIsReferenceTable</name></expr></argument>, <argument><expr><name>rightIsReferenceTable</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>MakeJoinOrderNode</name><argument_list>(<argument><expr><name>candidateTable</name></expr></argument>, <argument><expr><name>REFERENCE_JOIN</name></expr></argument>,
							 <argument><expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>partitionColumnList</name></name></expr></argument>,
							 <argument><expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr></argument>,
							 <argument><expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>anchorTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsSupportedReferenceJoin checks if with this join type we can safely do a simple join
 * on the reference table on all the workers.
 */</comment>
<function><type><name>bool</name></type>
<name>IsSupportedReferenceJoin</name><parameter_list>(<parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>leftIsReferenceTable</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>rightIsReferenceTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>joinType</name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator> <name>joinType</name> <operator>==</operator> <name>JOIN_LEFT</name> <operator>||</operator> <name>joinType</name> <operator>==</operator> <name>JOIN_ANTI</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>rightIsReferenceTable</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>joinType</name> <operator>==</operator> <name>JOIN_RIGHT</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <name>leftIsReferenceTable</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>joinType</name> <operator>==</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator> <name>leftIsReferenceTable</name> <operator>&amp;&amp;</operator> <name>rightIsReferenceTable</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReferenceJoin evaluates if the candidate table is a reference table for inner,
 * left and anti join. For right join, current join node must be represented by
 * a reference table. For full join, both of them must be a reference table.
 */</comment>
<function><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type>
<name>CartesianProductReferenceJoin</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>currentJoinNode</name></decl></parameter>, <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
							  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>leftIsReferenceTable</name> <init>= <expr><call><name>IsCitusTableType</name><argument_list>(
		<argument><expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>tableEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
		<argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>rightIsReferenceTable</name> <init>= <expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>candidateTable</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
												  <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSupportedReferenceJoin</name><argument_list>(<argument><expr><name>joinType</name></expr></argument>, <argument><expr><name>leftIsReferenceTable</name></expr></argument>, <argument><expr><name>rightIsReferenceTable</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>MakeJoinOrderNode</name><argument_list>(<argument><expr><name>candidateTable</name></expr></argument>, <argument><expr><name>CARTESIAN_PRODUCT_REFERENCE_JOIN</name></expr></argument>,
							 <argument><expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>partitionColumnList</name></name></expr></argument>,
							 <argument><expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr></argument>,
							 <argument><expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>anchorTable</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LocalJoin takes the current partition key column and the candidate table's
 * partition key column and the partition method for each table. The function
 * then evaluates if tables in the join order and the candidate table can be
 * joined locally, without any data transfers. If they can, the function returns
 * a join order node for a local join. Otherwise, the function returns null.
 *
 * Anchor table is used to decide whether the JoinOrderNode can be joined
 * locally with the candidate table. That table is updated by each join type
 * applied over JoinOrderNode. Note that, we lost the anchor table after
 * dual partitioning and cartesian product.
 */</comment>
<function><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type>
<name>LocalJoin</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>currentJoinNode</name></decl></parameter>, <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
		  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>candidateTable</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>tableId</name> <init>= <expr><name><name>candidateTable</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>candidatePartitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>currentPartitionColumnList</name> <init>= <expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>partitionColumnList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>candidatePartitionMethod</name> <init>= <expr><call><name>PartitionMethod</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>currentPartitionMethod</name> <init>= <expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>currentAnchorTable</name> <init>= <expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>anchorTable</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we previously dual-hash re-partitioned the tables for a join or made cartesian
	 * product, there is no anchor table anymore. In that case we don't allow local join.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>currentAnchorTable</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* the partition method should be the same for a local join */</comment>
	<if_stmt><if>if <condition>(<expr><name>currentPartitionMethod</name> <operator>!=</operator> <name>candidatePartitionMethod</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>joinOnPartitionColumns</name> <init>= <expr><call><name>JoinOnColumns</name><argument_list>(<argument><expr><name>currentPartitionColumnList</name></expr></argument>,
												<argument><expr><name>candidatePartitionColumn</name></expr></argument>,
												<argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>joinOnPartitionColumns</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* shard interval lists must have 1-1 matching for local joins */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>coPartitionedTables</name> <init>= <expr><call><name>CoPartitionedTables</name><argument_list>(<argument><expr><name><name>currentAnchorTable</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
												   <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>coPartitionedTables</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since we are applying a local join to the candidate table we need to keep track of
	 * the partition column of the candidate table on the MultiJoinNode. This will allow
	 * subsequent joins colocated with this candidate table to correctly be recognized as
	 * a local join as well.
	 */</comment>
	<expr_stmt><expr><name>currentPartitionColumnList</name> <operator>=</operator> <call><name>list_append_unique</name><argument_list>(<argument><expr><name>currentPartitionColumnList</name></expr></argument>,
													<argument><expr><name>candidatePartitionColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>nextJoinNode</name> <init>= <expr><call><name>MakeJoinOrderNode</name><argument_list>(<argument><expr><name>candidateTable</name></expr></argument>, <argument><expr><name>LOCAL_PARTITION_JOIN</name></expr></argument>,
													<argument><expr><name>currentPartitionColumnList</name></expr></argument>,
													<argument><expr><name>currentPartitionMethod</name></expr></argument>,
													<argument><expr><name>currentAnchorTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<return>return <expr><name>nextJoinNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SinglePartitionJoin takes the current and the candidate table's partition keys
 * and methods. The function then evaluates if either "tables in the join order"
 * or the candidate table is already partitioned on a join column. If they are,
 * the function returns a join order node with the already partitioned column as
 * the next partition key. Otherwise, the function returns null.
 */</comment>
<function><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type>
<name>SinglePartitionJoin</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>currentJoinNode</name></decl></parameter>, <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>currentPartitionColumnList</name> <init>= <expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>partitionColumnList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>currentPartitionMethod</name> <init>= <expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>currentAnchorTable</name> <init>= <expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>anchorTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinRuleType</name></type> <name>currentJoinRuleType</name> <init>= <expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>joinRuleType</name></name></expr></init></decl>;</decl_stmt>


	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>candidateTable</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>tableId</name> <init>= <expr><name><name>candidateTable</name><operator>-&gt;</operator><name>rangeTableId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>candidatePartitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>candidatePartitionMethod</name> <init>= <expr><call><name>PartitionMethod</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* outer joins are not supported yet */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>joinType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we previously dual-hash re-partitioned the tables for a join or made
	 * cartesian product, we currently don't allow a single-repartition join.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>currentJoinRuleType</name> <operator>==</operator> <name>DUAL_PARTITION_JOIN</name> <operator>||</operator>
		<name>currentJoinRuleType</name> <operator>==</operator> <name>CARTESIAN_PRODUCT</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>joinClause</name> <init>=
		<expr><call><name>SinglePartitionJoinClause</name><argument_list>(<argument><expr><name>currentPartitionColumnList</name></expr></argument>, <argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>joinClause</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>currentPartitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Single hash repartitioning may perform worse than dual hash
			 * repartitioning. Thus, we control it via a guc.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableSingleHashRepartitioning</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><call><name>MakeJoinOrderNode</name><argument_list>(<argument><expr><name>candidateTable</name></expr></argument>, <argument><expr><name>SINGLE_HASH_PARTITION_JOIN</name></expr></argument>,
									 <argument><expr><name>currentPartitionColumnList</name></expr></argument>,
									 <argument><expr><name>currentPartitionMethod</name></expr></argument>,
									 <argument><expr><name>currentAnchorTable</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>candidatePartitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_RANGE</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>MakeJoinOrderNode</name><argument_list>(<argument><expr><name>candidateTable</name></expr></argument>, <argument><expr><name>SINGLE_RANGE_PARTITION_JOIN</name></expr></argument>,
									 <argument><expr><name>currentPartitionColumnList</name></expr></argument>,
									 <argument><expr><name>currentPartitionMethod</name></expr></argument>,
									 <argument><expr><name>currentAnchorTable</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* evaluate re-partitioning the current table only if the rule didn't apply above */</comment>
	<if_stmt><if>if <condition>(<expr><name>candidatePartitionMethod</name> <operator>!=</operator> <name>DISTRIBUTE_BY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Create a new unique list (set) with the partition column of the candidate table
		 * to check if a single repartition join will work for this table. When it works
		 * the set is retained on the MultiJoinNode for later local join verification.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>candidatePartitionColumnList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>candidatePartitionColumn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>joinClause</name> <operator>=</operator> <call><name>SinglePartitionJoinClause</name><argument_list>(<argument><expr><name>candidatePartitionColumnList</name></expr></argument>,
											   <argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>joinClause</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>candidatePartitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Single hash repartitioning may perform worse than dual hash
				 * repartitioning. Thus, we control it via a guc.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableSingleHashRepartitioning</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<return>return <expr><call><name>MakeJoinOrderNode</name><argument_list>(<argument><expr><name>candidateTable</name></expr></argument>,
										 <argument><expr><name>SINGLE_HASH_PARTITION_JOIN</name></expr></argument>,
										 <argument><expr><name>candidatePartitionColumnList</name></expr></argument>,
										 <argument><expr><name>candidatePartitionMethod</name></expr></argument>,
										 <argument><expr><name>candidateTable</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>currentPartitionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_RANGE</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>MakeJoinOrderNode</name><argument_list>(<argument><expr><name>candidateTable</name></expr></argument>,
										 <argument><expr><name>SINGLE_RANGE_PARTITION_JOIN</name></expr></argument>,
										 <argument><expr><name>candidatePartitionColumnList</name></expr></argument>,
										 <argument><expr><name>candidatePartitionMethod</name></expr></argument>,
										 <argument><expr><name>candidateTable</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SinglePartitionJoinClause walks over the applicable join clause list, and
 * finds an applicable join clause for the given partition column. If no such
 * clause exists, the function returns NULL.
 */</comment>
<function><type><name>OpExpr</name> <modifier>*</modifier></type>
<name>SinglePartitionJoinClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>partitionColumnList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>partitionColumn</argument>, <argument>partitionColumnList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>applicableJoinClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>applicableJoinClause</argument>, <argument>applicableJoinClauses</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NodeIsEqualsOpExpr</name><argument_list>(<argument><expr><name>applicableJoinClause</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>applicableJoinOpExpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>applicableJoinClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>leftColumn</name> <init>= <expr><call><name>LeftColumnOrNULL</name><argument_list>(<argument><expr><name>applicableJoinOpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>rightColumn</name> <init>= <expr><call><name>RightColumnOrNULL</name><argument_list>(<argument><expr><name>applicableJoinOpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>leftColumn</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>rightColumn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* not a simple partition column join */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>


			<comment type="block">/*
			 * We first check if partition column matches either of the join columns
			 * and if it does, we then check if the join column types match. If the
			 * types are different, we will use different hash functions for the two
			 * column types, and will incorrectly repartition the data.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>leftColumn</name></expr></argument>, <argument><expr><name>partitionColumn</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>equal</name><argument_list>(<argument><expr><name>rightColumn</name></expr></argument>, <argument><expr><name>partitionColumn</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>leftColumn</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>rightColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>applicableJoinOpExpr</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"single partition column types do not "</literal>
											<literal type="string">"match"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DualPartitionJoin evaluates if a join clause exists between "tables in the
 * join order" and the candidate table. If such a clause exists, both tables can
 * be repartitioned on the join column; and the function returns a join order
 * node with the join column as the next partition key. Otherwise, the function
 * returns null.
 */</comment>
<function><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type>
<name>DualPartitionJoin</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>currentJoinNode</name></decl></parameter>, <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>joinClause</name> <init>= <expr><call><name>DualPartitionJoinClause</name><argument_list>(<argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>joinClause</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* because of the dual partition, anchor table and partition column get lost */</comment>
		<return>return <expr><call><name>MakeJoinOrderNode</name><argument_list>(<argument><expr><name>candidateTable</name></expr></argument>,
								 <argument><expr><name>DUAL_PARTITION_JOIN</name></expr></argument>,
								 <argument><expr><name>NIL</name></expr></argument>,
								 <argument><expr><name>REDISTRIBUTE_BY_HASH</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DualPartitionJoinClause walks over the applicable join clause list, and finds
 * an applicable join clause for dual re-partitioning. If no such clause exists,
 * the function returns NULL.
 */</comment>
<function><type><name>OpExpr</name> <modifier>*</modifier></type>
<name>DualPartitionJoinClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>applicableJoinClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>applicableJoinClause</argument>, <argument>applicableJoinClauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NodeIsEqualsOpExpr</name><argument_list>(<argument><expr><name>applicableJoinClause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>applicableJoinOpExpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>applicableJoinClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>leftColumn</name> <init>= <expr><call><name>LeftColumnOrNULL</name><argument_list>(<argument><expr><name>applicableJoinOpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>rightColumn</name> <init>= <expr><call><name>RightColumnOrNULL</name><argument_list>(<argument><expr><name>applicableJoinOpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>leftColumn</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>rightColumn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we only need to check that the join column types match */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>leftColumn</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>rightColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>applicableJoinOpExpr</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dual partition column types do not match"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CartesianProduct always evaluates to true since all tables can be combined
 * using a cartesian product operator. This function acts as a catch-all rule,
 * in case none of the join rules apply.
 */</comment>
<function><type><specifier>static</specifier> <name>JoinOrderNode</name> <modifier>*</modifier></type>
<name>CartesianProduct</name><parameter_list>(<parameter><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>currentJoinNode</name></decl></parameter>, <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>candidateTable</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>joinType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>applicableJoinClauses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Because of the cartesian product, anchor table information got lost */</comment>
		<return>return <expr><call><name>MakeJoinOrderNode</name><argument_list>(<argument><expr><name>candidateTable</name></expr></argument>, <argument><expr><name>CARTESIAN_PRODUCT</name></expr></argument>,
								 <argument><expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>partitionColumnList</name></name></expr></argument>,
								 <argument><expr><name><name>currentJoinNode</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Constructs and returns a join-order node with the given arguments */</comment>
<function><type><name>JoinOrderNode</name> <modifier>*</modifier></type>
<name>MakeJoinOrderNode</name><parameter_list>(<parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>tableEntry</name></decl></parameter>, <parameter><decl><type><name>JoinRuleType</name></type> <name>joinRuleType</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionColumnList</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>partitionMethod</name></decl></parameter>,
				  <parameter><decl><type><name>TableEntry</name> <modifier>*</modifier></type><name>anchorTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinOrderNode</name> <modifier>*</modifier></type><name>joinOrderNode</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JoinOrderNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>tableEntry</name></name> <operator>=</operator> <name>tableEntry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>joinRuleType</name></name> <operator>=</operator> <name>joinRuleType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>joinType</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>partitionColumnList</name></name> <operator>=</operator> <name>partitionColumnList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>=</operator> <name>partitionMethod</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>joinClauseList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinOrderNode</name><operator>-&gt;</operator><name>anchorTable</name></name> <operator>=</operator> <name>anchorTable</name></expr>;</expr_stmt>

	<return>return <expr><name>joinOrderNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsApplicableJoinClause tests if the current joinClause is applicable to the join at
 * hand.
 *
 * Given a list of left hand tables and a candidate right hand table the join clause is
 * valid if atleast 1 column is from the right hand table AND all columns can be found
 * in either the list of tables on the left *or* in the right hand table.
 */</comment>
<function><type><name>bool</name></type>
<name>IsApplicableJoinClause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>leftTableIdList</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>rightTableId</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>varList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>joinContainsRightTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>var</argument>, <argument>varList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>columnTableId</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>rightTableId</name> <operator>==</operator> <name>columnTableId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>joinContainsRightTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name>leftTableIdList</name></expr></argument>, <argument><expr><name>columnTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We couldn't find this column either on the right hand side (first if
			 * statement), nor in the list on the left. This join clause involves a table
			 * not yet available during the candidate join.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * All columns referenced in this clause are available during this join, now the join
	 * is applicable if we found our candidate table as well
	 */</comment>
	<return>return <expr><name>joinContainsRightTable</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplicableJoinClauses finds all join clauses that apply between the given
 * left table list and the right table, and returns these found join clauses.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ApplicableJoinClauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>leftTableIdList</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>rightTableId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauseList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>applicableJoinClauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* make sure joinClauseList contains only join clauses */</comment>
	<expr_stmt><expr><name>joinClauseList</name> <operator>=</operator> <call><name>JoinClauseList</name><argument_list>(<argument><expr><name>joinClauseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>joinClause</argument>, <argument>joinClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsApplicableJoinClause</name><argument_list>(<argument><expr><name>leftTableIdList</name></expr></argument>, <argument><expr><name>rightTableId</name></expr></argument>, <argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>applicableJoinClauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>applicableJoinClauses</name></expr></argument>, <argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>applicableJoinClauses</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns the left column only when directly referenced in the given join clause,
 * otherwise NULL is returned.
 */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>LeftColumnOrNULL</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>joinClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>argumentList</name> <init>= <expr><name><name>joinClause</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>leftArgument</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>leftArgument</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>leftArgument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>leftArgument</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>leftArgument</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns the right column only when directly referenced in the given join clause,
 * otherwise NULL is returned.
 * */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>RightColumnOrNULL</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>joinClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>argumentList</name> <init>= <expr><name><name>joinClause</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rightArgument</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>argumentList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rightArgument</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>rightArgument</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rightArgument</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>rightArgument</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionColumn builds the partition column for the given relation, and sets
 * the partition column's range table references to the given table identifier.
 *
 * Note that reference tables do not have partition column. Thus, this function
 * returns NULL when called for reference tables.
 */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>PartitionColumn</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>rangeTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionKey</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* short circuit for reference tables */</comment>
	<if_stmt><if>if <condition>(<expr><name>partitionKey</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>partitionColumn</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>partitionColumn</name> <operator>=</operator> <name>partitionKey</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>rangeTableId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <name>rangeTableId</name></expr>;</expr_stmt>

	<return>return <expr><name>partitionColumn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistPartitionKey returns the partition key column for the given relation. Note
 * that in the context of distributed join and query planning, the callers of
 * this function *must* set the partition key column's range table reference
 * (varno) to match the table's location in the query range table list.
 *
 * Note that reference tables do not have partition column. Thus, this function
 * returns NULL when called for reference tables.
 */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>DistPartitionKey</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>partitionEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* non-distributed tables do not have partition column */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>partitionEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>partitionEntry</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistPartitionKeyOrError is the same as DistPartitionKey but errors out instead
 * of returning NULL if this is called with a relationId of a reference table.
 */</comment>
<function><type><name>Var</name> <modifier>*</modifier></type>
<name>DistPartitionKeyOrError</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionKey</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>partitionKey</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"no distribution column found for relation %d, because it is a reference table"</literal></expr></argument>,
							<argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>partitionKey</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Returns the partition method for the given relation. */</comment>
<function><type><name>char</name></type>
<name>PartitionMethod</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* errors out if not a distributed table */</comment>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>partitionEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>partitionMethod</name> <init>= <expr><name><name>partitionEntry</name><operator>-&gt;</operator><name>partitionMethod</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>partitionMethod</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Returns the replication model for the given relation. */</comment>
<function><type><name>char</name></type>
<name>TableReplicationModel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* errors out if not a distributed table */</comment>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>partitionEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><name><name>partitionEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>replicationModel</name></expr>;</return>
</block_content>}</block></function>
</unit>
