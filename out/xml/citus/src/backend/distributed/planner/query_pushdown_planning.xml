<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/planner/query_pushdown_planning.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * query_pushdown_planning.c
 *
 * Routines for creating pushdown plans for queries. Both select and modify
 * queries can be planned using query pushdown logic passing the checks given
 * in this file.
 *
 * Checks are controlled to understand whether the query can be sent to worker
 * nodes by simply adding shard_id to table names and getting the correct result
 * from them. That means, all the required data is present on the workers.
 *
 * For select queries, Citus try to use query pushdown planner if it has a
 * subquery or function RTEs. For modify queries, Citus try to use query pushdown
 * planner if the query accesses multiple tables.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_pushdown_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/recursive_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_restriction_equivalence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_RELID</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<comment type="block">/*
 * RecurringTuplesType is used to distinguish different types of expressions
 * that always produce the same set of tuples when a shard is queried. We make
 * this distinction to produce relevant error messages when recurring tuples
 * are used in a way that would give incorrect results.
 */</comment>
<typedef>typedef <type><enum>enum <name>RecurringTuplesType</name>
<block>{
	<decl><name>RECURRING_TUPLES_INVALID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>RECURRING_TUPLES_REFERENCE_TABLE</name></decl>,
	<decl><name>RECURRING_TUPLES_FUNCTION</name></decl>,
	<decl><name>RECURRING_TUPLES_EMPTY_JOIN_TREE</name></decl>,
	<decl><name>RECURRING_TUPLES_RESULT_FUNCTION</name></decl>,
	<decl><name>RECURRING_TUPLES_VALUES</name></decl>
}</block></enum></type> <name>RecurringTuplesType</name>;</typedef>

<comment type="block">/*
 * RelidsReferenceWalkerContext is used to find Vars in a (sub)query that
 * refer to certain relids from the upper query.
 */</comment>
<typedef>typedef <type><struct>struct <name>RelidsReferenceWalkerContext</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type> <name>relids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>foundRelid</name></decl>;</decl_stmt>
}</block></struct></type> <name>RelidsReferenceWalkerContext</name>;</typedef>


<comment type="block">/* Config variable managed via guc.c */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>SubqueryPushdown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* is subquery pushdown enabled */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>ValuesMaterializationThreshold</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Local functions forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>JoinTreeContainsSubqueryWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinTreeNode</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsFunctionOrValuesRTE</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsOuterJoinExpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>WindowPartitionOnDistributionColumn</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfFromClauseRecurs</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RecurringTuplesType</name></type> <name>FromClauseRecurringTupleType</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferredErrorIfUnsupportedRecurringTuplesJoin</name><parameter_list>(
	<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfUnsupportedTableCombination</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfSubqueryRequiresMerge</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subqueryTree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
																<name>lateral</name></decl></parameter>,
																<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>referencedThing</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExtractSetOperationStatementWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>setOperationList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RecurringTuplesType</name></type> <name>FetchFirstRecurType</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>plannerInfo</name></decl></parameter>,
											   <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsRecurringRTE</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
								 <parameter><decl><type><name>RecurringTuplesType</name> <modifier>*</modifier></type><name>recurType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsRecurringRangeTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTable</name></decl></parameter>, <parameter><decl><type><name>RecurringTuplesType</name> <modifier>*</modifier></type><name>recurType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasRecurringTuples</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RecurringTuplesType</name> <modifier>*</modifier></type><name>recurType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type> <name>SubqueryPushdownMultiNodeTree</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiTable</name> <modifier>*</modifier></type> <name>MultiSubqueryPushdownTable</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CreateSubqueryTargetListAndAdjustVars</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AttrNumber</name></type> <name>FindResnoForVarInTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varattno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RelationInfoContainsOnlyRecurringTuples</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>plannerInfo</name></decl></parameter>,
													<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>RecurringTypeDescription</name><parameter_list>(<parameter><decl><type><name>RecurringTuplesType</name></type> <name>recurType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferredErrorIfUnsupportedLateralSubquery</name><parameter_list>(
	<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>plannerInfo</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>recurringRelIds</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>nonRecurringRelIds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type> <name>PartitionColumnForPushedDownSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsReferencesToRelids</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>foundRelid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsReferencesToRelidsWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
											 <parameter><decl><type><name>RelidsReferenceWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ShouldUseSubqueryPushDown determines whether it's desirable to use
 * subquery pushdown to plan the query based on the original and
 * rewritten query.
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldUseSubqueryPushDown</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>rewrittenQuery</name></decl></parameter>,
						  <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We check the existence of subqueries in FROM clause on the modified query
	 * given that if postgres already flattened the subqueries, MultiNodeTree()
	 * can plan corresponding distributed plan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>JoinTreeContainsSubquery</name><argument_list>(<argument><expr><name>rewrittenQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We check the existence of subqueries in WHERE and HAVING clause on the
	 * modified query. In some cases subqueries in the original query are
	 * converted into inner joins and in those cases MultiNodeTree() can plan
	 * the rewritten plan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>WhereOrHavingClauseContainsSubquery</name><argument_list>(<argument><expr><name>rewrittenQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We check the existence of subqueries in the SELECT clause on the modified
	 * query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TargetListContainsSubquery</name><argument_list>(<argument><expr><name><name>rewrittenQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * We check if postgres planned any semi joins, MultiNodeTree doesn't
	 * support these so we fail. Postgres is able to replace some IN/ANY
	 * subqueries with semi joins and then replace those with inner joins (ones
	 * where the subquery returns unique results). This allows MultiNodeTree to
	 * execute these subqueries (because they are converted to inner joins).
	 * However, even in that case the rewrittenQuery still contains join nodes
	 * with jointype JOIN_SEMI because Postgres doesn't actually update these.
	 * The way we find out instead if it actually planned semi joins, is by
	 * checking the joins that were sent to multi_join_restriction_hook. If no
	 * joins of type JOIN_SEMI are sent it is safe to convert all JOIN_SEMI
	 * nodes to JOIN_INNER nodes (which is what is done in MultiNodeTree).
	 */</comment>
	<decl_stmt><decl><type><name>JoinRestrictionContext</name> <modifier>*</modifier></type><name>joinRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>joinRestrictionContext</name><operator>-&gt;</operator><name>hasSemiJoin</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * We process function and VALUES RTEs as subqueries, since the join order planner
	 * does not know how to handle them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalQuery</name></expr></argument>, <argument><expr><name>IsFunctionOrValuesRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We handle outer joins as subqueries, since the join order planner
	 * does not know how to handle them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>originalQuery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>IsOuterJoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Original query may not have an outer join while rewritten query does.
	 * We should push down in this case.
	 * An example of this is https://github.com/citusdata/citus/issues/2739
	 * where postgres pulls-up the outer-join in the subquery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rewrittenQuery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>IsOuterJoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Some unsupported join clauses in logical planner
	 * may be supported by subquery pushdown planner.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qualifierList</name> <init>= <expr><call><name>QualifierList</name><argument_list>(<argument><expr><name><name>rewrittenQuery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>DeferErrorIfUnsupportedClause</name><argument_list>(<argument><expr><name>qualifierList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check if the query has a window function and it is safe to pushdown */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>originalQuery</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>&amp;&amp;</operator>
		<call><name>SafeToPushdownWindowFunction</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinTreeContainsSubquery returns true if the input query contains any subqueries
 * in the join tree (e.g., FROM clause).
 */</comment>
<function><type><name>bool</name></type>
<name>JoinTreeContainsSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>joinTree</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>joinTree</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>JoinTreeContainsSubqueryWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinTree</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasEmptyJoinTree returns whether the query selects from anything.
 */</comment>
<function><type><name>bool</name></type>
<name>HasEmptyJoinTree</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RESULT</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinTreeContainsSubqueryWalker returns true if the input joinTreeNode
 * references to a subquery. Otherwise, recurses into the expression.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>JoinTreeContainsSubqueryWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinTreeNode</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>joinTreeNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>joinTreeNode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>joinTreeNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>joinTreeNode</name></expr></argument>, <argument><expr><name>JoinTreeContainsSubqueryWalker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WhereOrHavingClauseContainsSubquery returns true if the input query contains
 * any subqueries in the WHERE or HAVING clause.
 */</comment>
<function><type><name>bool</name></type>
<name>WhereOrHavingClauseContainsSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>IsNodeSubquery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We search the whole jointree here, not just the quals. The reason for
	 * this is that the fromlist can contain other FromExpr nodes again or
	 * JoinExpr nodes that also have quals. If that's the case we need to check
	 * those as well if they contain andy subqueries.
	 */</comment>
	<return>return <expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>IsNodeSubquery</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TargetList returns true if the input query contains
 * any subqueries in the WHERE clause.
 */</comment>
<function><type><name>bool</name></type>
<name>TargetListContainsSubquery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr></argument>, <argument><expr><name>IsNodeSubquery</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsFunctionRTE determines whether the given node is a function RTE.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsFunctionOrValuesRTE</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTblEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rangeTblEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name> <operator>||</operator>
			<name><name>rangeTblEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsNodeSubquery returns true if the given node is a Query or SubPlan or a
 * Param node with paramkind PARAM_EXEC.
 *
 * The check for SubPlan is needed when this is used on a already rewritten
 * query. Such a query has SubPlan nodes instead of SubLink nodes (which
 * contain a Query node).
 * The check for PARAM_EXEC is needed because some very simple subqueries like
 * (select 1) are converted to init plans in the rewritten query. In this case
 * the only thing left in the query tree is a Param node with type PARAM_EXEC.
 */</comment>
<function><type><name>bool</name></type>
<name>IsNodeSubquery</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_EXEC</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsOuterJoinExpr returns whether the given node is an outer join expression.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsOuterJoinExpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isOuterJoin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinType</name></type> <name>joinType</name> <init>= <expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>joinType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isOuterJoin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>isOuterJoin</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SafeToPushdownWindowFunction checks if the query with window function is supported.
 * Returns the result accordingly and modifies errorDetail if non null.
 */</comment>
<function><type><name>bool</name></type>
<name>SafeToPushdownWindowFunction</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name> <modifier>*</modifier></type><name>errorDetail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>windowClauseCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>windowClauseList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We need to check each window clause separately if there is a partition by clause
	 * and if it is partitioned on the distribution column.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>windowClauseCell</argument>, <argument>windowClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>windowClause</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>windowClauseCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>windowClause</name><operator>-&gt;</operator><name>partitionClause</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errorDetail</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>errorDetail</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>*</operator><name>errorDetail</name></expr></argument>,
									   <argument><expr><literal type="string">"Window functions without PARTITION BY on distribution "</literal>
									   <literal type="string">"column is currently unsupported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>WindowPartitionOnDistributionColumn</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errorDetail</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>errorDetail</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>*</operator><name>errorDetail</name></expr></argument>,
								   <argument><expr><literal type="string">"Window functions with PARTITION BY list missing distribution "</literal>
								   <literal type="string">"column is currently unsupported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WindowPartitionOnDistributionColumn checks if the given subquery has one
 * or more window functions and at least one of them is not partitioned by
 * distribution column. The function returns false if your window function does not
 * have a partition by clause or it does not include the distribution column.
 *
 * Please note that if the query does not have a window function, the function
 * returns true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>WindowPartitionOnDistributionColumn</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>windowClauseList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>windowClauseCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>windowClauseCell</argument>, <argument>windowClauseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>windowClause</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>windowClauseCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionClauseList</name> <init>= <expr><name><name>windowClause</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupTargetEntryList</name> <init>=
			<expr><call><name>GroupTargetEntryList</name><argument_list>(<argument><expr><name>partitionClauseList</name></expr></argument>, <argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>partitionOnDistributionColumn</name> <init>=
			<expr><call><name>TargetListOnPartitionColumn</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>groupTargetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partitionOnDistributionColumn</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SubqueryMultiNodeTree gets the query objects and returns logical plan
 * for subqueries.
 *
 * We currently have two different code paths for creating logic plan for subqueries:
 *   (i) subquery pushdown
 *   (ii) single relation repartition subquery
 *
 * In order to create the logical plan, we follow the algorithm below:
 *    -  If subquery pushdown planner can plan the query
 *        -  We're done, we create the multi plan tree and return
 *    -  Else
 *       - If the query is not eligible for single table repartition subquery planning
 *            - Throw the error that the subquery pushdown planner generated
 *       - If it is eligible for single table repartition subquery planning
 *            - Check for the errors for single table repartition subquery planning
 *                - If no errors found, we're done. Create the multi plan and return
 *                - If found errors, throw it
 */</comment>
<function><type><name>MultiNode</name> <modifier>*</modifier></type>
<name>SubqueryMultiNodeTree</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>,
					  <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * This is a generic error check that applies to both subquery pushdown
	 * and single table repartition subquery.
	 */</comment>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>unsupportedQueryError</name> <init>= <expr><call><name>DeferErrorIfQueryNotSupported</name><argument_list>(
		<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>unsupportedQueryError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>unsupportedQueryError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>subqueryPushdownError</name> <init>= <expr><call><name>DeferErrorIfUnsupportedSubqueryPushdown</name><argument_list>(
		<argument><expr><name>originalQuery</name></expr></argument>,
		<argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>subqueryPushdownError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>subqueryPushdownError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>multiQueryNode</name> <init>= <expr><call><name>SubqueryPushdownMultiNodeTree</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>multiQueryNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>multiQueryNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfContainsUnsupportedSubqueryPushdown iterates on the query's subquery
 * entry list and uses helper functions to check if we can push down subquery
 * to worker nodes. These helper functions returns a deferred error if we
 * cannot push down the subquery.
 */</comment>
<function><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfUnsupportedSubqueryPushdown</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
										<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
										<name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>outerMostQueryHasLimit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>subqueryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subqueryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>originalQuery</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>outerMostQueryHasLimit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We're checking two things here:
	 *    (i)   If the query contains a top level union, ensure that all leaves
	 *          return the partition key at the same position
	 *    (ii)  Else, check whether all relations joined on the partition key or not
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ContainsUnionSubquery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeToPushdownUnionSubquery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot pushdown the subquery since not all subqueries "</literal>
								 <literal type="string">"in the UNION have the partition column in the same "</literal>
								 <literal type="string">"position"</literal></expr></argument>,
								 <argument><expr><literal type="string">"Each leaf query of the UNION should return the "</literal>
								 <literal type="string">"partition column in the same position and all joins "</literal>
								 <literal type="string">"must be on the partition column"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>RestrictionEquivalenceForPartitionKeys</name><argument_list>(<argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"complex joins are only supported when all distributed tables are "</literal>
							 <literal type="string">"co-located and joined on their distribution columns"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we shouldn't allow reference tables in the FROM clause when the query has sublinks */</comment>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>DeferErrorIfFromClauseRecurs</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>error</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>DeferredErrorIfUnsupportedRecurringTuplesJoin</name><argument_list>(<argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>error</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We first extract all the queries that appear in the original query. Later,
	 * we delete the original query given that error rules does not apply to the
	 * top level query. For instance, we could support any LIMIT/ORDER BY on the
	 * top level query.
	 */</comment>
	<expr_stmt><expr><call><name>ExtractQueryWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalQuery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subqueryList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>subqueryList</name> <operator>=</operator> <call><name>list_delete</name><argument_list>(<argument><expr><name>subqueryList</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* iterate on the subquery list and error out accordingly */</comment>
	<macro><name>foreach</name><argument_list>(<argument>subqueryCell</argument>, <argument>subqueryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>subqueryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>DeferErrorIfCannotPushdownSubquery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>,
												   <argument><expr><name>outerMostQueryHasLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>error</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfFromClauseRecurs returns a deferred error if the
 * given query is not suitable for subquery pushdown.
 *
 * While planning sublinks, we rely on Postgres in the sense that it converts some of
 * sublinks into joins.
 *
 * In some cases, sublinks are pulled up and converted into outer joins. Those cases
 * are already handled with RecursivelyPlanRecurringTupleOuterJoinWalker() or thrown
 * an error for in DeferredErrorIfUnsupportedRecurringTuplesJoin().
 *
 * If the sublinks are not pulled up, we should still error out in if the expression
 * in the FROM clause would recur for every shard in a subquery on the WHERE clause.
 *
 * Otherwise, the result would include duplicate rows.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfFromClauseRecurs</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>queryTree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RecurringTuplesType</name></type> <name>recurType</name> <init>= <expr><call><name>FromClauseRecurringTupleType</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>recurType</name> <operator>==</operator> <name>RECURRING_TUPLES_REFERENCE_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"correlated subqueries are not supported when "</literal>
							 <literal type="string">"the FROM clause contains a reference table"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>recurType</name> <operator>==</operator> <name>RECURRING_TUPLES_FUNCTION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"correlated subqueries are not supported when "</literal>
							 <literal type="string">"the FROM clause contains a set returning function"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>recurType</name> <operator>==</operator> <name>RECURRING_TUPLES_RESULT_FUNCTION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"correlated subqueries are not supported when "</literal>
							 <literal type="string">"the FROM clause contains a CTE or subquery"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>recurType</name> <operator>==</operator> <name>RECURRING_TUPLES_EMPTY_JOIN_TREE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"correlated subqueries are not supported when "</literal>
							 <literal type="string">"the FROM clause contains a subquery without FROM"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>recurType</name> <operator>==</operator> <name>RECURRING_TUPLES_VALUES</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"correlated subqueries are not supported when "</literal>
							 <literal type="string">"the FROM clause contains VALUES"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * We get here when there is neither a distributed table, nor recurring tuples.
	 * That usually means that there isn't a FROM at all (only sublinks), this
	 * implies that queryTree is recurring, but whether this is a problem depends
	 * on outer queries, not on queryTree itself.
	 */</comment>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FromClauseRecurringTupleType returns tuple recurrence information
 * in query result based on range table entries in from clause.
 *
 * Returned information is used to prepare appropriate deferred error
 * message for subquery pushdown checks.
 */</comment>
<function><type><specifier>static</specifier> <name>RecurringTuplesType</name></type>
<name>FromClauseRecurringTupleType</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecurringTuplesType</name></type> <name>recurType</name> <init>= <expr><name>RECURRING_TUPLES_INVALID</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HasEmptyJoinTree</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>RECURRING_TUPLES_EMPTY_JOIN_TREE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
													  <argument><expr><name>IsDistributedTableRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There is a distributed table somewhere in the FROM clause.
		 *
		 * In the typical case this means that the query does not recur,
		 * but there are two exceptions:
		 *
		 * - outer joins such as reference_table LEFT JOIN distributed_table
		 * - FROM reference_table WHERE .. (SELECT .. FROM distributed_table) ..
		 *
		 * However, we check all subqueries and joins separately, so we would
		 * find such conditions in other calls.
		 */</comment>
		<return>return <expr><name>RECURRING_TUPLES_INVALID</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Try to figure out which type of recurring tuples we have to produce a
	 * relevant error message. If there are several we'll pick the first one.
	 */</comment>
	<expr_stmt><expr><call><name>ContainsRecurringRangeTable</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recurType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>recurType</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferredErrorIfUnsupportedRecurringTuplesJoin returns a DeferredError if
 * there exists a join between a recurring rel (such as reference tables
 * and intermediate_results) and a non-recurring rel (such as distributed tables
 * and subqueries that we can push-down to worker nodes) that can return an
 * incorrect result set due to recurring tuples coming from the recurring rel.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferredErrorIfUnsupportedRecurringTuplesJoin</name><parameter_list>(
	<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinRestrictionList</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>joinRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecurringTuplesType</name></type> <name>recurType</name> <init>= <expr><name>RECURRING_TUPLES_INVALID</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>joinRestrictionCell</argument>, <argument>joinRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinRestriction</name> <modifier>*</modifier></type><name>joinRestriction</name> <init>= <expr><operator>(</operator><name>JoinRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(
			<argument><expr><name>joinRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JoinType</name></type> <name>joinType</name> <init>= <expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>joinType</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>plannerInfo</name> <init>= <expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>plannerInfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type> <name>innerrelRelids</name> <init>= <expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>innerrelRelids</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relids</name></type> <name>outerrelRelids</name> <init>= <expr><name><name>joinRestriction</name><operator>-&gt;</operator><name>outerrelRelids</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * This loop aims to determine whether this join is between a recurring
		 * rel and a non-recurring rel, and if so, whether it can yield an incorrect
		 * result set due to recurring tuples.
		 *
		 * For outer joins, this can only happen if it's a lateral outer join
		 * where the inner distributed subquery references the recurring outer
		 * rel. This because, such outer joins should not appear here because
		 * the recursive planner (RecursivelyPlanRecurringTupleOuterJoinWalker)
		 * should have already planned the non-recurring side if it wasn't a
		 * lateral join. For this reason, if the outer join is between a recurring
		 * rel --on the outer side-- and a non-recurring rel --on the other side--,
		 * we throw an error assuming that it's a lateral outer join.
		 * Also note that; in the context of outer joins, we only check left outer
		 * and full outer joins because PostgreSQL converts right joins to left
		 * joins before passing them through "set_join_pathlist_hook"s.
		 *
		 * For semi / anti joins, we anyway throw an error when the inner
		 * side is a distributed subquery that references a recurring outer rel
		 * (in the FROM clause) thanks to DeferErrorIfFromClauseRecurs. And when
		 * the inner side is a recurring rel and the outer side a non-recurring
		 * one, then the non-recurring side can't reference the recurring side
		 * anyway.
		 *
		 * For those reasons, here we perform below lateral join checks only for
		 * outer (except anti) / inner joins but not for anti / semi joins.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><name>joinType</name> <operator>==</operator> <name>JOIN_LEFT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>RelationInfoContainsOnlyRecurringTuples</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>, <argument><expr><name>innerrelRelids</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* inner side only contains recurring rels */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>RelationInfoContainsOnlyRecurringTuples</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>, <argument><expr><name>outerrelRelids</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Inner side contains distributed rels but the outer side only
				 * contains recurring rels, must be an unsupported lateral outer
				 * join.
				 */</comment>
				<expr_stmt><expr><name>recurType</name> <operator>=</operator> <call><name>FetchFirstRecurType</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>, <argument><expr><name>outerrelRelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>joinType</name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>innerContainOnlyRecurring</name> <init>=
				<expr><call><name>RelationInfoContainsOnlyRecurringTuples</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>, <argument><expr><name>innerrelRelids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>outerContainOnlyRecurring</name> <init>=
				<expr><call><name>RelationInfoContainsOnlyRecurringTuples</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>, <argument><expr><name>outerrelRelids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>innerContainOnlyRecurring</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>outerContainOnlyRecurring</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Right side contains distributed rels but the left side only
				 * contains recurring rels, must be an unsupported lateral outer
				 * join.
				 */</comment>
				<expr_stmt><expr><name>recurType</name> <operator>=</operator> <call><name>FetchFirstRecurType</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>, <argument><expr><name>innerrelRelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>innerContainOnlyRecurring</name> <operator>&amp;&amp;</operator> <name>outerContainOnlyRecurring</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Left side contains distributed rels but the right side only
				 * contains recurring rels, must be an unsupported lateral outer
				 * join.
				 */</comment>
				<expr_stmt><expr><name>recurType</name> <operator>=</operator> <call><name>FetchFirstRecurType</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>, <argument><expr><name>outerrelRelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>joinType</name> <operator>==</operator> <name>JOIN_INNER</name> <operator>&amp;&amp;</operator> <name><name>plannerInfo</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Sometimes we cannot push down INNER JOINS when they have only
			 * recurring tuples on one side and a lateral on the other side.
			 * See comment on DeferredErrorIfUnsupportedLateralSubquery for
			 * details.
			 *
			 * When planning inner joins, postgres can move RTEs from left to
			 * right and from right to left. So we don't know on which side the
			 * lateral join wil appear. Thus we try to find a side of the join
			 * that only contains recurring tuples. And then we check the other
			 * side to see if it contains an unsupported lateral join.
			 *
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>RelationInfoContainsOnlyRecurringTuples</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>, <argument><expr><name>innerrelRelids</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>deferredError</name> <init>=
					<expr><call><name>DeferredErrorIfUnsupportedLateralSubquery</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>,
															  <argument><expr><name>innerrelRelids</name></expr></argument>,
															  <argument><expr><name>outerrelRelids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>deferredError</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>deferredError</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>RelationInfoContainsOnlyRecurringTuples</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>, <argument><expr><name>outerrelRelids</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This branch uses "else if" instead of "if", because if both
				 * sides contain only recurring tuples there will never be an
				 * unsupported lateral subquery.
				 */</comment>
				<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>deferredError</name> <init>=
					<expr><call><name>DeferredErrorIfUnsupportedLateralSubquery</name><argument_list>(<argument><expr><name>plannerInfo</name></expr></argument>,
															  <argument><expr><name>outerrelRelids</name></expr></argument>,
															  <argument><expr><name>innerrelRelids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>deferredError</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>deferredError</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>recurType</name> <operator>!=</operator> <name>RECURRING_TUPLES_INVALID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errmsg</name> <init>= <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"cannot perform a lateral outer join when "</literal>
								<literal type="string">"a distributed subquery references %s"</literal></expr></argument>,
								<argument><expr><call><name>RecurringTypeDescription</name><argument_list>(<argument><expr><name>recurType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><name>errmsg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CanPushdownSubquery checks if we can push down the given
 * subquery to worker nodes.
 */</comment>
<function><type><name>bool</name></type>
<name>CanPushdownSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subqueryTree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>outerMostQueryHasLimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>DeferErrorIfCannotPushdownSubquery</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>, <argument><expr><name>outerMostQueryHasLimit</name></expr></argument>)</argument_list></call> <operator>==</operator>
		   <name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfCannotPushdownSubquery checks if we can push down the given
 * subquery to worker nodes. If we cannot push down the subquery, this function
 * returns a deferred error.
 *
 * We can push down a subquery if it follows rules below:
 * a. If there is an aggregate, it must be grouped on partition column.
 * b. If there is a join, it must be between two regular tables or two subqueries.
 * We don't support join between a regular table and a subquery. And columns on
 * the join condition must be partition columns.
 * c. If there is a distinct clause, it must be on the partition column.
 *
 * This function is very similar to DeferErrorIfQueryNotSupported() in logical
 * planner, but we don't reuse it, because differently for subqueries we support
 * a subset of distinct, union and left joins.
 *
 * Note that this list of checks is not exhaustive, there can be some cases
 * which we let subquery to run but returned results would be wrong. Such as if
 * a subquery has a group by on another subquery which includes order by with
 * limit, we let this query to run, but results could be wrong depending on the
 * features of underlying tables.
 */</comment>
<function><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfCannotPushdownSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subqueryTree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>outerMostQueryHasLimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>preconditionsSatisfied</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errorDetail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>deferredError</name> <init>= <expr><call><name>DeferErrorIfUnsupportedTableCombination</name><argument_list>(
		<argument><expr><name>subqueryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>deferredError</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>deferredError</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HasEmptyJoinTree</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subqueryTree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Subqueries without a FROM clause can only contain immutable "</literal>
					  <literal type="string">"functions"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Correlated subqueries are effectively functions that are repeatedly called
	 * for the values of the vars that point to the outer query. We can liberally
	 * push down SQL features within such a function, as long as co-located join
	 * checks are applied.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ContainsReferencesToOuterQuery</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>deferredError</name> <operator>=</operator> <call><name>DeferErrorIfSubqueryRequiresMerge</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
														  <argument><expr><literal type="string">"another query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>deferredError</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>deferredError</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Limit is partially supported when SubqueryPushdown is set.
	 * The outermost query must have a limit clause.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>&amp;&amp;</operator> <name>SubqueryPushdown</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>outerMostQueryHasLimit</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Limit in subquery without limit in the outermost query is "</literal>
					  <literal type="string">"unsupported"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>deferredError</name> <operator>=</operator> <call><name>DeferErrorIfUnsupportedUnionQuery</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>deferredError</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>deferredError</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>hasRecursive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Recursive queries are currently unsupported"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Common Table Expressions are currently unsupported"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>hasForUpdate</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"For Update/Share commands are currently unsupported"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* grouping sets are not allowed in subqueries*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"could not run distributed query with GROUPING SETS, CUBE, "</literal>
					  <literal type="string">"or ROLLUP"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>deferredError</name> <operator>=</operator> <call><name>DeferErrorIfFromClauseRecurs</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>deferredError</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>deferredError</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* finally check and return deferred if not satisfied */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preconditionsSatisfied</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>,
							 <argument><expr><name>errorDetail</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfSubqueryRequiresMerge returns a deferred error if the subquery
 * requires a merge step on the coordinator (e.g. limit, group by non-distribution
 * column, etc.).
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfSubqueryRequiresMerge</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subqueryTree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lateral</name></decl></parameter>,
								  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>referencedThing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>preconditionsSatisfied</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errorDetail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lateralString</name> <init>= <expr><ternary><condition><expr><name>lateral</name></expr> ?</condition><then> <expr><literal type="string">"lateral "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Offset clause is currently unsupported when a %ssubquery "</literal>
							   <literal type="string">"references a column from %s"</literal></expr></argument>, <argument><expr><name>lateralString</name></expr></argument>,
							   <argument><expr><name>referencedThing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* limit is not supported when SubqueryPushdown is not set */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>SubqueryPushdown</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Limit clause is currently unsupported when a "</literal>
							   <literal type="string">"%ssubquery references a column from %s"</literal></expr></argument>, <argument><expr><name>lateralString</name></expr></argument>,
							   <argument><expr><name>referencedThing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* group clause list must include partition column */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseList</name> <init>= <expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>groupClause</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupTargetEntryList</name> <init>= <expr><call><name>GroupTargetEntryList</name><argument_list>(<argument><expr><name>groupClauseList</name></expr></argument>,
														  <argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>groupOnPartitionColumn</name> <init>=
			<expr><call><name>TargetListOnPartitionColumn</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>, <argument><expr><name>groupTargetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>groupOnPartitionColumn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Group by list without partition column is currently "</literal>
								   <literal type="string">"unsupported when a %ssubquery references a column "</literal>
								   <literal type="string">"from %s"</literal></expr></argument>, <argument><expr><name>lateralString</name></expr></argument>, <argument><expr><name>referencedThing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we don't support aggregates without group by */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>subqueryTree</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Aggregates without group by are currently unsupported "</literal>
							   <literal type="string">"when a %ssubquery references a column from %s"</literal></expr></argument>,
							   <argument><expr><name>lateralString</name></expr></argument>, <argument><expr><name>referencedThing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* having clause without group by on partition column is not supported */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>subqueryTree</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Having qual without group by on partition column is "</literal>
							   <literal type="string">"currently unsupported when a %ssubquery references "</literal>
							   <literal type="string">"a column from %s"</literal></expr></argument>, <argument><expr><name>lateralString</name></expr></argument>, <argument><expr><name>referencedThing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We support window functions when the window function
	 * is partitioned on distribution column.
	 */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>errorInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SafeToPushdownWindowFunction</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>,
																	  <argument><expr><operator>&amp;</operator><name>errorInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>errorInfo</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* distinct clause list must include partition column */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctClauseList</name> <init>= <expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctTargetEntryList</name> <init>= <expr><call><name>GroupTargetEntryList</name><argument_list>(<argument><expr><name>distinctClauseList</name></expr></argument>,
															 <argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>distinctOnPartitionColumn</name> <init>=
			<expr><call><name>TargetListOnPartitionColumn</name><argument_list>(<argument><expr><name>subqueryTree</name></expr></argument>, <argument><expr><name>distinctTargetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>distinctOnPartitionColumn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>preconditionsSatisfied</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Distinct on columns without partition column is "</literal>
						  <literal type="string">"currently unsupported"</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finally check and return deferred if not satisfied */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preconditionsSatisfied</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>,
							 <argument><expr><name>errorDetail</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfUnsupportedTableCombination checks if the given query tree contains any
 * unsupported range table combinations. For this, the function walks over all
 * range tables in the join tree, and checks if they correspond to simple relations
 * or subqueries. It also checks if there is a join between a regular table and
 * a subquery and if join is on more than two range table entries. If any error is found,
 * a deferred error is returned. Else, NULL is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfUnsupportedTableCombination</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinTreeTableIndexList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>joinTreeTableIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>unsupportedTableCombination</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errorDetail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Extract all range table indexes from the join tree. Note that sub-queries
	 * that get pulled up by PostgreSQL don't appear in this join tree.
	 */</comment>
	<expr_stmt><expr><call><name>ExtractRangeTableIndexWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>joinTreeTableIndexList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach_int</name><argument_list>(<argument>joinTreeTableIndex</argument>, <argument>joinTreeTableIndexList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Join tree's range table index starts from 1 in the query tree. But,
		 * list indexes start from 0.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>rangeTableListIndex</name> <init>= <expr><name>joinTreeTableIndex</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>=
			<expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>rangeTableListIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check if the range table in the join tree is a simple relation, a
		 * subquery, or immutable function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>||</operator>
			<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>||</operator>
			<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RESULT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* accepted */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When GUC is set to -1, we disable materialization, when set to 0,
			 * we materialize everything. Other values are compared against the
			 * length of the values_lists.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>valuesRowCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>ValuesMaterializationThreshold</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name>valuesRowCount</name> <operator>&gt;</operator> <name>ValuesMaterializationThreshold</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>unsupportedTableCombination</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"VALUES has more than "</literal>
							  <literal type="string">"\"citus.values_materialization_threshold\" "</literal>
							  <literal type="string">"entries, so it is materialized"</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* VALUES should not contain mutable functions */</comment>
				<expr_stmt><expr><name>unsupportedTableCombination</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Only immutable functions can be used in VALUES"</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionList</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>functions</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>functionList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>ContainsReadIntermediateResultFunction</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>functionList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The read_intermediate_result function is volatile, but we know
				 * it has the same result across all nodes and can therefore treat
				 * it as a reference table.
				 */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>functionList</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>unsupportedTableCombination</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Only immutable functions can be used as a table "</literal>
							  <literal type="string">"expressions in a multi-shard query"</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* immutable function RTEs are treated as reference tables */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>unsupportedTableCombination</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"CTEs in subqueries are currently unsupported"</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>unsupportedTableCombination</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>errorDetail</name> <operator>=</operator> <literal type="string">"Table expressions other than relations, subqueries, "</literal>
						  <literal type="string">"and immutable functions are currently unsupported"</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* finally check and error out if not satisfied */</comment>
	<if_stmt><if>if <condition>(<expr><name>unsupportedTableCombination</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>,
							 <argument><expr><name>errorDetail</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfUnsupportedUnionQuery is a helper function for ErrorIfCannotPushdownSubquery().
 * The function also errors out for set operations INTERSECT and EXCEPT.
 */</comment>
<function><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfUnsupportedUnionQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subqueryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>setOperationStatementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>setOperationStatmentCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RecurringTuplesType</name></type> <name>recurType</name> <init>= <expr><name>RECURRING_TUPLES_INVALID</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractSetOperationStatementWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subqueryTree</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>setOperationStatementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>setOperationStatmentCell</argument>, <argument>setOperationStatementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOperation</name> <init>=
			<expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>setOperationStatmentCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>leftArg</name> <init>= <expr><name><name>setOperation</name><operator>-&gt;</operator><name>larg</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rightArg</name> <init>= <expr><name><name>setOperation</name><operator>-&gt;</operator><name>rarg</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>leftArgRTI</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rightArgRTI</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>setOperation</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_UNION</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>,
								 <argument><expr><literal type="string">"Intersect and Except are currently unsupported"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>leftArg</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>leftArgRTI</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>leftArg</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>leftArgSubquery</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>leftArgRTI</name></expr></argument>,
											  <argument><expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subquery</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>recurType</name> <operator>=</operator> <call><name>FromClauseRecurringTupleType</name><argument_list>(<argument><expr><name>leftArgSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>recurType</name> <operator>!=</operator> <name>RECURRING_TUPLES_INVALID</name></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightArg</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rightArgRTI</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>rightArg</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>rightArgSubquery</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rightArgRTI</name></expr></argument>,
											   <argument><expr><name><name>subqueryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subquery</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>recurType</name> <operator>=</operator> <call><name>FromClauseRecurringTupleType</name><argument_list>(<argument><expr><name>rightArgSubquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>recurType</name> <operator>!=</operator> <name>RECURRING_TUPLES_INVALID</name></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>recurType</name> <operator>==</operator> <name>RECURRING_TUPLES_REFERENCE_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Reference tables are not supported with union operator"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>recurType</name> <operator>==</operator> <name>RECURRING_TUPLES_FUNCTION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Table functions are not supported with union operator"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>recurType</name> <operator>==</operator> <name>RECURRING_TUPLES_EMPTY_JOIN_TREE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Subqueries without a FROM clause are not supported with "</literal>
							 <literal type="string">"union operator"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>recurType</name> <operator>==</operator> <name>RECURRING_TUPLES_RESULT_FUNCTION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>,
							 <argument><expr><literal type="string">"Complex subqueries and CTEs are not supported within a "</literal>
							 <literal type="string">"UNION"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>recurType</name> <operator>==</operator> <name>RECURRING_TUPLES_VALUES</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"cannot push down this subquery"</literal></expr></argument>,
							 <argument><expr><literal type="string">"VALUES is not supported within a "</literal>
							 <literal type="string">"UNION"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractSetOperationStatementWalker walks over a set operations statment,
 * and finds all set operations in the tree.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExtractSetOperationStatementWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>setOperationList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOperation</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>setOperationList</name><operator>)</operator> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>setOperationList</name></expr></argument>, <argument><expr><name>setOperation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>walkerResult</name> <init>= <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
											   <argument><expr><name>ExtractSetOperationStatementWalker</name></expr></argument>,
											   <argument><expr><name>setOperationList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>walkerResult</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationInfoContainsOnlyRecurringTuples returns false if any of the relations in
 * a RelOptInfo is not recurring.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RelationInfoContainsOnlyRecurringTuples</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>plannerInfo</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>relationId</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>relationId</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name><name>plannerInfo</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>relationId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name>IsDistributedTableRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we already found a distributed table, no need to check further */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there are no distributed tables, there should be at least
		 * one recurring rte.
		 */</comment>
		<decl_stmt><decl><type><name>RecurringTuplesType</name> <name>recurType</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ContainsRecurringRTE</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recurType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecurringTypeDescription returns a discriptive string for the given
 * recurType. This string can be used in error messages to help the users
 * understand why a query cannot be planned.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>RecurringTypeDescription</name><parameter_list>(<parameter><decl><type><name>RecurringTuplesType</name></type> <name>recurType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>recurType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RECURRING_TUPLES_REFERENCE_TABLE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"a reference table"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>RECURRING_TUPLES_FUNCTION</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"a table function"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>RECURRING_TUPLES_EMPTY_JOIN_TREE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"a subquery without FROM"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>RECURRING_TUPLES_RESULT_FUNCTION</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"complex subqueries, CTEs or local tables"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>RECURRING_TUPLES_VALUES</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"a VALUES clause"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>RECURRING_TUPLES_INVALID</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * This branch should never be hit, but it's here just in case it
			 * happens.
			 */</comment>
			<return>return <expr><literal type="string">"an unknown recurring tuple"</literal></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * This should never be hit, but is needed to fix compiler warnings.
	 */</comment>
	<return>return <expr><literal type="string">"an unknown recurring tuple"</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsReferencesToRelids determines whether the given query contains
 * any references that point to columns of the given relids. The given relids
 * should be from exactly one query level above the given query.
 *
 * If the function returns true, then foundRelid is set to the first relid that
 * was referenced.
 *
 * There are some queries where it cannot easily be determined if the relids
 * are used, e.g because the query contains placeholder vars. In those cases
 * this function returns true, because it's better to error out than to return
 * wrong results. But in these cases foundRelid is set to INVALID_RELID.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsReferencesToRelids</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>foundRelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelidsReferenceWalkerContext</name></type> <name>context</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>level</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>relids</name></name> <operator>=</operator> <name>relids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>foundRelid</name></name> <operator>=</operator> <name>INVALID_RELID</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>ContainsReferencesToRelidsWalker</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>foundRelid</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>foundRelid</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsReferencesToRelidsWalker determines whether the given query
 * contains any Vars that reference the relids in the context.
 *
 * ContainsReferencesToRelidsWalker recursively descends into subqueries
 * and increases the level by 1 before recursing.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsReferencesToRelidsWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RelidsReferenceWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>level</name></name> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>,
																<argument><expr><name><name>context</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>foundRelid</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * TODO: Only return true when aggref points to an aggregate that
			 * uses vars from a recurring tuple.
			 */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * TODO: Only return true when groupingfunc points to a grouping
			 * func that uses vars from a recurring tuple.
			 */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>phlevelsup</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * TODO: Only return true when aggref points to a placeholdervar
			 * that uses vars from a recurring tuple.
			 */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>ContainsReferencesToRelidsWalker</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><name>found</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ContainsReferencesToRelidsWalker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferredErrorIfUnsupportedLateralSubquery returns true if
 * notFullyRecurringRelids contains a lateral subquery that we do not support.
 *
 * If there is an inner join with a lateral subquery we cannot
 * push it down when the following properties all hold:
 * 1. The lateral subquery contains some non recurring tuples
 * 2. The lateral subquery references a recurring tuple from
 *    outside of the subquery (recurringRelids)
 * 3. The lateral subquery requires a merge step (e.g. a LIMIT)
 * 4. The reference to the recurring tuple should be something else than an
 *    equality check on the distribution column, e.g. equality on a non
 *    distribution column.
 *
 * Property number four is considered both hard to detect and
 * probably not used very often, so we only check for 1, 2 and 3.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferredErrorIfUnsupportedLateralSubquery</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>plannerInfo</name></decl></parameter>,
										  <parameter><decl><type><name>Relids</name></type> <name>recurringRelids</name></decl></parameter>,
										  <parameter><decl><type><name>Relids</name></type> <name>notFullyRecurringRelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>relationId</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>relationId</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>notFullyRecurringRelids</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name><name>plannerInfo</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>relationId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* TODO: What about others kinds? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* property number 1, contains non-recurring tuples */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(
					<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IsDistributedTableRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* property number 2, references recurring tuple */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>recurringRelid</name> <init>= <expr><name>INVALID_RELID</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ContainsReferencesToRelids</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>recurringRelids</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>recurringRelid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>recurTypeDescription</name> <init>=
				<expr><literal type="string">"an aggregate, grouping func or placeholder var coming from the outer query"</literal></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>recurringRelid</name> <operator>!=</operator> <name>INVALID_RELID</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>recurringRangeTableEntry</name> <init>=
					<expr><name><name>plannerInfo</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>recurringRelid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RecurringTuplesType</name></type> <name>recurType</name> <init>= <expr><name>RECURRING_TUPLES_INVALID</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ContainsRecurringRTE</name><argument_list>(<argument><expr><name>recurringRangeTableEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recurType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>recurTypeDescription</name> <operator>=</operator> <call><name>RecurringTypeDescription</name><argument_list>(<argument><expr><name>recurType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Add the alias for all recuring tuples where it is useful to
				 * see them. We don't add it for VALUES and intermediate
				 * results, because there the aliases are currently hardcoded
				 * strings anyway.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>recurType</name> <operator>!=</operator> <name>RECURRING_TUPLES_VALUES</name> <operator>&amp;&amp;</operator>
					<name>recurType</name> <operator>!=</operator> <name>RECURRING_TUPLES_RESULT_FUNCTION</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>recurTypeDescription</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s (%s)"</literal></expr></argument>, <argument><expr><name>recurTypeDescription</name></expr></argument>,
													<argument><expr><name><name>recurringRangeTableEntry</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator>
													<name>aliasname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* property number 3, has a merge step */</comment>
			<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>deferredError</name> <init>= <expr><call><name>DeferErrorIfSubqueryRequiresMerge</name><argument_list>(
				<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>recurTypeDescription</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>deferredError</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>deferredError</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FetchFirstRecurType checks whether the relationInfo
 * contains any recurring table expression, namely a reference table,
 * or immutable function. If found, FetchFirstRecurType
 * returns true.
 *
 * Note that since relation ids of relationInfo indexes to the range
 * table entry list of planner info, planner info is also passed.
 */</comment>
<function><type><specifier>static</specifier> <name>RecurringTuplesType</name></type>
<name>FetchFirstRecurType</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>plannerInfo</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecurringTuplesType</name></type> <name>recurType</name> <init>= <expr><name>RECURRING_TUPLES_INVALID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>relationId</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>relationId</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name><name>plannerInfo</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>relationId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* relationInfo has this range table entry */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ContainsRecurringRTE</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recurType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>recurType</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>recurType</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsRecurringRTE returns whether the range table entry contains
 * any entry that generates the same set of tuples when repeating it in
 * a query on different shards.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsRecurringRTE</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>RecurringTuplesType</name> <modifier>*</modifier></type><name>recurType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ContainsRecurringRangeTable</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>recurType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsRecurringRangeTable returns whether the range table list contains
 * any entry that generates the same set of tuples when repeating it in
 * a query on different shards.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsRecurringRangeTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTable</name></decl></parameter>, <parameter><decl><type><name>RecurringTuplesType</name> <modifier>*</modifier></type><name>recurType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>range_table_walker</name><argument_list>(<argument><expr><name>rangeTable</name></expr></argument>, <argument><expr><name>HasRecurringTuples</name></expr></argument>, <argument><expr><name>recurType</name></expr></argument>,
							  <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasRecurringTuples returns whether any part of the expression will generate
 * the same set of tuples in every query on shards when executing a distributed
 * query.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasRecurringTuples</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RecurringTuplesType</name> <modifier>*</modifier></type><name>recurType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>recurType</name> <operator>=</operator> <name>RECURRING_TUPLES_REFERENCE_TABLE</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Tuples from reference tables will recur in every query on shards
				 * that includes it.
				 */</comment>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionList</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>functions</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>functionList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>ContainsReadIntermediateResultFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>functionList</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>recurType</name> <operator>=</operator> <name>RECURRING_TUPLES_RESULT_FUNCTION</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>recurType</name> <operator>=</operator> <name>RECURRING_TUPLES_FUNCTION</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Tuples from functions will recur in every query on shards that includes
			 * it.
			 */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RESULT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>recurType</name> <operator>=</operator> <name>RECURRING_TUPLES_EMPTY_JOIN_TREE</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>recurType</name> <operator>=</operator> <name>RECURRING_TUPLES_VALUES</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HasEmptyJoinTree</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>recurType</name> <operator>=</operator> <name>RECURRING_TUPLES_EMPTY_JOIN_TREE</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Queries with empty join trees will recur in every query on shards
			 * that includes it.
			 */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>HasRecurringTuples</name></expr></argument>,
								 <argument><expr><name>recurType</name></expr></argument>, <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>HasRecurringTuples</name></expr></argument>, <argument><expr><name>recurType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SubqueryPushdownMultiNodeTree creates logical plan for subquery pushdown logic.
 * Note that this logic will be changed in next iterations, so we decoupled it
 * from other parts of code although it causes some code duplication.
 *
 * Current subquery pushdown support in MultiTree logic requires a single range
 * table entry in the top most from clause. Therefore we inject a synthetic
 * query derived from the top level query and make it the only range table
 * entry for the top level query. This way we can push down any subquery joins
 * down to workers without invoking join order planner.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiNode</name> <modifier>*</modifier></type>
<name>SubqueryPushdownMultiNodeTree</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiCollect</name> <modifier>*</modifier></type><name>subqueryCollectNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiCollect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* verify we can perform distributed planning on this query */</comment>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>unsupportedQueryError</name> <init>= <expr><call><name>DeferErrorIfQueryNotSupported</name><argument_list>(
		<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>unsupportedQueryError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>unsupportedQueryError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We would be creating a new Query and pushing down top level query's
	 * contents down to it. Join and filter clauses in higher level query would
	 * be transferred to lower query. Therefore after this function we would
	 * only have a single range table entry in the top level query. We need to
	 * create a target list entry in lower query for each column reference in
	 * upper level query's target list and having clauses. Any column reference
	 * in the upper query will be updated to have varno=1, and varattno=&lt;resno&gt;
	 * of matching target entry in pushed down query.
	 * Consider query
	 *      SELECT s1.a, sum(s2.c)
	 *      FROM (some subquery) s1, (some subquery) s2
	 *      WHERE s1.a = s2.a
	 *      GROUP BY s1.a
	 *      HAVING avg(s2.b);
	 *
	 * We want to prepare a multi tree to avoid subquery joins at top level,
	 * therefore above query is converted to an equivalent
	 *      SELECT worker_column_0, sum(worker_column_1)
	 *      FROM (
	 *              SELECT
	 *                  s1.a AS worker_column_0,
	 *                  s2.c AS worker_column_1,
	 *                  s2.b AS worker_column_2
	 *              FROM (some subquery) s1, (some subquery) s2
	 *              WHERE s1.a = s2.a) worker_subquery
	 *      GROUP BY worker_column_0
	 *      HAVING avg(worker_column_2);
	 *  After this conversion MultiTree is created as follows
	 *
	 *  MultiExtendedOpNode(
	 *      targetList : worker_column_0, sum(worker_column_1)
	 *      groupBy : worker_column_0
	 *      having :  avg(worker_column_2))
	 * ---&gt;MultiProject (worker_column_0, worker_column_1, worker_column_2)
	 * ---&gt;---&gt;	MultiTable (subquery : worker_subquery)
	 *
	 * Master and worker queries will be created out of this MultiTree at later stages.
	 */</comment>

	<comment type="block">/*
	 * columnList contains all columns returned by subquery. Subquery target
	 * entry list, subquery range table entry's column name list are derived from
	 * columnList. Columns mentioned in multiProject node and multiExtendedOp
	 * node are indexed with their respective position in columnList.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetColumnList</name> <init>= <expr><call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetEntryList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>havingClauseColumnList</name> <init>= <expr><call><name>pull_var_clause_default</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>targetColumnList</name></expr></argument>, <argument><expr><name>havingClauseColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create a target entry for each unique column */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subqueryTargetEntryList</name> <init>= <expr><call><name>CreateSubqueryTargetListAndAdjustVars</name><argument_list>(<argument><expr><name>columnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* new query only has target entries, join tree, and rtable*/</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>pushedDownQuery</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>pushedDownQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pushedDownQuery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>subqueryTargetEntryList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pushedDownQuery</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pushedDownQuery</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pushedDownQuery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pushedDownQuery</name><operator>-&gt;</operator><name>querySource</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>querySource</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pushedDownQuery</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>subqueryNode</name> <init>= <expr><call><name>MultiSubqueryPushdownTable</name><argument_list>(<argument><expr><name>pushedDownQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>subqueryCollectNode</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>subqueryNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>MultiNode</name> <modifier>*</modifier></type><name>currentTopNode</name> <init>= <expr><operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>subqueryCollectNode</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build project node for the columns to project */</comment>
	<decl_stmt><decl><type><name>MultiProject</name> <modifier>*</modifier></type><name>projectNode</name> <init>= <expr><call><name>MultiProjectNode</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>projectNode</name></expr></argument>, <argument><expr><name>currentTopNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentTopNode</name> <operator>=</operator> <operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>projectNode</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We build the extended operator node to capture aggregate functions, group
	 * clauses, sort clauses, limit/offset clauses, and expressions. We need to
	 * distinguish between aggregates and expressions; and we address this later
	 * in the logical optimizer.
	 */</comment>
	<decl_stmt><decl><type><name>MultiExtendedOp</name> <modifier>*</modifier></type><name>extendedOpNode</name> <init>= <expr><call><name>MultiExtendedOpNode</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Postgres standard planner converts having qual node to a list of and
	 * clauses and expects havingQual to be of type List when executing the
	 * query later. This function is called on an original query, therefore
	 * havingQual has not been converted yet. Perform conversion here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator>
			<operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>extendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Group by on primary key allows all columns to appear in the target
	 * list, but once we wrap the join tree into a subquery the GROUP BY
	 * will no longer directly refer to the primary key and referencing
	 * columns that are not in the GROUP BY would result in an error. To
	 * prevent that we wrap all the columns that do not appear in the
	 * GROUP BY in an any_value aggregate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>groupClauseList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>WrapUngroupedVarsInAnyValueAggregate</name><argument_list>(
			<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>extendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
			<argument><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>groupClauseList</name></name></expr></argument>,
			<argument><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <call><name>WrapUngroupedVarsInAnyValueAggregate</name><argument_list>(
			<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>extendedOpNode</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
			<argument><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>groupClauseList</name></name></expr></argument>,
			<argument><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Postgres standard planner evaluates expressions in the LIMIT/OFFSET clauses.
	 * Since we're using original query here, we should manually evaluate the
	 * expression on the LIMIT and OFFSET clauses. Note that logical optimizer
	 * expects those clauses to be already evaluated.
	 */</comment>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator>
		<call><name>PartiallyEvaluateExpression</name><argument_list>(<argument><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator>
		<call><name>PartiallyEvaluateExpression</name><argument_list>(<argument><expr><name><name>extendedOpNode</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetChild</name><argument_list>(<argument><expr><operator>(</operator><name>MultiUnaryNode</name> <operator>*</operator><operator>)</operator> <name>extendedOpNode</name></expr></argument>, <argument><expr><name>currentTopNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentTopNode</name> <operator>=</operator> <operator>(</operator><name>MultiNode</name> <operator>*</operator><operator>)</operator> <name>extendedOpNode</name></expr>;</expr_stmt>

	<return>return <expr><name>currentTopNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateSubqueryTargetListAndAdjustVars creates a target entry for each unique
 * column in the column list, adjusts the columns to point into the subquery target
 * list and returns the new subquery target list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CreateSubqueryTargetListAndAdjustVars</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subqueryTargetEntryList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>column</argument>, <argument>columnList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * To avoid adding the same column multiple times, we first check whether there
		 * is already a target entry containing a Var with the given varno and varattno.
		 */</comment>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>resNo</name> <init>= <expr><call><name>FindResnoForVarInTargetList</name><argument_list>(<argument><expr><name>subqueryTargetEntryList</name></expr></argument>,
													   <argument><expr><name><name>column</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>column</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>resNo</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Var is not yet on the target list, create a new entry */</comment>
			<expr_stmt><expr><name>resNo</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subqueryTargetEntryList</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * The join tree in the subquery is an exact duplicate of the original
			 * query. Hence, we can make a copy of the original Var. However, if the
			 * original Var was in a sublink it would be pointing up whereas now it
			 * will be placed directly on the target list. Hence we reset the
			 * varlevelsup.
			 */</comment>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>subqueryTargetListVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>subqueryTargetListVar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newTargetEntry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>subqueryTargetListVar</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>WorkerColumnName</name><argument_list>(<argument><expr><name>resNo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>resNo</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>subqueryTargetEntryList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subqueryTargetEntryList</name></expr></argument>, <argument><expr><name>newTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Change the original column reference to point to the target list
		 * entry in the subquery. There is only 1 subquery, so the varno is 1.
		 */</comment>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>resNo</name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>subqueryTargetEntryList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindResnoForVarInTargetList finds a Var on a target list that has the given varno
 * (range table entry number) and varattno (column number) and returns the resno
 * of the target list entry.
 */</comment>
<function><type><specifier>static</specifier> <name>AttrNumber</name></type>
<name>FindResnoForVarInTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varattno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetEntryVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>targetEntryVar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>varno</name> <operator>&amp;&amp;</operator> <name><name>targetEntryVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>varattno</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resno</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>InvalidAttrNumber</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MultiSubqueryPushdownTable creates a MultiTable from the given subquery,
 * populates column list and returns the multitable.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiTable</name> <modifier>*</modifier></type>
<name>MultiSubqueryPushdownTable</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>rteName</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNamesList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>targetEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>rteName</name></expr></argument>, <argument><expr><literal type="string">"worker_subquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>subquery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>columnNamesList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columnNamesList</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>MultiTable</name> <modifier>*</modifier></type><name>subqueryTableNode</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>MultiTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>subqueryTableNode</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>subquery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTableNode</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name>SUBQUERY_PUSHDOWN_RELATION_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTableNode</name><operator>-&gt;</operator><name>rangeTableId</name></name> <operator>=</operator> <name>SUBQUERY_RANGE_TABLE_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTableNode</name><operator>-&gt;</operator><name>partitionColumn</name></name> <operator>=</operator> <call><name>PartitionColumnForPushedDownSubquery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTableNode</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTableNode</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name> <operator>=</operator> <name><name>rteName</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTableNode</name><operator>-&gt;</operator><name>referenceNames</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTableNode</name><operator>-&gt;</operator><name>referenceNames</name><operator>-&gt;</operator><name>aliasname</name></name> <operator>=</operator> <name><name>rteName</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subqueryTableNode</name><operator>-&gt;</operator><name>referenceNames</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>columnNamesList</name></expr>;</expr_stmt>

	<return>return <expr><name>subqueryTableNode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PartitionColumnForPushedDownSubquery finds the partition column on the target
 * list of a pushed down subquery.
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>PartitionColumnForPushedDownSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>targetEntry</argument>, <argument>targetEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>targetExpression</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>targetExpression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>skipOuterVars</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>isPartitionColumn</name> <init>= <expr><call><name>IsPartitionColumn</name><argument_list>(<argument><expr><name>targetExpression</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
													   <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>isPartitionColumn</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>targetExpression</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* the pushed down subquery is the only range table entry */</comment>
				<expr_stmt><expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

				<comment type="block">/* point the var to the position in the subquery target list */</comment>
				<expr_stmt><expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>

				<return>return <expr><name>partitionColumn</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
