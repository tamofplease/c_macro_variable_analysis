<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/planner/multi_router_planner.c">
<comment type="block">/*-------------------------------------------------------------------------
 *
 * multi_router_planner.c
 *
 * This file contains functions to plan multiple shard queries without any
 * aggregation step including distributed table modifications.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distribution_column.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/insert_select_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_result_pruning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_pushdown_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_restriction_equivalence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relay_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/recursive_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shardinterval_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_pruning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/joininfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/errcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>

<comment type="block">/* intermediate value for INSERT processing */</comment>
<typedef>typedef <type><struct>struct <name>InsertValues</name>
<block>{
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>partitionValueExpr</name></decl>;</decl_stmt> <comment type="block">/* partition value provided in INSERT row */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rowValues</name></decl>;</decl_stmt>          <comment type="block">/* full values list of INSERT row, possibly NIL */</comment>
	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name></decl>;</decl_stmt>            <comment type="block">/* target shard for this row, possibly invalid */</comment>
	<decl_stmt><decl><type><name>Index</name></type> <name>listIndex</name></decl>;</decl_stmt>          <comment type="block">/* index to make our sorting stable */</comment>
}</block></struct></type> <name>InsertValues</name>;</typedef>


<comment type="block">/*
 * A ModifyRoute encapsulates the information needed to route modifications
 * to the appropriate shard. For a single-shard modification, only one route
 * is needed, but in the case of e.g. a multi-row INSERT, lists of these values
 * will help divide the rows by their destination shards, permitting later
 * shard-and-row-specific extension of the original SQL.
 */</comment>
<typedef>typedef <type><struct>struct <name>ModifyRoute</name>
<block>{
	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name></decl>;</decl_stmt>        <comment type="block">/* identifier of target shard */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rowValuesLists</name></decl>;</decl_stmt> <comment type="block">/* for multi-row INSERTs, list of rows to be inserted */</comment>
}</block></struct></type> <name>ModifyRoute</name>;</typedef>


<typedef>typedef <type><struct>struct <name>WalkerState</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type> <name>containsVar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>varArgument</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>badCoalesce</name></decl>;</decl_stmt>
}</block></struct></type> <name>WalkerState</name>;</typedef>

<decl_stmt><decl><type><name>bool</name></type> <name>EnableRouterExecution</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* planner functions forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateSingleTaskRouterSelectPlan</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name></decl></parameter>,
											 <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
											 <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
											 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
											 <name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ResultRelationOidForQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTidColumn</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>ModifyPartialQuerySupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
														  <name>multiShardQuery</name></decl></parameter>,
														  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>distributedTableId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NodeIsFieldStore</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>MultiShardUpdateDeleteMergeSupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
																   <parameter><decl><type><name>PlannerRestrictionContext</name>
																   <modifier>*</modifier></type>
																   <name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>SingleShardUpdateDeleteSupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
															   <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
															   <name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasDangerousJoinUsing</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtableList</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MasterIrreducibleExpression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>varArgument</name></decl></parameter>,
										<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>badCoalesce</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MasterIrreducibleExpressionWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>, <parameter><decl><type><name>WalkerState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MasterIrreducibleExpressionFunctionChecker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TargetEntryChangesValue</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name></decl></parameter>,
									<parameter><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>joinTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type> <name>RouterInsertJob</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfNoShardsExist</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfModifyView</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type> <name>CreateJob</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type> <name>CreateTask</name><parameter_list>(<parameter><decl><type><name>TaskType</name></type> <name>taskType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type> <name>RouterJob</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
					   <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>,
					   <parameter><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>planningError</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RelationPrunesToMultipleShards</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>NormalizeMultiRowInsertTargetList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendNextDummyColReference</name><parameter_list>(<parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>expendedReferenceNames</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type> <name>MakeDummyColumnString</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dummyColumnId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>BuildRoutesForInsert</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>planningError</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GroupInsertValuesByShardId</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertValuesList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ExtractInsertValuesList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfUnsupportedRouterPlannableSelectQuery</name><parameter_list>(
	<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>ErrorIfQueryHasUnroutableModifyingCTE</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>ErrorIfQueryHasCTEWithSearchClause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsSearchClauseWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SelectsFromDistributedTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type> <name>CreateDummyPlacement</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>hasLocalRelation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type> <name>CreateLocalDummyPlacement</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareInsertValuesByShardId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>SingleShardTaskList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name></decl></parameter>,
								  <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parametersInQueryResolved</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>isLocalTableModification</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RowLocksOnRelations</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>rtiLockList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReorderTaskPlacementsByTaskAssignmentPolicy</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>,
														<parameter><decl><type><name>TaskAssignmentPolicyType</name></type>
														<name>taskAssignmentPolicy</name></decl></parameter>,
														<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ModifiesLocalTableWithRemoteCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>DeferErrorIfUnsupportedLocalTableJoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsLocallyAccessibleCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * CreateRouterPlan attempts to create a router executor plan for the given
 * SELECT statement. -&gt;planningError is set if planning fails.
 */</comment>
<function><type><name>DistributedPlan</name> <modifier>*</modifier></type>
<name>CreateRouterPlan</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
				 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>DistributedPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>=</operator> <call><name>DeferErrorIfUnsupportedRouterPlannableSelectQuery</name><argument_list>(
		<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CreateSingleTaskRouterSelectPlan</name><argument_list>(<argument><expr><name>distributedPlan</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
										 <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>fastPathRouterPlan</name></name> <operator>=</operator>
		<name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name><operator>-&gt;</operator><name>fastPathRouterQuery</name></name></expr>;</expr_stmt>

	<return>return <expr><name>distributedPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateModifyPlan attempts to create a plan for the given modification
 * statement. If planning fails -&gt;planningError is set to a description of
 * the failure.
 */</comment>
<function><type><name>DistributedPlan</name> <modifier>*</modifier></type>
<name>CreateModifyPlan</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
				 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>DistributedPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>multiShardQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>originalQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>modLevel</name></name> <operator>=</operator> <call><name>RowModifyLevelForQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>=</operator> <call><name>ModifyQuerySupported</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>,
														  <argument><expr><name>multiShardQuery</name></expr></argument>,
														  <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>distributedPlan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>UpdateOrDeleteOrMergeQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>job</name> <operator>=</operator> <call><name>RouterJob</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>job</name> <operator>=</operator> <call><name>RouterInsertJob</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>distributedPlan</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Creating router plan"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>workerJob</name></name> <operator>=</operator> <name>job</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>combineQuery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>expectResults</name></name> <operator>=</operator> <name><name>originalQuery</name><operator>-&gt;</operator><name>returningList</name></name> <operator>!=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>targetRelationId</name></name> <operator>=</operator> <call><name>ResultRelationOidForQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>fastPathRouterPlan</name></name> <operator>=</operator>
		<name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name><operator>-&gt;</operator><name>fastPathRouterQuery</name></name></expr>;</expr_stmt>


	<return>return <expr><name>distributedPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateSingleTaskRouterSelectPlan creates a physical plan for given SELECT query.
 * The returned plan is a router task that returns query results from a single worker.
 * If not router plannable, the returned plan's planningError describes the problem.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateSingleTaskRouterSelectPlan</name><parameter_list>(<parameter><decl><type><name>DistributedPlan</name> <modifier>*</modifier></type><name>distributedPlan</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
								 <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
								 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>modLevel</name></name> <operator>=</operator> <call><name>RowModifyLevelForQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>RouterJob</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>planningError</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* query cannot be handled by this planner */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Creating router plan"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>workerJob</name></name> <operator>=</operator> <name>job</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>combineQuery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedPlan</name><operator>-&gt;</operator><name>expectResults</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShardIntervalOpExpressions returns a list of OpExprs with exactly two
 * items in it. The list consists of shard interval ranges with partition columns
 * such as (partitionColumn &gt;= shardMinValue) and (partitionColumn &lt;= shardMaxValue).
 *
 * The function returns hashed columns generated by MakeInt4Column() for the hash
 * partitioned tables in place of partition columns.
 *
 * The function returns NIL if shard interval does not belong to a hash,
 * range and append distributed tables.
 *
 * NB: If you update this, also look at PrunableExpressionsWalker().
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ShardIntervalOpExpressions</name><parameter_list>(<parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rteIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionColumn</name> <operator>=</operator> <call><name>MakeInt4Column</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsCitusTableType</name><argument_list>(
				 <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rteIndex</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partitionColumn</name> <operator>=</operator> <call><name>PartitionColumn</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>rteIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* do not add any shard range interval for reference tables */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* build the base expression for constraint */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>baseConstraint</name> <init>= <expr><call><name>BuildBaseConstraint</name><argument_list>(<argument><expr><name>partitionColumn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* walk over shard list and check if shards can be pruned */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>shardInterval</name><operator>-&gt;</operator><name>minValueExists</name></name> <operator>&amp;&amp;</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>maxValueExists</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UpdateConstraint</name><argument_list>(<argument><expr><name>baseConstraint</name></expr></argument>, <argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>baseConstraint</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddPartitionKeyNotNullFilterToSelect adds the following filters to a subquery:
 *
 *    partitionColumn IS NOT NULL
 *
 * The function expects and asserts that subquery's target list contains a partition
 * column value. Thus, this function should never be called with reference tables.
 */</comment>
<function><type><name>void</name></type>
<name>AddPartitionKeyNotNullFilterToSelect</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subqery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name><name>subqery</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>targetEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetPartitionColumnVar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* iterate through the target entries */</comment>
	<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>skipOuterVars</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsPartitionColumn</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>subqery</name></expr></argument>, <argument><expr><name>skipOuterVars</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>targetPartitionColumnVar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* we should have found target partition column */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetPartitionColumnVar</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create expression for partition_column IS NOT NULL */</comment>
	<decl_stmt><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>nullTest</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>nullTest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nullTest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>targetPartitionColumnVar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nullTest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* finally add the quals */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subqery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>subqery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>nullTest</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>subqery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>make_and_qual</name><argument_list>(<argument><expr><name><name>subqery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
												 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>nullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractSelectRangeTableEntry returns the range table entry of the subquery.
 * Note that the function expects and asserts that the input query be
 * an INSERT...SELECT query.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>ExtractSelectRangeTableEntry</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>InsertSelectIntoCitusTable</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>InsertSelectIntoLocalTable</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we already asserted InsertSelectIntoCitusTable() it is safe to access
	 * both lists
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fromList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>reference</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>fromList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subqueryRte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>reference</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>subqueryRte</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ModifyQueryResultRelationId returns the result relation's Oid
 * for the given modification query.
 *
 * The function errors out if the input query is not a
 * modify query (e.g., INSERT, UPDATE or DELETE). So, this
 * function is not expected to be called on SELECT queries.
 */</comment>
<function><type><name>Oid</name></type>
<name>ModifyQueryResultRelationId</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* only modify queries have result relations */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsModifyCommand</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"input query is not a modification query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>resultRte</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>resultRte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>resultRte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResultRelationOidForQuery returns the OID of the relation this is modified
 * by a given query.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ResultRelationOidForQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>resultRTE</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>resultRTE</name><operator>-&gt;</operator><name>relid</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractResultRelationRTE returns the table's resultRelation range table
 * entry. This returns NULL when there's no resultRelation, such as in a SELECT
 * query.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>ExtractResultRelationRTE</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractResultRelationRTEOrError returns the table's resultRelation range table
 * entry and errors out if there's no result relation at all, e.g. like in a
 * SELECT query.
 *
 * This is a separate function (instead of using missingOk), so static analysis
 * reasons about NULL returns correctly.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>ExtractResultRelationRTEOrError</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no result relation could be found for the query"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"is this a SELECT query?"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>relation</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsTidColumn gets a node and returns true if the node is a Var type of TID.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTidColumn</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>TIDOID</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ModifyPartialQuerySupported implements a subset of what ModifyQuerySupported checks,
 * that subset being what's necessary to check modifying CTEs for.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>ModifyPartialQuerySupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>multiShardQuery</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>distributedTableIdOutput</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>deferredError</name> <init>= <expr><call><name>DeferErrorIfModifyView</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>deferredError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>deferredError</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type> <name>commandType</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>deferredError</name> <operator>=</operator> <call><name>DeferErrorIfUnsupportedLocalTableJoin</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>deferredError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>deferredError</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reject subqueries which are in SELECT or WHERE clause.
	 * Queries which include subqueries in FROM clauses are rejected below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>==</operator> <name>true</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we support subqueries for INSERTs only via INSERT INTO ... SELECT */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UpdateOrDeleteOrMergeQuery</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"subqueries are not supported within INSERT queries"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"Try rewriting your queries with 'INSERT "</literal>
									   <literal type="string">"INTO ... SELECT' syntax."</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* reject queries which include CommonTableExpr which aren't routable */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>cteList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cteCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* CTEs still not supported for INSERTs. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"Router planner doesn't support common table expressions with INSERT queries."</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cteCell</argument>, <argument>queryTree-&gt;cteList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cteCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>cteQuery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cteQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Modifying CTEs still not supported for multi shard queries. */</comment>
				<if_stmt><if>if <condition>(<expr><name>multiShardQuery</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
										 <argument><expr><literal type="string">"Router planner doesn't support non-select common table expressions with multi shard queries."</literal></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if>
				<comment type="block">/* Modifying CTEs exclude both INSERT CTEs &amp; INSERT queries. */</comment>
				<if type="elseif">else if <condition>(<expr><name><name>cteQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
										 <argument><expr><literal type="string">"Router planner doesn't support INSERT common table expressions."</literal></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cteQuery</name><operator>-&gt;</operator><name>hasForUpdate</name></name> <operator>&amp;&amp;</operator>
				<call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(<argument><expr><name><name>cteQuery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
															  <argument><expr><name>IsReferenceTableRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"Router planner doesn't support SELECT FOR UPDATE"</literal>
									 <literal type="string">" in common table expressions involving reference tables."</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cteQuery</name></expr></argument>, <argument><expr><name>CitusIsVolatileFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"Router planner doesn't support VOLATILE functions"</literal>
									 <literal type="string">" in common table expressions."</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cteQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>cteError</name> <init>=
					<expr><call><name>DeferErrorIfUnsupportedRouterPlannableSelectQuery</name><argument_list>(<argument><expr><name>cteQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>cteError</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>cteError</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>


	<decl_stmt><decl><type><name>Oid</name></type> <name>resultRelationId</name> <init>= <expr><call><name>ModifyQueryResultRelationId</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>distributedTableIdOutput</name> <operator>=</operator> <name>resultRelationId</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rangeTableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>resultRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionColumn</name> <operator>=</operator> <call><name>PartitionColumn</name><argument_list>(<argument><expr><name>resultRelationId</name></expr></argument>, <argument><expr><name>rangeTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>commandType</name> <operator>=</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
		<name>commandType</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>hasVarArgument</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* A STABLE function is passed a Var argument */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>hasBadCoalesce</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* CASE/COALESCE passed a mutable function */</comment>
		<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>joinTree</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>targetEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>queryTree-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* skip resjunk entries: UPDATE adds some for ctid, etc. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>targetEntryPartitionColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>targetColumnAttrNumber</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* reference tables do not have partition column */</comment>
			<if_stmt><if>if <condition>(<expr><name>partitionColumn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>targetEntryPartitionColumn</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Note that it is not possible to give an alias to
					 * UPDATE table SET ...
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>targetColumnAttrNumber</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>resultRelationId</name></expr></argument>,
															<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>targetColumnAttrNumber</name> <operator>==</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>targetEntryPartitionColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>


			<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
				<call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
											  <argument><expr><name>CitusIsVolatileFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"functions used in UPDATE queries on distributed "</literal>
									 <literal type="string">"tables must not be VOLATILE"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator> <name>targetEntryPartitionColumn</name> <operator>&amp;&amp;</operator>
				<call><name>TargetEntryChangesValue</name><argument_list>(<argument><expr><name>targetEntry</name></expr></argument>, <argument><expr><name>partitionColumn</name></expr></argument>,
										<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"modifying the partition value of rows is not "</literal>
									 <literal type="string">"allowed"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
				<call><name>MasterIrreducibleExpression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>hasVarArgument</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasBadCoalesce</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hasVarArgument</name> <operator>||</operator> <name>hasBadCoalesce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
											  <argument><expr><name>NodeIsFieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* DELETE cannot do field indirection already */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>commandType</name> <operator>==</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"inserting or modifying composite type fields is not "</literal>
									 <literal type="string">"supported"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><literal type="string">"Use the column name to insert or update the composite "</literal>
									 <literal type="string">"type as a single value"</literal></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>joinTree</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>joinTree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
											  <argument><expr><name>CitusIsVolatileFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"functions used in the WHERE clause of modification "</literal>
									 <literal type="string">"queries on distributed tables must not be VOLATILE"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>MasterIrreducibleExpression</name><argument_list>(<argument><expr><name><name>joinTree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasVarArgument</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>hasBadCoalesce</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>hasVarArgument</name> <operator>||</operator> <name>hasBadCoalesce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>hasVarArgument</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"STABLE functions used in UPDATE queries "</literal>
								 <literal type="string">"cannot be called with column references"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>hasBadCoalesce</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"non-IMMUTABLE functions are not allowed in CASE or "</literal>
								 <literal type="string">"COALESCE statements"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"non-IMMUTABLE functions are not allowed in the "</literal>
								 <literal type="string">"RETURNING clause"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>nodeTag</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_CurrentOfExpr</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot run DML queries with cursors"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>deferredError</name> <operator>=</operator> <call><name>ErrorIfOnConflictNotSupported</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>deferredError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>deferredError</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/* set it for caller to use when we don't return any errors */</comment>
	<expr_stmt><expr><operator>*</operator><name>distributedTableIdOutput</name> <operator>=</operator> <name>resultRelationId</name></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfUnsupportedLocalTableJoin returns an error message
 * if there is an unsupported join in the given range table list.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfUnsupportedLocalTableJoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ModifiesLocalTableWithRemoteCitusLocalTable</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"Modifying local tables with remote local tables is "</literal>
							 <literal type="string">"not supported."</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><literal type="string">"Consider wrapping remote local table to a CTE, or subquery"</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ModifiesLocalTableWithRemoteCitusLocalTable returns true if a local
 * table is modified with a remote citus local table. This could be a case with
 * MX structure.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ModifiesLocalTableWithRemoteCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>containsLocalResultRelation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>containsRemoteCitusLocalTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>rangeTableEntry</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsRecursivelyPlannableRelation</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsLocallyAccessibleCitusLocalTable</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>containsRemoteCitusLocalTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>containsLocalResultRelation</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>containsLocalResultRelation</name> <operator>&amp;&amp;</operator> <name>containsRemoteCitusLocalTable</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsLocallyAccessibleCitusLocalTable returns true if the given table
 * is a citus local table that can be accessed using local execution.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsLocallyAccessibleCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Citus local tables should always have exactly one shard, but we have
	 * this check for safety.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>localShardPlacement</name> <init>=
		<expr><call><name>ActiveShardPlacementOnGroup</name><argument_list>(<argument><expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>localShardPlacement</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeIsFieldStore returns true if given Node is a FieldStore object.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NodeIsFieldStore</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ModifyQuerySupported returns NULL if the query only contains supported
 * features, otherwise it returns an error description.
 * Note that we need both the original query and the modified one because
 * different checks need different versions. In particular, we cannot
 * perform the ContainsReadIntermediateResultFunction check on the
 * rewritten query because it may have been replaced by a subplan,
 * while some of the checks for setting the partition column value rely
 * on the rewritten query.
 */</comment>
<function><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>ModifyQuerySupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>multiShardQuery</name></decl></parameter>,
					 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>ModifyPartialQuerySupported</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>, <argument><expr><name>multiShardQuery</name></expr></argument>,
															  <argument><expr><operator>&amp;</operator><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>error</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>queryTableCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type> <name>commandType</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>fastPathRouterQuery</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name><operator>-&gt;</operator><name>fastPathRouterQuery</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Here, we check if a recursively planned query tries to modify
	 * rows based on the ctid column. This is a bad idea because ctid of
	 * the rows could be changed before the modification part of
	 * the query is executed.
	 *
	 * We can exclude fast path queries since they cannot have intermediate
	 * results by definition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fastPathRouterQuery</name> <operator>&amp;&amp;</operator>
		<call><name>ContainsReadIntermediateResultFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>hasTidColumn</name> <init>= <expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(
			<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>originalQuery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>IsTidColumn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hasTidColumn</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot perform distributed planning for the given "</literal>
								 <literal type="string">"modification"</literal></expr></argument>,
								 <argument><expr><literal type="string">"Recursively planned distributed modifications "</literal>
								 <literal type="string">"with ctid on where clause are not supported."</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Extract range table entries for queries that are not fast path. We can skip fast
	 * path queries because their definition is a single RTE entry, which is a relation,
	 * so the following check doesn't apply for fast-path queries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fastPathRouterQuery</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExtractRangeTableEntryWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalQuery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>containsLocalTableDistributedTableJoin</name> <init>=
		<expr><call><name>ContainsLocalTableDistributedTableJoin</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>rangeTableEntry</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we do not expect to see a view in modify query */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * we already check if modify is run on a view in DeferErrorIfModifyView
				 * function call. In addition, since Postgres replaced views in FROM
				 * clause with subqueries, encountering with a view should not be a problem here.
				 */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsMergeAllowedOnRelation</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<continue>continue;</continue>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
										 <argument><expr><literal type="string">"materialized views in "</literal>
										 <literal type="string">"modify queries are not supported"</literal></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<comment type="block">/* for other kinds of relations, check if its distributed */</comment>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsRelationLocalTableOrMatView</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name>containsLocalTableDistributedTableJoin</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>StringInfo</name></type> <name>errorMessage</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>,
										 <argument><expr><literal type="string">"local table %s cannot be joined with these distributed tables"</literal></expr></argument>,
										 <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><literal type="string">"relation %s is not distributed"</literal></expr></argument>,
										 <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
										 <argument><expr><name><name>errorMessage</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>queryTableCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name> <operator>||</operator>
				 <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RESULT</name></expr>
				 )</condition>
		<block>{<block_content>
			<comment type="block">/* do nothing, this type is supported */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rangeTableEntryErrorDetail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We support UPDATE, DELETE and MERGE with subqueries and joins unless
			 * they are multi shard queries.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>UpdateOrDeleteOrMergeQuery</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Error out for rangeTableEntries that we do not support.
			 * We do not explicitly specify "in FROM clause" in the error detail
			 * for the features that we do not support at all (SUBQUERY, JOIN).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StringInfo</name></type> <name>errorHint</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(
					<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionColumnName</name> <init>=
					<expr><call><name>ColumnToColumnName</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorHint</name></expr></argument>, <argument><expr><literal type="string">"Consider using an equality filter on "</literal>
											<literal type="string">"partition column \"%s\" to target a single shard."</literal></expr></argument>,
								 <argument><expr><name>partitionColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>, <argument><expr><literal type="string">"subqueries are not "</literal>
																	<literal type="string">"supported in modifications across multiple shards"</literal></expr></argument>,
									 <argument><expr><name><name>errorHint</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rangeTableEntryErrorDetail</name> <operator>=</operator> <literal type="string">"Joins are not supported in distributed"</literal>
											 <literal type="string">" modifications."</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rangeTableEntryErrorDetail</name> <operator>=</operator> <literal type="string">"Functions must not appear in the FROM"</literal>
											 <literal type="string">" clause of a distributed modifications."</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rangeTableEntryErrorDetail</name> <operator>=</operator> <literal type="string">"Common table expressions are not supported"</literal>
											 <literal type="string">" in distributed modifications."</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>rangeTableEntryErrorDetail</name> <operator>=</operator> <literal type="string">"Unrecognized range table entry."</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot perform distributed planning for the given "</literal>
								 <literal type="string">"modifications"</literal></expr></argument>,
								 <argument><expr><name>rangeTableEntryErrorDetail</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>!=</operator> <name>CMD_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>errorMessage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>multiShardQuery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <call><name>MultiShardUpdateDeleteMergeSupported</name><argument_list>(
				<argument><expr><name>originalQuery</name></expr></argument>,
				<argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <call><name>SingleShardUpdateDeleteSupported</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>,
															<argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>errorMessage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>errorMessage</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>CTEWithSearchClauseError</name> <init>=
		<expr><call><name>ErrorIfQueryHasCTEWithSearchClause</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>CTEWithSearchClauseError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>CTEWithSearchClauseError</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Modify statements on simple updetable views are not supported yet.
 * Actually, we need the original query (the query before postgres
 * pg_rewrite_query) to detect if the view sitting in rtable is to
 * be updated or just to be used in FROM clause.
 * Hence, tracing the postgres source code, we deduced that postgres
 * puts the relation to be modified to the first entry of rtable.
 * If first element of the range table list is a simple updatable
 * view and this view is not coming from FROM clause (inFromCl = False),
 * then update is run "on" that view.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfModifyView</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>firstRangeTableElement</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(
			<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>firstRangeTableElement</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>firstRangeTableElement</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
			<name><name>firstRangeTableElement</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"cannot modify views when the query contains citus tables"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfOnConflictNotSupprted returns an error if an INSERT query has an
 * unsupported ON CONFLICT clause. In particular, changing the partition
 * column value or using volatile functions is not allowed.
 */</comment>
<function><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>ErrorIfOnConflictNotSupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rangeTableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>setTargetCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>specifiesPartitionValue</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CmdType</name></type> <name>commandType</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>!=</operator> <name>CMD_INSERT</name> <operator>||</operator> <name><name>queryTree</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><call><name>ExtractFirstCitusTableId</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>rangeTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>onConflictSet</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arbiterWhere</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>onConflictWhere</name> <init>= <expr><name><name>queryTree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * onConflictSet is expanded via expand_targetlist() on the standard planner.
	 * This ends up adding all the columns to the onConflictSet even if the user
	 * does not explicitly state the columns in the query.
	 *
	 * The following loop simply allows "DO UPDATE SET part_col = table.part_col"
	 * types of elements in the target list, which are added by expand_targetlist().
	 * Any other attempt to update partition column value is forbidden.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>setTargetCell</argument>, <argument>onConflictSet</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>setTargetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>setTargetCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>setTargetEntryPartitionColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* reference tables do not have partition column */</comment>
		<if_stmt><if>if <condition>(<expr><name>partitionColumn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>setTargetEntryPartitionColumn</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>resultRelationId</name> <init>= <expr><call><name>ModifyQueryResultRelationId</name><argument_list>(<argument><expr><name>queryTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>targetColumnAttrNumber</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>setTargetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>targetColumnAttrNumber</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>resultRelationId</name></expr></argument>,
													<argument><expr><name><name>setTargetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>targetColumnAttrNumber</name> <operator>==</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>setTargetEntryPartitionColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>setTargetEntryPartitionColumn</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>setExpr</name> <init>= <expr><name><name>setTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setExpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>setExpr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>specifiesPartitionValue</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>specifiesPartitionValue</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Similarly, allow  "DO UPDATE SET col_1 = table.col_1" types of
			 * target list elements. Note that, the following check allows
			 * "DO UPDATE SET col_1 = table.col_2", which is not harmful.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>setTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>setTargetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"functions used in the DO UPDATE SET clause of "</literal>
									 <literal type="string">"INSERTs on distributed tables must be marked "</literal>
									 <literal type="string">"IMMUTABLE"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* error if either arbiter or on conflict WHERE contains a mutable function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>arbiterWhere</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>onConflictWhere</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"functions used in the WHERE clause of the "</literal>
							 <literal type="string">"ON CONFLICT clause of INSERTs on distributed "</literal>
							 <literal type="string">"tables must be marked IMMUTABLE"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>specifiesPartitionValue</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"modifying the partition value of rows is not "</literal>
							 <literal type="string">"allowed"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MultiShardUpdateDeleteMergeSupported returns the error message if the update/delete is
 * not pushdownable, otherwise it returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>MultiShardUpdateDeleteMergeSupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
									 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>errorMessage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>resultRangeTable</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>resultRelationOid</name> <init>= <expr><name><name>resultRangeTable</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HasDangerousJoinUsing</name><argument_list>(<argument><expr><name><name>originalQuery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>originalQuery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"a join with USING causes an internal naming conflict, use "</literal>
									 <literal type="string">"ON instead"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalQuery</name></expr></argument>,
										   <argument><expr><name>CitusIsVolatileFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"functions used in UPDATE queries on distributed "</literal>
									 <literal type="string">"tables must not be VOLATILE"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>resultRelationOid</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"only reference tables may be queried when targeting "</literal>
									 <literal type="string">"a reference table with multi shard UPDATE/DELETE queries "</literal>
									 <literal type="string">"with multiple tables "</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <call><name>DeferErrorIfUnsupportedSubqueryPushdown</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>,
															   <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>errorMessage</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SingleShardUpdateDeleteSupported returns the error message if the update/delete query is
 * not routable, otherwise it returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>SingleShardUpdateDeleteSupported</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
								 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>errorMessage</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We currently do not support volatile functions in update/delete statements because
	 * the function evaluation logic does not know how to distinguish volatile functions
	 * (that need to be evaluated per row) from stable functions (that need to be evaluated per query),
	 * and it is also not safe to push the volatile functions down on replicated tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalQuery</name></expr></argument>,
									  <argument><expr><name>CitusIsVolatileFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errorMessage</name> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"functions used in UPDATE queries on distributed "</literal>
									 <literal type="string">"tables must not be VOLATILE"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>errorMessage</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasDangerousJoinUsing search jointree for unnamed JOIN USING. Check the
 * implementation of has_dangerous_join_using in ruleutils.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasDangerousJoinUsing</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtableList</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinTreeNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>joinTreeNode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do here */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>joinTreeNode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>fromExpr</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>joinTreeNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>listCell</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>listCell</argument>, <argument>fromExpr-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>HasDangerousJoinUsing</name><argument_list>(<argument><expr><name>rtableList</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>listCell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>joinTreeNode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>joinTreeNode</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Is it an unnamed JOIN with USING? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>joinExpr</name><operator>-&gt;</operator><name>alias</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>joinExpr</name><operator>-&gt;</operator><name>usingClause</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Yes, so check each join alias var to see if any of them are not
			 * simple references to underlying columns. If so, we have a
			 * dangerous situation and must pick unique aliases.
			 */</comment>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>joinRTE</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>rtableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>listCell</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>listCell</argument>, <argument>joinRTE-&gt;joinaliasvars</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>aliasVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>listCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>aliasVar</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>aliasVar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Nope, but inspect children */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HasDangerousJoinUsing</name><argument_list>(<argument><expr><name>rtableList</name></expr></argument>, <argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HasDangerousJoinUsing</name><argument_list>(<argument><expr><name>rtableList</name></expr></argument>, <argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>joinTreeNode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateOrDeleteOrMergeQuery checks if the given query is an UPDATE or DELETE or
 * MERGE command. If it is, it returns true otherwise it returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>UpdateOrDeleteOrMergeQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
			<name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator>
			<name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_MERGE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsMergeQuery checks if the given query is a MERGE SQL command.
 */</comment>
<function><type><name>bool</name></type>
<name>IsMergeQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_MERGE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * If the expression contains STABLE functions which accept any parameters derived from a
 * Var returns true and sets varArgument.
 *
 * If the expression contains a CASE or COALESCE which invoke non-IMMUTABLE functions
 * returns true and sets badCoalesce.
 *
 * Assumes the expression contains no VOLATILE functions.
 *
 * Var's are allowed, but only if they are passed solely to IMMUTABLE functions
 *
 * We special-case CASE/COALESCE because those are evaluated lazily. We could evaluate
 * CASE/COALESCE expressions which don't reference Vars, or partially evaluate some
 * which do, but for now we just error out. That makes both the code and user-education
 * easier.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MasterIrreducibleExpression</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>varArgument</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>badCoalesce</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WalkerState</name></type> <name>data</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>data</name><operator>.</operator><name>containsVar</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>varArgument</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>badCoalesce</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><call><name>MasterIrreducibleExpressionWalker</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>varArgument</name> <operator>|=</operator> <name><name>data</name><operator>.</operator><name>varArgument</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>badCoalesce</name> <operator>|=</operator> <name><name>data</name><operator>.</operator><name>badCoalesce</name></name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MasterIrreducibleExpressionWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expression</name></decl></parameter>, <parameter><decl><type><name>WalkerState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>volatileFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WalkerState</name></type> <name>childState</name> <init>= <expr><block>{ <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>containsDisallowedFunction</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <name>hasVolatileFunction</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>expression</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>expression</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>expr</name><operator>-&gt;</operator><name>args</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>badCoalesce</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * There's no need to recurse. Since there are no STABLE functions
			 * varArgument will never be set.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><name>expression</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>badCoalesce</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>containsVar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In order for statement replication to give us consistent results it's important
	 * that we either disallow or evaluate on the coordinator anything which has a
	 * volatility category above IMMUTABLE. Newer versions of postgres might add node
	 * types which should be checked in this function.
	 *
	 * Look through contain_mutable_functions_walker or future PG's equivalent for new
	 * node types before bumping this version number to fix compilation; e.g. for any
	 * PostgreSQL after 9.5, see check_functions_in_node. Review
	 * MasterIrreducibleExpressionFunctionChecker for any changes in volatility
	 * permissibility ordering.
	 *
	 * Once you've added them to this check, make sure you also evaluate them in the
	 * executor!
	 */</comment>

	<expr_stmt><expr><name>hasVolatileFunction</name> <operator>=</operator>
		<call><name>check_functions_in_node</name><argument_list>(<argument><expr><name>expression</name></expr></argument>, <argument><expr><name>MasterIrreducibleExpressionFunctionChecker</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>volatileFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the caller should have already checked for this */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>hasVolatileFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>volatileFlag</name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>volatileFlag</name> <operator>==</operator> <name>PROVOLATILE_STABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>containsDisallowedFunction</name> <operator>=</operator>
			<call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>expression</name></expr></argument>,
								   <argument><expr><name>MasterIrreducibleExpressionWalker</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>childState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>childState</name><operator>.</operator><name>containsVar</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>varArgument</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>badCoalesce</name></name> <operator>|=</operator> <name><name>childState</name><operator>.</operator><name>badCoalesce</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>varArgument</name></name> <operator>|=</operator> <name><name>childState</name><operator>.</operator><name>varArgument</name></name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>containsDisallowedFunction</name> <operator>||</operator> <name><name>childState</name><operator>.</operator><name>containsVar</name></name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* keep traversing */</comment>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>expression</name></expr></argument>,
								  <argument><expr><name>MasterIrreducibleExpressionWalker</name></expr></argument>,
								  <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MasterIrreducibleExpressionFunctionChecker returns true if a provided function
 * oid corresponds to a volatile function. It also updates provided context if
 * the current volatility flag is more permissive than the provided one. It is
 * only called from check_functions_in_node as checker function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MasterIrreducibleExpressionFunctionChecker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>func_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>volatileFlag</name> <init>= <expr><call><name>func_volatile</name><argument_list>(<argument><expr><name>func_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>volatileContext</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>volatileFlag</name> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name> <operator>||</operator> <operator>*</operator><name>volatileContext</name> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>volatileContext</name> <operator>=</operator> <name>PROVOLATILE_VOLATILE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>volatileFlag</name> <operator>==</operator> <name>PROVOLATILE_STABLE</name> <operator>||</operator> <operator>*</operator><name>volatileContext</name> <operator>==</operator> <name>PROVOLATILE_STABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>volatileContext</name> <operator>=</operator> <name>PROVOLATILE_STABLE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>volatileContext</name> <operator>=</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><name>volatileFlag</name> <operator>==</operator> <name>PROVOLATILE_VOLATILE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TargetEntryChangesValue determines whether the given target entry may
 * change the value in a given column, given a join tree. The result is
 * true unless the expression refers directly to the column, or the
 * expression is a value that is implied by the qualifiers of the join
 * tree, or the target entry sets a different column.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TargetEntryChangesValue</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name></decl></parameter>, <parameter><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>joinTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isColumnValueChanged</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>setExpr</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setExpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>newValue</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>setExpr</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>newValue</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>column</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* target entry of the form SET col = table.col */</comment>
			<expr_stmt><expr><name>isColumnValueChanged</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>setExpr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>newValue</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>setExpr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictClauseList</name> <init>= <expr><call><name>WhereClauseList</name><argument_list>(<argument><expr><name>joinTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>equalityExpr</name> <init>= <expr><call><name>MakeOpExpression</name><argument_list>(<argument><expr><name>column</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rightOp</name> <init>= <expr><call><name>get_rightop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>equalityExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rightOp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightOp</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>rightConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightOp</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rightConst</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <name><name>newValue</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rightConst</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name><name>newValue</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rightConst</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name><name>newValue</name><operator>-&gt;</operator><name>constbyval</name></name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>predicateIsImplied</name> <init>= <expr><call><name>predicate_implied_by</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>equalityExpr</name></expr></argument>)</argument_list></call></expr></argument>,
													   <argument><expr><name>restrictClauseList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>predicateIsImplied</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* target entry of the form SET col = &lt;x&gt; WHERE col = &lt;x&gt; AND ... */</comment>
			<expr_stmt><expr><name>isColumnValueChanged</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>isColumnValueChanged</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RouterInsertJob builds a Job to represent an insertion performed by the provided
 * query. For inserts we always defer shard pruning and generating the task list to
 * the executor.
 */</comment>
<function><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type>
<name>RouterInsertJob</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>originalQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isMultiRowInsert</name> <init>= <expr><call><name>IsMultiRowInsert</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isMultiRowInsert</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* add default expressions to RTE_VALUES in multi-row INSERTs */</comment>
		<expr_stmt><expr><call><name>NormalizeMultiRowInsertTargetList</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>CreateJob</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>requiresCoordinatorEvaluation</name></name> <operator>=</operator> <call><name>RequiresCoordinatorEvaluation</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>deferredPruning</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>partitionKeyValue</name></name> <operator>=</operator> <call><name>ExtractInsertPartitionKeyValue</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>job</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateJob returns a new Job for the given query.
 */</comment>
<function><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type>
<name>CreateJob</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Job</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <call><name>UniqueJobId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>jobQuery</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>dependentJobList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>subqueryPushdown</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>requiresCoordinatorEvaluation</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>deferredPruning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>job</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfNoShardsExist throws an error if the given table has no shards.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfNoShardsExist</name><parameter_list>(<parameter><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shardCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find any shards"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"No shards exist for distributed table \"%s\"."</literal></expr></argument>,
								  <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Run master_create_worker_shards to create shards "</literal>
								<literal type="string">"and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RouterInsertTaskList generates a list of tasks for performing an INSERT on
 * a distributed table via the router executor.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RouterInsertTaskList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parametersInQueryResolved</name></decl></parameter>,
					 <parameter><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>planningError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertTaskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><call><name>ExtractFirstCitusTableId</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfNoShardsExist</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>modifyRouteList</name> <init>= <expr><call><name>BuildRoutesForInsert</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>planningError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>planningError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ModifyRoute</name> <modifier>*</modifier></type><name>modifyRoute</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>modifyRoute</argument>, <argument>modifyRouteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>modifyTask</name> <init>= <expr><call><name>CreateTask</name><argument_list>(<argument><expr><name>MODIFY_TASK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name><name>modifyRoute</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name><name>cacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>rowValuesLists</name></name> <operator>=</operator> <name><name>modifyRoute</name><operator>-&gt;</operator><name>rowValuesLists</name></name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>RelationShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>modifyRoute</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name>distributedTableId</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>relationShardList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>relationShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>ActiveShardPlacementList</name><argument_list>(
			<argument><expr><name><name>modifyRoute</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>modifyTask</name><operator>-&gt;</operator><name>parametersInQueryStringResolved</name></name> <operator>=</operator> <name>parametersInQueryResolved</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>insertTaskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>insertTaskList</name></expr></argument>, <argument><expr><name>modifyTask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>insertTaskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateTask returns a new Task with the given type.
 */</comment>
<function><type><specifier>static</specifier> <name>Task</name> <modifier>*</modifier></type>
<name>CreateTask</name><parameter_list>(<parameter><decl><type><name>TaskType</name></type> <name>taskType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>taskType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>INVALID_JOB_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>INVALID_TASK_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>INVALID_SHARD_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>partitionId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>upstreamTaskId</name></name> <operator>=</operator> <name>INVALID_TASK_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>shardInterval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>assignmentConstrained</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>relationRowLockList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>modifyWithSubquery</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>partiallyLocalOrRemote</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>relationShardList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><name>task</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractFirstCitusTableId takes a given query, and finds the relationId
 * for the first distributed table in that query. If the function cannot find a
 * distributed table, it returns InvalidOid.
 *
 * We only use this function for modifications and fast path queries, which
 * should have the first distributed table in the top-level rtable.
 */</comment>
<function><type><name>Oid</name></type>
<name>ExtractFirstCitusTableId</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>distributedTableId</name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>distributedTableId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RouterJob builds a Job to represent a single shard select/update/delete and
 * multiple shard update/delete queries.
 */</comment>
<function><type><specifier>static</specifier> <name>Job</name> <modifier>*</modifier></type>
<name>RouterJob</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>, <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>,
		  <parameter><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>planningError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name>INVALID_SHARD_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardIntervalListList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isMultiShardModifyQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>partitionKeyValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* router planner should create task even if it doesn't hit a shard at all */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>replacePrunedQueryWithDummy</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isLocalTableModification</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check if this query requires coordinator evaluation */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>requiresCoordinatorEvaluation</name> <init>= <expr><call><name>RequiresCoordinatorEvaluation</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FastPathRestrictionContext</name> <modifier>*</modifier></type><name>fastPathRestrictionContext</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We prefer to defer shard pruning/task generation to the
	 * execution when the parameter on the distribution key
	 * cannot be resolved.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fastPathRestrictionContext</name><operator>-&gt;</operator><name>fastPathRouterQuery</name></name> <operator>&amp;&amp;</operator>
		<name><name>fastPathRestrictionContext</name><operator>-&gt;</operator><name>distributionKeyHasParam</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>CreateJob</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>deferredPruning</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Deferred pruning for a fast-path router "</literal>
								<literal type="string">"query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>job</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>planningError</name><operator>)</operator> <operator>=</operator> <call><name>PlanRouterQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>placementList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relationShardList</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>prunedShardIntervalListList</name></expr></argument>,
										   <argument><expr><name>replacePrunedQueryWithDummy</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>isMultiShardModifyQuery</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>partitionKeyValue</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>isLocalTableModification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>planningError</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For MERGE, we do _not_ plan anything other than Router job, let's
		 * not continue further down the lane in distributed planning, simply
		 * bail out.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsMergeQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><operator>*</operator><name>planningError</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name> <init>= <expr><call><name>CreateJob</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>partitionKeyValue</name></name> <operator>=</operator> <name>partitionKeyValue</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>originalQuery</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>updateOrDeleteOrMergeRTE</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If all of the shards are pruned, we replace the relation RTE into
		 * subquery RTE that returns no results. However, this is not useful
		 * for UPDATE and DELETE queries. Therefore, if we detect a UPDATE or
		 * DELETE RTE with subquery type, we just set task list to empty and return
		 * the job.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>updateOrDeleteOrMergeRTE</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<return>return <expr><name>job</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isMultiShardModifyQuery</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>QueryPushdownSqlTaskList</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>,
												 <argument><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator>
												 <name>relationRestrictionContext</name></name></expr></argument>,
												 <argument><expr><name>prunedShardIntervalListList</name></expr></argument>,
												 <argument><expr><name>MODIFY_TASK</name></expr></argument>,
												 <argument><expr><name>requiresCoordinatorEvaluation</name></expr></argument>,
												 <argument><expr><name>planningError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>planningError</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>GenerateSingleShardRouterTaskList</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>relationShardList</name></expr></argument>,
										  <argument><expr><name>placementList</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
										  <argument><expr><name>isLocalTableModification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>requiresCoordinatorEvaluation</name></name> <operator>=</operator> <name>requiresCoordinatorEvaluation</name></expr>;</expr_stmt>
	<return>return <expr><name>job</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateSingleShardRouterTaskList is a wrapper around other corresponding task
 * list generation functions specific to single shard selects and modifications.
 *
 * The function updates the input job's taskList in-place.
 */</comment>
<function><type><name>void</name></type>
<name>GenerateSingleShardRouterTaskList</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
								  <name>isLocalTableModification</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name> <init>= <expr><name><name>job</name><operator>-&gt;</operator><name>jobQuery</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>originalQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>SingleShardTaskList</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>,
											<argument><expr><name>relationShardList</name></expr></argument>, <argument><expr><name>placementList</name></expr></argument>,
											<argument><expr><name>shardId</name></expr></argument>,
											<argument><expr><name><name>job</name><operator>-&gt;</operator><name>parametersInJobQueryResolved</name></name></expr></argument>,
											<argument><expr><name>isLocalTableModification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Queries to reference tables, or distributed tables with multiple replica's have
		 * their task placements reordered according to the configured
		 * task_assignment_policy. This is only applicable to select queries as the modify
		 * queries will _always_ be executed on all placements.
		 *
		 * We also ignore queries that are targeting only intermediate results (e.g., no
		 * valid anchorShardId).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>shardId</name> <operator>!=</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReorderTaskPlacementsByTaskAssignmentPolicy</name><argument_list>(<argument><expr><name>job</name></expr></argument>, <argument><expr><name>TaskAssignmentPolicy</name></expr></argument>,
														<argument><expr><name>placementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>shardId</name> <operator>==</operator> <name>INVALID_SHARD_ID</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isLocalTableModification</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* modification that prunes to 0 shards */</comment>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>SingleShardTaskList</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name><name>job</name><operator>-&gt;</operator><name>jobId</name></name></expr></argument>,
											<argument><expr><name>relationShardList</name></expr></argument>, <argument><expr><name>placementList</name></expr></argument>,
											<argument><expr><name>shardId</name></expr></argument>,
											<argument><expr><name><name>job</name><operator>-&gt;</operator><name>parametersInJobQueryResolved</name></name></expr></argument>,
											<argument><expr><name>isLocalTableModification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReorderTaskPlacementsByTaskAssignmentPolicy applies selective reordering for supported
 * TaskAssignmentPolicyTypes.
 *
 * Supported Types
 * - TASK_ASSIGNMENT_ROUND_ROBIN round robin schedule queries among placements
 *
 * By default it does not reorder the task list, implying a first-replica strategy.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReorderTaskPlacementsByTaskAssignmentPolicy</name><parameter_list>(<parameter><decl><type><name>Job</name> <modifier>*</modifier></type><name>job</name></decl></parameter>,
											<parameter><decl><type><name>TaskAssignmentPolicyType</name></type> <name>taskAssignmentPolicy</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>taskAssignmentPolicy</name> <operator>==</operator> <name>TASK_ASSIGNMENT_ROUND_ROBIN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We hit a single shard on router plans, and there should be only
		 * one task in the task list
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><operator>(</operator><name>Task</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>job</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * For round-robin SELECT queries, we don't want to include the coordinator
		 * because the user is trying to distributed the load across nodes via
		 * round-robin policy. Otherwise, the local execution would prioritize
		 * executing the local tasks and especially for reference tables on the
		 * coordinator this would prevent load balancing across nodes.
		 *
		 * For other worker nodes in Citus MX, we let the local execution to kick-in
		 * even for round-robin policy, that's because we expect the clients to evenly
		 * connect to the worker nodes.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ReadOnlyTask</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>placementList</name> <operator>=</operator> <call><name>RemoveCoordinatorPlacementIfNotSingleNode</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* reorder the placement list */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>reorderedPlacementList</name> <init>= <expr><call><name>RoundRobinReorder</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name>reorderedPlacementList</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>primaryPlacement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(
			<argument><expr><name>reorderedPlacementList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"assigned task %u to node %s:%u"</literal></expr></argument>, <argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name></expr></argument>,
								<argument><expr><name><name>primaryPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
								<argument><expr><name><name>primaryPlacement</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoveCoordinatorPlacementIfNotSingleNode gets a task placement list and returns the list
 * by removing the placement belonging to the coordinator (if any).
 *
 * If the list has a single element or no placements on the coordinator, the list
 * returned is unmodified.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RemoveCoordinatorPlacementIfNotSingleNode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>placementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>placementList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>placementCell</argument>, <argument>placementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>placementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>COORDINATOR_GROUP_ID</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>, <argument><expr><name>placement</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>placementList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SingleShardTaskList generates a task for single shard query
 * and returns it as a list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>SingleShardTaskList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>jobId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>parametersInQueryResolved</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>isLocalTableModification</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TaskType</name></type> <name>taskType</name> <init>= <expr><name>READ_TASK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExtractRangeTableEntryWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rangeTableList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>updateOrDeleteRTE</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>updateOrDeleteRTE</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>modificationTableCacheEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>updateOrDeleteRTE</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>modificationTableCacheEntry</name> <operator>=</operator> <call><name>GetCitusTableCacheEntry</name><argument_list>(
				<argument><expr><name><name>updateOrDeleteRTE</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>updateOrDeleteRTE</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>SelectsFromDistributedTable</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform select on a distributed table "</literal>
								   <literal type="string">"and modify a reference table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>taskType</name> <operator>=</operator> <name>MODIFY_TASK</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>modificationTableCacheEntry</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>replicationModel</name> <operator>=</operator> <name><name>modificationTableCacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>taskType</name> <operator>==</operator> <name>READ_TASK</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* assume ErrorIfQueryHasUnroutableModifyingCTE checked query already */</comment>

		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>cte</argument>, <argument>query-&gt;cteList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>cteQuery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>cteQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>updateOrDeleteRTE</name> <init>= <expr><call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>cteQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>modificationTableCacheEntry</name> <init>=
					<expr><call><name>GetCitusTableCacheEntry</name><argument_list>(
						<argument><expr><name><name>updateOrDeleteRTE</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>taskType</name> <operator>=</operator> <name>MODIFY_TASK</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>replicationModel</name> <operator>=</operator> <name><name>modificationTableCacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CreateTask</name><argument_list>(<argument><expr><name>taskType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>isLocalTableModification</name></name> <operator>=</operator> <name>isLocalTableModification</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationRowLockList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RowLocksOnRelations</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relationRowLockList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For performance reasons, we skip generating the queryString. For local
	 * execution this is not needed, so we wait until the executor determines
	 * that the query cannot be executed locally.
	 */</comment>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <name>placementList</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetTaskQueryIfShouldLazyDeparse</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>relationShardList</name></name> <operator>=</operator> <name>relationShardList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>relationRowLockList</name></name> <operator>=</operator> <name>relationRowLockList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>replicationModel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>parametersInQueryStringResolved</name></name> <operator>=</operator> <name>parametersInQueryResolved</name></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RowLocksOnRelations forms the list for range table IDs and corresponding
 * row lock modes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RowLocksOnRelations</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationRowLockList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rowMarkCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>rowMarkCell</argument>, <argument>query-&gt;rowMarks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rowMarkClause</name> <init>= <expr><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rowMarkCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTable</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rowMarkClause</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>rangeTable</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RelationRowLock</name> <modifier>*</modifier></type><name>relationRowLock</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>RelationRowLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>relationRowLock</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>relationRowLock</name><operator>-&gt;</operator><name>rowLockStrength</name></name> <operator>=</operator> <name><name>rowMarkClause</name><operator>-&gt;</operator><name>strength</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>relationRowLockList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>relationRowLockList</name></expr></argument>, <argument><expr><name>relationRowLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>RowLocksOnRelations</name></expr></argument>, <argument><expr><name>relationRowLockList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RowLocksOnRelations</name></expr></argument>, <argument><expr><name>relationRowLockList</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SelectsFromDistributedTable checks if there is a select on a distributed
 * table by looking into range table entries.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SelectsFromDistributedTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>resultRangeTableEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>resultRangeTableEntry</name> <operator>=</operator> <call><name>ExtractResultRelationRTE</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
			<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Skip over views, which would error out in GetCitusTableCacheEntry.
			 * Distributed tables within (regular) views are already in rangeTableList.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(
			<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>resultRangeTableEntry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>resultRangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator>
			 <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsOnlyLocalTables</name><parameter_list>(<parameter><decl><type><name>RTEListProperties</name> <modifier>*</modifier></type><name>rteProperties</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * RouterQuery runs router pruning logic for SELECT, UPDATE and DELETE queries.
 * If there are shards present and query is routable, all RTEs have been updated
 * to point to the relevant shards in the originalQuery. Also, placementList is
 * filled with the list of worker nodes that has all the required shard placements
 * for the query execution. anchorShardId is set to the first pruned shardId of
 * the given query. Finally, relationShardList is filled with the list of
 * relation-to-shard mappings for the query.
 *
 * If the given query is not routable, it fills planningError with the related
 * DeferredErrorMessage. The caller can check this error message to see if query
 * is routable or not.
 *
 * Note: If the query prunes down to 0 shards due to filters (e.g. WHERE false),
 * or the query has only read_intermediate_result calls (no relations left after
 * recursively planning CTEs and subqueries), then it will be assigned to an
 * arbitrary worker node in a round-robin fashion.
 *
 * Relations that prune down to 0 shards are replaced by subqueries returning
 * 0 values in UpdateRelationToShardNames.
 */</comment>
<function><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>PlanRouterQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
				<parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>placementList</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>anchorShardId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationShardList</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>prunedShardIntervalListList</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>replacePrunedQueryWithDummy</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>multiShardModifyQuery</name></decl></parameter>,
				<parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>partitionValueConst</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isLocalTableModification</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isMultiShardQuery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>planningError</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>shardsPresent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type> <name>commandType</name> <init>= <expr><name><name>originalQuery</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>fastPathRouterQuery</name> <init>=
		<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name><operator>-&gt;</operator><name>fastPathRouterQuery</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>placementList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * When FastPathRouterQuery() returns true, we know that standard_planner() has
	 * not been called. Thus, restriction information is not avaliable and we do the
	 * shard pruning based on the distribution column in the quals of the query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fastPathRouterQuery</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>distributionKeyValue</name> <init>=
			<expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>fastPathRestrictionContext</name><operator>-&gt;</operator><name>distributionKeyValue</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>=
			<expr><call><name>TargetShardIntervalForFastPathQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isMultiShardQuery</name></expr></argument>,
												<argument><expr><name>distributionKeyValue</name></expr></argument>,
												<argument><expr><name>partitionValueConst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * This could only happen when there is a parameter on the distribution key.
		 * We defer error here, later the planner is forced to use a generic plan
		 * by assigning arbitrarily high cost to the plan.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>UpdateOrDeleteOrMergeQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>isMultiShardQuery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>planningError</name> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
										  <argument><expr><literal type="string">"Router planner cannot handle multi-shard "</literal>
										  <literal type="string">"modify queries"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>planningError</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>prunedShardIntervalListList</name> <operator>=</operator> <name>shardIntervalList</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isMultiShardQuery</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Distributed planning for a fast-path router "</literal>
									<literal type="string">"query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>prunedShardIntervalListList</name> <operator>=</operator>
			<call><name>TargetShardIntervalsForRestrictInfo</name><argument_list>(<argument><expr><name><name>plannerRestrictionContext</name><operator>-&gt;</operator>
												<name>relationRestrictionContext</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>isMultiShardQuery</name></expr></argument>,
												<argument><expr><name>partitionValueConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isMultiShardQuery</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If multiShardQuery is true and it is a type of SELECT query, then
		 * return deferred error. We do not support multi-shard SELECT queries
		 * with this code path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"Router planner cannot handle multi-shard select queries"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>UpdateOrDeleteOrMergeQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>planningError</name> <operator>=</operator> <call><name>ModifyQuerySupported</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>originalQuery</name></expr></argument>,
											 <argument><expr><name>isMultiShardQuery</name></expr></argument>,
											 <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>planningError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>planningError</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>multiShardModifyQuery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>planningError</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>relationShardList</name> <operator>=</operator>
		<call><name>RelationShardListForShardIntervalList</name><argument_list>(<argument><expr><operator>*</operator><name>prunedShardIntervalListList</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>shardsPresent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shardsPresent</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>replacePrunedQueryWithDummy</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For INSERT ... SELECT, this query could be still a valid for some other target
		 * shard intervals. Thus, we should return empty list if there aren't any matching
		 * workers, so that the caller can decide what to do with this task.
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We bail out if there are RTEs that prune multiple shards above, but
	 * there can also be multiple RTEs that reference the same relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationPrunesToMultipleShards</name><argument_list>(<argument><expr><operator>*</operator><name>relationShardList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>planningError</name> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									  <argument><expr><literal type="string">"cannot run command which targets "</literal>
									  <literal type="string">"multiple shards"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>planningError</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we need anchor shard id for select queries with router planner */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>GetAnchorShardId</name><argument_list>(<argument><expr><operator>*</operator><name>prunedShardIntervalListList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* both Postgres tables and materialized tables are locally avaliable */</comment>
	<decl_stmt><decl><type><name>RTEListProperties</name> <modifier>*</modifier></type><name>rteProperties</name> <init>= <expr><call><name>GetRTEListPropertiesForQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shardId</name> <operator>==</operator> <name>INVALID_SHARD_ID</name> <operator>&amp;&amp;</operator> <call><name>ContainsOnlyLocalTables</name><argument_list>(<argument><expr><name>rteProperties</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>isLocalTableModification</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasPostgresLocalRelation</name> <init>=
		<expr><name><name>rteProperties</name><operator>-&gt;</operator><name>hasPostgresLocalTable</name></name> <operator>||</operator> <name><name>rteProperties</name><operator>-&gt;</operator><name>hasMaterializedView</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskPlacementList</name> <init>=
		<expr><call><name>CreateTaskPlacementListForShardIntervals</name><argument_list>(<argument><expr><operator>*</operator><name>prunedShardIntervalListList</name></expr></argument>,
												 <argument><expr><name>shardsPresent</name></expr></argument>,
												 <argument><expr><name>replacePrunedQueryWithDummy</name></expr></argument>,
												 <argument><expr><name>hasPostgresLocalRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>taskPlacementList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>planningError</name> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									  <argument><expr><literal type="string">"found no worker with all shard placements"</literal></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>planningError</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this is an UPDATE or DELETE query which requires coordinator evaluation,
	 * don't try update shard names, and postpone that to execution phase.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>isUpdateOrDelete</name> <init>= <expr><call><name>UpdateOrDeleteOrMergeQuery</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>isUpdateOrDelete</name> <operator>&amp;&amp;</operator> <call><name>RequiresCoordinatorEvaluation</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UpdateRelationToShardNames</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>originalQuery</name></expr></argument>, <argument><expr><operator>*</operator><name>relationShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>multiShardModifyQuery</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>placementList</name> <operator>=</operator> <name>taskPlacementList</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>anchorShardId</name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>

	<return>return <expr><name>planningError</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsOnlyLocalTables returns true if there is only
 * local tables and not any distributed or reference table.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsOnlyLocalTables</name><parameter_list>(<parameter><decl><type><name>RTEListProperties</name> <modifier>*</modifier></type><name>rteProperties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><name><name>rteProperties</name><operator>-&gt;</operator><name>hasDistributedTable</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rteProperties</name><operator>-&gt;</operator><name>hasReferenceTable</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateTaskPlacementListForShardIntervals returns a list of shard placements
 * on which it can access all shards in shardIntervalListList, which contains
 * a list of shards for each relation in the query.
 *
 * If the query contains a local table then hasLocalRelation should be set to
 * true. In that case, CreateTaskPlacementListForShardIntervals only returns
 * a placement for the local node or an empty list if the shards cannot be
 * accessed locally.
 *
 * If generateDummyPlacement is true and there are no shards that need to be
 * accessed to answer the query (shardsPresent is false), then a single
 * placement is returned that is either local or follows a round-robin policy.
 * A typical example is a router query that only reads an intermediate result.
 * This will happen on the coordinator, unless the user wants to balance the
 * load by setting the citus.task_assignment_policy.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CreateTaskPlacementListForShardIntervals</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalListList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shardsPresent</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name></type> <name>generateDummyPlacement</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name></type> <name>hasLocalRelation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shardsPresent</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Determine the workers that have all shard placements, if any.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>=
			<expr><call><name>PlacementsForWorkersContainingAllShards</name><argument_list>(<argument><expr><name>shardIntervalListList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hasLocalRelation</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>taskPlacement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If there is a local table, we only allow the local placement to
			 * be used. If there is none, we disallow the query.
			 */</comment>
			<macro><name>foreach_ptr</name><argument_list>(<argument>taskPlacement</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>taskPlacement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>placementList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>, <argument><expr><name>taskPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>placementList</name> <operator>=</operator> <name>shardPlacementList</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>generateDummyPlacement</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>dummyPlacement</name> <init>= <expr><call><name>CreateDummyPlacement</name><argument_list>(<argument><expr><name>hasLocalRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>placementList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>dummyPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>placementList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateLocalDummyPlacement creates a dummy placement for the local node that
 * can be used for queries that don't involve any shards. The typical examples
 * are:
 *       (a) queries that consist of only intermediate results
 *       (b) queries that hit zero shards (... WHERE false;)
 */</comment>
<function><type><specifier>static</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type>
<name>CreateLocalDummyPlacement</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>dummyPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>dummyPlacement</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>=</operator> <name>LOCAL_NODE_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dummyPlacement</name><operator>-&gt;</operator><name>nodeName</name></name> <operator>=</operator> <name>LocalHostName</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dummyPlacement</name><operator>-&gt;</operator><name>nodePort</name></name> <operator>=</operator> <name>PostPortNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dummyPlacement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>dummyPlacement</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateDummyPlacement creates a dummy placement that can be used for queries
 * that don't involve any shards. The typical examples are:
 *       (a) queries that consist of only intermediate results
 *       (b) queries that hit zero shards (... WHERE false;)
 *
 * If round robin policy is set, the placement could be on any node in pg_dist_node.
 * Else, the local node is set for the placement.
 *
 * Queries can also involve local tables. In that case we always use the local
 * node.
 */</comment>
<function><type><specifier>static</specifier> <name>ShardPlacement</name> <modifier>*</modifier></type>
<name>CreateDummyPlacement</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>hasLocalRelation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>zeroShardQueryRoundRobin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>TaskAssignmentPolicy</name> <operator>!=</operator> <name>TASK_ASSIGNMENT_ROUND_ROBIN</name> <operator>||</operator> <name>hasLocalRelation</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>CreateLocalDummyPlacement</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActiveReadableNonCoordinatorNodeList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNodeList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We want to round-robin over the workers, but there are no workers.
		 * To make sure the query can still succeed we fall back to returning
		 * a local dummy placement.
		 */</comment>
		<return>return <expr><call><name>CreateLocalDummyPlacement</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>workerNodeCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>workerNodeIndex</name> <init>= <expr><name>zeroShardQueryRoundRobin</name> <operator>%</operator> <name>workerNodeCount</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>,
													 <argument><expr><name>workerNodeIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>dummyPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetPlacementNodeMetadata</name><argument_list>(<argument><expr><name>dummyPlacement</name></expr></argument>, <argument><expr><name>workerNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>zeroShardQueryRoundRobin</name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>dummyPlacement</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationShardListForShardIntervalList is a utility function which gets a list of
 * shardInterval, and returns a list of RelationShard.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RelationShardListForShardIntervalList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>shardsPresent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardIntervalListCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>shardIntervalListCell</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardIntervalList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardIntervalListCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* no shard is present or all shards are pruned out case will be handled later */</comment>
		<if_stmt><if>if <condition>(<expr><name>prunedShardIntervalList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>shardsPresent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardIntervalCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>shardIntervalCell</argument>, <argument>prunedShardIntervalList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>shardIntervalCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>RelationShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>relationShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>relationShardList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relationShardList</name></expr></argument>, <argument><expr><name>relationShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>relationShardList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAnchorShardId returns the anchor shard id given relation shard list.
 * The desired anchor shard is found as follows:
 *
 * - Return the first distributed table shard id in the relationShardList if
 * there is any.
 * - Return a random reference table shard id if all the shards belong to
 * reference tables
 * - Return INVALID_SHARD_ID on empty lists
 */</comment>
<function><type><name>uint64</name></type>
<name>GetAnchorShardId</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardIntervalListList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>prunedShardIntervalListCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>referenceShardId</name> <init>= <expr><name>INVALID_SHARD_ID</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>prunedShardIntervalListCell</argument>, <argument>prunedShardIntervalListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardIntervalList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>prunedShardIntervalListCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* no shard is present or all shards are pruned out case will be handled later */</comment>
		<if_stmt><if>if <condition>(<expr><name>prunedShardIntervalList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>prunedShardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ReferenceTableShardId</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>referenceShardId</name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>referenceShardId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TargetShardIntervalForFastPathQuery gets a query which is in
 * the form defined by FastPathRouterQuery() and returns exactly
 * one list of a a one shard interval (see FastPathRouterQuery()
 * for the detail).
 *
 * If the caller requested the distributionKey value that this function
 * yields, set outputPartitionValueConst.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>TargetShardIntervalForFastPathQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isMultiShardQuery</name></decl></parameter>,
									<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>inputDistributionKeyValue</name></decl></parameter>,
									<parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>outputPartitionValueConst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>ExtractFirstCitusTableId</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we don't need to do shard pruning for non-distributed tables */</comment>
		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>inputDistributionKeyValue</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>inputDistributionKeyValue</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionKey</name> <init>= <expr><name><name>cache</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We currently don't allow implicitly coerced values to be handled by fast-
		 * path planner. Still, let's be defensive for any  future changes..
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>inputDistributionKeyValue</name><operator>-&gt;</operator><name>consttype</name></name> <operator>!=</operator> <name><name>distributionKey</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>inputDistributionKeyValue</name> <operator>=</operator>
				<call><name>TransformPartitionRestrictionValue</name><argument_list>(<argument><expr><name>distributionKey</name></expr></argument>,
												   <argument><expr><name>inputDistributionKeyValue</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>cachedShardInterval</name> <init>=
			<expr><call><name>FindShardInterval</name><argument_list>(<argument><expr><name><name>inputDistributionKeyValue</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>cachedShardInterval</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"could not find shardinterval to which to send the query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>outputPartitionValueConst</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* set the outgoing partition column value if requested */</comment>
			<expr_stmt><expr><operator>*</operator><name>outputPartitionValueConst</name> <operator>=</operator> <name>inputDistributionKeyValue</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>CopyShardInterval</name><argument_list>(<argument><expr><name>cachedShardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>relationIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We couldn't do the shard pruning based on inputDistributionKeyValue as it might
	 * be passed as NULL. Still, we can search the quals for distribution key.
	 */</comment>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>distributionKeyValueInQuals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardIntervalList</name> <init>=
		<expr><call><name>PruneShards</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>relationIndex</name></expr></argument>, <argument><expr><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>quals</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>&amp;</operator><name>distributionKeyValueInQuals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>distributionKeyValueInQuals</name> <operator>||</operator> <name><name>distributionKeyValueInQuals</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the distribution key equals to NULL, we prefer to treat it as a zero shard
		 * query as it cannot return any rows.
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we're only expecting single shard from a single table */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>prunedShardIntervalList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isMultiShardQuery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>prunedShardIntervalList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			 <name>outputPartitionValueConst</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* set the outgoing partition column value if requested */</comment>
		<expr_stmt><expr><operator>*</operator><name>outputPartitionValueConst</name> <operator>=</operator> <name>distributionKeyValueInQuals</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>prunedShardIntervalList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TargetShardIntervalsForRestrictInfo performs shard pruning for all referenced
 * relations in the relation restriction context and returns list of shards per
 * relation. Shard pruning is done based on provided restriction context per relation.
 * The function sets multiShardQuery to true if any of the relations pruned down to
 * more than one active shard. It also records pruned shard intervals in relation
 * restriction context to be used later on. Some queries may have contradiction
 * clauses like 'and false' or 'and 1=0', such queries are treated as if all of
 * the shards of joining relations are pruned out.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>TargetShardIntervalsForRestrictInfo</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>,
									<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>multiShardQuery</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>partitionValueConst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardIntervalListList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>restrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>multiplePartitionValuesExist</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>queryPartitionValueConst</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>restrictionContext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>restrictionCell</argument>, <argument>restrictionContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>relationRestriction</name> <init>=
			<expr><operator>(</operator><name>RelationRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>restrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ignore local tables for shard pruning purposes */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Index</name></type> <name>tableId</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>baseRestrictionList</name> <init>= <expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relOptInfo</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictClauseList</name> <init>= <expr><call><name>get_all_actual_clauses</name><argument_list>(<argument><expr><name>baseRestrictionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Queries may have contradiction clauses like 'false', or '1=0' in
		 * their filters. Such queries would have pseudo constant 'false'
		 * inside relOptInfo-&gt;joininfo list. We treat such cases as if all
		 * shards of the table are pruned out.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>joinFalseQuery</name> <init>= <expr><call><name>JoinConditionIsOnFalse</name><argument_list>(
			<argument><expr><name><name>relationRestriction</name><operator>-&gt;</operator><name>relOptInfo</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>joinFalseQuery</name> <operator>&amp;&amp;</operator> <name>shardCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>restrictionPartitionValueConst</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>prunedShardIntervalList</name> <operator>=</operator> <call><name>PruneShards</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>restrictClauseList</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>restrictionPartitionValueConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>prunedShardIntervalList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>multiShardQuery</name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>restrictionPartitionValueConst</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<name>queryPartitionValueConst</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>queryPartitionValueConst</name> <operator>=</operator> <name>restrictionPartitionValueConst</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>restrictionPartitionValueConst</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					 <operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>queryPartitionValueConst</name></expr></argument>, <argument><expr><name>restrictionPartitionValueConst</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>multiplePartitionValuesExist</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>prunedShardIntervalListList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prunedShardIntervalListList</name></expr></argument>,
											  <argument><expr><name>prunedShardIntervalList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Different resrictions might have different partition columns.
	 * We report partition column value if there is only one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>multiplePartitionValuesExist</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>queryPartitionValueConst</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set the outgoing partition column value if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name>partitionValueConst</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>partitionValueConst</name> <operator>=</operator> <name>queryPartitionValueConst</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>prunedShardIntervalListList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * JoinConditionIsOnFalse returns true for queries that
 * have contradiction clauses like 'false', or '1=0' in
 * their filters. Such queries would have pseudo constant 'false'
 * inside joininfo list.
 */</comment>
<function><type><name>bool</name></type>
<name>JoinConditionIsOnFalse</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinInfoList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pseudoJoinRestrictionList</name> <init>= <expr><call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>joinInfoList</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>joinFalseQuery</name> <init>= <expr><call><name>ContainsFalseClause</name><argument_list>(<argument><expr><name>pseudoJoinRestrictionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>joinFalseQuery</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationPrunesToMultipleShards returns true if the given list of
 * relation-to-shard mappings contains at least two mappings with
 * the same relation, but different shards.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RelationPrunesToMultipleShards</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationShardList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationShardCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>previousRelationShard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>relationShardList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>relationShardList</name></expr></argument>, <argument><expr><name>CompareRelationShards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationShardCell</argument>, <argument>relationShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>relationShard</name> <init>= <expr><operator>(</operator><name>RelationShard</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>relationShardCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>previousRelationShard</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>relationShard</name><operator>-&gt;</operator><name>relationId</name></name> <operator>==</operator> <name><name>previousRelationShard</name><operator>-&gt;</operator><name>relationId</name></name> <operator>&amp;&amp;</operator>
			<name><name>relationShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>!=</operator> <name><name>previousRelationShard</name><operator>-&gt;</operator><name>shardId</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>previousRelationShard</name> <operator>=</operator> <name>relationShard</name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PlacementsForWorkersContainingAllShards returns list of shard placements for workers
 * that contain all shard intervals in the given list of shard interval lists.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PlacementsForWorkersContainingAllShards</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalListList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>firstShard</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>currentPlacementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>shardIntervalList</argument>, <argument>shardIntervalListList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>shardIntervalList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* retrieve all active shard placements for this shard */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>firstShard</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>firstShard</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>currentPlacementList</name> <operator>=</operator> <name>newPlacementList</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* keep placements that still exists for this shard */</comment>
			<expr_stmt><expr><name>currentPlacementList</name> <operator>=</operator> <call><name>IntersectPlacementList</name><argument_list>(<argument><expr><name>currentPlacementList</name></expr></argument>,
														  <argument><expr><name>newPlacementList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Bail out if placement list becomes empty. This means there is no worker
		 * containing all shards referenced by the query, hence we can not forward
		 * this query directly to any worker.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>currentPlacementList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>currentPlacementList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildRoutesForInsert returns a list of ModifyRoute objects for an INSERT
 * query or an empty list if the partition column value is defined as an ex-
 * pression that still needs to be evaluated. If any partition column value
 * falls within 0 or multiple (overlapping) shards, the planning error is set.
 *
 * Multi-row INSERTs are handled by grouping their rows by target shard. These
 * groups are returned in ascending order by shard id, ready for later deparse
 * to shard-specific SQL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>BuildRoutesForInsert</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier><modifier>*</modifier></type><name>planningError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><call><name>ExtractFirstCitusTableId</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>modifyRouteList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>insertValuesCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reference tables and citus local tables can only have one shard */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>shardCount</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reference table cannot have %d shards"</literal></expr></argument>,
									   <argument><expr><name>shardCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local table cannot have %d shards"</literal></expr></argument>,
									   <argument><expr><name>shardCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ModifyRoute</name> <modifier>*</modifier></type><name>modifyRoute</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ModifyRoute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>modifyRoute</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>valuesRTE</name> <init>= <expr><call><name>ExtractDistributedInsertValuesRTE</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>valuesRTE</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* add the values list for a multi-row INSERT */</comment>
			<expr_stmt><expr><name><name>modifyRoute</name><operator>-&gt;</operator><name>rowValuesLists</name></name> <operator>=</operator> <name><name>valuesRTE</name><operator>-&gt;</operator><name>values_lists</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>modifyRoute</name><operator>-&gt;</operator><name>rowValuesLists</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>modifyRouteList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>modifyRouteList</name></expr></argument>, <argument><expr><name>modifyRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>modifyRouteList</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionColumn</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get full list of insert values and iterate over them to prune */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertValuesList</name> <init>= <expr><call><name>ExtractInsertValuesList</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>partitionColumn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>insertValuesCell</argument>, <argument>insertValuesList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>InsertValues</name> <modifier>*</modifier></type><name>insertValues</name> <init>= <expr><operator>(</operator><name>InsertValues</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>insertValuesCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>prunedShardIntervalList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>partitionValueExpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>insertValues</name><operator>-&gt;</operator><name>partitionValueExpr</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We only support constant partition values at this point. Sometimes
		 * they are wrappend in an implicit coercion though. Most notably
		 * FuncExpr coercions for casts created with CREATE CAST ... WITH
		 * FUNCTION .. AS IMPLICIT. To support this first we strip them here.
		 * Then we do the coercion manually below using
		 * TransformPartitionRestrictionValue, if the types are not the same.
		 *
		 * NOTE: eval_const_expressions below would do some of these removals
		 * too, but it's unclear if it would do all of them. It is possible
		 * that there are no cases where this strip_implicit_coercions call is
		 * really necessary at all, but currently that's hard to rule out.
		 * So to be on the safe side we call strip_implicit_coercions too, to
		 * be sure we support as much as possible.
		 */</comment>
		<expr_stmt><expr><name>partitionValueExpr</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><name>partitionValueExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * By evaluating constant expressions an expression such as 2 + 4
		 * will become const 6. That way we can use them as a partition column
		 * value. Normally the planner evaluates constant expressions, but we
		 * may be working on the original query tree here. So we do it here
		 * explicitely before checking that the partition value is a const.
		 *
		 * NOTE: We do not use expression_planner here, since all it does
		 * apart from calling eval_const_expressions is call fix_opfuncids.
		 * This is not needed here, since it's a no-op for T_Const nodes and we
		 * error out below in all other cases.
		 */</comment>
		<expr_stmt><expr><name>partitionValueExpr</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>partitionValueExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>partitionValueExpr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to evaluate partition key in insert"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"try using constant values for partition column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>partitionValueConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>partitionValueExpr</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>partitionValueConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform an INSERT with NULL in the partition "</literal>
								   <literal type="string">"column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* actually do the coercions that we skipped before, if fails throw an
		 * error */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>partitionValueConst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>!=</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>partitionValueConst</name> <operator>=</operator>
				<call><name>TransformPartitionRestrictionValue</name><argument_list>(<argument><expr><name>partitionColumn</name></expr></argument>,
												   <argument><expr><name>partitionValueConst</name></expr></argument>,
												   <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>partitionValue</name> <init>= <expr><name><name>partitionValueConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>FindShardInterval</name><argument_list>(<argument><expr><name>partitionValue</name></expr></argument>, <argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>shardInterval</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>prunedShardIntervalList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>shardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Index</name></type> <name>tableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>equalityExpr</name> <init>= <expr><call><name>MakeOpExpression</name><argument_list>(<argument><expr><name>partitionColumn</name></expr></argument>,
													<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rightOp</name> <init>= <expr><call><name>get_rightop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>equalityExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rightOp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightOp</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>rightConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightOp</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rightConst</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <name><name>partitionValueConst</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rightConst</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name><name>partitionValueConst</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rightConst</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name><name>partitionValueConst</name><operator>-&gt;</operator><name>constbyval</name></name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictClauseList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>equalityExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>prunedShardIntervalList</name> <operator>=</operator> <call><name>PruneShards</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>tableId</name></expr></argument>,
												  <argument><expr><name>restrictClauseList</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>prunedShardIntervalCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>prunedShardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>prunedShardIntervalCount</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionKeyString</name> <init>= <expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>partitionKeyString</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionColumnName</name> <init>=
				<expr><call><name>ColumnToColumnName</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><name>partitionKeyString</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>errorMessage</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>errorHint</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetCountType</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>prunedShardIntervalCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>targetCountType</name> <operator>=</operator> <literal type="string">"no"</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>targetCountType</name> <operator>=</operator> <literal type="string">"multiple"</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>prunedShardIntervalCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorHint</name></expr></argument>, <argument><expr><literal type="string">"Make sure you have created a shard which "</literal>
											<literal type="string">"can receive this partition column value."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorHint</name></expr></argument>, <argument><expr><literal type="string">"Make sure the value for partition column "</literal>
											<literal type="string">"\"%s\" falls into a single shard."</literal></expr></argument>,
								 <argument><expr><name>partitionColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><literal type="string">"cannot run INSERT command which targets %s "</literal>
										   <literal type="string">"shards"</literal></expr></argument>, <argument><expr><name>targetCountType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>planningError</name><operator>)</operator> <operator>=</operator> <call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
											 <argument><expr><name><name>errorMessage</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name><name>errorHint</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>targetShard</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>prunedShardIntervalList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>insertValues</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>targetShard</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>modifyRouteList</name> <operator>=</operator> <call><name>GroupInsertValuesByShardId</name><argument_list>(<argument><expr><name>insertValuesList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>modifyRouteList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsMultiRowInsert returns whether the given query is a multi-row INSERT.
 *
 * It does this by determining whether the query is an INSERT that has an
 * RTE_VALUES. Single-row INSERTs will have their RTE_VALUES optimised away
 * in transformInsertStmt, and instead use the target list.
 */</comment>
<function><type><name>bool</name></type>
<name>IsMultiRowInsert</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ExtractDistributedInsertValuesRTE</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractDistributedInsertValuesRTE does precisely that. If the provided
 * query is not an INSERT, or if the INSERT does not have a VALUES RTE
 * (i.e. it is not a multi-row INSERT), this function returns NULL.
 * If all those conditions are met, an RTE representing the multiple values
 * of a multi-row INSERT is returned.
 */</comment>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>ExtractDistributedInsertValuesRTE</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rteCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rteCell</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rteCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>rte</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NormalizeMultiRowInsertTargetList ensures all elements of multi-row INSERT target
 * lists are Vars. In multi-row INSERTs, most target list entries contain a Var
 * expression pointing to a position within the values_lists field of a VALUES
 * RTE, but non-NULL default columns are handled differently. Instead of adding
 * the default expression to each row, a single expression encoding the DEFAULT
 * appears in the target list. For consistency, we move these expressions into
 * values lists and replace them with an appropriately constructed Var.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NormalizeMultiRowInsertTargetList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>valuesListCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>targetEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>targetEntryNo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>valuesRTE</name> <init>= <expr><call><name>ExtractDistributedInsertValuesRTE</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>valuesRTE</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>valuesListCell</argument>, <argument>valuesRTE-&gt;values_lists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>valuesList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>valuesListCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>valuesArray</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>PointerArrayFromList</name><argument_list>(<argument><expr><name>valuesList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>expandedValuesList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>targetExpr</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>targetExpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* expression from the VALUES section */</comment>
				<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetListVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>targetExpr</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>targetExpr</name> <operator>=</operator> <name><name>valuesArray</name><index>[<expr><name><name>targetListVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* copy the column's default expression */</comment>
				<expr_stmt><expr><name>targetExpr</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>targetExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>expandedValuesList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>expandedValuesList</name></expr></argument>, <argument><expr><name>targetExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>SetListCellPtr</name><argument_list>(<argument><expr><name>valuesListCell</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>expandedValuesList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* reset coltypes, coltypmods, colcollations and rebuild them below */</comment>
	<expr_stmt><expr><name><name>valuesRTE</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>valuesRTE</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>valuesRTE</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>targetExprNode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* RTE_VALUES comes 2nd, after destination table */</comment>
		<decl_stmt><decl><type><name>Index</name></type> <name>valuesVarno</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>targetEntryNo</name><operator>++</operator></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>targetType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>targetExprNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>targetTypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>targetExprNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>targetColl</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>targetExprNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>valuesRTE</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>valuesRTE</name><operator>-&gt;</operator><name>coltypes</name></name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>valuesRTE</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>valuesRTE</name><operator>-&gt;</operator><name>coltypmods</name></name></expr></argument>, <argument><expr><name>targetTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>valuesRTE</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>valuesRTE</name><operator>-&gt;</operator><name>colcollations</name></name></expr></argument>, <argument><expr><name>targetColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>targetExprNode</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>targetExprNode</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>targetVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>targetEntryNo</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* replace the original expression with a Var referencing values_lists */</comment>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>syntheticVar</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>valuesVarno</name></expr></argument>, <argument><expr><name>targetEntryNo</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>targetTypmod</name></expr></argument>,
									<argument><expr><name>targetColl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>syntheticVar</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Postgres appends a dummy column reference into valuesRTE-&gt;eref-&gt;colnames
		 * list in addRangeTableEntryForValues for each column specified in VALUES
		 * clause. Now that we replaced DEFAULT column with a synthetic Var, we also
		 * need to add a dummy column reference for that column.
		 */</comment>
		<expr_stmt><expr><call><name>AppendNextDummyColReference</name><argument_list>(<argument><expr><name><name>valuesRTE</name><operator>-&gt;</operator><name>eref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * AppendNextDummyColReference appends a new dummy column reference to colnames
 * list of given Alias object.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendNextDummyColReference</name><parameter_list>(<parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>expendedReferenceNames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>existingColReferences</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expendedReferenceNames</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nextColReferenceId</name> <init>= <expr><name>existingColReferences</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>missingColumnString</name> <init>= <expr><call><name>MakeDummyColumnString</name><argument_list>(<argument><expr><name>nextColReferenceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>expendedReferenceNames</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>expendedReferenceNames</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>,
											   <argument><expr><name>missingColumnString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MakeDummyColumnString returns a String (Value) object by appending given
 * integer to end of the "column" string.
 */</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>MakeDummyColumnString</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dummyColumnId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>dummyColumnStringInfo</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dummyColumnStringInfo</name></expr></argument>, <argument><expr><literal type="string">"column%d"</literal></expr></argument>, <argument><expr><name>dummyColumnId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>dummyColumnString</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>dummyColumnStringInfo</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>dummyColumnString</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IntersectPlacementList performs placement pruning based on matching on
 * nodeName:nodePort fields of shard placement data. We start pruning from all
 * placements of the first relation's shard. Then for each relation's shard, we
 * compute intersection of the new shards placement with existing placement list.
 * This operation could have been done using other methods, but since we do not
 * expect very high replication factor, iterating over a list and making string
 * comparisons should be sufficient.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>IntersectPlacementList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>lhsPlacementList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rhsPlacementList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lhsPlacementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Keep existing placement in the list if it is also present in new placement list */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lhsPlacementCell</argument>, <argument>lhsPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>lhsPlacement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lhsPlacementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rhsPlacementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>rhsPlacementCell</argument>, <argument>rhsPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>rhsPlacement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rhsPlacementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rhsPlacement</name><operator>-&gt;</operator><name>nodePort</name></name> <operator>==</operator> <name><name>lhsPlacement</name><operator>-&gt;</operator><name>nodePort</name></name> <operator>&amp;&amp;</operator>
				<call><name>strncmp</name><argument_list>(<argument><expr><name><name>rhsPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>, <argument><expr><name><name>lhsPlacement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
						<argument><expr><name>WORKER_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>placementList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>placementList</name></expr></argument>, <argument><expr><name>rhsPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We don't need to add the same placement over and over again. This
				 * could happen if both placements of a shard appear on the same node.
				 */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>placementList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GroupInsertValuesByShardId takes care of grouping the rows from a multi-row
 * INSERT by target shard. At this point, all pruning has taken place and we
 * need only to build sets of rows for each destination. This is done by a
 * simple sort (by shard identifier) and gather step. The sort has the side-
 * effect of getting things in ascending order to avoid unnecessary deadlocks
 * during Task execution.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GroupInsertValuesByShardId</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>insertValuesList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ModifyRoute</name> <modifier>*</modifier></type><name>route</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>insertValuesCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>modifyRouteList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>insertValuesList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>insertValuesList</name></expr></argument>, <argument><expr><name>CompareInsertValuesByShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>insertValuesCell</argument>, <argument>insertValuesList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>InsertValues</name> <modifier>*</modifier></type><name>insertValues</name> <init>= <expr><operator>(</operator><name>InsertValues</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>insertValuesCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><name><name>insertValues</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>foundSameShardId</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>route</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>route</name><operator>-&gt;</operator><name>shardId</name></name> <operator>==</operator> <name>shardId</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foundSameShardId</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* new shard id seen; current aggregation done; add to list */</comment>
				<expr_stmt><expr><name>modifyRouteList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>modifyRouteList</name></expr></argument>, <argument><expr><name>route</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>foundSameShardId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Our current value has the same shard id as our aggregate object,
			 * so append the rowValues.
			 */</comment>
			<expr_stmt><expr><name><name>route</name><operator>-&gt;</operator><name>rowValuesLists</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>route</name><operator>-&gt;</operator><name>rowValuesLists</name></name></expr></argument>,
											<argument><expr><name><name>insertValues</name><operator>-&gt;</operator><name>rowValues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* we encountered a new shard id; build a new aggregate object */</comment>
			<expr_stmt><expr><name>route</name> <operator>=</operator> <operator>(</operator><name>ModifyRoute</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ModifyRoute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>route</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>insertValues</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>route</name><operator>-&gt;</operator><name>rowValuesLists</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>insertValues</name><operator>-&gt;</operator><name>rowValues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* left holding one final aggregate object; add to list */</comment>
	<expr_stmt><expr><name>modifyRouteList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>modifyRouteList</name></expr></argument>, <argument><expr><name>route</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>modifyRouteList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractInsertValuesList extracts the partition column value for an INSERT
 * command and returns it within an InsertValues struct. For single-row INSERTs
 * this is simply a value extracted from the target list, but multi-row INSERTs
 * will generate a List of InsertValues, each with full row values in addition
 * to the partition value. If a partition value is NULL or missing altogether,
 * this function errors.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExtractInsertValuesList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>insertValuesList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
												<argument><expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetEntry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform an INSERT without a partition column "</literal>
							   <literal type="string">"value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We've got a multi-row INSERT. PostgreSQL internally represents such
	 * commands by linking Vars in the target list to lists of values within
	 * a special VALUES range table entry. By extracting the right positional
	 * expression from each list within that RTE, we will extract the partition
	 * values for each row within the multi-row INSERT.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>valuesListCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>ivIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>referencedRTE</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>partitionVar</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>valuesListCell</argument>, <argument>referencedRTE-&gt;values_lists</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>InsertValues</name> <modifier>*</modifier></type><name>insertValues</name> <init>= <expr><operator>(</operator><name>InsertValues</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>InsertValues</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>insertValues</name><operator>-&gt;</operator><name>rowValues</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>valuesListCell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>insertValues</name><operator>-&gt;</operator><name>partitionValueExpr</name></name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>insertValues</name><operator>-&gt;</operator><name>rowValues</name></name></expr></argument>,
														<argument><expr><operator>(</operator><name><name>partitionVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>insertValues</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name>INVALID_SHARD_ID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>insertValues</name><operator>-&gt;</operator><name>listIndex</name></name> <operator>=</operator> <name>ivIndex</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>insertValuesList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>insertValuesList</name></expr></argument>, <argument><expr><name>insertValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ivIndex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* nothing's been found yet; this is a simple single-row INSERT */</comment>
	<if_stmt><if>if <condition>(<expr><name>insertValuesList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>InsertValues</name> <modifier>*</modifier></type><name>insertValues</name> <init>= <expr><operator>(</operator><name>InsertValues</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>InsertValues</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>insertValues</name><operator>-&gt;</operator><name>rowValues</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>insertValues</name><operator>-&gt;</operator><name>partitionValueExpr</name></name> <operator>=</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>insertValues</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name>INVALID_SHARD_ID</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>insertValuesList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>insertValuesList</name></expr></argument>, <argument><expr><name>insertValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>insertValuesList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractInsertPartitionKeyValue extracts the partition column value
 * from an INSERT query. If the expression in the partition column is
 * non-constant or it is a multi-row INSERT with multiple different partition
 * column values, the function returns NULL.
 */</comment>
<function><type><name>Const</name> <modifier>*</modifier></type>
<name>ExtractInsertPartitionKeyValue</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><call><name>ExtractFirstCitusTableId</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>rangeTableId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>singlePartitionValueConst</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>rangeTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
												<argument><expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>targetEntry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* partition column value not specified */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>targetExpression</name> <init>= <expr><call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Multi-row INSERTs have a Var in the target list that points to
	 * an RTE_VALUES.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>targetExpression</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>targetExpression</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>valuesListCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>referencedRTE</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>partitionVar</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>valuesListCell</argument>, <argument>referencedRTE-&gt;values_lists</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rowValues</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>valuesListCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>partitionValueNode</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>rowValues</name></expr></argument>, <argument><expr><name><name>partitionVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>partitionValueExpr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>strip_implicit_coercions</name><argument_list>(
				<argument><expr><name>partitionValueNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>partitionValueExpr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* non-constant value in the partition column */</comment>
				<expr_stmt><expr><name>singlePartitionValueConst</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>partitionValueConst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>partitionValueExpr</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>singlePartitionValueConst</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* first row has a constant in the partition column, looks promising! */</comment>
				<expr_stmt><expr><name>singlePartitionValueConst</name> <operator>=</operator> <name>partitionValueConst</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>partitionValueConst</name></expr></argument>, <argument><expr><name>singlePartitionValueConst</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* multiple different values in the partition column, too bad */</comment>
				<expr_stmt><expr><name>singlePartitionValueConst</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* another row with the same partition column value! */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>targetExpression</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* single-row INSERT with a constant partition column value */</comment>
		<expr_stmt><expr><name>singlePartitionValueConst</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>targetExpression</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* single-row INSERT with a non-constant partition column value */</comment>
		<expr_stmt><expr><name>singlePartitionValueConst</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>singlePartitionValueConst</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>singlePartitionValueConst</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>singlePartitionValueConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>singlePartitionValueConst</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeferErrorIfUnsupportedRouterPlannableSelectQuery checks if given query is router plannable,
 * SELECT query, setting distributedPlan-&gt;planningError if not.
 * The query is router plannable if it is a modify query, or if it is a select
 * query issued on a hash partitioned distributed table. Router plannable checks
 * for select queries can be turned off by setting citus.enable_router_execution
 * flag to false.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>DeferErrorIfUnsupportedRouterPlannableSelectQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableRelationList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableRelationCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_ASSERT_FAILURE</name></expr></argument>,
							 <argument><expr><literal type="string">"Only SELECT query types are supported in this path"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableRouterExecution</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_SUCCESSFUL_COMPLETION</name></expr></argument>,
							 <argument><expr><literal type="string">"Router planner not enabled."</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>hasPostgresOrCitusLocalTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasDistributedTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasReferenceTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExtractRangeTableRelationWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rangeTableRelationList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>rangeTableRelationCell</argument>, <argument>rangeTableRelationList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableRelationCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* local tables are allowed if there are no distributed tables */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>hasPostgresOrCitusLocalTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>hasReferenceTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>hasPostgresOrCitusLocalTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"Router planner finds a local table added to metadata"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(
					<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
					<argument><expr><literal type="string">"Router planner does not support append-partitioned tables."</literal></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>hasDistributedTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Currently, we don't support tables with replication factor &gt; 1,
			 * except reference tables with SELECT ... FOR UPDATE queries. It is
			 * also not supported from MX nodes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasForUpdate</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint32</name></type> <name>tableReplicationFactor</name> <init>= <expr><call><name>TableShardReplicationFactor</name><argument_list>(
					<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>tableReplicationFactor</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>,
																   <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><call><name>DeferredError</name><argument_list>(
						<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
						<argument><expr><literal type="string">"SELECT FOR UPDATE with table replication factor &gt; 1 not supported for non-reference tables."</literal></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We want to make sure nextval happens on the coordinator / the current
	 * node, since the user may have certain expectations around the values
	 * produced by the sequence. We therefore cannot push down the nextval
	 * call as part of a router query.
	 *
	 * We let queries with nextval in the target list fall through to
	 * the logical planner, which will ensure that the nextval is called
	 * in the combine query on the coordinator.
	 *
	 * If there are no distributed or reference tables in the query,
	 * then the query will anyway happen on the coordinator, so we can
	 * allow nextval.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_nextval_expression_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>hasDistributedTable</name> <operator>||</operator> <name>hasReferenceTable</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"Sequences cannot be used in router queries"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* local tables are not allowed if there are distributed tables */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasPostgresOrCitusLocalTable</name> <operator>&amp;&amp;</operator> <name>hasDistributedTable</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"Local tables cannot be used in distributed queries."</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>CTEWithSearchClauseError</name> <init>=
		<expr><call><name>ErrorIfQueryHasCTEWithSearchClause</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>CTEWithSearchClauseError</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>CTEWithSearchClauseError</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>ErrorIfQueryHasUnroutableModifyingCTE</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Copy a RelationRestrictionContext. Note that several subfields are copied
 * shallowly, for lack of copyObject support.
 *
 * Note that CopyRelationRestrictionContext copies the following fields per relation
 * context: index, relationId, distributedRelation, rte, relOptInfo-&gt;baserestrictinfo
 * and relOptInfo-&gt;joininfo. Also, the function shallowly copies plannerInfo and
 * prunedShardIntervalList which are read-only. All other parts of the relOptInfo
 * is also shallowly copied.
 */</comment>
<function><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type>
<name>CopyRelationRestrictionContext</name><parameter_list>(<parameter><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>oldContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationRestrictionContext</name> <modifier>*</modifier></type><name>newContext</name> <init>=
		<expr><operator>(</operator><name>RelationRestrictionContext</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationRestrictionContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relationRestrictionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>newContext</name><operator>-&gt;</operator><name>allReferenceTables</name></name> <operator>=</operator> <name><name>oldContext</name><operator>-&gt;</operator><name>allReferenceTables</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newContext</name><operator>-&gt;</operator><name>relationRestrictionList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>relationRestrictionCell</argument>, <argument>oldContext-&gt;relationRestrictionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>oldRestriction</name> <init>=
			<expr><operator>(</operator><name>RelationRestriction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>relationRestrictionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelationRestriction</name> <modifier>*</modifier></type><name>newRestriction</name> <init>= <expr><operator>(</operator><name>RelationRestriction</name> <operator>*</operator><operator>)</operator>
											  <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationRestriction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>newRestriction</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>oldRestriction</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newRestriction</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>oldRestriction</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newRestriction</name><operator>-&gt;</operator><name>citusTable</name></name> <operator>=</operator> <name><name>oldRestriction</name><operator>-&gt;</operator><name>citusTable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newRestriction</name><operator>-&gt;</operator><name>rte</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>oldRestriction</name><operator>-&gt;</operator><name>rte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* can't be copied, we copy (flatly) a RelOptInfo, and then decouple baserestrictinfo */</comment>
		<expr_stmt><expr><name><name>newRestriction</name><operator>-&gt;</operator><name>relOptInfo</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name><name>newRestriction</name><operator>-&gt;</operator><name>relOptInfo</name></name> <operator>=</operator> <operator>*</operator><name><name>oldRestriction</name><operator>-&gt;</operator><name>relOptInfo</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>newRestriction</name><operator>-&gt;</operator><name>relOptInfo</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>=</operator>
			<call><name>copyObject</name><argument_list>(<argument><expr><name><name>oldRestriction</name><operator>-&gt;</operator><name>relOptInfo</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>newRestriction</name><operator>-&gt;</operator><name>relOptInfo</name><operator>-&gt;</operator><name>joininfo</name></name> <operator>=</operator>
			<call><name>copyObject</name><argument_list>(<argument><expr><name><name>oldRestriction</name><operator>-&gt;</operator><name>relOptInfo</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* not copyable, but readonly */</comment>
		<expr_stmt><expr><name><name>newRestriction</name><operator>-&gt;</operator><name>plannerInfo</name></name> <operator>=</operator> <name><name>oldRestriction</name><operator>-&gt;</operator><name>plannerInfo</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>newContext</name><operator>-&gt;</operator><name>relationRestrictionList</name></name> <operator>=</operator>
			<call><name>lappend</name><argument_list>(<argument><expr><name><name>newContext</name><operator>-&gt;</operator><name>relationRestrictionList</name></name></expr></argument>, <argument><expr><name>newRestriction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>newContext</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfQueryHasUnroutableModifyingCTE checks if the query contains modifying common table
 * expressions and errors out if it does.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>ErrorIfQueryHasUnroutableModifyingCTE</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>queryTree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>queryTree</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we can't route conflicting replication models */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>cte</argument>, <argument>queryTree-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>cteQuery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Here we only check for command type of top level query. Normally there can be
		 * nested CTE, however PostgreSQL dictates that data-modifying statements must
		 * be at top level of CTE. Therefore it is OK to just check for top level.
		 * Similarly, we do not need to check for subqueries.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cteQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<name><name>cteQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
			<name><name>cteQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"only SELECT, UPDATE, or DELETE common table expressions "</literal>
								 <literal type="string">"may be router planned"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cteQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>distributedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>cteError</name> <init>=
				<expr><call><name>ModifyPartialQuerySupported</name><argument_list>(<argument><expr><name>cteQuery</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>cteError</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>cteError</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>modificationTableCacheEntry</name> <init>=
				<expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>distributedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>modificationTableCacheEntry</name></expr></argument>,
										   <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"cannot router plan modification of a non-distributed table"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>replicationModel</name> <operator>&amp;&amp;</operator>
				<name><name>modificationTableCacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>!=</operator> <name>replicationModel</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
									 <argument><expr><literal type="string">"cannot route mixed replication models"</literal></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>replicationModel</name> <operator>=</operator> <name><name>modificationTableCacheEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* everything OK */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>

<comment type="block">/*
 * ErrorIfQueryHasCTEWithSearchClause checks if the query contains any common table
 * expressions with search clause and errors out if it does.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>ErrorIfQueryHasCTEWithSearchClause</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>queryTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ContainsSearchClauseWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>queryTree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"CTEs with search clauses are not supported"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsSearchClauseWalker walks over the node and finds if there are any
 * CommonTableExprs with search clause
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsSearchClauseWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CommonTableExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>search_clause</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>ContainsSearchClauseWalker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ContainsSearchClauseWalker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * get_all_actual_clauses
 *
 * Returns a list containing the bare clauses from 'restrictinfo_list'.
 *
 * This loses the distinction between regular and pseudoconstant clauses,
 * so be careful what you use it for.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_all_actual_clauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictinfo_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>restrictinfo_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareInsertValuesByShardId does what it says in the name. Used for sorting
 * InsertValues objects by their shard.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareInsertValuesByShardId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>InsertValues</name> <modifier>*</modifier></type><name>leftValue</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>InsertValues</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InsertValues</name> <modifier>*</modifier></type><name>rightValue</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>InsertValues</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>leftShardId</name> <init>= <expr><name><name>leftValue</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>rightShardId</name> <init>= <expr><name><name>rightValue</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>leftIndex</name> <init>= <expr><name><name>leftValue</name><operator>-&gt;</operator><name>listIndex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type> <name>rightIndex</name> <init>= <expr><name><name>rightValue</name><operator>-&gt;</operator><name>listIndex</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>leftShardId</name> <operator>&gt;</operator> <name>rightShardId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>leftShardId</name> <operator>&lt;</operator> <name>rightShardId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* shard identifiers are the same, list index is secondary sort key */</comment>
		<if_stmt><if>if <condition>(<expr><name>leftIndex</name> <operator>&gt;</operator> <name>rightIndex</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>leftIndex</name> <operator>&lt;</operator> <name>rightIndex</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
