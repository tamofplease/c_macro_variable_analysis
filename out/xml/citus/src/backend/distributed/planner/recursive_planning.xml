<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/planner/recursive_planning.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * recursive_planning.c
 *
 * Logic for calling the postgres planner recursively for CTEs and
 * non-pushdownable subqueries in distributed queries.
 *
 * PostgreSQL with Citus can execute 4 types of queries:
 *
 * - Postgres queries on local tables and functions.
 *
 *   These queries can use all SQL features, but they may not reference
 *   distributed tables.
 *
 * - Router queries that can be executed on a single by node by replacing
 *   table names with shard names.
 *
 *   These queries can use nearly all SQL features, but only if they have
 *   a single-valued filter on the distribution column.
 *
 * - Multi-shard queries that can be executed by performing a task for each
 *   shard in a distributed table and performing a merge step.
 *
 *   These queries have limited SQL support. They may only include
 *   subqueries if the subquery can be executed on each shard by replacing
 *   table names with shard names and concatenating the result.
 *
 *   These queries have very limited SQL support and only support basic
 *   inner joins and subqueries without joins.
 *
 * To work around the limitations of these planners, we recursively call
 * the planner for CTEs and unsupported subqueries to obtain a list of
 * subplans.
 *
 * During execution, each subplan is executed separately through the method
 * that is appropriate for that query. The results are written to temporary
 * files on the workers. In the original query, the CTEs and subqueries are
 * replaced by mini-subqueries that read from the temporary files.
 *
 * This allows almost all SQL to be directly or indirectly supported,
 * because if all subqueries that contain distributed tables have been
 * replaced then what remains is a router query which can use nearly all
 * SQL features.
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/multi_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_distributed_join_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_server_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_colocation_checker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/query_pushdown_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/recursive_planning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_restriction_equivalence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_pruning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * RecursivePlanningContext is used to recursively plan subqueries
 * and CTEs, pull results to the coordinator, and push it back into
 * the workers.
 */</comment>
<struct>struct <name>RecursivePlanningContextInternal</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>planId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>allDistributionKeysInQueryAreEqual</name></decl>;</decl_stmt> <comment type="block">/* used for some optimizations */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subPlanList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* track depth of current recursive planner query */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recursivePlanningDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * CteReferenceWalkerContext is used to collect CTE references in
 * CteReferenceListWalker.
 */</comment>
<typedef>typedef <type><struct>struct <name>CteReferenceWalkerContext</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cteReferenceList</name></decl>;</decl_stmt>
}</block></struct></type> <name>CteReferenceWalkerContext</name>;</typedef>

<comment type="block">/*
 * VarLevelsUpWalkerContext is used to find Vars in a (sub)query that
 * refer to upper levels and therefore cannot be planned separately.
 */</comment>
<typedef>typedef <type><struct>struct <name>VarLevelsUpWalkerContext</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
}</block></struct></type> <name>VarLevelsUpWalkerContext</name>;</typedef>


<comment type="block">/* local function forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>RecursivelyPlanSubqueriesAndCTEs</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
															   <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type>
															   <name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldRecursivelyPlanNonColocatedSubqueries</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
														<parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type>
														<name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldRecursivelyPlanOuterJoins</name><parameter_list>(<parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecursivelyPlanNonColocatedSubqueries</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
												  <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecursivelyPlanNonColocatedJoinWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinNode</name></decl></parameter>,
												  <parameter><decl><type><name>ColocatedJoinChecker</name> <modifier>*</modifier></type>
												  <name>colocatedJoinChecker</name></decl></parameter>,
												  <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type>
												  <name>recursivePlanningContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecursivelyPlanNonColocatedSubqueriesInWhere</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
														 <parameter><decl><type><name>ColocatedJoinChecker</name> <modifier>*</modifier></type>
														 <name>colocatedJoinChecker</name></decl></parameter>,
														 <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type>
														 <name>recursivePlanningContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecursivelyPlanRecurringTupleOuterJoinWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
														 <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecursivelyPlanDistributedJoinNode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
											   <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsRTERefRecurring</name><parameter_list>(<parameter><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>SublinkListFromWhere</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExtractSublinkWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>sublinkList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldRecursivelyPlanSublinks</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecursivelyPlanAllSubqueries</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										 <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>planningContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type> <name>RecursivelyPlanCTEs</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
												  <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecursivelyPlanSubqueryWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldRecursivelyPlanSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
										  <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AllDistributionKeysInSubqueryAreEqual</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
												  <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
												  <name>restrictionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldRecursivelyPlanSetOperation</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
											  <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecursivelyPlanSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
									<parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>planningContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RecursivelyPlanSetOperations</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										 <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsLocalTableRteOrMatView</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DistributedSubPlan</name> <modifier>*</modifier></type> <name>CreateDistributedSubPlan</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>subPlanId</name></decl></parameter>,
													 <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subPlanQuery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CteReferenceListWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>CteReferenceWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsReferencesToOuterQueryWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
												 <parameter><decl><type><name>VarLevelsUpWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NodeContainsSubqueryReferencingOuterQuery</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WrapFunctionsInSubqueries</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TransformFunctionRTE</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTblEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldTransformRTE</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type> <name>BuildReadIntermediateResultsQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnAliasList</name></decl></parameter>,
												 <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultIdConst</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>,
												 <parameter><decl><type><name>bool</name></type> <name>useBinaryCopyFormat</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateVarNosInNode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>newVarNo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type> <name>CreateOuterSubquery</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outerSubqueryTargetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateRequiredColNamesFromTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetRelationNameAndAliasName</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTablentry</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * GenerateSubplansForSubqueriesAndCTEs is a wrapper around RecursivelyPlanSubqueriesAndCTEs.
 * The function returns the subplans if necessary. For the details of when/how subplans are
 * generated, see RecursivelyPlanSubqueriesAndCTEs().
 *
 * Note that the input originalQuery query is modified if any subplans are generated.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GenerateSubplansForSubqueriesAndCTEs</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>,
									 <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>plannerRestrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RecursivePlanningContext</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursivePlanningDepth</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Plan subqueries and CTEs that cannot be pushed down by recursively
	 * calling the planner and add the resulting plans to subPlanList.
	 */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>planId</name></name> <operator>=</operator> <name>planId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>subPlanList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>plannerRestrictionContext</name></name> <operator>=</operator> <name>plannerRestrictionContext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculating the distribution key equality upfront is a trade-off for us.
	 *
	 * When the originalQuery contains the distribution key equality, we'd be
	 * able to skip further checks for each lower level subqueries (i.e., if the
	 * all query contains distribution key equality, each subquery also contains
	 * distribution key equality.)
	 *
	 * When the originalQuery doesn't contain the distribution key equality,
	 * calculating this wouldn't help us at all, we should individually check
	 * each each subquery and subquery joins among subqueries.
	 */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>allDistributionKeysInQueryAreEqual</name></name> <operator>=</operator>
		<call><name>AllDistributionKeysInQueryAreEqual</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>plannerRestrictionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>RecursivelyPlanSubqueriesAndCTEs</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>,
																   <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>recursivePlanningDepth</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>subPlanList</name></name> <operator>&amp;&amp;</operator> <call><name>IsLoggableLevel</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>subPlanString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pg_get_query_def</name><argument_list>(<argument><expr><name>originalQuery</name></expr></argument>, <argument><expr><name>subPlanString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							 <argument><expr><literal type="string">"Plan "</literal> <name>UINT64_FORMAT</name>
							 <literal type="string">" query after replacing subqueries and CTEs: %s"</literal></expr></argument>, <argument><expr><name>planId</name></expr></argument>,
							 <argument><expr><name><name>subPlanString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>recursivePlanningDepth</name><operator>--</operator></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>subPlanList</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanSubqueriesAndCTEs finds subqueries and CTEs that cannot be pushed down to
 * workers directly and instead plans them by recursively calling the planner and
 * adding the subplan to subPlanList.
 *
 * Subplans are executed prior to the distributed plan and the results are written
 * to temporary files on workers.
 *
 * CTE references are replaced by a subquery on the read_intermediate_result
 * function, which reads from the temporary file.
 *
 * If recursive planning results in an error then the error is returned. Otherwise, the
 * subplans will be added to subPlanList.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>RecursivelyPlanSubqueriesAndCTEs</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>RecursivelyPlanCTEs</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>error</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>SubqueryPushdown</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When the subquery_pushdown flag is enabled we make some hacks
		 * to push down subqueries with LIMIT. Recursive planning would
		 * valiantly do the right thing and try to recursively plan the
		 * inner subqueries, but we don't really want it to because those
		 * subqueries might not be supported and would be much slower.
		 *
		 * Instead, we skip recursive planning altogether when
		 * subquery_pushdown is enabled.
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* make sure function calls in joins are executed in the coordinator */</comment>
	<expr_stmt><expr><call><name>WrapFunctionsInSubqueries</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* descend into subqueries */</comment>
	<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>RecursivelyPlanSubqueryWalker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * At this point, all CTEs, leaf subqueries containing local tables and
	 * non-pushdownable subqueries have been replaced. We now check for
	 * combinations of subqueries that cannot be pushed down (e.g.
	 * &lt;subquery on reference table&gt; UNION &lt;subquery on distributed table&gt;).
	 *
	 * This code also runs for the top-level query, which allows us to support
	 * top-level set operations.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>ShouldRecursivelyPlanSetOperation</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RecursivelyPlanSetOperations</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the FROM clause is recurring (does not contain a distributed table),
	 * then we cannot have any distributed tables appearing in subqueries in
	 * the SELECT and WHERE clauses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ShouldRecursivelyPlanSublinks</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* replace all subqueries in the WHERE clause */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RecursivelyPlanAllSubqueries</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* replace all subqueries in the SELECT clause */</comment>
		<expr_stmt><expr><call><name>RecursivelyPlanAllSubqueries</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>NodeContainsSubqueryReferencingOuterQuery</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"Subqueries in HAVING cannot refer to outer query"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>RecursivelyPlanAllSubqueries</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the query doesn't have distribution key equality,
	 * recursively plan some of its subqueries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ShouldRecursivelyPlanNonColocatedSubqueries</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RecursivelyPlanNonColocatedSubqueries</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><call><name>ShouldConvertLocalTableJoinsToSubqueries</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Logical planner cannot handle "local_table" [OUTER] JOIN "dist_table", or
		 * a query with local table/citus local table and subquery. We convert local/citus local
		 * tables to a subquery until they can be planned.
		 */</comment>
		<expr_stmt><expr><call><name>RecursivelyPlanLocalTableJoins</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Similarly, logical planner cannot handle outer joins when the outer rel
	 * is recurring, such as "&lt;recurring&gt; LEFT JOIN &lt;distributed&gt;". In that case,
	 * we convert distributed table into a subquery and recursively plan inner
	 * side of the outer join. That way, inner rel gets converted into an intermediate
	 * result and logical planner can handle the new query since it's of the from
	 * "&lt;recurring&gt; LEFT JOIN &lt;recurring&gt;".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ShouldRecursivelyPlanOuterJoins</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RecursivelyPlanRecurringTupleOuterJoinWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
													 <argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetPlannerRestrictionContext returns the planner restriction context
 * from the given context.
 */</comment>
<function><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type>
<name>GetPlannerRestrictionContext</name><parameter_list>(<parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>recursivePlanningContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>recursivePlanningContext</name><operator>-&gt;</operator><name>plannerRestrictionContext</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldRecursivelyPlanNonColocatedSubqueries returns true if the input query contains joins
 * that are not on the distribution key.
 * *
 * Note that at the point that this function is called, we've already recursively planned all
 * the leaf subqueries. Thus, we're actually checking whether the joins among the subqueries
 * on the distribution key or not.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldRecursivelyPlanNonColocatedSubqueries</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
											<parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the input query already contains the equality, simply return since it is not
	 * possible to find any non colocated subqueries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>allDistributionKeysInQueryAreEqual</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This check helps us in two ways:
	 *   (i) We're not targeting queries that don't include subqueries at all,
	 *       they should go through regular planning.
	 *  (ii) Lower level subqueries are already recursively planned, so we should
	 *       only bother non-colocated subquery joins, which only happens when
	 *       there are subqueries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ContainsSubquery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* direct joins with local tables are not supported by any of Citus planners */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
													  <argument><expr><name>IsLocalTableRteOrMatView</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Finally, check whether this subquery contains distribution key equality or not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AllDistributionKeysInSubqueryAreEqual</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>,
											   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>plannerRestrictionContext</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsSubquery returns true if the input query contains any subqueries
 * in the FROM or WHERE clauses.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>JoinTreeContainsSubquery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>WhereOrHavingClauseContainsSubquery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldRecursivelyPlanOuterJoins returns true if the JoinRestrictionContext
 * that given RecursivePlanningContext holds implies that the query has outer
 * join(s) that might need to be recursively planned.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldRecursivelyPlanOuterJoins</name><parameter_list>(<parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>context</name> <operator>||</operator> <operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>plannerRestrictionContext</name></name> <operator>||</operator>
		<operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpectedly got NULL pointer in recursive "</literal>
							   <literal type="string">"planning context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>context</name><operator>-&gt;</operator><name>plannerRestrictionContext</name><operator>-&gt;</operator><name>joinRestrictionContext</name><operator>-&gt;</operator><name>hasOuterJoin</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanNonColocatedSubqueries gets a query which includes one or more
 * other subqueries that are not joined on their distribution keys. The function
 * tries to recursively plan some of the subqueries to make the input query
 * executable by Citus.
 *
 * The function picks an anchor subquery and iterates on the remaining subqueries.
 * Whenever it finds a non colocated subquery with the anchor subquery, the function
 * decides to recursively plan the non colocated subquery.
 *
 * The function first handles subqueries in FROM clause (i.e., jointree-&gt;fromlist) and then
 * subqueries in WHERE clause (i.e., jointree-&gt;quals).
 *
 * The function does not treat outer joins seperately. Thus, we might end up with
 * a query where the function decides to recursively plan an outer side of an outer
 * join (i.e., LEFT side of LEFT JOIN). For simplicity, we chose to do so and handle
 * outer joins with a seperate pass on the join tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecursivelyPlanNonColocatedSubqueries</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>joinTree</name> <init>= <expr><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create the context for the non colocated subquery planning */</comment>
	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>plannerRestrictionContext</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColocatedJoinChecker</name></type> <name>colocatedJoinChecker</name> <init>= <expr><call><name>CreateColocatedJoinChecker</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>,
																		   <argument><expr><name>restrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Although this is a rare case, we weren't able to pick an anchor
	 * range table entry, so we cannot continue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>colocatedJoinChecker</name><operator>.</operator><name>anchorRelationRestrictionList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* handle from clause subqueries first */</comment>
	<expr_stmt><expr><call><name>RecursivelyPlanNonColocatedJoinWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinTree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colocatedJoinChecker</name></expr></argument>,
										  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* handle subqueries in WHERE clause */</comment>
	<expr_stmt><expr><call><name>RecursivelyPlanNonColocatedSubqueriesInWhere</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colocatedJoinChecker</name></expr></argument>,
												 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanNonColocatedJoinWalker gets a join node and walks over it to find
 * subqueries that live under the node.
 *
 * When a subquery found, it's checked whether the subquery is colocated with the
 * anchor subquery specified in the nonColocatedJoinContext. If not,
 * the subquery is recursively planned.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecursivelyPlanNonColocatedJoinWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>joinNode</name></decl></parameter>,
									  <parameter><decl><type><name>ColocatedJoinChecker</name> <modifier>*</modifier></type><name>colocatedJoinChecker</name></decl></parameter>,
									  <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>recursivePlanningContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>joinNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>joinNode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>fromExpr</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>fromExprCell</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * For each element of the from list, check whether the element is
		 * colocated with the anchor subquery by recursing until we
		 * find the subqueries.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>fromExprCell</argument>, <argument>fromExpr-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>fromElement</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fromExprCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>RecursivelyPlanNonColocatedJoinWalker</name><argument_list>(<argument><expr><name>fromElement</name></expr></argument>, <argument><expr><name>colocatedJoinChecker</name></expr></argument>,
												  <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>joinNode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>joinNode</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* recurse into the left subtree */</comment>
		<expr_stmt><expr><call><name>RecursivelyPlanNonColocatedJoinWalker</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>colocatedJoinChecker</name></expr></argument>,
											  <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* recurse into the right subtree */</comment>
		<expr_stmt><expr><call><name>RecursivelyPlanNonColocatedJoinWalker</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>colocatedJoinChecker</name></expr></argument>,
											  <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>joinNode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>rangeTableIndex</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>joinNode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>colocatedJoinChecker</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rangeTableIndex</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we're only interested in subqueries for now */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the subquery is not colocated with the anchor subquery,
		 * recursively plan it.
		 */</comment>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SubqueryColocated</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>colocatedJoinChecker</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RecursivelyPlanSubquery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanNonColocatedSubqueriesInWhere gets a query and walks over its
 * sublinks to find subqueries that live in WHERE clause.
 *
 * When a subquery found, it's checked whether the subquery is colocated with the
 * anchor subquery specified in the nonColocatedJoinContext. If not,
 * the subquery is recursively planned.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecursivelyPlanNonColocatedSubqueriesInWhere</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
											 <parameter><decl><type><name>ColocatedJoinChecker</name> <modifier>*</modifier></type><name>colocatedJoinChecker</name></decl></parameter>,
											 <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type>
											 <name>recursivePlanningContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sublinkList</name> <init>= <expr><call><name>SublinkListFromWhere</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>sublinkCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>sublinkCell</argument>, <argument>sublinkList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>sublinkCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* subselect is probably never NULL, but anyway lets keep the check */</comment>
		<if_stmt><if>if <condition>(<expr><name>subselect</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SubqueryColocated</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>, <argument><expr><name>colocatedJoinChecker</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RecursivelyPlanSubquery</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>, <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanRecurringTupleOuterJoinWalker descends into a join tree and
 * recursively plans all non-recurring (i.e., distributed) rels that that
 * participate in an outer join expression together with a recurring rel,
 * such as &lt;distributed&gt; in "&lt;recurring&gt; LEFT JOIN &lt;distributed&gt;", i.e.,
 * where the recurring rel causes returning recurring tuples from the worker
 * nodes.
 *
 * Returns true if given node is recurring.
 *
 * See RecursivelyPlanDistributedJoinNode() function for the explanation on
 * what does it mean for a node to be "recurring" or "distributed".
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RecursivelyPlanRecurringTupleOuterJoinWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
											 <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type>
											 <name>recursivePlanningContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>fromExpr</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>fromExprCell</name></decl>;</decl_stmt>

		<comment type="block">/* search for join trees in each FROM element */</comment>
		<macro><name>foreach</name><argument_list>(<argument>fromExprCell</argument>, <argument>fromExpr-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>fromElement</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fromExprCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>RecursivelyPlanRecurringTupleOuterJoinWalker</name><argument_list>(<argument><expr><name>fromElement</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
														 <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Can only appear during the top-level call and top-level callers
		 * are not interested in the return value. Even more, we can't tell
		 * whether a FromExpr is recurring or not.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>leftNode</name> <init>= <expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rightNode</name> <init>= <expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rarg</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * There may be recursively plannable outer joins deeper in the join tree.
		 *
		 * We first handle the sub join trees and then the top level one since the
		 * top level join expression might not require recursive planning after
		 * handling the sub join trees.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>leftNodeRecurs</name> <init>=
			<expr><call><name>RecursivelyPlanRecurringTupleOuterJoinWalker</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
														 <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>rightNodeRecurs</name> <init>=
			<expr><call><name>RecursivelyPlanRecurringTupleOuterJoinWalker</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
														 <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* &lt;recurring&gt; left join &lt;distributed&gt; */</comment>
				<if_stmt><if>if <condition>(<expr><name>leftNodeRecurs</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>rightNodeRecurs</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recursively planning right side of "</literal>
											<literal type="string">"the left join since the outer side "</literal>
											<literal type="string">"is a recurring rel"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>RecursivelyPlanDistributedJoinNode</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
													   <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * A LEFT JOIN is recurring if the lhs is recurring.
				 * Note that we might have converted the rhs into a recurring
				 * one too if the lhs is recurring, but this anyway has no
				 * effects when deciding whether a LEFT JOIN is recurring.
				 */</comment>
				<return>return <expr><name>leftNodeRecurs</name></expr>;</return>
			</block_content>}</block>

			<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* &lt;distributed&gt; right join &lt;recurring&gt; */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>leftNodeRecurs</name> <operator>&amp;&amp;</operator> <name>rightNodeRecurs</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recursively planning left side of "</literal>
											<literal type="string">"the right join since the outer side "</literal>
											<literal type="string">"is a recurring rel"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>RecursivelyPlanDistributedJoinNode</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
													   <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Similar to LEFT JOINs, a RIGHT JOIN is recurring if the rhs
				 * is recurring.
				 */</comment>
				<return>return <expr><name>rightNodeRecurs</name></expr>;</return>
			</block_content>}</block>

			<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * &lt;recurring&gt; full join &lt;distributed&gt;
				 * &lt;distributed&gt; full join &lt;recurring&gt;
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>leftNodeRecurs</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>rightNodeRecurs</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recursively planning right side of "</literal>
											<literal type="string">"the full join since the other side "</literal>
											<literal type="string">"is a recurring rel"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>RecursivelyPlanDistributedJoinNode</name><argument_list>(<argument><expr><name>rightNode</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
													   <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name>leftNodeRecurs</name> <operator>&amp;&amp;</operator> <name>rightNodeRecurs</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recursively planning left side of "</literal>
											<literal type="string">"the full join since the other side "</literal>
											<literal type="string">"is a recurring rel"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>RecursivelyPlanDistributedJoinNode</name><argument_list>(<argument><expr><name>leftNode</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
													   <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * An OUTER JOIN is recurring if any sides of the join is
				 * recurring. As in other outer join types, it doesn't matter
				 * whether the other side was / became recurring or not.
				 */</comment>
				<return>return <expr><name>leftNodeRecurs</name> <operator>||</operator> <name>rightNodeRecurs</name></expr>;</return>
			</block_content>}</block>

			<case>case <expr><name>JOIN_INNER</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * We don't need to recursively plan non-outer joins and we
				 * already descended into sub join trees to handle outer joins
				 * buried in them.
				 */</comment>
				<return>return <expr><name>leftNodeRecurs</name> <operator>&amp;&amp;</operator> <name>rightNodeRecurs</name></expr>;</return>
			</block_content>}</block>

			<default>default:</default>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"got unexpected join type (%d) when recursively "</literal>
									   <literal type="string">"planning a join"</literal></expr></argument>,
									   <argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>IsRTERefRecurring</name><argument_list>(<argument><expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"got unexpected node type (%d) when recursively "</literal>
							  <literal type="string">"planning a join"</literal></expr></argument>,
							  <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanDistributedJoinNode is a helper function for
 * RecursivelyPlanRecurringTupleOuterJoinWalker that recursively plans given
 * distributed node that is known to be inner side of an outer join.
 *
 * Fails to do so if the distributed join node references the recurring one.
 * In that case, we don't throw an error here but instead we let
 * DeferredErrorIfUnsupportedRecurringTuplesJoin to so for a better error
 * message.
 *
 * We call a node "distributed" if it points to a distributed table or a
 * more complex object (i.e., a join tree or a subquery) that can be pushed
 * down to the worker nodes directly. For a join, this means that it's either
 * an INNER join where any side of it is a distributed table / a distributed
 * sub join tree, or an OUTER join where the outer side is a distributed table
 * / a distributed sub join tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecursivelyPlanDistributedJoinNode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
								   <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>recursivePlanningContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This, for example, means that RecursivelyPlanRecurringTupleOuterJoinWalker
		 * needs to plan inner side, i.e., "&lt;distributed&gt; INNER JOIN &lt;distributed&gt;",
		 * of the following join:
		 *   &lt;recurring&gt; LEFT JOIN (&lt;distributed&gt; JOIN &lt;distributed&gt;)
		 *
		 * XXX: Ideally, we should handle such a sub join tree by moving
		 *      it into a subquery "as a whole" but this implies that we need to
		 *      rebuild the rtable and re-point all the Vars to the new rtable
		 *      indexes, so we've not implemented that yet.
		 *
		 *      Instead, we recursively plan all the distributed tables in that
		 *      sub join tree. This is much more inefficient than the other
		 *      approach (since we lose the opportunity to push-down the whole
		 *      sub join tree into the workers) but is easier to implement.
		 */</comment>

		<expr_stmt><expr><call><name>RecursivelyPlanDistributedJoinNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>larg</name></expr></argument>,
										   <argument><expr><name>query</name></expr></argument>, <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RecursivelyPlanDistributedJoinNode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>rarg</name></expr></argument>,
										   <argument><expr><name>query</name></expr></argument>, <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected join node type (%d)"</literal></expr></argument>,
							   <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsRTERefRecurring</name><argument_list>(<argument><expr><name>rangeTableRef</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Not the top-level callers but RecursivelyPlanDistributedJoinNode
		 * might call itself for recurring nodes and need to skip them.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>distributedRte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>,
											 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>distributedRte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recursively planning distributed relation %s "</literal>
								<literal type="string">"since it is part of a distributed join node "</literal>
								<literal type="string">"that is outer joined with a recurring rel"</literal></expr></argument>,
								<argument><expr><call><name>GetRelationNameAndAliasName</name><argument_list>(<argument><expr><name>distributedRte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name> <init>=
			<expr><call><name>GetPlannerRestrictionContext</name><argument_list>(<argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>requiredAttributes</name> <init>=
			<expr><call><name>RequiredAttrNumbersForRelation</name><argument_list>(<argument><expr><name>distributedRte</name></expr></argument>, <argument><expr><name>restrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ReplaceRTERelationWithRteSubquery</name><argument_list>(<argument><expr><name>distributedRte</name></expr></argument>, <argument><expr><name>requiredAttributes</name></expr></argument>,
										  <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>distributedRte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't try logging the subquery here because RecursivelyPlanSubquery
		 * will anyway do so if the query doesn't reference the outer query.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"recursively planning the distributed subquery "</literal>
								<literal type="string">"since it is part of a distributed join node "</literal>
								<literal type="string">"that is outer joined with a recurring rel"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>recursivelyPlanned</name> <init>= <expr><call><name>RecursivelyPlanSubquery</name><argument_list>(<argument><expr><name><name>distributedRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
														  <argument><expr><name>recursivePlanningContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursivelyPlanned</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * RecursivelyPlanSubquery fails to plan a subquery only if it
			 * contains references to the outer query. This means that, we can't
			 * plan such outer joins (like &lt;recurring LEFT OUTER distributed&gt;)
			 * if it's a LATERAL join where the distributed side is a subquery that
			 * references the outer side, as in,
			 *
			 * SELECT * FROM reference
			 * LEFT JOIN LATERAL
			 * (SELECT * FROM distributed WHERE reference.b &gt; distributed.b) q
			 * USING (a);
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ContainsReferencesToOuterQuery</name><argument_list>(<argument><expr><name><name>distributedRte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We don't expect RecursivelyPlanRecurringTupleOuterJoinWalker to try recursively
		 * plan such an RTE.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"got unexpected RTE type (%d) when recursively "</literal>
							  <literal type="string">"planning a join"</literal></expr></argument>,
							  <argument><expr><name><name>distributedRte</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsRTERefRecurring returns true if given rte reference points to a recurring
 * rte.
 *
 * If an rte points to a table, then we call it recurring if the table is not
 * a distributed table. Otherwise, e.g., if it points a query, then we call it
 * recurring if none of the rtes that belongs to the query point to a distributed
 * table.
 *
 * Note that it's safe to assume a subquery is not recurring if we have a rte reference
 * to a distributed table somewhere in the query tree. For example, considering
 * the subquery (q) of the the following query:
 *   SELECT * FROM ref LEFT JOIN (SELECT * FROM ref LEFT dist) q,
 * one might think that it's not appropriate to call IsRTERefRecurring for subquery
 * (q). However, this is already not the case because this function is called
 * in the context of recursive planning and hence any query that contains
 * rtes pointing to distributed tables and that cannot be pushed down to worker
 * nodes should've been recursively planned already. This is because, the recursive
 * planner processes the queries in bottom-up fashion. For this reason, the subquery
 * in the example should've already be converted to the following before we check
 * the rte reference that points to the subquery (q):
 *   SELECT * FROM ref LEFT JOIN (SELECT * FROM ref LEFT (SELECT * FROM read_intermediate_result()) dist_1)
 * That way, we wouldn't incorrectly say that (SELECT * FROM ref LEFT dist) is a
 * distributed subquery (due to having a reference to a distributed table).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsRTERefRecurring</name><parameter_list>(<parameter><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rangeTableIndex</name> <init>= <expr><name><name>rangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rangeTableIndex</name></expr></argument>, <argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>!</operator><call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name>IsDistributedTableRTE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SublinkListFromWhere finds the subquery nodes in the where clause of the given query. Note
 * that the function should be called on the original query given that postgres
 * standard_planner() may convert the subqueries in WHERE clause to joins.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>SublinkListFromWhere</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>originalQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>joinTree</name> <init>= <expr><name><name>originalQuery</name><operator>-&gt;</operator><name>jointree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sublinkList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>joinTree</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>queryQuals</name> <init>= <expr><name><name>joinTree</name><operator>-&gt;</operator><name>quals</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExtractSublinkWalker</name><argument_list>(<argument><expr><name>queryQuals</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sublinkList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sublinkList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractSublinkWalker walks over a quals node, and finds all sublinks
 * in that node.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExtractSublinkWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>sublinkList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>walkerResult</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>sublinkList</name><operator>)</operator> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>sublinkList</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>walkerResult</name> <operator>=</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ExtractSublinkWalker</name></expr></argument>,
											  <argument><expr><name>sublinkList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>walkerResult</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldRecursivelyPlanSublinks returns true if the query has a recurring
 * FROM clause.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldRecursivelyPlanSublinks</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
													  <argument><expr><name>IsDistributedTableRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there is a distributed table in the FROM clause */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanAllSubqueries descends into an expression tree and recursively
 * plans all subqueries that contain at least one distributed table. The recursive
 * planning starts from the top of the input query.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RecursivelyPlanAllSubqueries</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>planningContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>IsCitusTableRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RecursivelyPlanSubquery</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>planningContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RecursivelyPlanAllSubqueries</name></expr></argument>, <argument><expr><name>planningContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanCTEs plans all CTEs in the query by recursively calling the planner
 * The resulting plan is added to planningContext-&gt;subPlanList and CTE references
 * are replaced by subqueries that call read_intermediate_result, which reads the
 * intermediate result of the CTE after it is executed.
 *
 * Recursive and modifying CTEs are not yet supported and return an error.
 */</comment>
<function><type><specifier>static</specifier> <name>DeferredErrorMessage</name> <modifier>*</modifier></type>
<name>RecursivelyPlanCTEs</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>planningContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cteCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CteReferenceWalkerContext</name></type> <name>context</name> <init>= <expr><block>{ <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NIL</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>cteList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no CTEs, nothing to do */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasRecursive</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
							 <argument><expr><literal type="string">"recursive CTEs are not supported in distributed "</literal>
							 <literal type="string">"queries"</literal></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get all RTE_CTEs that point to CTEs from cteList */</comment>
	<expr_stmt><expr><call><name>CteReferenceListWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cteCell</argument>, <argument>query-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cteCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cteName</name> <init>= <expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>planId</name> <init>= <expr><name><name>planningContext</name><operator>-&gt;</operator><name>planId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cteTargetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rteCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>replacedCtesCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ContainsReferencesToOuterQuery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>DeferredError</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>,
								 <argument><expr><literal type="string">"CTEs that refer to other subqueries are not "</literal>
								 <literal type="string">"supported in multi-shard queries"</literal></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>subquery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * SELECT CTEs that aren't referenced aren't executed in postgres.
			 * We don't need to generate a subplan for it and can take the rest
			 * of this iteration off.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>uint32</name></type> <name>subPlanId</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>planningContext</name><operator>-&gt;</operator><name>subPlanList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsLoggableLevel</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>subPlanString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>pg_get_query_def</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>subPlanString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"generating subplan "</literal> <name>UINT64_FORMAT</name>
									<literal type="string">"_%u for CTE %s: %s"</literal></expr></argument>, <argument><expr><name>planId</name></expr></argument>, <argument><expr><name>subPlanId</name></expr></argument>,
									<argument><expr><name>cteName</name></expr></argument>,
									<argument><expr><name><name>subPlanString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* build a sub plan for the CTE */</comment>
		<decl_stmt><decl><type><name>DistributedSubPlan</name> <modifier>*</modifier></type><name>subPlan</name> <init>= <expr><call><name>CreateDistributedSubPlan</name><argument_list>(<argument><expr><name>subPlanId</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>planningContext</name><operator>-&gt;</operator><name>subPlanList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>planningContext</name><operator>-&gt;</operator><name>subPlanList</name></name></expr></argument>, <argument><expr><name>subPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* build the result_id parameter for the call to read_intermediate_result */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><call><name>GenerateResultId</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name>subPlanId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* modifying CTE with returning */</comment>
			<expr_stmt><expr><name>cteTargetList</name> <operator>=</operator> <name><name>subquery</name><operator>-&gt;</operator><name>returningList</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* regular SELECT CTE */</comment>
			<expr_stmt><expr><name>cteTargetList</name> <operator>=</operator> <name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* replace references to the CTE with a subquery that reads results */</comment>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>resultQuery</name> <init>= <expr><call><name>BuildSubPlanResultQuery</name><argument_list>(<argument><expr><name>cteTargetList</name></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>aliascolnames</name></name></expr></argument>,
													 <argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>rteCell</argument>, <argument>context.cteReferenceList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rteCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_CTE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This RTE pointed to a preceding CTE that was already replaced
				 * by a subplan.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name>cteName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* change the RTE_CTE into an RTE_SUBQUERY */</comment>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>replacedCtesCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Replace the first CTE reference with the result query directly.
					 */</comment>
					<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>resultQuery</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Replace subsequent CTE references with a copy of the result
					 * query.
					 */</comment>
					<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>resultQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>replacedCtesCount</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name> <operator>==</operator> <name>replacedCtesCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * All CTEs are now executed through subplans and RTE_CTEs pointing
	 * to the CTE list have been replaced with subqueries. We can now
	 * clear the cteList.
	 */</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanSubqueryWalker recursively finds all the Query nodes and
 * recursively plans if necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RecursivelyPlanSubqueryWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * First, make sure any subqueries and CTEs within this subquery
		 * are recursively planned if necessary.
		 */</comment>
		<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>RecursivelyPlanSubqueriesAndCTEs</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Recursively plan this subquery if it cannot be pushed down and is
		 * eligible for recursive planning.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ShouldRecursivelyPlanSubquery</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RecursivelyPlanSubquery</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we're done, no need to recurse anymore for this query */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RecursivelyPlanSubqueryWalker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldRecursivelyPlanSubquery decides whether the input subquery should be recursively
 * planned or not.
 *
 * For the details, see the cases in the function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldRecursivelyPlanSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
													  <argument><expr><name>IsLocalTableRteOrMatView</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Postgres can always plan queries that don't require distributed planning.
		 * Note that we need to check this first, otherwise the calls to the many other
		 * Citus planner functions would error our due to local relations.
		 *
		 * TODO: We could only successfully create distributed plans with local tables
		 * when the local tables are on the leaf queries and the upper level queries
		 * do not contain any other local tables.
		 */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CanPushdownSubquery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We should do one more check for the distribution key equality.
		 *
		 * If the input query to the planner doesn't contain distribution key equality,
		 * we should further check whether this individual subquery contains or not.
		 *
		 * If all relations are not joined on their distribution keys for the given
		 * subquery, we cannot push push it down and therefore we should try to
		 * recursively plan it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>allDistributionKeysInQueryAreEqual</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>AllDistributionKeysInSubqueryAreEqual</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>,
												   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>plannerRestrictionContext</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Citus can pushdown this subquery, no need to recursively
		 * plan which is much more expensive than pushdown.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AllDistributionKeysInSubqueryAreEqual is a wrapper function
 * for AllDistributionKeysInQueryAreEqual(). Here, we filter the
 * planner restrictions for the given subquery and do the restriction
 * equality checks on the filtered restriction.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AllDistributionKeysInSubqueryAreEqual</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
									  <parameter><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>restrictionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* we don't support distribution eq. checks for CTEs yet */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>filteredRestrictionContext</name> <init>=
		<expr><call><name>FilterPlannerRestrictionForQuery</name><argument_list>(<argument><expr><name>restrictionContext</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>allDistributionKeysInSubqueryAreEqual</name> <init>=
		<expr><call><name>AllDistributionKeysInQueryAreEqual</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>filteredRestrictionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allDistributionKeysInSubqueryAreEqual</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldRecursivelyPlanSetOperation determines whether the leaf queries of a
 * set operations tree need to be recursively planned in order to support the
 * query as a whole.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldRecursivelyPlanSetOperation</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOperations</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>setOperations</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>level</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We cannot push down top-level set operation. Recursively plan the
		 * leaf nodes such that it becomes a router query.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>setOperations</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_UNION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We can only push down UNION operaionts, plan other set operations
		 * recursively.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DeferErrorIfUnsupportedUnionQuery</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If at least one leaf query in the union is recurring, then all
		 * leaf nodes need to be recurring.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PlannerRestrictionContext</name> <modifier>*</modifier></type><name>filteredRestrictionContext</name> <init>=
		<expr><call><name>FilterPlannerRestrictionForQuery</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>plannerRestrictionContext</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SafeToPushdownUnionSubquery</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>filteredRestrictionContext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The distribution column is not in the same place in all sides
		 * of the union, meaning we cannot determine distribution column
		 * equivalence. Recursive planning is necessary.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanSetOperations descends into a tree of set operations
 * (e.g. UNION, INTERSECTS) and recursively plans all leaf nodes that
 * contain distributed tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RecursivelyPlanSetOperations</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							 <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOperations</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RecursivelyPlanSetOperations</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>setOperations</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RecursivelyPlanSetOperations</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>setOperations</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>,
												  <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator>
			<call><name>FindNodeMatchingCheckFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subquery</name></expr></argument>, <argument><expr><name>IsDistributedTableRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RecursivelyPlanSubquery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected node type (%d) while "</literal>
							   <literal type="string">"expecting set operations or "</literal>
							   <literal type="string">"range table references"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsLocalTableRteOrMatView gets a node and returns true if the node is a range
 * table entry that points to a postgres local or citus local table or to a
 * materialized view.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsLocalTableRteOrMatView</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>IsRelationLocalTableOrMatView</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsRelationLocalTableOrMatView returns true if the given relation
 * is a citus local, local, or materialized view.
 */</comment>
<function><type><name>bool</name></type>
<name>IsRelationLocalTableOrMatView</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* postgres local table or a materialized view */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* no local table found */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecursivelyPlanSubquery recursively plans a query, replaces it with a
 * result query and returns the subplan.
 *
 * Before we recursively plan the given subquery, we should ensure
 * that the subquery doesn't contain any references to the outer
 * queries (i.e., such queries cannot be separately planned). In
 * that case, the function doesn't recursively plan the input query
 * and immediately returns. Later, the planner decides on what to do
 * with the query.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RecursivelyPlanSubquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>planningContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>planId</name> <init>= <expr><name><name>planningContext</name><operator>-&gt;</operator><name>planId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>debugQuery</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ContainsReferencesToOuterQuery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"skipping recursive planning for the subquery since it "</literal>
					 <literal type="string">"contains references to outer queries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Subquery will go through the standard planner, thus to properly deparse it
	 * we keep its copy: debugQuery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsLoggableLevel</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>debugQuery</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * Create the subplan and append it to the list in the planning context.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>subPlanId</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>planningContext</name><operator>-&gt;</operator><name>subPlanList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedSubPlan</name> <modifier>*</modifier></type><name>subPlan</name> <init>= <expr><call><name>CreateDistributedSubPlan</name><argument_list>(<argument><expr><name>subPlanId</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>planningContext</name><operator>-&gt;</operator><name>subPlanList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>planningContext</name><operator>-&gt;</operator><name>subPlanList</name></name></expr></argument>, <argument><expr><name>subPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build the result_id parameter for the call to read_intermediate_result */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><call><name>GenerateResultId</name><argument_list>(<argument><expr><name>planId</name></expr></argument>, <argument><expr><name>subPlanId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * BuildSubPlanResultQuery() can optionally use provided column aliases.
	 * We do not need to send additional alias list for subqueries.
	 */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>resultQuery</name> <init>= <expr><call><name>BuildSubPlanResultQuery</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsLoggableLevel</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>subqueryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_get_query_def</name><argument_list>(<argument><expr><name>debugQuery</name></expr></argument>, <argument><expr><name>subqueryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"generating subplan "</literal> <name>UINT64_FORMAT</name>
								<literal type="string">"_%u for subquery %s"</literal></expr></argument>, <argument><expr><name>planId</name></expr></argument>, <argument><expr><name>subPlanId</name></expr></argument>,
								<argument><expr><name><name>subqueryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finally update the input subquery to point the result query */</comment>
	<expr_stmt><expr><operator>*</operator><name>subquery</name> <operator>=</operator> <operator>*</operator><name>resultQuery</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateDistributedSubPlan creates a distributed subplan by recursively calling
 * the planner from the top, which may either generate a local plan or another
 * distributed plan, which can itself contain subplans.
 */</comment>
<function><type><specifier>static</specifier> <name>DistributedSubPlan</name> <modifier>*</modifier></type>
<name>CreateDistributedSubPlan</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>subPlanId</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subPlanQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>cursorOptions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ContainsReadIntermediateResultFunction</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subPlanQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure we go through distributed planning if there are
		 * read_intermediate_result calls, even if there are no distributed
		 * tables in the query anymore.
		 *
		 * We cannot perform this check in the planner itself, since that
		 * would also cause the workers to attempt distributed planning.
		 */</comment>
		<expr_stmt><expr><name>cursorOptions</name> <operator>|=</operator> <name>CURSOR_OPT_FORCE_DISTRIBUTED</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DistributedSubPlan</name> <modifier>*</modifier></type><name>subPlan</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>DistributedSubPlan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>subPlan</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <call><name>planner</name><argument_list>(<argument><expr><name>subPlanQuery</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subPlan</name><operator>-&gt;</operator><name>subPlanId</name></name> <operator>=</operator> <name>subPlanId</name></expr>;</expr_stmt>

	<return>return <expr><name>subPlan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CteReferenceListWalker finds all references to CTEs in the top level of a query
 * and adds them to context-&gt;cteReferenceList.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CteReferenceListWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>CteReferenceWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name> <operator>&amp;&amp;</operator>
			<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>cteReferenceList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>cteReferenceList</name></name></expr></argument>,
												<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* caller will descend into range table entry */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>CteReferenceListWalker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
						  <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CteReferenceListWalker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsReferencesToOuterQuery determines whether the given query contains
 * anything that points outside of the query itself. Such queries cannot be
 * planned recursively.
 */</comment>
<function><type><name>bool</name></type>
<name>ContainsReferencesToOuterQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarLevelsUpWalkerContext</name></type> <name>context</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>ContainsReferencesToOuterQueryWalker</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsReferencesToOuterQueryWalker determines whether the given query
 * contains any Vars that point more than context-&gt;level levels up.
 *
 * ContainsReferencesToOuterQueryWalker recursively descends into subqueries
 * and increases the level by 1 before recursing.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsReferencesToOuterQueryWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>VarLevelsUpWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>phlevelsup</name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>ContainsReferencesToOuterQueryWalker</name></expr></argument>,
									   <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<return>return <expr><name>found</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ContainsReferencesToOuterQueryWalker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeContainsSubqueryReferencingOuterQuery determines whether the given node
 * contains anything that points outside of the query itself.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NodeContainsSubqueryReferencingOuterQuery</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sublinks</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExtractSublinkWalker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sublinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>sublink</argument>, <argument>sublinks</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ContainsReferencesToOuterQuery</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReplaceRTERelationWithRteSubquery replaces the input rte relation target entry
 * with a subquery. The function also pushes down the filters to the subquery.
 *
 * It then recursively plans the subquery. This subquery is wrapped with another subquery
 * as a trick to reduce network cost, because we currently don't have an easy way to
 * skip generating NULL's for non-required columns, and if we create (SELECT a, NULL, NULL FROM table)
 * then this will be sent over network and NULL's also occupy some space. Instead of this we generate:
 * (SELECT t.a, NULL, NULL FROM (SELECT a FROM table) t). The inner subquery will be recursively planned
 * but the outer part will not be yet it will still have the NULL columns so that the query is correct.
 */</comment>
<function><type><name>void</name></type>
<name>ReplaceRTERelationWithRteSubquery</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>requiredAttrNumbers</name></decl></parameter>,
								  <parameter><decl><type><name>RecursivePlanningContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><call><name>WrapRteRelationIntoSubquery</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>requiredAttrNumbers</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>outerQueryTargetList</name> <init>= <expr><call><name>CreateAllTargetListForRelation</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
																<argument><expr><name>requiredAttrNumbers</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>restrictionList</name> <init>=
		<expr><call><name>GetRestrictInfoListForRelation</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>,
									   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>plannerRestrictionContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>copyRestrictionList</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>restrictionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>andedBoundExpressions</name> <init>= <expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>copyRestrictionList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>andedBoundExpressions</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Originally the quals were pointing to the RTE and its varno
	 * was pointing to its index in rtable. However now we converted the RTE
	 * to a subquery and the quals should be pointing to that subquery, which
	 * is the only RTE in its rtable, hence we update the varnos so that they
	 * point to the subquery RTE.
	 * Originally: rtable: [rte1, current_rte, rte3...]
	 * Now: rtable: [rte1, subquery[current_rte], rte3...] --subquery[current_rte] refers to its rtable.
	 */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UpdateVarNosInNode</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>SINGLE_RTE_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* replace the function with the constructed subquery */</comment>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>subquery</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the relation is inherited, it'll still be inherited as
	 * we've copied it earlier. This is to prevent the newly created
	 * subquery being treated as inherited.
	 */</comment>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsLoggableLevel</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationAndAliasName</name> <init>= <expr><call><name>GetRelationNameAndAliasName</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Wrapping relation %s to a subquery"</literal></expr></argument>,
								<argument><expr><name>relationAndAliasName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* as we created the subquery, now forcefully recursively plan it */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>recursivelyPlanned</name> <init>= <expr><call><name>RecursivelyPlanSubquery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursivelyPlanned</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"unexpected state: query should have been recursively planned"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>outerSubquery</name> <init>= <expr><call><name>CreateOuterSubquery</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>, <argument><expr><name>outerQueryTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>outerSubquery</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationNameAndAliasName returns the relname + alias name if
 * alias name exists otherwise only the relname is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetRelationNameAndAliasName</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>str</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aliasName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>alias</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aliasName</name> <operator>=</operator> <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>aliasName</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" \"%s\""</literal></expr></argument>, <argument><expr><name>aliasName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateOuterSubquery creates outer subquery which contains
 * the given range table entry in its rtable.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>CreateOuterSubquery</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outerSubqueryTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>innerSubqueryColNames</name> <init>= <expr><call><name>GenerateRequiredColNamesFromTargetList</name><argument_list>(
		<argument><expr><name>outerSubqueryTargetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>outerSubquery</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>outerSubquery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<comment type="block">/* we copy the input rteRelation to preserve the rteIdentity */</comment>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>innerSubqueryRTE</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>innerSubqueryRTE</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>innerSubqueryColNames</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outerSubquery</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>innerSubqueryRTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set the FROM expression to the subquery */</comment>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>newRangeTableRef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>newRangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outerSubquery</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>newRangeTableRef</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>outerSubquery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>outerSubqueryTargetList</name></expr>;</expr_stmt>
	<return>return <expr><name>outerSubquery</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateRequiredColNamesFromTargetList generates the required colnames
 * from the given target list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GenerateRequiredColNamesFromTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>innerSubqueryColNames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>entry</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * column names of the inner subquery should only contain the
			 * required columns, as in if we choose 'b' from ('a','b') colnames
			 * should be 'a' not ('a','b')
			 */</comment>
			<expr_stmt><expr><name>innerSubqueryColNames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>innerSubqueryColNames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(
												<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>innerSubqueryColNames</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateVarNosInNode iterates the Vars in the
 * given node and updates the varno's as the newVarNo.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateVarNosInNode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>newVarNo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>varList</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
									<name>PVC_RECURSE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>var</argument>, <argument>varList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>newVarNo</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * IsRecursivelyPlannableRelation returns true if the given range table entry
 * is a relation type that can be converted to a subquery.
 */</comment>
<function><type><name>bool</name></type>
<name>IsRecursivelyPlannableRelation</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
		   <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		   <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		   <name><name>rangeTableEntry</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsLocalTableDistributedTableJoin returns true if the input range table list
 * contains a direct join between local RTE and an RTE that contains a distributed
 * or reference table.
 */</comment>
<function><type><name>bool</name></type>
<name>ContainsLocalTableDistributedTableJoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>containsLocalTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>containsDistributedTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>rangeTableEntry</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FindNodeMatchingCheckFunctionInRangeTableList</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr></argument>,
														  <argument><expr><name>IsDistributedOrReferenceTableRTE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>containsDistributedTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsRecursivelyPlannableRelation</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <call><name>IsLocalTableRteOrMatView</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we consider citus local tables as local table */</comment>
			<expr_stmt><expr><name>containsLocalTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>containsLocalTable</name> <operator>&amp;&amp;</operator> <name>containsDistributedTable</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WrapFunctionsInSubqueries iterates over all the immediate Range Table Entries
 * of a query and wraps the functions inside (SELECT * FROM fnc() f)
 * subqueries, so that those functions will be executed on the coordinator if
 * necessary.
 *
 * We wrap all the functions that are used in joins except the ones that are
 * laterally joined or have WITH ORDINALITY clauses.
 * */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WrapFunctionsInSubqueries</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeTableList</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rangeTableCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we have only one function call in a query without any joins, we can
	 * easily decide where to execute it.
	 *
	 * If there are some subqueries and/or functions that are joined with a
	 * function, it is not trivial to decide whether we should run this
	 * function in the coordinator or in workers and therefore we may need to
	 * wrap some of those functions in subqueries.
	 *
	 * If we have only one RTE, we leave the parsed query tree as it is. This
	 * also makes sure we do not wrap an already wrapped function call
	 * because we know that there will always be 1 RTE in a wrapped function.
	 * */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rangeTableList</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* iterate over all RTEs and wrap them if necessary */</comment>
	<macro><name>foreach</name><argument_list>(<argument>rangeTableCell</argument>, <argument>rangeTableList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rangeTableCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ShouldTransformRTE</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TransformFunctionRTE</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * TransformFunctionRTE wraps a given function RangeTableEntry
 * inside a (SELECT * from function() f) subquery.
 *
 * The said RangeTableEntry is modified and now points to the new subquery.
 * */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TransformFunctionRTE</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTblEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>newRangeTableRef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>targetColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>targetColumnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rangeTblFunction</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rangeTblEntry</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>subquery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<comment type="block">/* copy the input rangeTblEntry to prevent cycles */</comment>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newRangeTableEntry</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>rangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set the FROM expression to the subquery */</comment>
	<expr_stmt><expr><name><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>newRangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newRangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>newRangeTableRef</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine the result type of the function.
	 *
	 * If function return type is not composite or rowtype can't be determined,
	 * tupleDesc is set to null here
	 */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name> <init>= <expr><operator>(</operator><name>TupleDesc</name><operator>)</operator> <call><name>get_expr_result_tupdesc</name><argument_list>(<argument><expr><name><name>rangeTblFunction</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>,
															  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If tupleDesc is not null, we iterate over all the attributes and
	 * create targetEntries
	 * */</comment>
	<if_stmt><if>if <condition>(<expr><name>tupleDesc</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A sample function join that end up here:
		 *
		 * CREATE FUNCTION f(..) RETURNS TABLE(c1 int, c2 text) AS .. ;
		 * SELECT .. FROM table JOIN f(..) ON ( .. ) ;
		 *
		 * We will iterate over Tuple Description attributes. i.e (c1 int, c2 text)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&gt;</operator> <name>MaxAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"bad number of tuple descriptor attributes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>targetColumnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>targetColumnIndex</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition>
			 <incr><expr><name>targetColumnIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
															 <argument><expr><name>targetColumnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>columnType</name> <init>= <expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * The indexing of attributes and TupleDesc and varattno differ
			 *
			 * varattno=0 corresponds to whole row
			 * varattno=1 corresponds to first column that is stored in tupDesc-&gt;attrs[0]
			 *
			 * That's why we need to add one to the targetColumnIndex
			 * */</comment>
			<expr_stmt><expr><name>targetColumn</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>targetColumnIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>columnType</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>targetEntry</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>targetColumn</name></expr></argument>, <argument><expr><name>targetColumnIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										  <argument><expr><name>columnName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>targetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>

	<comment type="block">/*
	 * If tupleDesc is NULL we have 2 different cases:
	 *
	 * 1. The function returns a record but the attributes can not be
	 * determined just by looking at the function definition. In this case the
	 * column names and types must be defined explicitly in the query
	 *
	 * 2. The function returns a non-composite type (e.g. int, text, jsonb ..)
	 * */</comment>
	<else>else
	<block>{<block_content>
		<comment type="block">/* create target entries for all columns returned by the function */</comment>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>functionColumnName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionColumnNames</name> <init>= <expr><name><name>rangeTblEntry</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>functionColumnName</argument>, <argument>functionColumnNames</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>functionColumnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>columnType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the function returns a set of records, the query needs
			 * to explicitly name column names and types
			 *
			 * Use explicitly defined types in the query if they are
			 * available
			 * */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rangeTblFunction</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * A sample function join that end up here:
				 *
				 * CREATE FUNCTION get_set_of_records() RETURNS SETOF RECORD AS
				 * $cmd$
				 * SELECT x, x+1 FROM generate_series(0,4) f(x)
				 * $cmd$
				 * LANGUAGE SQL;
				 *
				 * SELECT *
				 * FROM table1 JOIN get_set_of_records() AS t2(x int, y int)
				 * ON (id = x);
				 *
				 * Note that the function definition does not have column
				 * names and types. Therefore the user needs to explicitly
				 * state them in the query
				 * */</comment>
				<expr_stmt><expr><name>columnType</name> <operator>=</operator> <call><name>list_nth_oid</name><argument_list>(<argument><expr><name><name>rangeTblFunction</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>,
										  <argument><expr><name>targetColumnIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>

			<comment type="block">/* use the types in the function definition otherwise */</comment>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Only functions returning simple types end up here.
				 * A sample function:
				 *
				 * CREATE FUNCTION add(integer, integer) RETURNS integer AS
				 * 'SELECT $1 + $2;'
				 * LANGUAGE SQL;
				 * SELECT * FROM table JOIN add(3,5) sum ON ( .. ) ;
				 * */</comment>
				<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcExpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>rangeTblFunction</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>columnType</name> <operator>=</operator> <name><name>funcExpr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Note that the column k is associated with varattno/resno of k+1 */</comment>
			<expr_stmt><expr><name>targetColumn</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>targetColumnIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>columnType</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								   <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>targetEntry</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>targetColumn</name></expr></argument>,
										  <argument><expr><name>targetColumnIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>columnName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>targetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>targetColumnIndex</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* replace the function with the constructed subquery */</comment>
	<expr_stmt><expr><name><name>rangeTblEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTblEntry</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>subquery</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldTransformRTE determines whether a given RTE should bne wrapped in a
 * subquery.
 *
 * Not all functions should be wrapped in a subquery for now. As we support more
 * functions to be used in joins, the constraints here will be relaxed.
 * */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldTransformRTE</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We should wrap only function rtes that are not LATERAL and
	 * without WITH ORDINALITY clause
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_FUNCTION</name> <operator>||</operator>
		<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>lateral</name></name> <operator>||</operator>
		<name><name>rangeTableEntry</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildSubPlanResultQuery returns a query of the form:
 *
 * SELECT
 *   &lt;target list&gt;
 * FROM
 *   read_intermediate_result('&lt;resultId&gt;', '&lt;copy format'&gt;)
 *   AS res (&lt;column definition list&gt;);
 *
 * The caller can optionally supply a columnAliasList, which is useful for
 * CTEs that have column aliases.
 *
 * If any of the types in the target list cannot be used in the binary copy format,
 * then the copy format 'text' is used, otherwise 'binary' is used.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>BuildSubPlanResultQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnAliasList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resultId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>functionOid</name> <init>= <expr><call><name>CitusReadIntermediateResultFuncId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>useBinaryCopyFormat</name> <init>= <expr><call><name>CanUseBinaryCopyFormatForTargetList</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultIdConst</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constlen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>BuildReadIntermediateResultsQuery</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>, <argument><expr><name>columnAliasList</name></expr></argument>,
											 <argument><expr><name>resultIdConst</name></expr></argument>, <argument><expr><name>functionOid</name></expr></argument>,
											 <argument><expr><name>useBinaryCopyFormat</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildReadIntermediateResultsArrayQuery returns a query of the form:
 *
 * SELECT
 *   &lt;target list&gt;
 * FROM
 *   read_intermediate_results(ARRAY['&lt;resultId&gt;', ...]::text[], '&lt;copy format'&gt;)
 *   AS res (&lt;column definition list&gt;);
 *
 * The caller can optionally supply a columnAliasList, which is useful for
 * CTEs that have column aliases.
 *
 * If useBinaryCopyFormat is true, then 'binary' format is used. Otherwise,
 * 'text' format is used.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>BuildReadIntermediateResultsArrayQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnAliasList</name></decl></parameter>,
									   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultIdList</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>useBinaryCopyFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>functionOid</name> <init>= <expr><call><name>CitusReadIntermediateResultArrayFuncId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultIdConst</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>TEXTARRAYOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constlen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>strlist_to_textarray</name><argument_list>(<argument><expr><name>resultIdList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultIdConst</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><call><name>BuildReadIntermediateResultsQuery</name><argument_list>(<argument><expr><name>targetEntryList</name></expr></argument>, <argument><expr><name>columnAliasList</name></expr></argument>,
											 <argument><expr><name>resultIdConst</name></expr></argument>, <argument><expr><name>functionOid</name></expr></argument>,
											 <argument><expr><name>useBinaryCopyFormat</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildReadIntermediateResultsQuery is the common code for generating
 * queries to read from result files. It is used by
 * BuildReadIntermediateResultsArrayQuery and BuildSubPlanResultQuery.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>BuildReadIntermediateResultsQuery</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnAliasList</name></decl></parameter>,
								  <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultIdConst</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name></type> <name>useBinaryCopyFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColNames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColTypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColTypMods</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcColCollations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>targetEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>columnNumber</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>copyFormatId</name> <init>= <expr><call><name>BinaryCopyFormatId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>columnAliasCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>columnAliasList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* build the target list and column definition list */</comment>
	<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>targetEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>targetExpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resname</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>columnType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>targetExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>columnTypMod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>targetExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>columnCollation</name> <init>= <expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>targetExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>targetEntry</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>funcColNames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>funcColNames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcColTypes</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>funcColTypes</name></expr></argument>, <argument><expr><name>columnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcColTypMods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>funcColTypMods</name></expr></argument>, <argument><expr><name>columnTypMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcColCollations</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>funcColCollations</name></expr></argument>, <argument><expr><name>columnCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>functionColumnVar</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>functionColumnVar</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>functionColumnVar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>columnNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>functionColumnVar</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name>columnType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>functionColumnVar</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>=</operator> <name>columnTypMod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>functionColumnVar</name><operator>-&gt;</operator><name>varcollid</name></name> <operator>=</operator> <name>columnCollation</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>functionColumnVar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>functionColumnVar</name><operator>-&gt;</operator><name>varnosyn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>functionColumnVar</name><operator>-&gt;</operator><name>varattnosyn</name></name> <operator>=</operator> <name>columnNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>functionColumnVar</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newTargetEntry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>functionColumnVar</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>columnNumber</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Rename the column only if a column alias is defined.
		 * Notice that column alias count could be less than actual
		 * column count. We only use provided aliases and keep the
		 * original column names if no alias is defined.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>columnAliasCount</name> <operator>&gt;=</operator> <name>columnNumber</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>columnAlias</name> <init>= <expr><operator>(</operator><name>String</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>columnAliasList</name></expr></argument>, <argument><expr><name>columnNumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>columnAlias</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>columnAlias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name>columnName</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>newTargetEntry</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>newTargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>columnNumber</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* build the citus_copy_format parameter for the call to read_intermediate_result */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>useBinaryCopyFormat</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>copyFormatId</name> <operator>=</operator> <call><name>TextCopyFormatId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>resultFormatConst</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>resultFormatConst</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <call><name>CitusCopyFormatTypeId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultFormatConst</name><operator>-&gt;</operator><name>consttypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultFormatConst</name><operator>-&gt;</operator><name>constlen</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultFormatConst</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>copyFormatId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultFormatConst</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultFormatConst</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultFormatConst</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* build the call to read_intermediate_result */</comment>
	<decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcExpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name>functionOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcExpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>resultIdConst</name></expr></argument>, <argument><expr><name>resultFormatConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build the RTE for the call to read_intermediate_result */</comment>
	<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rangeTableFunction</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funccolcount</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>funcColNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funccolnames</name></name> <operator>=</operator> <name>funcColNames</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funccoltypes</name></name> <operator>=</operator> <name>funcColTypes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funccoltypmods</name></name> <operator>=</operator> <name>funcColTypMods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funccolcollations</name></name> <operator>=</operator> <name>funcColCollations</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funcparams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableFunction</name><operator>-&gt;</operator><name>funcexpr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>funcExpr</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>funcAlias</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>funcAlias</name><operator>-&gt;</operator><name>aliasname</name></name> <operator>=</operator> <literal type="string">"intermediate_result"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>funcAlias</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>funcColNames</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rangeTableEntry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_FUNCTION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rangeTableEntry</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <name>funcAlias</name></expr>;</expr_stmt>

	<comment type="block">/* build the join tree using the read_intermediate_result RTE */</comment>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rangeTableRef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rangeTableRef</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>FromExpr</name> <modifier>*</modifier></type><name>joinTree</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>joinTree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build the SELECT query */</comment>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>resultQuery</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>resultQuery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultQuery</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rangeTableEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultQuery</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <name>joinTree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>resultQuery</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>targetList</name></expr>;</expr_stmt>

	<return>return <expr><name>resultQuery</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateResultId generates the result ID that is used to identify an intermediate
 * result of the subplan with the given plan ID and subplan ID.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GenerateResultId</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>planId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>subPlanId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>resultId</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>, <argument><expr><name>UINT64_FORMAT</name> <literal type="string">"_%u"</literal></expr></argument>, <argument><expr><name>planId</name></expr></argument>, <argument><expr><name>subPlanId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>resultId</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GeneratingSubplans returns true if we are currently in the process of
 * generating subplans.
 */</comment>
<function><type><name>bool</name></type>
<name>GeneratingSubplans</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>recursivePlanningDepth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
