<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/commands/index.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * index.c
 *    Commands for creating and altering indices on distributed tables.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/namespace_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/* Local functions forward declarations for helper functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfCreateIndexHasTooManyColumns</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>GetNumberOfIndexParameters</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IndexAlreadyExists</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>CreateIndexStmtGetIndexId</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>CreateIndexStmtGetSchemaId</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SwitchToSequentialAndLocalExecutionIfIndexNameTooLong</name><parameter_list>(
	<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GenerateLongestShardPartitionIndexName</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GenerateDefaultIndexName</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateIndexParameters</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DDLJob</name> <modifier>*</modifier></type> <name>GenerateCreateIndexDDLJob</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>createIndexCommand</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>CreateIndexStmtGetRelationId</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CreateIndexTaskList</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>indexStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CreateReindexTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForDropIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>,
										 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RangeVarCallbackForReindexIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
											<name>oldRelOid</name></decl></parameter>,
											<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedIndexStmt</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedDropIndexStmt</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropIndexStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>DropIndexTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>, <parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ReindexStmtFindRelationOid</name><parameter_list>(<parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * This struct defines the state for the callback for drop statements.
 * It is copied as it is from commands/tablecmds.c in Postgres source.
 */</comment>
<struct>struct <name>DropRelationCallbackState</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type> <name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>heapOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>concurrent</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * This struct defines the state for the callback for reindex statements.
 * It is copied as it is from commands/indexcmds.c in Postgres source.
 */</comment>
<struct>struct <name>ReindexIndexCallbackState</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type> <name>concurrent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>locked_table_oid</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/*
 * IsIndexRenameStmt returns whether the passed-in RenameStmt is the following
 * form:
 *
 *   - ALTER INDEX RENAME
 */</comment>
<function><type><name>bool</name></type>
<name>IsIndexRenameStmt</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>renameStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isIndexRenameStmt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>renameStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isIndexRenameStmt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>isIndexRenameStmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessIndexStmt determines whether a given CREATE INDEX statement involves
 * a distributed table. If so (and if the statement does not use unsupported
 * options), it modifies the input statement to ensure proper execution against
 * the coordinator node table and creates a DDLJob to encapsulate information needed
 * during the worker node portion of DDL execution before returning that DDLJob
 * in a List. If no distributed table is involved, this function returns NIL.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessIndexStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>createIndexCommand</name></decl></parameter>,
					<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relationRangeVar</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relationRangeVar</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* let's be on the safe side */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We first check whether a distributed relation is affected. For that,
	 * we need to open the relation. To prevent race conditions with later
	 * lookups, lock the table.
	 *
	 * XXX: Consider using RangeVarGetRelidExtended with a permission
	 * checking callback. Right now we'll acquire the lock before having
	 * checked permissions, and will only fail when executing the actual
	 * index statements.
	 */</comment>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><call><name>GetCreateIndexRelationLockMode</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_openrv</name><argument_list>(<argument><expr><name>relationRangeVar</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Before we do any further processing, fix the schema name to make sure
	 * that a (distributed) table with the same name does not appear on the
	 * search_path in front of the current schema. We do this even if the
	 * table is not distributed, since a distributed table may appear on the
	 * search_path by the time postgres starts processing this command.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relationRangeVar</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ensure we copy string into proper context */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>relationContext</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>relationRangeVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>namespaceName</name> <init>= <expr><call><name>RelationGetNamespaceName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>relationRangeVar</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>relationContext</name></expr></argument>,
														   <argument><expr><name>namespaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>CreateIndexStmtGetRelationId</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>idxname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Postgres does not support indexes with over INDEX_MAX_KEYS columns
		 * and we should not attempt to generate an index name for such cases.
		 */</comment>
		<expr_stmt><expr><call><name>ErrorIfCreateIndexHasTooManyColumns</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there are expressions on the index, we should first transform
		 * the statement as the default index name depends on that. We do
		 * it on a copy not to interfere with standard process utility.
		 */</comment>
		<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>copyCreateIndexStatement</name> <init>=
			<expr><call><name>transformIndexStmt</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>createIndexCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ensure we copy string into proper context */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>relationContext</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>relationRangeVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>defaultIndexName</name> <init>= <expr><call><name>GenerateDefaultIndexName</name><argument_list>(<argument><expr><name>copyCreateIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>relationContext</name></expr></argument>,
															<argument><expr><name>defaultIndexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IndexAlreadyExists</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Let standard_processUtility to error out or skip if command has
		 * IF NOT EXISTS.
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ErrorIfUnsupportedIndexStmt</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Citus has the logic to truncate the long shard names to prevent
	 * various issues, including self-deadlocks. However, for partitioned
	 * tables, when index is created on the parent table, the index names
	 * on the partitions are auto-generated by Postgres. We use the same
	 * Postgres function to generate the index names on the shards of the
	 * partitions. If the length exceeds the limit, we switch to sequential
	 * execution mode.
	 *
	 * The root cause of the problem is that postgres truncates the
	 * table/index names if they are longer than "NAMEDATALEN - 1".
	 * From Citus' perspective, running commands in parallel on the
	 * shards could mean these table/index names are truncated to be
	 * the same, and thus forming a self-deadlock as these tables/
	 * indexes are inserted into postgres' metadata tables, like pg_class.
	 */</comment>
	<expr_stmt><expr><call><name>SwitchToSequentialAndLocalExecutionIfIndexNameTooLong</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>GenerateCreateIndexDDLJob</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>, <argument><expr><name>createIndexCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfCreateIndexHasTooManyColumns errors out if given CREATE INDEX command
 * would use more than INDEX_MAX_KEYS columns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfCreateIndexHasTooManyColumns</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>numberOfIndexParameters</name> <init>= <expr><call><name>GetNumberOfIndexParameters</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>numberOfIndexParameters</name> <operator>&lt;=</operator> <name>INDEX_MAX_KEYS</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use more than %d columns in an index"</literal></expr></argument>,
						   <argument><expr><name>INDEX_MAX_KEYS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetNumberOfIndexParameters returns number of parameters to be used when
 * creating the index to be defined by given CREATE INDEX command.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetNumberOfIndexParameters</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexParams</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>indexParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexIncludingParams</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>indexParams</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexIncludingParams</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IndexAlreadyExists returns true if index to be created by given CREATE INDEX
 * command already exists.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IndexAlreadyExists</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>indexRelationId</name> <init>= <expr><call><name>CreateIndexStmtGetIndexId</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateIndexStmtGetIndexId returns OID of the index that given CREATE INDEX
 * command attempts to create if it's already created before. Otherwise, returns
 * InvalidOid.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>CreateIndexStmtGetIndexId</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>indexName</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>idxname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceId</name> <init>= <expr><call><name>CreateIndexStmtGetSchemaId</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>indexRelationId</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>indexRelationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateIndexStmtGetSchemaId returns schemaId of the schema that given
 * CREATE INDEX command operates on.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>CreateIndexStmtGetSchemaId</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relationRangeVar</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><name><name>relationRangeVar</name><operator>-&gt;</operator><name>schemaname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceId</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>namespaceId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteFunctionOnEachTableIndex executes the given pgIndexProcessor function on each
 * index of the given relation.
 * It returns a list that is filled by the pgIndexProcessor.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ExecuteFunctionOnEachTableIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>PGIndexProcessor</name></type> <name>pgIndexProcessor</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>indexFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexIdList</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>indexId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>indexId</argument>, <argument>indexIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>indexTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cache lookup failed for index with oid %u"</literal></expr></argument>,
								   <argument><expr><name>indexId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name> <init>= <expr><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pgIndexProcessor</name><argument_list>(<argument><expr><name>indexForm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>indexFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SwitchToSequentialAndLocalExecutionIfIndexNameTooLong generates the longest index name
 * on the shards of the partitions, and if exceeds the limit switches to sequential and
 * local execution to prevent self-deadlocks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SwitchToSequentialAndLocalExecutionIfIndexNameTooLong</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>CreateIndexStmtGetRelationId</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Citus already handles long names for regular tables */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ShardIntervalCount</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Relation has no shards, so we cannot run into "long shard index
		 * name" issue.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>indexName</name> <init>= <expr><call><name>GenerateLongestShardPartitionIndexName</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>indexName</name> <operator>&amp;&amp;</operator>
		<call><name>strnlen</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there has already been a parallel query executed, the sequential mode
			 * would still use the already opened parallel connections to the workers,
			 * thus contradicting our purpose of using sequential mode.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"The index name (%s) on a shard is too long and could lead "</literal>
								<literal type="string">"to deadlocks when executed in a transaction "</literal>
								<literal type="string">"block after a parallel query"</literal></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
									<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
									<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"the index name on the shards of the partition "</literal>
						 <literal type="string">"is too long, switching to sequential and local execution "</literal>
						 <literal type="string">"mode to prevent self deadlocks: %s"</literal></expr></argument>, <argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetLocalExecutionStatus</name><argument_list>(<argument><expr><name>LOCAL_EXECUTION_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateLongestShardPartitionIndexName emulates Postgres index name
 * generation for partitions on the shards. It returns the longest
 * possible index name.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GenerateLongestShardPartitionIndexName</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>CreateIndexStmtGetRelationId</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>longestNamePartitionId</name> <init>= <expr><call><name>PartitionWithLongestNameRelationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no partitions have been created yet */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>longestPartitionShardName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardIntervalWithLongestShardName</name><argument_list>(
		<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>longestPartitionShardName</name></expr></argument>, <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createLongestShardIndexStmt</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>createLongestShardIndexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <name>longestPartitionShardName</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>choosenIndexName</name> <init>= <expr><call><name>GenerateDefaultIndexName</name><argument_list>(<argument><expr><name>createLongestShardIndexStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>choosenIndexName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateDefaultIndexName is a wrapper around postgres function ChooseIndexName
 * that generates default index name for the index to be created by given CREATE
 * INDEX statement as postgres would do.
 *
 * (See DefineIndex at postgres/src/backend/commands/indexcmds.c)
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GenerateDefaultIndexName</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceId</name> <init>= <expr><call><name>CreateIndexStmtGetSchemaId</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexParams</name> <init>= <expr><call><name>GenerateIndexParameters</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexColNames</name> <init>= <expr><call><name>ChooseIndexColumnNames</name><argument_list>(<argument><expr><name>indexParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>indexName</name> <init>= <expr><call><name>ChooseIndexName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>indexColNames</name></expr></argument>,
									  <argument><expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>,
									  <argument><expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>primary</name></name></expr></argument>,
									  <argument><expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>isconstraint</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>indexName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateIndexParameters is a helper function that creates a list of parameters
 * required to assign a default index name for the index to be created by given
 * CREATE INDEX command.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GenerateIndexParameters</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexParams</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>indexParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexIncludingParams</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allIndexParams</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>indexParams</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>indexIncludingParams</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>allIndexParams</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateCreateIndexDDLJob returns DDLJob for given CREATE INDEX command.
 */</comment>
<function><type><specifier>static</specifier> <name>DDLJob</name> <modifier>*</modifier></type>
<name>GenerateCreateIndexDDLJob</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>createIndexCommand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
					 <argument><expr><call><name>CreateIndexStmtGetRelationId</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>startNewTransaction</name></name> <operator>=</operator> <name><name>createIndexStatement</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>createIndexCommand</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>CreateIndexTaskList</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ddlJob</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateIndexStmtGetRelationId returns relationId for relation that given
 * CREATE INDEX command operates on.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>CreateIndexStmtGetRelationId</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relationRangeVar</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><call><name>GetCreateIndexRelationLockMode</name><argument_list>(<argument><expr><name>createIndexStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relationRangeVar</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>relationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetCreateIndexRelationLockMode returns required lock mode to open the
 * relation that given CREATE INDEX command operates on.
 */</comment>
<function><type><name>LOCKMODE</name></type>
<name>GetCreateIndexRelationLockMode</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>ShareUpdateExclusiveLock</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>ShareLock</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReindexStmtFindRelationOid returns the oid of the relation on which the index exist
 * if the object is an index in the reindex stmt. It returns the oid of the relation
 * if the object is a table in the reindex stmt. It also acquires the relevant lock
 * for the statement.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ReindexStmtFindRelationOid</name><parameter_list>(<parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_INDEX</name> <operator>||</operator>
		   <name><name>reindexStmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><ternary><condition><expr><call><name>IsReindexWithParam_compat</name><argument_list>(<argument><expr><name>reindexStmt</name></expr></argument>, <argument><expr><literal type="string">"concurrently"</literal></expr></argument>)</argument_list></call></expr> ?</condition><then>
						<expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>AccessExclusiveLock</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>ReindexIndexCallbackState</name></name></type> <name>state</name></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>concurrent</name></name> <operator>=</operator> <call><name>IsReindexWithParam_compat</name><argument_list>(<argument><expr><name>reindexStmt</name></expr></argument>,
													 <argument><expr><literal type="string">"concurrently"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>locked_table_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>indOid</name> <init>= <expr><call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
											  <argument><expr><ternary><condition><expr><operator>(</operator><name>missingOk</name><operator>)</operator></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
											  <argument><expr><name>RangeVarCallbackForReindexIndex</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indOid</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name><name>reindexStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
											  <argument><expr><ternary><condition><expr><operator>(</operator><name>missingOk</name><operator>)</operator></expr> ?</condition><then> <expr><name>RVR_MISSING_OK</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
											  <argument><expr><name>RangeVarCallbackOwnsTable</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>relationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessReindexStmt determines whether a given REINDEX statement involves
 * a distributed table. If so (and if the statement does not use unsupported
 * options), it modifies the input statement to ensure proper execution against
 * the coordinator node table and creates a DDLJob to encapsulate information needed
 * during the worker node portion of DDL execution before returning that DDLJob
 * in a List. If no distributed table is involved, this function returns NIL.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessReindexStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reindexCommand</name></decl></parameter>,
					  <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStatement</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ReindexStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlJobs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We first check whether a distributed relation is affected. For that, we need to
	 * open the relation. To prevent race conditions with later lookups, lock the table,
	 * and modify the rangevar to include the schema.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>reindexStatement</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>ReindexStmtFindRelationOid</name><argument_list>(<argument><expr><name>reindexStatement</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>relationContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>reindexStatement</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>indOid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>reindexStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indOid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name><name>reindexStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>isCitusRelation</name> <init>= <expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>reindexStatement</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Before we do any further processing, fix the schema name to make sure
			 * that a (distributed) table with the same name does not appear on the
			 * search path in front of the current schema. We do this even if the
			 * table is not distributed, since a distributed table may appear on the
			 * search path by the time postgres starts processing this statement.
			 */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>namespaceName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* ensure we copy string into proper context */</comment>
			<expr_stmt><expr><name>relationContext</name> <operator>=</operator> <call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name><name>reindexStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>reindexStatement</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>relationContext</name></expr></argument>,
																		 <argument><expr><name>namespaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>reindexStatement</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>REINDEX_OBJECT_INDEX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>isCitusRelation</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"REINDEX TABLE queries on distributed partitioned "</literal>
									   <literal type="string">"tables are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>startNewTransaction</name></name> <operator>=</operator> <call><name>IsReindexWithParam_compat</name><argument_list>(<argument><expr><name>reindexStatement</name></expr></argument>,
																	<argument><expr><literal type="string">"concurrently"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>reindexCommand</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>CreateReindexTaskList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>reindexStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ddlJobs</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ddlJobs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReindexStmtObjectAddress returns list of object addresses in the reindex
 * statement. We add the address if the object is either index or table;
 * else, we add invalid address.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ReindexStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStatement</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ReindexStmt</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>reindexStatement</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we currently only support reindex commands on tables */</comment>
		<expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>ReindexStmtFindRelationOid</name><argument_list>(<argument><expr><name>reindexStatement</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>objectAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessDropIndexStmt determines whether a given DROP INDEX statement involves
 * a distributed table. If so (and if the statement does not use unsupported
 * options), it modifies the input statement to ensure proper execution against
 * the coordinator node table and creates a DDLJob to encapsulate information needed
 * during the worker node portion of DDL execution before returning that DDLJob
 * in a List. If no distributed table is involved, this function returns NIL.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessDropIndexStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dropIndexCommand</name></decl></parameter>,
						<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropIndexStatement</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlJobs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedIndexId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributedRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dropIndexStatement</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* check if any of the indexes being dropped belong to a distributed table */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>objectNameList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>objectNameList</argument>, <argument>dropIndexStatement-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>DropRelationCallbackState</name></name></type> <name>state</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>rvrFlags</name> <init>= <expr><name>RVR_MISSING_OK</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rangeVar</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>objectNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We don't support concurrently dropping indexes for distributed
		 * tables, but till this point, we don't know if it is a regular or a
		 * distributed table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>dropIndexStatement</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>ShareUpdateExclusiveLock</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The next few statements are based on RemoveRelations() in
		 * commands/tablecmds.c in Postgres source.
		 */</comment>
		<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_INDEX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>heapOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>.</operator><name>concurrent</name></name> <operator>=</operator> <name><name>dropIndexStatement</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>indexId</name> <init>= <expr><call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>rangeVar</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>rvrFlags</name></expr></argument>,
											   <argument><expr><name>RangeVarCallbackForDropIndex</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the index does not exist, we don't do anything here, and allow
		 * postgres to throw appropriate error or notice message later.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isCitusRelation</name> <init>= <expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>isCitusRelation</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>distributedIndexId</name> <operator>=</operator> <name>indexId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>distributedRelationId</name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>distributedIndexId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ErrorIfUnsupportedDropIndexStmt</name><argument_list>(<argument><expr><name>dropIndexStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>AnyForeignKeyDependsOnIndex</name><argument_list>(<argument><expr><name>distributedIndexId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MarkInvalidateForeignKeyGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>,
						 <argument><expr><name>distributedRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We do not want DROP INDEX CONCURRENTLY to commit locally before
		 * sending commands, because if there is a failure we would like to
		 * to be able to repeat the DROP INDEX later.
		 */</comment>
		<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>startNewTransaction</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>dropIndexCommand</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>DropIndexTaskList</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>, <argument><expr><name>distributedIndexId</name></expr></argument>,
											 <argument><expr><name>dropIndexStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ddlJobs</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ddlJobs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessIndexStmt marks new indexes invalid if they were created using the
 * CONCURRENTLY flag. This (non-transactional) change provides the fallback
 * state if an error is raised, otherwise a sub-sequent change to valid will be
 * committed.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessIndexStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>indexStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this logic only applies to the coordinator */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCoordinator</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We make sure schema name is not null in the PreprocessIndexStmt
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>indexRelationId</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></argument>, <argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* ensure dependencies of index exist on all nodes */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* furtheron we are only processing CONCURRENT index statements */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexStmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * EnsureAllObjectDependenciesExistOnAllNodes could have distributed objects that are required
	 * by this index. During the propagation process an active snapshout might be left as
	 * a side effect of inserting the local tuples via SPI. To not leak a snapshot like
	 * that we will pop any snapshot if we have any right before we commit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* commit the current transaction and start anew */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the affected relation and index */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_openrv</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>indexRelation</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* close relations but retain locks */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mark index as invalid, in-place (cannot be rolled back) */</comment>
	<expr_stmt><expr><call><name>index_set_state_flags</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>INDEX_DROP_CLEAR_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* re-open a transaction command from here on out */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedAlterIndexStmt checks if the corresponding alter index
 * statement is supported for distributed tables and errors out if it is not.
 * Currently, only the following commands are supported.
 *
 * ALTER INDEX SET ()
 * ALTER INDEX RESET ()
 * ALTER INDEX ALTER COLUMN SET STATISTICS
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfUnsupportedAlterIndexStmt</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* error out if any of the subcommands are unsupported */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableType</name></type> <name>alterTableType</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>alterTableType</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>  <comment type="block">/* SET (...) */</comment>
			<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>    <comment type="block">/* RESET (...) */</comment>
			<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>  <comment type="block">/* replace entire option list */</comment>
			<case>case <expr><name>AT_SetStatistics</name></expr>:</case>  <comment type="block">/* SET STATISTICS */</comment>
			<case>case <expr><name>AT_AttachPartition</name></expr>:</case> <comment type="block">/* ATTACH PARTITION */</comment>
			<block>{<block_content>
				<comment type="block">/* this command is supported by Citus */</comment>
				<break>break;</break>
			</block_content>}</block>

			<comment type="block">/* unsupported create index statements */</comment>
			<case>case <expr><name>AT_SetTableSpace</name></expr>:</case>
			<default>default:</default>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"alter index ... set tablespace ... "</literal>
								<literal type="string">"is currently unsupported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Only RENAME TO, SET (), RESET (), ATTACH PARTITION "</literal>
								   <literal type="string">"and SET STATISTICS are supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return> <comment type="block">/* keep compiler happy */</comment>
			</block_content>}</block>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CreateIndexTaskList builds a list of tasks to execute a CREATE INDEX command.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CreateIndexTaskList</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>indexStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>CreateIndexStmtGetRelationId</name><argument_list>(<argument><expr><name>indexStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>ddlString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* lock metadata before getting placement lists */</comment>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>deparse_shard_index_statement</name><argument_list>(<argument><expr><name>indexStmt</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>DDL_TASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>ddlString</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>cannotBeExecutedInTransction</name></name> <operator>=</operator> <name><name>indexStmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateReindexTaskList builds a list of tasks to execute a REINDEX command
 * against a specified distributed table.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CreateReindexTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>ReindexStmt</name> <modifier>*</modifier></type><name>reindexStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>ddlString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* lock metadata before getting placement lists */</comment>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>deparse_shard_reindex_statement</name><argument_list>(<argument><expr><name>reindexStmt</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>DDL_TASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>ddlString</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>cannotBeExecutedInTransction</name></name> <operator>=</operator>
			<call><name>IsReindexWithParam_compat</name><argument_list>(<argument><expr><name>reindexStmt</name></expr></argument>, <argument><expr><literal type="string">"concurrently"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Before acquiring a table lock, check whether we have sufficient rights.
 * In the case of DROP INDEX, also try to lock the table before the index.
 *
 * This code is heavily borrowed from RangeVarCallbackForDropRelation() in
 * commands/tablecmds.c in Postgres source. We need this to ensure the right
 * order of locking while dealing with DROP INDEX statements. Because we are
 * exclusively using this callback for INDEX processing, the PARTITION-related
 * logic from PostgreSQL's similar callback has been omitted as unneeded.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForDropIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelOid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* *INDENT-OFF* */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>expected_relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>heap_lockmode</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>DropRelationCallbackState</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator>struct <name>DropRelationCallbackState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>heap_lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then>
	                <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>AccessExclusiveLock</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we previously locked some other index's heap, and the name we're
	 * looking up no longer refers to that relation, release the now-useless
	 * lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relOid</name> <operator>!=</operator> <name>oldRelOid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>, <argument><expr><name>heap_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Didn't find a relation, so no need for locking or permission checks. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* concurrently dropped, so nothing to do */</comment>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classform</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * PG 11 sends relkind as partitioned index for an index
	 * on partitioned table. It is handled the same
	 * as regular index as far as we are concerned here.
	 *
	 * See tablecmds.c:RangeVarCallbackForDropRelation()
	 */</comment>
	<expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name><name>classform</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>expected_relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expected_relkind</name> <operator>=</operator> <name>RELKIND_INDEX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>expected_relkind</name> <operator>!=</operator> <name>relkind</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Allow DROP to either table owner or schema owner */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	    <operator>!</operator><call><name>pg_namespace_ownercheck</name><argument_list>(<argument><expr><name><name>classform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_INDEX</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allowSystemTableMods</name> <operator>&amp;&amp;</operator> <call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>classform</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied: \"%s\" is a system catalog"</literal></expr></argument>,
				               <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In DROP INDEX, attempt to acquire lock on the parent table before
	 * locking the index.  index_drop() will need this anyway, and since
	 * regular queries lock tables before their indexes, we risk deadlock if
	 * we do it the other way around.  No error if we don't find a pg_index
	 * entry, though --- the relation may have been dropped.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator> <name>relOid</name> <operator>!=</operator> <name>oldRelOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>heapOid</name></name></expr></argument>, <argument><expr><name>heap_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* *INDENT-ON* */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Check permissions on table before acquiring relation lock; also lock
 * the heap before the RangeVarGetRelidExtended takes the index lock, to avoid
 * deadlocks.
 *
 * This code is borrowed from RangeVarCallbackForReindexIndex() in
 * commands/indexcmds.c in Postgres source. We need this to ensure the right
 * order of locking while dealing with REINDEX statements.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RangeVarCallbackForReindexIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oldRelId</name></decl></parameter>,
								<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* *INDENT-OFF* */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ReindexIndexCallbackState</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>table_lockmode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Lock level here should match table lock in reindex_index() for
	 * non-concurrent case and table locks used by index_concurrently_*() for
	 * concurrent case.
	 */</comment>
	<expr_stmt><expr><name>table_lockmode</name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>ShareLock</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we previously locked some other index's heap, and the name we're
	 * looking up no longer refers to that relation, release the now-useless
	 * lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relId</name> <operator>!=</operator> <name>oldRelId</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>locked_table_oid</name></name></expr></argument>, <argument><expr><name>table_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>locked_table_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If the relation does not exist, there's nothing more to do. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the relation does exist, check whether it's an index.  But note that
	 * the relation might have been dropped between the time we did the name
	 * lookup and now.  In that case, there's nothing to do.
	 */</comment>
	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relkind</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_INDEX</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not an index"</literal></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check permissions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_INDEX</name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Lock heap before index to avoid deadlock. */</comment>
	<if_stmt><if>if <condition>(<expr><name>relId</name> <operator>!=</operator> <name>oldRelId</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>table_oid</name> <init>= <expr><call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the OID isn't valid, it means the index was concurrently
		 * dropped, which is not a problem for us; just return normally.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>, <argument><expr><name>table_lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>locked_table_oid</name></name> <operator>=</operator> <name>table_oid</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* *INDENT-ON* */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedIndexStmt checks if the corresponding index statement is
 * supported for distributed tables and errors out if it is not.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedIndexStmt</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>createIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>tableSpace</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specifying tablespaces with CREATE INDEX statements is "</literal>
							   <literal type="string">"currently unsupported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>unique</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* caller uses ShareLock for non-concurrent indexes, use the same lock here */</comment>
		<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><name>ShareLock</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>indexContainsPartitionColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Non-distributed tables do not have partition key, and unique constraints
		 * are allowed for them. Thus, we added a short-circuit for non-distributed tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating unique indexes on append-partitioned tables "</literal>
								   <literal type="string">"is currently unsupported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>AllowUnsafeConstraints</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The user explicitly wants to allow the constraint without
			 * distribution column.
			 */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionKey</name> <init>= <expr><call><name>DistPartitionKeyOrError</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexParameterList</name> <init>= <expr><name><name>createIndexStatement</name><operator>-&gt;</operator><name>indexParams</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexElem</name> <modifier>*</modifier></type><name>indexElement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>indexElement</argument>, <argument>indexParameterList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><name><name>indexElement</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* column name is null for index expressions, skip it */</comment>
			<if_stmt><if>if <condition>(<expr><name>columnName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attributeNumber</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>attributeNumber</name> <operator>==</operator> <name><name>partitionKey</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>indexContainsPartitionColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>indexContainsPartitionColumn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating unique indexes on non-partition "</literal>
								   <literal type="string">"columns is currently unsupported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedDropIndexStmt checks if the corresponding drop index statement is
 * supported for distributed tables and errors out if it is not.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedDropIndexStmt</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropIndexStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dropIndexStatement</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dropIndexStatement</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop multiple distributed objects in a "</literal>
							   <literal type="string">"single command"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try dropping each object in a separate DROP "</literal>
								<literal type="string">"command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DropIndexTaskList builds a list of tasks to execute a DROP INDEX command
 * against a specified distributed table.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>DropIndexTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>, <parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>indexName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>ddlString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* lock metadata before getting placement lists */</comment>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardIndexName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardIndexName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* deparse shard-specific DROP INDEX command */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>, <argument><expr><literal type="string">"DROP INDEX %s %s %s %s"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>dropStmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then> <expr><literal type="string">"CONCURRENTLY"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>dropStmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> ?</condition><then> <expr><literal type="string">"IF EXISTS"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
						 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardIndexName</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>dropStmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>==</operator> <name>DROP_RESTRICT</name></expr> ?</condition><then> <expr><literal type="string">"RESTRICT"</literal></expr> </then><else>: <expr><literal type="string">"CASCADE"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>DDL_TASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>ddlString</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>cannotBeExecutedInTransction</name></name> <operator>=</operator> <name><name>dropStmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MarkIndexValid marks an index as valid after a CONCURRENTLY command. We mark
 * indexes invalid in PostProcessIndexStmt and then commit, such that any failure
 * leaves behind an invalid index. We mark it as valid here when the command
 * completes.
 */</comment>
<function><type><name>void</name></type>
<name>MarkIndexValid</name><parameter_list>(<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>indexStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsCoordinator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We make sure schema name is not null in the PreprocessIndexStmt
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name> <name>relationId</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>=
		<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the affected relation and index */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_openrv</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>indexRelationId</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></argument>,
											<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>indexRelation</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* mark index as valid, in-place (cannot be rolled back) */</comment>
	<expr_stmt><expr><call><name>index_set_state_flags</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>INDEX_CREATE_SET_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
