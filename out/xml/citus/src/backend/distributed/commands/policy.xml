<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/commands/policy.c"><comment type="block">/*-------------------------------------------------------------------------
 * policy.c
 *
 * This file contains functions to create, alter and drop policies on
 * distributed tables.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rowsecurity.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>unparse_policy_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>aclchar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddRangeTableEntryToQueryCompat</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parseState</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RowSecurityPolicy</name> <modifier>*</modifier></type> <name>GetPolicyByName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>policyName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetPolicyListForRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>CreatePolicyCommandForPolicy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * CreatePolicyCommands takes in a relationId, and returns the list of create policy
 * commands needed to reconstruct the policies of that table.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CreatePolicyCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>policyList</name> <init>= <expr><call><name>GetPolicyListForRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>policy</name></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>policy</argument>, <argument>policyList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>createPolicyCommand</name> <init>= <expr><call><name>CreatePolicyCommandForPolicy</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(<argument><expr><name>createPolicyCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>commands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetPolicyListForRelation returns a list of RowSecurityPolicy objects identifying
 * the policies on the relation with relationId. Note that this function acquires
 * AccessShareLock on relation and does not release it in the end to make sure that
 * caller will process valid policies through the transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetPolicyListForRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>relation_has_policies</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rsdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * there are policies, but since RLS is not enabled they are not loaded into
		 * cache, we will do so here for us to access
		 */</comment>
		<expr_stmt><expr><call><name>RelationBuildRowSecurity</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>policyList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>policy</name></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>policy</argument>, <argument>relation-&gt;rd_rsdesc-&gt;policies</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>policyList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>policyList</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>policyList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreatePolicyCommandForPolicy takes a relationId and a policy, returns
 * the CREATE POLICY command needed to reconstruct the policy identified
 * by the "policy" object on the relation with relationId.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreatePolicyCommandForPolicy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationContext</name> <init>= <expr><call><name>deparse_context_for</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>createPolicyCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>createPolicyCommand</name></expr></argument>, <argument><expr><literal type="string">"CREATE POLICY %s ON %s FOR %s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>relationName</name></expr></argument>,
					 <argument><expr><call><name>unparse_policy_command</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>polcmd</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createPolicyCommand</name></expr></argument>, <argument><expr><literal type="string">" TO "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * iterate over all roles and append them to the ddl command with commas
	 * separating the role names
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>roles</name> <init>= <expr><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>roleIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>roleIndex</name> <operator>&lt;</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>roleIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>roleName</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>roleIndex</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createPolicyCommand</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>roles</name><index>[<expr><name>roleIndex</name></expr>]</index></name> <operator>==</operator> <name>ACL_ID_PUBLIC</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>roleName</name> <operator>=</operator> <literal type="string">"PUBLIC"</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>roleName</name> <operator>=</operator> <call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name><name>roles</name><index>[<expr><name>roleIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createPolicyCommand</name></expr></argument>, <argument><expr><name>roleName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualString</name> <init>= <expr><call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>policy</name><operator>-&gt;</operator><name>qual</name></name><operator>)</operator></expr></argument>,
											  <argument><expr><name>relationContext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>createPolicyCommand</name></expr></argument>, <argument><expr><literal type="string">" USING (%s)"</literal></expr></argument>, <argument><expr><name>qualString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>with_check_qual</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>withCheckQualString</name> <init>= <expr><call><name>deparse_expression</name><argument_list>(
			<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>policy</name><operator>-&gt;</operator><name>with_check_qual</name></name><operator>)</operator></expr></argument>, <argument><expr><name>relationContext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>createPolicyCommand</name></expr></argument>, <argument><expr><literal type="string">" WITH CHECK (%s)"</literal></expr></argument>,
						 <argument><expr><name>withCheckQualString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>createPolicyCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * unparse_policy_command takes the type of a policy command and converts it to its full
 * command string. This function is the exact inverse of parse_policy_command that is in
 * postgres.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>unparse_policy_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>aclchar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>aclchar</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'*'</literal></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"ALL"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>ACL_SELECT_CHR</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"SELECT"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>ACL_INSERT_CHR</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"INSERT"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>ACL_UPDATE_CHR</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"UPDATE"</literal></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>ACL_DELETE_CHR</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><literal type="string">"DELETE"</literal></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized aclchar: %d"</literal></expr></argument>, <argument><expr><name>aclchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessCreatePolicyStmt determines when a CREATE POLICY statement involves
 * a distributed table. If so, it creates DDLJobs to encapsulate information
 * needed during the worker node portion of DDL execution before returning the
 * DDLJobs in a List. If no distributed table is involved, this returns NIL.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessCreatePolicyStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreatePolicyStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreatePolicyStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* load relation information */</comment>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relvar</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>table</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relvar</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>qual_pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AddRangeTableEntryToQueryCompat</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><call><name>transformWhereClause</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>,
									  <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>EXPR_KIND_POLICY</name></expr></argument>,
									  <argument><expr><literal type="string">"POLICY"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>qual</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ErrorIfUnsupportedPolicyExpr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>with_check_pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AddRangeTableEntryToQueryCompat</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>with_check_qual</name> <init>= <expr><call><name>transformWhereClause</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>,
												 <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>with_check</name></name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>EXPR_KIND_POLICY</name></expr></argument>,
												 <argument><expr><literal type="string">"POLICY"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>with_check_qual</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ErrorIfUnsupportedPolicyExpr</name><argument_list>(<argument><expr><name>with_check_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>policy</name> <init>= <expr><call><name>GetPolicyByName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>policy</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * As this function is executed after standard process utility created the
		 * policy, we should be able to find &amp; deparse the policy with policy_name.
		 * But to be more safe, error out here.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create policy, policy does not exist."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ddlCommand</name> <init>= <expr><call><name>CreatePolicyCommandForPolicy</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * create the DDLJob that needs to be executed both on the local relation and all its
	 * placements.
	 */</comment>
	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>ddlCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>DDLTaskList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ddlCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddRangeTableEntryToQueryCompat adds the given relation to query.
 * This method is a compatibility wrapper.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddRangeTableEntryToQueryCompat</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parseState</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>parseState</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>,
															<argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
															<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>addNSItemToQuery</name><argument_list>(<argument><expr><name>parseState</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetPolicyByName takes a relationId and a policyName, returns RowSecurityPolicy
 * object which identifies the policy with name "policyName" on the relation
 * with relationId. If there does not exist such a policy, then this function
 * returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>RowSecurityPolicy</name> <modifier>*</modifier></type>
<name>GetPolicyByName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>policyName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>policyList</name> <init>= <expr><call><name>GetPolicyListForRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>policy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>policy</argument>, <argument>policyList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>, <argument><expr><name>policyName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>policy</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterPolicyStmt determines whether a given ALTER POLICY statement involves a
 * distributed table. If so, it creates DDLJobs to encapsulate information needed during
 * the worker node portion of DDL execution before returning the DDLJobs in a list. If no
 * distributed table is involved this returns NIL.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterPolicyStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						  <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterPolicyStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterPolicyStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>ddlString</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>roleCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* load relation information */</comment>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relvar</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>table</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relOid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relvar</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>generate_relation_name</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>, <argument><expr><literal type="string">"ALTER POLICY %s ON %s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>policy_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>relationName</name></expr></argument>
					 )</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>, <argument><expr><literal type="string">" TO "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>roleCell</argument>, <argument>stmt-&gt;roles</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>roleSpec</name> <init>= <expr><operator>(</operator><name>RoleSpec</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>roleCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>, <argument><expr><call><name>RoleSpecString</name><argument_list>(<argument><expr><name>roleSpec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name></expr></argument>, <argument><expr><name>roleCell</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationContext</name> <init>= <expr><call><name>deparse_context_for</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>qual_pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AddRangeTableEntryToQueryCompat</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><call><name>transformWhereClause</name><argument_list>(<argument><expr><name>qual_pstate</name></expr></argument>,
									  <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>EXPR_KIND_POLICY</name></expr></argument>,
									  <argument><expr><literal type="string">"POLICY"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>qual</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ErrorIfUnsupportedPolicyExpr</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualString</name> <init>= <expr><call><name>deparse_expression</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>relationContext</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>, <argument><expr><literal type="string">" USING (%s)"</literal></expr></argument>, <argument><expr><name>qualString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>with_check_pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AddRangeTableEntryToQueryCompat</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>with_check_qual</name> <init>= <expr><call><name>transformWhereClause</name><argument_list>(<argument><expr><name>with_check_pstate</name></expr></argument>,
												 <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>with_check</name></name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>EXPR_KIND_POLICY</name></expr></argument>,
												 <argument><expr><literal type="string">"POLICY"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>with_check_qual</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ErrorIfUnsupportedPolicyExpr</name><argument_list>(<argument><expr><name>with_check_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>withCheckString</name> <init>= <expr><call><name>deparse_expression</name><argument_list>(<argument><expr><name>with_check_qual</name></expr></argument>, <argument><expr><name>relationContext</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlString</name></expr></argument>, <argument><expr><literal type="string">" WITH CHECK (%s)"</literal></expr></argument>, <argument><expr><name>withCheckString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * create the DDLJob that needs to be executed both on the local relation  and all its
	 * placements.
	 */</comment>
	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>ddlString</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>DDLTaskList</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name><name>ddlString</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedPolicy runs checks related to a Relation their Policies and errors
 * out if it is not possible to create one of the policies in a distributed environment.
 *
 * To support policies we require that:
 * - Policy expressions do not contain subqueries.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfUnsupportedPolicy</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>policyCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>relation_has_policies</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * even if a relation has policies they might not be loaded on the Relation yet. This
	 * happens if policies are on a Relation without Row Level Security enabled. We need
	 * to make sure the policies installed are valid for distribution if RLS gets enabled
	 * after the table has been distributed. Therefore we force a build of the policies on
	 * the cached Relation
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rsdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationBuildRowSecurity</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>policyCell</argument>, <argument>relation-&gt;rd_rsdesc-&gt;policies</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RowSecurityPolicy</name> <modifier>*</modifier></type><name>policy</name> <init>= <expr><operator>(</operator><name>RowSecurityPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>policyCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ErrorIfUnsupportedPolicyExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>policy</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ErrorIfUnsupportedPolicyExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>policy</name><operator>-&gt;</operator><name>with_check_qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedPolicyExpr tests if the provided expression for a policy is
 * supported on a distributed table.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfUnsupportedPolicyExpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We do not allow any sublink to prevent expressions with subqueries to be used as an
	 * expression in policies on distributed tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create policy"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Subqueries are not supported in policies on distributed "</literal>
						   <literal type="string">"tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessDropPolicyStmt determines whether a given DROP POLICY statement involves a
 * distributed table. If so it creates DDLJobs to encapsulate information needed during
 * the worker node portion of DDL execution before returning the DDLJobs in a List. If no
 * distributed table is involved this returns NIL.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessDropPolicyStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						 <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlJobs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>dropObjectCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_POLICY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>dropObjectCell</argument>, <argument>stmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>dropObjectCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * the last element in the list of names is the name of the policy. The ones
		 * before are describing the relation. By removing the last item from the list we
		 * can use makeRangeVarFromNameList to get to the relation. As list_truncate
		 * changes the list in place we make a copy before.
		 */</comment>
		<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>relOid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>DDLTaskList</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ddlJobs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlJobs</name></expr></argument>, <argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>ddlJobs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsPolicyRenameStmt returns wherher the passed-in RenameStmt is one of the following
 * forms:
 *
 *   - ALTER POLICY ... ON ... RENAME TO ...
 */</comment>
<function><type><name>bool</name></type>
<name>IsPolicyRenameStmt</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_POLICY</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreatePolicyEventExtendNames extends relation names in the given CreatePolicyStmt tree.
 * This function has side effects on the tree as the names are replaced inplace.
 */</comment>
<function><type><name>void</name></type>
<name>CreatePolicyEventExtendNames</name><parameter_list>(<parameter><decl><type><name>CreatePolicyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type>
							 <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>table</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* prefix with schema name if it is not added already */</comment>
	<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AlterPolicyEventExtendNames extends relation names in the given AlterPolicyStatement
 * tree. This function has side effects on the tree as the names are replaced inplace.
 */</comment>
<function><type><name>void</name></type>
<name>AlterPolicyEventExtendNames</name><parameter_list>(<parameter><decl><type><name>AlterPolicyStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>table</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* prefix with schema name if it is not added already */</comment>
	<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RenamePolicyEventExtendNames extends relation names in the given RenameStmt tree. This
 * function has side effects on the tree as the names are replaced inline.
 */</comment>
<function><type><name>void</name></type>
<name>RenamePolicyEventExtendNames</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>objectSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* prefix with schema name if it is not added already */</comment>
	<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>objectSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DropPolicyEventExtendNames extends relation names in the given DropStmt tree specific
 * to policies. This function has side effects on the tree as the names are replaced
 * inplace.
 */</comment>
<function><type><name>void</name></type>
<name>DropPolicyEventExtendNames</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropStmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>relationSchemaNameValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>relationNameValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>dropCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dropStmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>dropCount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extend name for multiple drop objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationNameList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>dropStmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>relationNameListLength</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>relationNameListLength</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>relationNameValue</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><literal type="number">3</literal></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>relationSchemaNameValue</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>relationNameValue</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper policy name: \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>

	<comment type="block">/* prefix with schema name if it is not added already */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationSchemaNameValue</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>schemaNameValue</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>relationNameList</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>schemaNameValue</name></expr></argument>, <argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><call><name>strVal</name><argument_list>(<argument><expr><name>relationNameValue</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
