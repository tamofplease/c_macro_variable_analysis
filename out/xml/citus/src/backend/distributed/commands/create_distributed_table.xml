<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/commands/create_distributed_table.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * create_distributed_table.c
 *	  Routines relation to the creation of distributed relations.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/multi_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distributed_execution_locks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distribution_column.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_colocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_cleaner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_rebalancer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_split.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_transfer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_library_init.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_rebalancer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_shard_visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/distribution_column_map.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>

<comment type="block">/*
 * once every LOG_PER_TUPLE_AMOUNT, the copy will be logged.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_PER_TUPLE_AMOUNT</name></cpp:macro> <cpp:value>1000000</cpp:value></cpp:define>

<comment type="block">/* local function forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateDistributedTableConcurrently</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
											   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name></decl></parameter>,
											   <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>,
											   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>shardCountIsStrict</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>DecideReplicationModel</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>HashSplitPointsForShardList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>HashSplitPointsForShardCount</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>WorkerNodesForShardList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>RoundRobinWorkerNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>listLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateHashDistributedTableShards</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>,
											 <parameter><decl><type><name>Oid</name></type> <name>colocatedTableId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localTableEmpty</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>ColocationIdForNewTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name></decl></parameter>,
									  <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shardCountIsStrict</name></decl></parameter>,
									  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureRelationCanBeDistributed</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name></decl></parameter>,
										   <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>,
										   <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureLocalTableEmpty</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureRelationHasNoTriggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>SupportFunctionForColumn</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>,
									<parameter><decl><type><name>int16</name></type> <name>supportFunctionNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureLocalTableEmptyIfNecessary</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldLocalTableBeEmpty</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureCitusTableCanBeCreated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PropagatePrerequisiteObjectsForDistributedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureDistributedSequencesHaveOneType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
												  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>seqInfoList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetFKeyCreationCommandsRelationInvolvedWithTableType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
																   <parameter><decl><type><name>int</name></type> <name>tableTypeFlag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>DropFKeysAndUndistributeTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropFKeysRelationInvolvedWithTableType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tableTypeFlag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyLocalDataIntoShards</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>TupleDescColumnNameList</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name><operator>)</operator></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DistributionColumnUsesNumericColumnNegativeScale</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>relationDesc</name></decl></parameter>,
															 <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>numeric_typmod_scale</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_valid_numeric_typmod</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DistributionColumnUsesGeneratedStoredColumn</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>relationDesc</name></decl></parameter>,
														<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CanUseExclusiveConnections</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localTableEmpty</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DoCopyFromLocalTableIntoShards</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>distributedRelation</name></decl></parameter>,
										   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>,
										   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
										   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfTemporaryTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfForeignTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendAddLocalTableToMetadataCommandOutsideTransaction</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureDistributableTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureForeignKeysForDistributedTableConcurrently</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureColocateWithTableIsValid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>,
										   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name></decl></parameter>,
										   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WarnIfTableHaveNoReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>master_create_distributed_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>create_distributed_table_concurrently</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>create_distributed_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>create_reference_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * master_create_distributed_table is a deprecated predecessor to
 * create_distributed_table
 */</comment>
<function><type><name>Datum</name></type>
<name>master_create_distributed_table</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"master_create_distributed_table has been deprecated"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * create_distributed_table gets a table name, distribution column,
 * distribution method and colocate_with option, then it creates a
 * distributed table.
 */</comment>
<function><type><name>Datum</name></type>
<name>create_distributed_table</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>distributionColumnText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionMethodOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>colocateWithTableNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>colocateWithTableNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>shardCountIsStrict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name>ShardCount</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot use colocate_with with a table "</literal>
								   <literal type="string">"and shard_count at the same time"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>shardCount</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if shard_count parameter is given than we have to
		 * make sure table has that many shards
		 */</comment>
		<expr_stmt><expr><name>shardCountIsStrict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCitusTableCanBeCreated</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* enable create_distributed_table on an empty node */</comment>
	<expr_stmt><expr><call><name>InsertCoordinatorIfClusterEmpty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lock target relation with an exclusive lock - there's no way to make
	 * sense of this table until we've committed, and we don't want multiple
	 * backends manipulating this relation.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create distributed table: "</literal>
							   <literal type="string">"relation does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>distributionColumnText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distributionColumnName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>distributionMethod</name> <init>= <expr><call><name>LookupDistributionMethod</name><argument_list>(<argument><expr><name>distributionMethodOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>shardCount</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>shardCount</name></expr></argument> &gt;</argument_list></name> <name>MAX_SHARD_COUNT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%d is outside the valid range for "</literal>
							   <literal type="string">"parameter \"shard_count\" (1 .. %d)"</literal></expr></argument>,
							   <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>MAX_SHARD_COUNT</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CreateDistributedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionColumnName</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>,
						   <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>shardCountIsStrict</name></expr></argument>, <argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * create_distributed_concurrently gets a table name, distribution column,
 * distribution method and colocate_with option, then it creates a
 * distributed table.
 */</comment>
<function><type><name>Datum</name></type>
<name>create_distributed_table_concurrently</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>distributionColumnText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>distributionColumnText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionMethodOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>distributionMethod</name> <init>= <expr><call><name>LookupDistributionMethod</name><argument_list>(<argument><expr><name>distributionMethodOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>colocateWithTableNameText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>colocateWithTableNameText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>shardCountIsStrict</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><name>ShardCount</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot use colocate_with with a table "</literal>
								   <literal type="string">"and shard_count at the same time"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>shardCount</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if shard_count parameter is given than we have to
		 * make sure table has that many shards
		 */</comment>
		<expr_stmt><expr><name>shardCountIsStrict</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CreateDistributedTableConcurrently</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionColumnName</name></expr></argument>,
									   <argument><expr><name>distributionMethod</name></expr></argument>,
									   <argument><expr><name>colocateWithTableName</name></expr></argument>,
									   <argument><expr><name>shardCount</name></expr></argument>,
									   <argument><expr><name>shardCountIsStrict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateDistributedTableConcurrently distributes a table by first converting
 * it to a Citus local table and then splitting the shard of the Citus local
 * table.
 *
 * If anything goes wrong during the second phase, the table is left as a
 * Citus local table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateDistributedTableConcurrently</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name></decl></parameter>,
								   <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>,
								   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>shardCountIsStrict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We disallow create_distributed_table_concurrently in transaction blocks
	 * because we cannot handle preceding writes, and we block writes at the
	 * very end of the operation so the transaction should end immediately after.
	 */</comment>
	<expr_stmt><expr><call><name>PreventInTransactionBlock</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"create_distributed_table_concurrently"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * do not allow multiple create_distributed_table_concurrently in the same
	 * transaction. We should do that check just here because concurrent local table
	 * conversion can cause issues.
	 */</comment>
	<expr_stmt><expr><call><name>ErrorIfMultipleNonblockingMoveSplitInTheSameTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do not allow concurrent CreateDistributedTableConcurrently operations */</comment>
	<expr_stmt><expr><call><name>AcquireCreateDistributedTableConcurrentlyLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>!=</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only hash-distributed tables can be distributed "</literal>
							   <literal type="string">"without blocking writes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ShardReplicationFactor</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute a table concurrently when "</literal>
							   <literal type="string">"citus.shard_replication_factor &gt; 1"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DropOrphanedResourcesInSeparateTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EnsureCitusTableCanBeCreated</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EnsureValidDistributionColumn</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure table type is valid to be distributed. It should be either regular or citus local table.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureDistributableTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we rely on citus_add_local_table_to_metadata, so it can generate irrelevant messages.
	 * we want to error with a user friendly message if foreign keys are not supported.
	 * We can miss foreign key violations because we are not holding locks, so relation
	 * can be modified until we acquire the lock for the relation, but we do as much as we can
	 * to be user friendly on foreign key violation messages.
	 */</comment>

	<expr_stmt><expr><call><name>EnsureForeignKeysForDistributedTableConcurrently</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><call><name>DecideReplicationModel</name><argument_list>(<argument><expr><name>distributionMethod</name></expr></argument>,
												   <argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * we fail transaction before local table conversion if the table could not be colocated with
	 * given table. We should make those checks after local table conversion by acquiring locks to
	 * the relation because the distribution column can be modified in that period.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsColocateWithDefault</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsColocateWithNone</name><argument_list>(
			<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureColocateWithTableIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>,
									   <argument><expr><name>distributionColumnName</name></expr></argument>,
									   <argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Get name of the table before possibly replacing it in
	 * citus_add_local_table_to_metadata.
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rangeVar</name> <init>= <expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If table is a regular table, then we need to add it into metadata. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Before taking locks, convert the table into a Citus local table and commit
		 * to allow shard split to see the shard.
		 */</comment>
		<expr_stmt><expr><call><name>SendAddLocalTableToMetadataCommandOutsideTransaction</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Lock target relation with a shard update exclusive lock to
	 * block DDL, but not writes.
	 *
	 * If there was a concurrent drop/rename, error out by setting missingOK = false.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rangeVar</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>, <argument><expr><name>missingOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTableNoLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* also lock partitions */</comment>
		<expr_stmt><expr><call><name>LockPartitionRelations</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>WarnIfTableHaveNoReplicaIdentity</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * It's technically possible for the table to have been concurrently
	 * distributed just after citus_add_local_table_to_metadata and just
	 * before acquiring the lock, so double check.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table was concurrently modified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The table currently has one shard, we will split that shard to match the
	 * target distribution.
	 */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardToSplit</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>shardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PropagatePrerequisiteObjectsForDistributedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we should re-evaluate distribution column values. It may have changed,
	 * because we did not lock the relation at the previous check before local
	 * table conversion.
	 */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name> <init>= <expr><call><name>BuildDistributionKeyFromColumnName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																 <argument><expr><name>distributionColumnName</name></expr></argument>,
																 <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnType</name> <init>= <expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name> <init>= <expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get an advisory lock to serialize concurrent default group creations */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsColocateWithDefault</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AcquireColocationDefaultLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * At this stage, we only want to check for an existing co-location group.
	 * We cannot create a new co-location group until after replication slot
	 * creation in NonBlockingShardSplit.
	 */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><call><name>FindColocateWithColocationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
													   <argument><expr><name>replicationModel</name></expr></argument>,
													   <argument><expr><name>distributionColumnType</name></expr></argument>,
													   <argument><expr><name>distributionColumnCollation</name></expr></argument>,
													   <argument><expr><name>shardCount</name></expr></argument>,
													   <argument><expr><name>shardCountIsStrict</name></expr></argument>,
													   <argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsColocateWithDefault</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>colocationId</name> <operator>!=</operator>
														 <name>INVALID_COLOCATION_ID</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we can release advisory lock if there is already a default entry for given params;
		 * else, we should keep it to prevent different default coloc entry creation by
		 * concurrent operations.
		 */</comment>
		<expr_stmt><expr><call><name>ReleaseColocationDefaultLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureRelationCanBeDistributed</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionColumn</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>,
								   <argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>replicationModel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>colocatedTableId</name> <operator>=</operator> <call><name>ColocatedTableId</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>DistributedTablePlacementNodeList</name><argument_list>(<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>workerNodeList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no worker nodes are available for placing shards"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Add more worker nodes."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workersForPlacementList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardSplitPointsList</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>colocatedTableId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedShardList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Match the shard ranges of an existing table.
		 */</comment>
		<expr_stmt><expr><name>shardSplitPointsList</name> <operator>=</operator> <call><name>HashSplitPointsForShardList</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Find the node IDs of the shard placements.
		 */</comment>
		<expr_stmt><expr><name>workersForPlacementList</name> <operator>=</operator> <call><name>WorkerNodesForShardList</name><argument_list>(<argument><expr><name>colocatedShardList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Generate a new set of #shardCount shards.
		 */</comment>
		<expr_stmt><expr><name>shardSplitPointsList</name> <operator>=</operator> <call><name>HashSplitPointsForShardCount</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Place shards in a round-robin fashion across all data nodes.
		 */</comment>
		<expr_stmt><expr><name>workersForPlacementList</name> <operator>=</operator> <call><name>RoundRobinWorkerNodeList</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Make sure that existing reference tables have been replicated to all the nodes
	 * such that we can create foreign keys and joins work immediately after creation.
	 * We do this after applying all essential checks to error out early in case of
	 * user error.
	 *
	 * Use force_logical since this function is meant to not block writes.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureReferenceTablesExistOnAllNodesExtended</name><argument_list>(<argument><expr><name>TRANSFER_MODE_FORCE_LOGICAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * At this point, the table is a Citus local table, which means it does
	 * not have a partition column in the metadata. However, we cannot update
	 * the metadata here because that would prevent us from creating a replication
	 * slot to copy ongoing changes. Instead, we pass a hash that maps relation
	 * IDs to partition column vars.
	 */</comment>
	<decl_stmt><decl><type><name>DistributionColumnMap</name> <modifier>*</modifier></type><name>distributionColumnOverrides</name> <init>= <expr><call><name>CreateDistributionColumnMap</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AddDistributionColumnForRelation</name><argument_list>(<argument><expr><name>distributionColumnOverrides</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>,
									 <argument><expr><name>distributionColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * there is no colocation entries yet for local table, so we should
	 * check if table has any partition and add them to same colocation
	 * group
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceColocatedShardIntervalList</name> <init>= <expr><call><name>ListShardsUnderParentRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SplitMode</name></type> <name>splitMode</name> <init>= <expr><name>NON_BLOCKING_SPLIT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SplitOperation</name></type> <name>splitOperation</name> <init>= <expr><name>CREATE_DISTRIBUTED_TABLE</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SplitShard</name><argument_list>(
		<argument><expr><name>splitMode</name></expr></argument>,
		<argument><expr><name>splitOperation</name></expr></argument>,
		<argument><expr><name><name>shardToSplit</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
		<argument><expr><name>shardSplitPointsList</name></expr></argument>,
		<argument><expr><name>workersForPlacementList</name></expr></argument>,
		<argument><expr><name>distributionColumnOverrides</name></expr></argument>,
		<argument><expr><name>sourceColocatedShardIntervalList</name></expr></argument>,
		<argument><expr><name>colocationId</name></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureForeignKeysForDistributedTableConcurrently ensures that referenced and referencing foreign
 * keys for the given table are supported.
 *
 * We allow distributed -&gt; reference
 *          distributed -&gt; citus local
 *
 * We disallow reference   -&gt; distributed
 *             citus local -&gt; distributed
 *             regular     -&gt; distributed
 *
 * Normally regular		-&gt; distributed is allowed but it is not allowed when we create the
 * distributed table concurrently because we rely on conversion of regular table to citus local table,
 * which errors with an unfriendly message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureForeignKeysForDistributedTableConcurrently</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * disallow citus local -&gt; distributed fkeys.
	 * disallow reference   -&gt; distributed fkeys.
	 * disallow regular     -&gt; distributed fkeys.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureNoFKeyFromTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>INCLUDE_CITUS_LOCAL_TABLES</name> <operator>|</operator>
							  <name>INCLUDE_REFERENCE_TABLES</name> <operator>|</operator> <name>INCLUDE_LOCAL_TABLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * disallow distributed -&gt; regular fkeys.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureNoFKeyToTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>INCLUDE_LOCAL_TABLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureColocateWithTableIsValid ensures given relation can be colocated with the table of given name.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureColocateWithTableIsValid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>,
							   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><call><name>DecideReplicationModel</name><argument_list>(<argument><expr><name>distributionMethod</name></expr></argument>,
												   <argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * we fail transaction before local table conversion if the table could not be colocated with
	 * given table. We should make those checks after local table conversion by acquiring locks to
	 * the relation because the distribution column can be modified in that period.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnType</name> <init>= <expr><call><name>ColumnTypeIdForRelationColumnName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																   <argument><expr><name>distributionColumnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>colocateWithTableNameText</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>colocateWithTableId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>colocateWithTableNameText</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>EnsureTableCanBeColocatedWith</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>replicationModel</name></expr></argument>,
								  <argument><expr><name>distributionColumnType</name></expr></argument>, <argument><expr><name>colocateWithTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AcquireCreateDistributedTableConcurrentlyLock does not allow concurrent create_distributed_table_concurrently
 * operations.
 */</comment>
<function><type><name>void</name></type>
<name>AcquireCreateDistributedTableConcurrentlyLock</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>sessionLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dontWait</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_LOCKTAG_CITUS_OPERATION</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>CITUS_CREATE_DISTRIBUTED_TABLE_CONCURRENTLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>LockAcquireResult</name></type> <name>lockAcquired</name> <init>= <expr><call><name>LockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>sessionLock</name></expr></argument>,
												 <argument><expr><name>dontWait</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lockAcquired</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"another create_distributed_table_concurrently "</literal>
							   <literal type="string">"operation is in progress"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Make sure that the concurrent operation has "</literal>
								<literal type="string">"finished and re-run the command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SendAddLocalTableToMetadataCommandOutsideTransaction executes metadata add local
 * table command locally to avoid deadlock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendAddLocalTableToMetadataCommandOutsideTransaction</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * we need to allow nested distributed execution, because we start a new distributed
	 * execution inside the pushed-down UDF citus_add_local_table_to_metadata. Normally
	 * citus does not allow that because it cannot guarantee correctness.
	 */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>allowNestedDistributionCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>allowNestedDistributionCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SET LOCAL citus.allow_nested_distributed_execution to ON"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>addLocalTableToMetadataCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>addLocalTableToMetadataCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT pg_catalog.citus_add_local_table_to_metadata(%s)"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><name><name>allowNestedDistributionCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								<argument><expr><name><name>addLocalTableToMetadataCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>username</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SendCommandListToWorkerOutsideTransaction</name><argument_list>(<argument><expr><name>LocalHostName</name></expr></argument>, <argument><expr><name>PostPortNumber</name></expr></argument>, <argument><expr><name>username</name></expr></argument>,
											  <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WarnIfTableHaveNoReplicaIdentity notices user if the given table or its partitions (if any)
 * do not have a replica identity which is required for logical replication to replicate
 * UPDATE and DELETE commands during create_distributed_table_concurrently.
 */</comment>
<function><type><name>void</name></type>
<name>WarnIfTableHaveNoReplicaIdentity</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>foundRelationWithNoReplicaIdentity</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check for source relation's partitions if any. We do not need to check for the source relation
	 * because we can replicate partitioned table even if it does not have replica identity.
	 * Source table will have no data if it has partitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>partitionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>partitionCell</argument>, <argument>partitionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>partitionTableId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>partitionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationCanPublishAllModifications</name><argument_list>(<argument><expr><name>partitionTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foundRelationWithNoReplicaIdentity</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<comment type="block">/* check for source relation if it is not partitioned */</comment>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationCanPublishAllModifications</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>foundRelationWithNoReplicaIdentity</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>foundRelationWithNoReplicaIdentity</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation %s does not have a REPLICA "</literal>
								<literal type="string">"IDENTITY or PRIMARY KEY"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"UPDATE and DELETE commands on the relation will "</literal>
								   <literal type="string">"error out during create_distributed_table_concurrently unless "</literal>
								   <literal type="string">"there is a REPLICA IDENTITY or PRIMARY KEY. "</literal>
								   <literal type="string">"INSERT commands will still work."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * HashSplitPointsForShardList returns a list of split points which match
 * the shard ranges of the given list of shards;
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>HashSplitPointsForShardList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>splitPointList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMaxValue</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>maxValue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>splitPointList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>splitPointList</name></expr></argument>, <argument><expr><name>shardMaxValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Split point lists only include the upper boundaries.
	 */</comment>
	<expr_stmt><expr><name>splitPointList</name> <operator>=</operator> <call><name>list_delete_last</name><argument_list>(<argument><expr><name>splitPointList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>splitPointList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HashSplitPointsForShardCount returns a list of split points for a given
 * shard count with roughly equal hash ranges.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>HashSplitPointsForShardCount</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>splitPointList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* calculate the split of the hash space */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>hashTokenIncrement</name> <init>= <expr><name>HASH_TOKEN_COUNT</name> <operator>/</operator> <name>shardCount</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Split points lists only include the upper boundaries, so we only
	 * go up to shardCount - 1 and do not have to apply the correction
	 * for the last shardmaxvalue.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int64</name></type> <name>shardIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>shardIndex</name> <operator>&lt;</operator> <name>shardCount</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>shardIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* initialize the hash token space for this shard */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMinValue</name> <init>= <expr><name>PG_INT32_MIN</name> <operator>+</operator> <operator>(</operator><name>shardIndex</name> <operator>*</operator> <name>hashTokenIncrement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>shardMaxValue</name> <init>= <expr><name>shardMinValue</name> <operator>+</operator> <operator>(</operator><name>hashTokenIncrement</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>splitPointList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>splitPointList</name></expr></argument>, <argument><expr><name>shardMaxValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>splitPointList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WorkerNodesForShardList returns a list of node ids reflecting the locations of
 * the given list of shards.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>WorkerNodesForShardList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><call><name>ActiveShardPlacementWorkerNode</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>nodeIdList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>nodeIdList</name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>nodeIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RoundRobinWorkerNodeList round robins over the workers in the worker node list
 * and adds node ids to a list of length listLength.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>RoundRobinWorkerNodeList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>listLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>workerNodeList</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>listLength</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>nodeIdx</name> <init>= <expr><name>idx</name> <operator>%</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><operator>(</operator><name>WorkerNode</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>, <argument><expr><name>nodeIdx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>nodeIdList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>nodeIdList</name></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>nodeIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * create_reference_table creates a distributed table with the given relationId. The
 * created table has one shard and replication factor is set to the active worker
 * count. In fact, the above is the definition of a reference table in Citus.
 */</comment>
<function><type><name>Datum</name></type>
<name>create_reference_table</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureCitusTableCanBeCreated</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* enable create_reference_table on an empty node */</comment>
	<expr_stmt><expr><call><name>InsertCoordinatorIfClusterEmpty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Lock target relation with an exclusive lock - there's no way to make
	 * sense of this table until we've committed, and we don't want multiple
	 * backends manipulating this relation.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create reference table: "</literal>
							   <literal type="string">"relation does not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>= <expr><call><name>ActivePrimaryNodeList</name><argument_list>(<argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>workerCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>workerNodeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if there are no workers, error out */</comment>
	<if_stmt><if>if <condition>(<expr><name>workerCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create reference table \"%s\""</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"There are no active worker nodes."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CreateDistributedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionColumnName</name></expr></argument>, <argument><expr><name>DISTRIBUTE_BY_NONE</name></expr></argument>,
						   <argument><expr><name>ShardCount</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureCitusTableCanBeCreated checks if
 * - we are on the coordinator
 * - the current user is the owner of the table
 * - relation kind is supported
 * - relation is not a shard
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureCitusTableCanBeCreated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureRelationExists</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorIfTemporaryTable</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorIfForeignTable</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should do this check here since the codes in the following lines rely
	 * on this relation to have a supported relation kind. More extensive checks
	 * will be performed in CreateDistributedTable.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureRelationKindSupported</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When coordinator is added to the metadata, or on the workers,
	 * some of the relations of the coordinator node may/will be shards.
	 * We disallow creating distributed tables from shard relations, by
	 * erroring out here.
	 */</comment>
	<expr_stmt><expr><call><name>ErrorIfRelationIsAKnownShard</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureRelationExists does a basic check on whether the OID belongs to
 * an existing relation.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureRelationExists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationExists</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation with OID %d does not exist"</literal></expr></argument>,
							   <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateDistributedTable creates distributed table in the given configuration.
 * This functions contains all necessary logic to create distributed tables. It
 * performs necessary checks to ensure distributing the table is safe. If it is
 * safe to distribute the table, this function creates distributed table metadata,
 * creates shards and copies local data to shards. This function also handles
 * partitioned tables by distributing its partitions as well.
 */</comment>
<function><type><name>void</name></type>
<name>CreateDistributedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name></decl></parameter>,
					   <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>shardCountIsStrict</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * EnsureTableNotDistributed errors out when relation is a citus table but
	 * we don't want to ask user to first undistribute their citus local tables
	 * when creating reference or distributed tables from them.
	 * For this reason, here we undistribute citus local tables beforehand.
	 * But since UndistributeTable does not support undistributing relations
	 * involved in foreign key relationships, we first drop foreign keys that
	 * given relation is involved, then we undistribute the relation and finally
	 * we re-create dropped foreign keys at the end of this function.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>originalForeignKeyRecreationCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* store foreign key creation commands that relation is involved */</comment>
		<expr_stmt><expr><name>originalForeignKeyRecreationCommands</name> <operator>=</operator>
			<call><name>GetFKeyCreationCommandsRelationInvolvedWithTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																 <argument><expr><name>INCLUDE_ALL_TABLE_TYPES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>DropFKeysAndUndistributeTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/*
	 * To support foreign keys between reference tables and local tables,
	 * we drop &amp; re-define foreign keys at the end of this function so
	 * that ALTER TABLE hook does the necessary job, which means converting
	 * local tables to citus local tables to properly support such foreign
	 * keys.
	 *
	 * This function does not expect to create Citus local table, so we blindly
	 * create reference table when the method is DISTRIBUTE_BY_NONE.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name> <operator>&amp;&amp;</operator>
			 <call><name>ShouldEnableLocalReferenceForeignKeys</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>HasForeignKeyWithLocalTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Store foreign key creation commands for foreign key relationships
		 * that relation has with postgres tables.
		 */</comment>
		<expr_stmt><expr><name>originalForeignKeyRecreationCommands</name> <operator>=</operator>
			<call><name>GetFKeyCreationCommandsRelationInvolvedWithTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																 <argument><expr><name>INCLUDE_LOCAL_TABLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Soon we will convert local tables to citus local tables. As
		 * CreateCitusLocalTable needs to use local execution, now we
		 * switch to local execution beforehand so that reference table
		 * creation doesn't use remote execution and we don't error out
		 * in CreateCitusLocalTable.
		 */</comment>
		<expr_stmt><expr><call><name>SetLocalExecutionStatus</name><argument_list>(<argument><expr><name>LOCAL_EXECUTION_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DropFKeysRelationInvolvedWithTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>INCLUDE_LOCAL_TABLES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EnsureTableNotDistributed</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PropagatePrerequisiteObjectsForDistributedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><call><name>DecideReplicationModel</name><argument_list>(<argument><expr><name>distributionMethod</name></expr></argument>,
												   <argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name> <init>= <expr><call><name>BuildDistributionKeyFromColumnName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
																 <argument><expr><name>distributionColumnName</name></expr></argument>,
																 <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * ColocationIdForNewTable assumes caller acquires lock on relationId. In our case,
	 * our caller already acquired lock on relationId.
	 */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><call><name>ColocationIdForNewTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionColumn</name></expr></argument>,
												  <argument><expr><name>distributionMethod</name></expr></argument>, <argument><expr><name>replicationModel</name></expr></argument>,
												  <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>shardCountIsStrict</name></expr></argument>,
												  <argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureRelationCanBeDistributed</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionColumn</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>,
								   <argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>replicationModel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure that existing reference tables have been replicated to all the nodes
	 * such that we can create foreign keys and joins work immediately after creation.
	 *
	 * This will take a lock on the nodes to make sure no nodes are added after we have
	 * verified and ensured the reference tables are copied everywhere.
	 * Although copying reference tables here for anything but creating a new colocation
	 * group, it requires significant refactoring which we don't want to perform now.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureReferenceTablesExistOnAllNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * While adding tables to a colocation group we need to make sure no concurrent
	 * mutations happen on the colocation group with regards to its placements. It is
	 * important that we have already copied any reference tables before acquiring this
	 * lock as these are competing operations.
	 */</comment>
	<expr_stmt><expr><call><name>LockColocationId</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we need to calculate these variables before creating distributed metadata */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>localTableEmpty</name> <init>= <expr><call><name>TableEmpty</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><call><name>ColocatedTableId</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* setting to false since this flag is only valid for citus local tables */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>autoConverted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* create an entry for distributed table in pg_dist_partition */</comment>
	<expr_stmt><expr><call><name>InsertIntoPgDistPartition</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>, <argument><expr><name>distributionColumn</name></expr></argument>,
							  <argument><expr><name>colocationId</name></expr></argument>, <argument><expr><name>replicationModel</name></expr></argument>, <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* foreign tables do not support TRUNCATE trigger */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RegularTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CreateTruncateTrigger</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* create shards for hash distributed and reference tables */</comment>
	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CreateHashDistributedTableShards</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>colocatedTableId</name></expr></argument>,
										 <argument><expr><name>localTableEmpty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This function does not expect to create Citus local table, so we blindly
		 * create reference table when the method is DISTRIBUTE_BY_NONE.
		 */</comment>
		<expr_stmt><expr><call><name>CreateReferenceTableShard</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SyncCitusTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We've a custom way of foreign key graph invalidation,
	 * see InvalidateForeignKeyGraph().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TableReferenced</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TableReferencing</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvalidateForeignKeyGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* if this table is partitioned table, distribute its partitions too */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>partitionRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach_oid</name><argument_list>(<argument>partitionRelationId</argument>, <argument>partitionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CreateDistributedTable</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>, <argument><expr><name>distributionColumnName</name></expr></argument>,
								   <argument><expr><name>distributionMethod</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								   <argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* copy over data for hash distributed and reference tables */</comment>
	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>||</operator>
		<name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>RegularTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CopyLocalDataIntoShards</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now recreate foreign keys that we dropped beforehand. As modifications are not
	 * allowed on the relations that are involved in the foreign key relationship,
	 * we can skip the validation of the foreign keys.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>skip_validation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecuteForeignKeyCreateCommandList</name><argument_list>(<argument><expr><name>originalForeignKeyRecreationCommands</name></expr></argument>,
									   <argument><expr><name>skip_validation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PropagatePrerequisiteObjectsForDistributedTable ensures we can create shards
 * on all nodes by ensuring all dependent objects exist on all node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PropagatePrerequisiteObjectsForDistributedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Ensure that the sequences used in column defaults of the table
	 * have proper types
	 */</comment>
	<expr_stmt><expr><call><name>EnsureRelationHasCompatibleSequenceTypes</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * distributed tables might have dependencies on different objects, since we create
	 * shards for a distributed table via multiple sessions these objects will be created
	 * via their own connection and committed immediately so they become visible to all
	 * sessions creating shards.
	 */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>tableAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>tableAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>tableAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureSequenceTypeSupported ensures that the type of the column that uses
 * a sequence on its DEFAULT is consistent with previous uses (if any) of the
 * sequence in distributed tables.
 * If any other distributed table uses the input sequence, it checks whether
 * the types of the columns using the sequence match. If they don't, it errors out.
 * Otherwise, the condition is ensured.
 * Since the owner of the sequence may not distributed yet, it should be added
 * explicitly.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureSequenceTypeSupported</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>seqOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>attributeTypeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ownerRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>citusTableIdList</name> <init>= <expr><call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>ANY_CITUS_TABLE_TYPE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>citusTableIdList</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>citusTableIdList</name></expr></argument>, <argument><expr><name>ownerRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>citusTableId</argument>, <argument>citusTableIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>seqInfoList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>GetDependentSequencesWithRelation</name><argument_list>(<argument><expr><name>citusTableId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqInfoList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>SequenceInfo</name> <modifier>*</modifier></type><name>seqInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>seqInfo</argument>, <argument>seqInfoList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>currentAttnum</name> <init>= <expr><name><name>seqInfo</name><operator>-&gt;</operator><name>attributeNumber</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>currentSeqOid</name> <init>= <expr><name><name>seqInfo</name><operator>-&gt;</operator><name>sequenceOid</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>seqInfo</name><operator>-&gt;</operator><name>isNextValDefault</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If a sequence is not on the nextval, we don't need any check.
				 * This is a dependent sequence via ALTER SEQUENCE .. OWNED BY col
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If another distributed table is using the same sequence
			 * in one of its column defaults, make sure the types of the
			 * columns match
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>currentSeqOid</name> <operator>==</operator> <name>seqOid</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>currentAttributeTypId</name> <init>= <expr><call><name>GetAttributeTypeOid</name><argument_list>(<argument><expr><name>citusTableId</name></expr></argument>,
																<argument><expr><name>currentAttnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>attributeTypeId</name> <operator>!=</operator> <name>currentAttributeTypId</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(
						<argument><expr><name>seqOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>citusTableName</name> <init>=
						<expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>citusTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
										<argument><expr><literal type="string">"The sequence %s is already used for a different"</literal>
										<literal type="string">" type in column %d of the table %s"</literal></expr></argument>,
										<argument><expr><name>sequenceName</name></expr></argument>, <argument><expr><name>currentAttnum</name></expr></argument>,
										<argument><expr><name>citusTableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * AlterSequenceType alters the given sequence's type to the given type.
 */</comment>
<function><type><name>void</name></type>
<name>AlterSequenceType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>seqOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_sequence</name></type> <name>sequenceData</name> <init>= <expr><call><name>pg_get_sequencedef</name><argument_list>(<argument><expr><name>seqOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>currentSequenceTypeOid</name> <init>= <expr><name><name>sequenceData</name><operator>-&gt;</operator><name>seqtypid</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>currentSequenceTypeOid</name> <operator>!=</operator> <name>typeOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>alterSequenceStatement</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqNamespace</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>seqOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seqName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>seqOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>alterSequenceStatement</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>seqNamespace</name></expr></argument>, <argument><expr><name>seqName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>asTypeNode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SetDefElemArg</name><argument_list>(<argument><expr><name>alterSequenceStatement</name></expr></argument>, <argument><expr><literal type="string">"as"</literal></expr></argument>, <argument><expr><name>asTypeNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AlterSequence</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>alterSequenceStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureRelationHasCompatibleSequenceTypes ensures that sequences used for columns
 * of the table have compatible types both with the column type on that table and
 * all other distributed tables' columns they have used for
 */</comment>
<function><type><name>void</name></type>
<name>EnsureRelationHasCompatibleSequenceTypes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>seqInfoList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>GetDependentSequencesWithRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqInfoList</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureDistributedSequencesHaveOneType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>seqInfoList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureDistributedSequencesHaveOneType first ensures that the type of the column
 * in which the sequence is used as default is supported for each sequence in input
 * dependentSequenceList, and then alters the sequence type if not the same with the column type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureDistributedSequencesHaveOneType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>seqInfoList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SequenceInfo</name> <modifier>*</modifier></type><name>seqInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>seqInfo</argument>, <argument>seqInfoList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>seqInfo</name><operator>-&gt;</operator><name>isNextValDefault</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If a sequence is not on the nextval, we don't need any check.
			 * This is a dependent sequence via ALTER SEQUENCE .. OWNED BY col
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We should make sure that the type of the column that uses
		 * that sequence is supported
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceOid</name> <init>= <expr><name><name>seqInfo</name><operator>-&gt;</operator><name>sequenceOid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><name><name>seqInfo</name><operator>-&gt;</operator><name>attributeNumber</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>attributeTypeId</name> <init>= <expr><call><name>GetAttributeTypeOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>EnsureSequenceTypeSupported</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>, <argument><expr><name>attributeTypeId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Alter the sequence's data type in the coordinator if needed.
		 *
		 * First, we should only change the sequence type if the column
		 * is a supported sequence type. For example, if a sequence is used
		 * in an expression which then becomes a text, we should not try to
		 * alter the sequence type to text. Postgres only supports int2, int4
		 * and int8 as the sequence type.
		 *
		 * A sequence's type is bigint by default and it doesn't change even if
		 * it's used in an int column. We should change the type if needed,
		 * and not allow future ALTER SEQUENCE ... TYPE ... commands for
		 * sequences used as defaults in distributed tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>attributeTypeId</name> <operator>==</operator> <name>INT2OID</name> <operator>||</operator>
			<name>attributeTypeId</name> <operator>==</operator> <name>INT4OID</name> <operator>||</operator>
			<name>attributeTypeId</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AlterSequenceType</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>, <argument><expr><name>attributeTypeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetFKeyCreationCommandsRelationInvolvedWithTableType returns a list of DDL
 * commands to recreate the foreign keys that relation with relationId is involved
 * with given table type.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetFKeyCreationCommandsRelationInvolvedWithTableType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tableTypeFlag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>referencingFKeysFlag</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator>
							   <name>tableTypeFlag</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencingFKeyCreationCommands</name> <init>=
		<expr><call><name>GetForeignConstraintCommandsInternal</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>referencingFKeysFlag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* already captured self referencing foreign keys, so use EXCLUDE_SELF_REFERENCES */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>referencedFKeysFlag</name> <init>= <expr><name>INCLUDE_REFERENCED_CONSTRAINTS</name> <operator>|</operator>
							  <name>EXCLUDE_SELF_REFERENCES</name> <operator>|</operator>
							  <name>tableTypeFlag</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencedFKeyCreationCommands</name> <init>=
		<expr><call><name>GetForeignConstraintCommandsInternal</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>referencedFKeysFlag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>referencingFKeyCreationCommands</name></expr></argument>, <argument><expr><name>referencedFKeyCreationCommands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropFKeysAndUndistributeTable drops all foreign keys that relation with
 * relationId is involved then undistributes it.
 * Note that as UndistributeTable changes relationId of relation, this
 * function also returns new relationId of relation.
 * Also note that callers are responsible for storing &amp; recreating foreign
 * keys to be dropped if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>DropFKeysAndUndistributeTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>DropFKeysRelationInvolvedWithTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>INCLUDE_ALL_TABLE_TYPES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* store them before calling UndistributeTable as it changes relationId */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* suppress notices messages not to be too verbose */</comment>
	<decl_stmt><decl><type><name>TableConversionParameters</name></type> <name>params</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>relationId</name> <operator>=</operator> <name>relationId</name></expr>,
		<expr><operator>.</operator><name>cascadeViaForeignKeys</name> <operator>=</operator> <name>false</name></expr>,
		<expr><operator>.</operator><name>suppressNoticeMessages</name> <operator>=</operator> <name>true</name></expr>
	}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UndistributeTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>newRelationId</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't expect this to happen but to be on the safe side let's error
	 * out here.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureRelationExists</name><argument_list>(<argument><expr><name>newRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newRelationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropFKeysRelationInvolvedWithTableType drops foreign keys that relation
 * with relationId is involved with given table type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropFKeysRelationInvolvedWithTableType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tableTypeFlag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>referencingFKeysFlag</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator>
							   <name>tableTypeFlag</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>DropRelationForeignKeys</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>referencingFKeysFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* already captured self referencing foreign keys, so use EXCLUDE_SELF_REFERENCES */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>referencedFKeysFlag</name> <init>= <expr><name>INCLUDE_REFERENCED_CONSTRAINTS</name> <operator>|</operator>
							  <name>EXCLUDE_SELF_REFERENCES</name> <operator>|</operator>
							  <name>tableTypeFlag</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>DropRelationForeignKeys</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>referencedFKeysFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DecideReplicationModel function decides which replication model should be
 * used depending on given distribution configuration.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name></type>
<name>DecideReplicationModel</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>REPLICATION_MODEL_2PC</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>IsColocateWithNone</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>colocateWithTableNameText</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedRelationId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>colocateWithTableNameText</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>targetTableEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(
			<argument><expr><name>colocatedRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><name><name>targetTableEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr></init></decl>;</decl_stmt>

		<return>return <expr><name>replicationModel</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>DistributedTableReplicationIsEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>REPLICATION_MODEL_STREAMING</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>REPLICATION_MODEL_COORDINATOR</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* we should not reach to this point */</comment>
	<return>return <expr><name>REPLICATION_MODEL_INVALID</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateHashDistributedTableShards creates shards of given hash distributed table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateHashDistributedTableShards</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>colocatedTableId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localTableEmpty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>useExclusiveConnection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Decide whether to use exclusive connections per placement or not. Note that
	 * if the local table is not empty, we cannot use sequential mode since the COPY
	 * operation that'd load the data into shards currently requires exclusive
	 * connections.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RegularTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>useExclusiveConnection</name> <operator>=</operator> <call><name>CanUseExclusiveConnections</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
															<argument><expr><name>localTableEmpty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>colocatedTableId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We currently allow concurrent distribution of colocated tables (which
		 * we probably should not be allowing because of foreign keys /
		 * partitioning etc).
		 *
		 * We also prevent concurrent shard moves / copy / splits) while creating
		 * a colocated table.
		 */</comment>
		<expr_stmt><expr><call><name>AcquirePlacementColocationLock</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>,
									   <argument><expr><literal type="string">"colocate distributed table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CreateColocatedShards</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>colocatedTableId</name></expr></argument>, <argument><expr><name>useExclusiveConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * This path is only reached by create_distributed_table for the distributed
		 * tables which will not be part of an existing colocation group. Therefore,
		 * we can directly use ShardReplicationFactor global variable here.
		 */</comment>
		<expr_stmt><expr><call><name>CreateShardsWithRoundRobinPolicy</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>ShardReplicationFactor</name></expr></argument>,
										 <argument><expr><name>useExclusiveConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColocationIdForNewTable returns a colocation id for hash-distributed table
 * according to given configuration. If there is no such configuration, it
 * creates one and returns colocation id of newly the created colocation group.
 * For append and range distributed tables, this function errors out if
 * colocateWithTableName parameter is not NULL, otherwise directly returns
 * INVALID_COLOCATION_ID.
 *
 * This function assumes its caller take necessary lock on relationId to
 * prevent possible changes on it.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>ColocationIdForNewTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name></decl></parameter>,
						<parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>shardCount</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shardCountIsStrict</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><name>INVALID_COLOCATION_ID</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_APPEND</name> <operator>||</operator>
		<name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_RANGE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute relation"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Currently, colocate_with option is only supported "</literal>
									  <literal type="string">"for hash distributed tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>colocationId</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>CreateReferenceTableColocationId</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Get an exclusive lock on the colocation system catalog. Therefore, we
		 * can be sure that there will no modifications on the colocation table
		 * until this transaction is committed.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnType</name> <init>= <expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>distributionColumnCollation</name> <init>= <expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>distributionColumnType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* get an advisory lock to serialize concurrent default group creations */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsColocateWithDefault</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AcquireColocationDefaultLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <call><name>FindColocateWithColocationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
													<argument><expr><name>replicationModel</name></expr></argument>,
													<argument><expr><name>distributionColumnType</name></expr></argument>,
													<argument><expr><name>distributionColumnCollation</name></expr></argument>,
													<argument><expr><name>shardCount</name></expr></argument>,
													<argument><expr><name>shardCountIsStrict</name></expr></argument>,
													<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsColocateWithDefault</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>colocationId</name> <operator>!=</operator>
															 <name>INVALID_COLOCATION_ID</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we can release advisory lock if there is already a default entry for given params;
			 * else, we should keep it to prevent different default coloc entry creation by
			 * concurrent operations.
			 */</comment>
			<expr_stmt><expr><call><name>ReleaseColocationDefaultLock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsColocateWithDefault</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Generate a new colocation ID and insert a pg_dist_colocation
				 * record.
				 */</comment>
				<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <call><name>CreateColocationGroup</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>ShardReplicationFactor</name></expr></argument>,
													 <argument><expr><name>distributionColumnType</name></expr></argument>,
													 <argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsColocateWithNone</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Generate a new colocation ID and insert a pg_dist_colocation
				 * record.
				 */</comment>
				<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <call><name>CreateColocationGroup</name><argument_list>(<argument><expr><name>shardCount</name></expr></argument>, <argument><expr><name>ShardReplicationFactor</name></expr></argument>,
													 <argument><expr><name>distributionColumnType</name></expr></argument>,
													 <argument><expr><name>distributionColumnCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>colocationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureRelationCanBeDistributed checks whether Citus can safely distribute given
 * relation with the given configuration. We perform almost all safety checks for
 * distributing table here. If there is an unsatisfied requirement, we error out
 * and do not distribute the table.
 *
 * This function assumes, callers have already acquired necessary locks to ensure
 * there will not be any change in the given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureRelationCanBeDistributed</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name></decl></parameter>,
							   <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>,
							   <parameter><decl><type><name>char</name></type> <name>replicationModel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureLocalTableEmptyIfNecessary</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* user really wants triggers? */</comment>
	<if_stmt><if>if <condition>(<expr><name>EnableUnsafeTriggers</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ErrorIfRelationHasUnsupportedTrigger</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureRelationHasNoTriggers</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* we assume callers took necessary locks */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>relationDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfTableIsACatalogTable</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* verify target relation does not use identity columns */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationUsesIdentityColumns</name><argument_list>(<argument><expr><name>relationDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute relation: %s"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distributed relations must not use GENERATED "</literal>
								  <literal type="string">"... AS IDENTITY."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* verify target relation is not distributed by a generated columns */</comment>
	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>!=</operator> <name>DISTRIBUTE_BY_NONE</name> <operator>&amp;&amp;</operator>
		<call><name>DistributionColumnUsesGeneratedStoredColumn</name><argument_list>(<argument><expr><name>relationDesc</name></expr></argument>, <argument><expr><name>distributionColumn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute relation: %s"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distribution column must not use GENERATED ALWAYS "</literal>
								  <literal type="string">"AS (...) STORED."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name><operator>)</operator></expr></cpp:if>

	<comment type="block">/* verify target relation is not distributed by a column of type numeric with negative scale */</comment>
	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>!=</operator> <name>DISTRIBUTE_BY_NONE</name> <operator>&amp;&amp;</operator>
		<call><name>DistributionColumnUsesNumericColumnNegativeScale</name><argument_list>(<argument><expr><name>relationDesc</name></expr></argument>,
														 <argument><expr><name>distributionColumn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute relation: %s"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distribution column must not use numeric type "</literal>
								  <literal type="string">"with negative scale"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* check for support function needed by specified partition method */</comment>
	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>hashSupportFunction</name> <init>= <expr><call><name>SupportFunctionForColumn</name><argument_list>(<argument><expr><name>distributionColumn</name></expr></argument>,
														   <argument><expr><name>HASH_AM_OID</name></expr></argument>,
														   <argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>hashSupportFunction</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify a hash function for type %s"</literal></expr></argument>,
								   <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdatatype</name><argument_list>(<argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Partition column types must have a hash function "</literal>
									  <literal type="string">"defined to use hash partitioning."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>varcollid</name></name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>get_collation_isdeterministic</name><argument_list>(<argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>varcollid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Hash distributed partition columns may not use "</literal>
								   <literal type="string">"a non deterministic collation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_RANGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>btreeSupportFunction</name> <init>= <expr><call><name>SupportFunctionForColumn</name><argument_list>(<argument><expr><name>distributionColumn</name></expr></argument>,
															<argument><expr><name>BTREE_AM_OID</name></expr></argument>, <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>btreeSupportFunction</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify a comparison function for type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdatatype</name><argument_list>(<argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Partition column types must have a comparison function "</literal>
							   <literal type="string">"defined to use range partitioning."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PartitionTableNoLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>parentRelationId</name> <operator>=</operator> <call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* partitions cannot be distributed if their parent is not distributed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionTableNoLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute relation \"%s\" which is partition of "</literal>
							   <literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Citus does not support distributing partitions "</literal>
								  <literal type="string">"if their parent is not distributed table."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Distribute the partitioned table \"%s\" instead."</literal></expr></argument>,
								<argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * These checks are mostly for partitioned tables not partitions because we prevent
	 * distributing partitions directly in the above check. However, partitions can still
	 * reach this point because, we call CreateDistributedTable for partitions if their
	 * parent table is distributed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTableNoLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* distributing partitioned tables in only supported for hash-distribution */</comment>
		<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>!=</operator> <name>DISTRIBUTE_BY_HASH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributing partitioned tables in only supported "</literal>
								   <literal type="string">"for hash-distributed tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we don't support distributing tables with multi-level partitioning */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PartitionTableNoLock</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributing multi-level partitioned tables "</literal>
								   <literal type="string">"is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Relation \"%s\" is partitioned table itself and "</literal>
									  <literal type="string">"it is also partition of relation \"%s\"."</literal></expr></argument>,
									  <argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ErrorIfUnsupportedConstraint</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>, <argument><expr><name>replicationModel</name></expr></argument>,
								 <argument><expr><name>distributionColumn</name></expr></argument>, <argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><call><name>ErrorIfUnsupportedPolicy</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfTemporaryTable errors out if the given table is a temporary table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfTemporaryTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>get_rel_persistence</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute a temporary table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfTableIsACatalogTable is a helper function to error out for citus
 * table creation from a catalog table.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfTableIsACatalogTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create a citus table from a catalog table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureLocalTableEmptyIfNecessary errors out if the function should be empty
 * according to ShouldLocalTableBeEmpty but it is not.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureLocalTableEmptyIfNecessary</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ShouldLocalTableBeEmpty</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureLocalTableEmpty</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldLocalTableBeEmpty returns true if the local table should be empty
 * before creating a citus table.
 * In some cases, it is possible and safe to send local data to shards while
 * distributing the table. In those cases, we can distribute non-empty local
 * tables. This function checks the distributionMethod and relation kind to
 * see whether we need to be ensure emptiness of local table.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldLocalTableBeEmpty</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>shouldLocalTableBeEmpty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>!=</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>&amp;&amp;</operator>
		<name>distributionMethod</name> <operator>!=</operator> <name>DISTRIBUTE_BY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We only support hash distributed tables and reference tables
		 * for initial data loading
		 */</comment>
		<expr_stmt><expr><name>shouldLocalTableBeEmpty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>RegularTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We only support tables and partitioned tables for initial
		 * data loading
		 */</comment>
		<expr_stmt><expr><name>shouldLocalTableBeEmpty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>shouldLocalTableBeEmpty</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureLocalTableEmpty errors out if the local table is not empty.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureLocalTableEmpty</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>localTableEmpty</name> <init>= <expr><call><name>TableEmpty</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>localTableEmpty</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute relation \"%s\""</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Relation \"%s\" contains data."</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Empty your table before distributing it."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureDistributableTable ensures the given table type is appropriate to
 * be distributed. Table type should be regular or citus local table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureDistributableTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isLocalTable</name> <init>= <expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isRegularTable</name> <init>= <expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ANY_CITUS_TABLE_TYPE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isLocalTable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isRegularTable</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" is already distributed"</literal></expr></argument>,
							   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureTableNotDistributed errors out if the table is distributed.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureTableNotDistributed</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isCitusTable</name> <init>= <expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isCitusTable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" is already distributed"</literal></expr></argument>,
							   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureRelationHasNoTriggers errors out if the given table has triggers on
 * it. See also GetExplicitTriggerIdList function's comment for the triggers this
 * function errors out.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureRelationHasNoTriggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>explicitTriggerIds</name> <init>= <expr><call><name>GetExplicitTriggerIdList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>explicitTriggerIds</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relationName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute relation \"%s\" because it "</literal>
							   <literal type="string">"has triggers"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider dropping all the triggers on \"%s\" "</literal>
								<literal type="string">"and retry."</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LookupDistributionMethod maps the oids of citus.distribution_type enum
 * values to pg_dist_partition.partmethod values.
 *
 * The passed in oid has to belong to a value of citus.distribution_type.
 */</comment>
<function><type><name>char</name></type>
<name>LookupDistributionMethod</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>distributionMethodOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>distributionMethod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>enumTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>ENUMOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(
											  <argument><expr><name>distributionMethodOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>enumTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid internal value for enum: %u"</literal></expr></argument>,
							   <argument><expr><name>distributionMethodOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>enumForm</name> <init>= <expr><operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>enumTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enumLabel</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>enumForm</name><operator>-&gt;</operator><name>enumlabel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>enumLabel</name></expr></argument>, <argument><expr><literal type="string">"append"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>distributionMethod</name> <operator>=</operator> <name>DISTRIBUTE_BY_APPEND</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>enumLabel</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>distributionMethod</name> <operator>=</operator> <name>DISTRIBUTE_BY_HASH</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>enumLabel</name></expr></argument>, <argument><expr><literal type="string">"range"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>distributionMethod</name> <operator>=</operator> <name>DISTRIBUTE_BY_RANGE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid label for enum: %s"</literal></expr></argument>, <argument><expr><name>enumLabel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>enumTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>distributionMethod</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	SupportFunctionForColumn locates a support function given a column, an access method,
 *	and and id of a support function. This function returns InvalidOid if there is no
 *	support function for the operator class family of the column, but if the data type
 *	of the column has no default operator class whatsoever, this function errors out.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>SupportFunctionForColumn</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>,
						 <parameter><decl><type><name>int16</name></type> <name>supportFunctionNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>columnOid</name> <init>= <expr><name><name>partitionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorClassId</name> <init>= <expr><call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>columnOid</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* currently only support using the default operator class */</comment>
	<if_stmt><if>if <condition>(<expr><name>operatorClassId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"data type %s has no default operator class for specified"</literal>
							   <literal type="string">" partition method"</literal></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>columnOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdatatype</name><argument_list>(<argument><expr><name>columnOid</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Partition column types must have a default operator"</literal>
								  <literal type="string">" class defined."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorFamilyId</name> <init>= <expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name>operatorClassId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorClassInputType</name> <init>= <expr><call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name>operatorClassId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>supportFunctionOid</name> <init>= <expr><call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name>operatorFamilyId</name></expr></argument>, <argument><expr><name>operatorClassInputType</name></expr></argument>,
											   <argument><expr><name>operatorClassInputType</name></expr></argument>,
											   <argument><expr><name>supportFunctionNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>supportFunctionOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TableEmpty function checks whether given table contains any row and
 * returns false if there is any data.
 */</comment>
<function><type><name>bool</name></type>
<name>TableEmpty</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableQualifiedName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>selectTrueQueryString</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>readOnly</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>spiConnectionResult</name> <init>= <expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>spiConnectionResult</name> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to SPI manager"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>selectTrueQueryString</name></expr></argument>, <argument><expr><name>SELECT_TRUE_QUERY</name></expr></argument>, <argument><expr><name>tableQualifiedName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>spiQueryResult</name> <init>= <expr><call><name>SPI_execute</name><argument_list>(<argument><expr><name><name>selectTrueQueryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>readOnly</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>spiQueryResult</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"execution was not successful \"%s\""</literal></expr></argument>,
							   <argument><expr><name><name>selectTrueQueryString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we expect that SELECT TRUE query will return single value in a single row OR empty set */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SPI_processed</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>SPI_processed</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>localTableEmpty</name> <init>= <expr><operator>!</operator><name>SPI_processed</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>localTableEmpty</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CanUseExclusiveConnections checks if we can open parallel connections
 * while creating shards. We simply error out if we need to execute
 * sequentially but there is data in the table, since we cannot copy the
 * data to shards sequentially.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CanUseExclusiveConnections</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localTableEmpty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasForeignKeyToReferenceTable</name> <init>= <expr><call><name>HasForeignKeyToReferenceTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>shouldRunSequential</name> <init>= <expr><name>MultiShardConnectionType</name> <operator>==</operator> <name>SEQUENTIAL_CONNECTION</name> <operator>||</operator>
							   <name>hasForeignKeyToReferenceTable</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldRunSequential</name> <operator>&amp;&amp;</operator> <call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We decided to use sequential execution. It's either because relation
		 * has a pre-existing foreign key to a reference table or because we
		 * decided to use sequential execution due to a query executed in the
		 * current xact beforehand.
		 * We have specific error messages for either cases.
		 */</comment>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hasForeignKeyToReferenceTable</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there has already been a parallel query executed, the sequential mode
			 * would still use the already opened parallel connections to the workers,
			 * thus contradicting our purpose of using sequential mode.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute relation \"%s\" in this "</literal>
								   <literal type="string">"transaction because it has a foreign key to "</literal>
								   <literal type="string">"a reference table"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"If a hash distributed table has a foreign key "</literal>
									  <literal type="string">"to a reference table, it has to be created "</literal>
									  <literal type="string">"in sequential mode before any parallel commands "</literal>
									  <literal type="string">"have been executed in the same transaction"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
									<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
									<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>MultiShardConnectionType</name> <operator>==</operator> <name>SEQUENTIAL_CONNECTION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute \"%s\" in sequential mode because "</literal>
								   <literal type="string">"a parallel query was executed in this transaction"</literal></expr></argument>,
								   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If you have manually set "</literal>
									<literal type="string">"citus.multi_shard_modify_mode to 'sequential', "</literal>
									<literal type="string">"try with 'parallel' option. "</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>shouldRunSequential</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>localTableEmpty</name> <operator>||</operator> <call><name>IsMultiStatementTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateTruncateTrigger creates a truncate trigger on table identified by relationId
 * and assigns citus_truncate_trigger() as handler.
 */</comment>
<function><type><name>void</name></type>
<name>CreateTruncateTrigger</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>triggerName</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>internal</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>triggerName</name></expr></argument>, <argument><expr><literal type="string">"truncate_trigger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>trigger</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <name><name>triggerName</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><name>CITUS_TRUNCATE_TRIGGER_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_TRUNCATE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CreateTrigger</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
				  <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
				  <argument><expr><name>internal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RegularTable function returns true if given table's relation kind is RELKIND_RELATION
 * or RELKIND_PARTITIONED_TABLE otherwise it returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>RegularTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>relationKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>relationKind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relationKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyLocalDataIntoShards copies data from the local table, which is hidden
 * after converting it to a distributed table, into the shards of the distributed
 * table. For partitioned tables, this functions returns without copying the data
 * because we call this function for both partitioned tables and its partitions.
 * Returning early saves us from copying data to workers twice.
 *
 * This function uses CitusCopyDestReceiver to invoke the distributed COPY logic.
 * We cannot use a regular COPY here since that cannot read from a table. Instead
 * we read from the table and pass each tuple to the CitusCopyDestReceiver which
 * opens a connection and starts a COPY for each shard placement that will have
 * data.
 *
 * We could call the planner and executor here and send the output to the
 * DestReceiver, but we are in a tricky spot here since Citus is already
 * intercepting queries on this table in the planner and executor hooks and we
 * want to read from the local table. To keep it simple, we perform a heap scan
 * directly on the table.
 *
 * Any writes on the table that are started during this operation will be handled
 * as distributed queries once the current transaction commits. SELECTs will
 * continue to read from the local table until the current transaction commits,
 * after which new SELECTs will be handled as distributed queries.
 *
 * After copying local data into the distributed table, the local data remains
 * in place and should be truncated at a later time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyLocalDataIntoShards</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>distributedRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* take an ExclusiveLock to block all operations except SELECT */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>distributedRelation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Skip copying from partitioned tables, we will copy the data from
	 * partition to partition's shards.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * All writes have finished, make sure that we can see them by using the
	 * latest snapshot. We use GetLatestSnapshot instead of
	 * GetTransactionSnapshot since the latter would not reveal all writes
	 * in serializable or repeatable read mode. Note that subsequent reads
	 * from the distributed table would reveal those writes, temporarily
	 * violating the isolation level. However, this seems preferable over
	 * dropping the writes entirely.
	 */</comment>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the table columns */</comment>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>table_slot_create</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><call><name>TupleDescColumnNameList</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>partitionColumnIndex</name> <init>= <expr><name>INVALID_PARTITION_COLUMN_INDEX</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* determine the partition column in the tuple descriptor */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>partitionColumn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionColumnIndex</name> <operator>=</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* initialise per-tuple memory context */</comment>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>copyDest</name> <init>=
		<expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <call><name>CreateCitusCopyDestReceiver</name><argument_list>(<argument><expr><name>distributedRelationId</name></expr></argument>,
													 <argument><expr><name>columnNameList</name></expr></argument>,
													 <argument><expr><name>partitionColumnIndex</name></expr></argument>,
													 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* initialise state for writing to shards, we'll open connections on demand */</comment>
	<expr_stmt><expr><call><name><name>copyDest</name><operator>-&gt;</operator><name>rStartup</name></name><argument_list>(<argument><expr><name>copyDest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DoCopyFromLocalTableIntoShards</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>, <argument><expr><name>copyDest</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finish writing into the shards */</comment>
	<expr_stmt><expr><call><name><name>copyDest</name><operator>-&gt;</operator><name>rShutdown</name></name><argument_list>(<argument><expr><name>copyDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>copyDest</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name>copyDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free memory and close the relation */</comment>
	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DoCopyFromLocalTableIntoShards performs a copy operation
 * from local tables into shards.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DoCopyFromLocalTableIntoShards</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>distributedRelation</name></decl></parameter>,
							   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>,
							   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* begin reading from local table */</comment>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>table_beginscan</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>rowsCopied</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* send tuple it to a shard */</comment>
		<expr_stmt><expr><call><name><name>copyDest</name><operator>-&gt;</operator><name>receiveSlot</name></name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>copyDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* clear tuple memory */</comment>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make sure we roll back on cancellation */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rowsCopied</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Copying data from local table..."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rowsCopied</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rowsCopied</name> <operator>%</operator> <name>LOG_PER_TUPLE_AMOUNT</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Copied "</literal> <name>UINT64_FORMAT</name> <literal type="string">" rows"</literal></expr></argument>, <argument><expr><name>rowsCopied</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>rowsCopied</name> <operator>%</operator> <name>LOG_PER_TUPLE_AMOUNT</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Copied "</literal> <name>UINT64_FORMAT</name> <literal type="string">" rows"</literal></expr></argument>, <argument><expr><name>rowsCopied</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rowsCopied</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>=
			<expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"copying the data has completed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The local data in the table is no longer visible, "</literal>
								   <literal type="string">"but is still on disk."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To remove the local data, run: SELECT "</literal>
								 <literal type="string">"truncate_local_data_after_distributing_table($$%s$$)"</literal></expr></argument>,
								 <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finish reading from the local table */</comment>
	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TupleDescColumnNameList returns a list of column names for the given tuple
 * descriptor as plain strings.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>TupleDescColumnNameList</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>currentColumn</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator>
			<name><name>currentColumn</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>
			)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>columnNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columnNameList</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>columnNameList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationUsesIdentityColumns returns whether a given relation uses
 * GENERATED ... AS IDENTITY
 */</comment>
<function><type><name>bool</name></type>
<name>RelationUsesIdentityColumns</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>relationDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>attributeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>attributeIndex</name> <operator>&lt;</operator> <name><name>relationDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>attributeIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>relationDesc</name></expr></argument>, <argument><expr><name>attributeIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name><operator>)</operator></expr></cpp:if>

<comment type="block">/*
 * is_valid_numeric_typmod checks if the typmod value is valid
 *
 * Because of the offset, valid numeric typmods are at least VARHDRSZ
 *
 * Copied from PG. See numeric.c for understanding how this works.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_valid_numeric_typmod</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>typmod</name> <operator>&gt;=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>VARHDRSZ</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * numeric_typmod_scale extracts the scale from a numeric typmod.
 *
 * Copied from PG. See numeric.c for understanding how this works.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>numeric_typmod_scale</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>typmod</name> <operator>-</operator> <name>VARHDRSZ</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7ff</literal><operator>)</operator> <operator>^</operator> <literal type="number">1024</literal><operator>)</operator> <operator>-</operator> <literal type="number">1024</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DistributionColumnUsesNumericColumnNegativeScale returns whether a given relation uses
 * numeric data type with negative scale on distribution column
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DistributionColumnUsesNumericColumnNegativeScale</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>relationDesc</name></decl></parameter>,
												 <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>relationDesc</name></expr></argument>,
													<argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>==</operator> <name>NUMERICOID</name> <operator>&amp;&amp;</operator>
		<call><name>is_valid_numeric_typmod</name><argument_list>(<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>numeric_typmod_scale</name><argument_list>(<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * DistributionColumnUsesGeneratedStoredColumn returns whether a given relation uses
 * GENERATED ALWAYS AS (...) STORED on distribution column
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DistributionColumnUsesGeneratedStoredColumn</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>relationDesc</name></decl></parameter>,
											<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>relationDesc</name></expr></argument>,
													<argument><expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfForeignTable errors out if the relation with given relationOid
 * is a foreign table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfForeignTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelname</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign tables cannot be distributed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<operator>(</operator><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Can add foreign table \"%s\" to metadata by running: "</literal>
								 <literal type="string">"SELECT citus_add_local_table_to_metadata($$%s$$);"</literal></expr></argument>,
								 <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>qualifiedRelname</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
