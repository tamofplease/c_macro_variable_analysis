<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/commands/table.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * table.c
 *    Commands for creating and altering distributed tables.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attrdef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distribution_column.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/foreign_key_relationship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_shard_visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/* controlled via GUC, should be accessed via GetEnableLocalReferenceForeignKeys() */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableLocalReferenceForeignKeys</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC that controls whether to allow unique/exclude constraints without
 * distribution column.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>AllowUnsafeConstraints</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Local functions forward declarations for unsupported command checks */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PostprocessCreateTableStmtForeignKeys</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PostprocessCreateTableStmtPartitionOf</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStatement</name></decl></parameter>,
												  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PreprocessAttachPartitionToCitusTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>,
												  <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PreprocessAttachCitusPartitionToCitusTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentCitusRelationId</name></decl></parameter>,
													   <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DistributePartitionUsingParent</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>,
										   <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfMultiLevelPartitioning</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfAttachCitusTableToPgLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>,
												  <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AlterTableDefinesFKeyBetweenPostgresAndNonDistTable</name><parameter_list>(
	<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldMarkConnectedRelationsNotAutoConverted</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>leftRelationId</name></decl></parameter>,
														 <parameter><decl><type><name>Oid</name></type> <name>rightRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RelationIdListContainsCitusTableType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>,
												 <parameter><decl><type><name>CitusTableType</name></type> <name>citusTableType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RelationIdListContainsPostgresTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConvertPostgresLocalTablesToCitusLocalTables</name><parameter_list>(
	<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RangeVarListHasLocalRelationConvertedByUser</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationRangeVarList</name></decl></parameter>,
														<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type>
														<name>alterTableStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CompareRangeVarsByOid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetAlterTableAddFKeyRightRelationIdList</name><parameter_list>(
	<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetAlterTableAddFKeyRightRelationRangeVarList</name><parameter_list>(
	<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetAlterTableAddFKeyConstraintList</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetAlterTableCommandFKeyConstraintList</name><parameter_list>(<parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRangeVarListFromFKeyConstraintList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fKeyConstraintList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRelationIdListFromRangeVarList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeVarList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
												<parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AlterTableCommandTypeIsTrigger</name><parameter_list>(<parameter><decl><type><name>AlterTableType</name></type> <name>alterTableType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AlterTableDropsForeignKey</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedAlterTableStmt</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>InterShardDDLTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>leftRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rightRelationId</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AlterInvolvesPartitionColumn</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>,
										 <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedAlterAddConstraintStmt</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CreateRightShardListForInterShardDDLTask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rightRelationId</name></decl></parameter>,
													   <parameter><decl><type><name>Oid</name></type> <name>leftRelationId</name></decl></parameter>,
													   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>leftShardList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetInterShardDDLTaskPlacementList</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>,
											  <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name></decl></parameter>,
											  <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetInterShardDDLTaskRelationShardList</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>,
												  <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name></decl></parameter>,
												  <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>get_attrdef_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetAlterColumnWithNextvalDefaultCmd</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
												  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetAddColumnWithNextvalDefaultCmd</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
												<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>, <parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * We need to run some of the commands sequentially if there is a foreign constraint
 * from/to reference table.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SetupExecutionModeForAlterTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * PreprocessDropTableStmt processes DROP TABLE commands for partitioned tables.
 * If we are trying to DROP partitioned tables, we first need to go to MX nodes
 * and DETACH partitions from their parents. Otherwise, we process DROP command
 * multiple times in MX workers. For shards, we send DROP commands with IF EXISTS
 * parameter which solves problem of processing same command multiple times.
 * However, for distributed table itself, we directly remove related table from
 * Postgres catalogs via performDeletion function, thus we need to be cautious
 * about not processing same DROP command twice.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessDropTableStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTableStatement</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dropTableStatement</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableNameList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>tableNameList</argument>, <argument>dropTableStatement-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>tableRangeVar</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>tableNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>tableRangeVar</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>missingOK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ErrorIfIllegallyChangingKnownShard</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we're not interested in non-valid, non-distributed relations */</comment>
		<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * While changing the tables that are part of a colocation group we need to
		 * prevent concurrent mutations to the placements of the shard groups.
		 */</comment>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>!=</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LockColocationId</name><argument_list>(<argument><expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* invalidate foreign key cache if the table involved in any foreign key */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>TableReferenced</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TableReferencing</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MarkInvalidateForeignKeyGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we're only interested in partitioned and mx tables */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>partitionList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>partitionRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_oid</name><argument_list>(<argument>partitionRelationId</argument>, <argument>partitionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>detachPartitionCommand</name> <init>=
				<expr><call><name>GenerateDetachPartitionCommand</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>detachPartitionCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessCreateTableStmt takes CreateStmt object as a parameter and
 * processes foreign keys on relation via PostprocessCreateTableStmtForeignKeys
 * function.
 *
 * This function also processes CREATE TABLE ... PARTITION OF statements via
 * PostprocessCreateTableStmtPartitionOf function.
 *
 * Also CREATE TABLE ... INHERITS ... commands are filtered here. If the inherited
 * table is a distributed table, this function errors out, as we currently don't
 * support local tables inheriting a distributed table.
 */</comment>
<function><type><name>void</name></type>
<name>PostprocessCreateTableStmt</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStatement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PostprocessCreateTableStmtForeignKeys</name><argument_list>(<argument><expr><name>createStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>createStatement</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>createStatement</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* process CREATE TABLE ... PARTITION OF command */</comment>
			<expr_stmt><expr><call><name>PostprocessCreateTableStmtPartitionOf</name><argument_list>(<argument><expr><name>createStatement</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* process CREATE TABLE ... INHERITS ... */</comment>
			<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parentRelation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>parentRelation</argument>, <argument>createStatement-&gt;inhRelations</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>parentRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>,
														<argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parentRelationId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* here we error out if inheriting a distributed table */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"non-distributed tables cannot inherit "</literal>
										   <literal type="string">"distributed tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessCreateTableStmtForeignKeys drops ands re-defines foreign keys
 * defined by given CREATE TABLE command if command defined any foreign to
 * reference or citus local tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PostprocessCreateTableStmtForeignKeys</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldEnableLocalReferenceForeignKeys</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Either the user disabled foreign keys from/to local/reference tables
		 * or the coordinator is not in the metadata */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Relation must exist and it is already locked as standard process utility
	 * is already executed.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>createStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * As we are just creating the table, we cannot have foreign keys that our
	 * relation is referenced. So we use INCLUDE_REFERENCING_CONSTRAINTS here.
	 * Reason behind using other two flags is explained below.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>nonDistTableFKeysFlag</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator>
								<name>INCLUDE_CITUS_LOCAL_TABLES</name> <operator>|</operator>
								<name>INCLUDE_REFERENCE_TABLES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nonDistTableForeignKeyIdList</name> <init>=
		<expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>nonDistTableFKeysFlag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasForeignKeyToNonDistTable</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>nonDistTableForeignKeyIdList</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasForeignKeyToNonDistTable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * To support foreign keys from postgres tables to reference or citus
		 * local tables, we drop and re-define foreign keys so that our ALTER
		 * TABLE hook does the necessary job.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationFKeyCreationCommands</name> <init>=
			<expr><call><name>GetForeignConstraintCommandsInternal</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>nonDistTableFKeysFlag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>DropRelationForeignKeys</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>nonDistTableFKeysFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>skip_validation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExecuteForeignKeyCreateCommandList</name><argument_list>(<argument><expr><name>relationFKeyCreationCommands</name></expr></argument>,
										   <argument><expr><name>skip_validation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldEnableLocalReferenceForeignKeys is a wrapper around getting the GUC
 * EnableLocalReferenceForeignKeys. If the coordinator is not added
 * to the metadata, the function returns false. Else, the function returns
 * the value set by the user
 *
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldEnableLocalReferenceForeignKeys</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableLocalReferenceForeignKeys</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>CoordinatorAddedAsWorkerNode</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessCreateTableStmtPartitionOf processes CREATE TABLE ... PARTITION OF
 * statements and it checks if user creates the table as a partition of a distributed
 * table. In that case, it distributes partition as well. Since the table itself is a
 * partition, CreateDistributedTable will attach it to its parent table automatically
 * after distributing it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PostprocessCreateTableStmtPartitionOf</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStatement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier>
									  <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>parentRelation</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>createStatement</name><operator>-&gt;</operator><name>inhRelations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>parentRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* a partition can only inherit from single parent table */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>createStatement</name><operator>-&gt;</operator><name>inhRelations</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parentRelationId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>createStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In case of an IF NOT EXISTS statement, Postgres lets it pass through the
	 * standardProcess_Utility, and gets into this Post-process hook by
	 * ignoring the statement if the table already exists. Thus, we need to make
	 * sure Citus behaves like plain PG in case the relation already exists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>createStatement</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Ignore if the relation is already distributed.
			 */</comment>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator>
				 <call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>parentRelationId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Ignore if the relation is not a partition, or if that
			 * partition's parent is not the current parent from parentRelationId
			 */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If a partition is being created and if its parent is a distributed
	 * table, we will distribute this table as well.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CreateCitusLocalTablePartitionOf</name><argument_list>(<argument><expr><name>createStatement</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>,
											 <argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>parentDistributionColumn</name> <init>= <expr><call><name>DistPartitionKeyOrError</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name> <init>=
			<expr><call><name>ColumnToColumnName</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parentDistributionColumn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name>parentDistributionMethod</name> <init>= <expr><name>DISTRIBUTE_BY_HASH</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SwitchToSequentialAndLocalExecutionIfPartitionNameTooLong</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>,
																  <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CreateDistributedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>distributionColumnName</name></expr></argument>,
							   <argument><expr><name>parentDistributionMethod</name></expr></argument>, <argument><expr><name>ShardCount</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterTableStmtAttachPartition takes AlterTableStmt object as
 * parameter but it only processes into ALTER TABLE ... ATTACH PARTITION
 * commands and distributes the partition if necessary. There are four cases
 * to consider;
 *
 * Parent is not distributed, partition is not distributed: We do not need to
 * do anything in this case.
 *
 * Parent is not distributed, partition is distributed: This can happen if
 * user first distributes a table and tries to attach it to a non-distributed
 * table. Non-distributed tables cannot have distributed partitions, thus we
 * simply error out in this case.
 *
 * Parent is distributed, partition is not distributed: We should distribute
 * the table and attach it to its parent in workers. CreateDistributedTable
 * perform both of these operations. Thus, we will not propagate ALTER TABLE
 * ... ATTACH PARTITION command to workers.
 *
 * Parent is distributed, partition is distributed: Partition is already
 * distributed, we only need to attach it to its parent in workers. Attaching
 * operation will be performed via propagating this ALTER TABLE ... ATTACH
 * PARTITION command to workers.
 *
 * This function does nothing if the provided CreateStmt is not an ALTER TABLE ...
 * ATTACH PARTITION OF command.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterTableStmtAttachPartition</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>alterTableCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>alterTableCommand</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>alterTableCommand</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_AttachPartition</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We acquire the lock on the parent and child as we are in the pre-process
			 * and want to ensure we acquire the locks in the same order with Postgres
			 */</comment>
			<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>,
															<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>partitionCommand</name> <init>= <expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>alterTableCommand</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>partitionMissingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>partitionRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>partitionCommand</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
													   <argument><expr><name>partitionMissingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We can stop propagation here instead of logging error. Pg will complain
				 * in standard_utility, so we are safe to stop here. We pass missing_ok
				 * as true to not diverge from pg output.
				 */</comment>
				<return>return <expr><name>NIL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If the parent is a regular Postgres table, but the partition is a
				 * Citus table, we error out.
				 */</comment>
				<expr_stmt><expr><call><name>ErrorIfAttachCitusTableToPgLocalTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>,
													  <argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If both the parent and the child table are Postgres tables,
				 * we can just skip preprocessing this command.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Citus doesn't support multi-level partitioned tables */</comment>
			<expr_stmt><expr><call><name>ErrorIfMultiLevelPartitioning</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* attaching to a Citus table */</comment>
			<expr_stmt><expr><call><name>PreprocessAttachPartitionToCitusTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAttachPartitionToCitusTable takes a parent relation, which is a Citus table,
 * and a partition to be attached to it.
 * If the partition table is a regular Postgres table:
 * - Converts the partition to Citus Local Table, if the parent is a Citus Local Table.
 * - Distributes the partition, if the parent is a distributed table.
 * If not, calls PreprocessAttachCitusPartitionToCitusTable to attach given partition to
 * the parent relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PreprocessAttachPartitionToCitusTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reference tables cannot be partitioned */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if parent of this table is distributed, distribute this table too */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We pass the cascade option as false, since Citus Local Table partitions
			 * cannot have non-inherited foreign keys.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>cascadeViaForeignKeys</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>autoConverted</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>autoConverted</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>CreateCitusLocalTable</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>, <argument><expr><name>cascadeViaForeignKeys</name></expr></argument>,
								  <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DistributePartitionUsingParent</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* both the parent and child are Citus tables */</comment>
		<expr_stmt><expr><call><name>PreprocessAttachCitusPartitionToCitusTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAttachCitusPartitionToCitusTable takes a parent relation, and a partition
 * to be attached to it. Both of them are Citus tables.
 * Errors out if the partition is a reference table.
 * Errors out if the partition is distributed and the parent is a Citus Local Table.
 * Distributes the partition, if it's a Citus Local Table, and the parent is distributed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PreprocessAttachCitusPartitionToCitusTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentCitusRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
										   <name>partitionRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partitioned reference tables are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>parentCitusRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"non-distributed partitioned tables cannot have "</literal>
							   <literal type="string">"distributed partitions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>parentCitusRelationId</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if the parent is a distributed table, distribute the partition too */</comment>
		<expr_stmt><expr><call><name>DistributePartitionUsingParent</name><argument_list>(<argument><expr><name>parentCitusRelationId</name></expr></argument>, <argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>parentCitusRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We should ensure that the partition relation has no foreign keys,
		 * as Citus Local Table partitions can only have inherited foreign keys.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TableHasExternalForeignKeys</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition local tables added to citus metadata "</literal>
								   <literal type="string">"cannot have non-inherited foreign keys"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We don't need to add other cases here, like distributed - distributed and
	 * citus_local - citus_local, as PreprocessAlterTableStmt and standard process
	 * utility would do the work to attach partitions to shell and shard relations.
	 */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * DistributePartitionUsingParent takes a parent and a partition relation and
 * distributes the partition, using the same distribution column as the parent.
 * It creates a *hash* distributed table by default, as partitioned tables can only be
 * distributed by hash.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DistributePartitionUsingParent</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentCitusRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name> <init>= <expr><call><name>DistPartitionKeyOrError</name><argument_list>(<argument><expr><name>parentCitusRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name> <init>= <expr><call><name>ColumnToColumnName</name><argument_list>(<argument><expr><name>parentCitusRelationId</name></expr></argument>,
													  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>distributionColumn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>distributionMethod</name> <init>= <expr><name>DISTRIBUTE_BY_HASH</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>parentCitusRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SwitchToSequentialAndLocalExecutionIfPartitionNameTooLong</name><argument_list>(
		<argument><expr><name>parentCitusRelationId</name></expr></argument>, <argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CreateDistributedTable</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>, <argument><expr><name>distributionColumnName</name></expr></argument>,
						   <argument><expr><name>distributionMethod</name></expr></argument>, <argument><expr><name>ShardCount</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						   <argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfMultiLevelPartitioning takes a parent, and a partition relation to be attached
 * and errors out if the partition is also a partitioned table, which means we are
 * trying to build a multi-level partitioned table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfMultiLevelPartitioning</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Citus doesn't support multi-level "</literal>
							   <literal type="string">"partitioned tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Relation \"%s\" is partitioned table "</literal>
								  <literal type="string">"itself and it is also partition of "</literal>
								  <literal type="string">"relation \"%s\"."</literal></expr></argument>,
								  <argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfAttachCitusTableToPgLocalTable takes a parent, and a partition relation
 * to be attached. Errors out if the partition is a Citus table, and the parent is a
 * regular Postgres table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfAttachCitusTableToPgLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsCitusTable</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"non-citus partitioned tables cannot have "</literal>
							   <literal type="string">"citus table partitions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Distribute the partitioned table \"%s\" "</literal>
								<literal type="string">"instead, or add it to metadata"</literal></expr></argument>, <argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessAlterTableSchemaStmt is executed after the change has been applied
 * locally, we can now use the new dependencies of the table to ensure all its
 * dependencies exist on the workers before we apply the commands remotely.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessAlterTableSchemaStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We will let Postgres deal with missing_ok
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tableAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We have already asserted that we have exactly 1 address in the addresses. */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>tableAddress</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>tableAddresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check whether we are dealing with a sequence or view here and route queries
	 * accordingly to the right processor function.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>tableAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_SEQUENCE</name></expr>;</expr_stmt>
		<return>return <expr><call><name>PostprocessAlterSequenceSchemaStmt</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_VIEW</name></expr>;</expr_stmt>
		<return>return <expr><call><name>PostprocessAlterViewSchemaStmt</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>tableAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><name>tableAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SwitchToSequentialAndLocalExecutionIfPrimaryKeyNameTooLong generates the longest primary key name
 * among the shards of the partitions, and if exceeds the limit switches to sequential and
 * local execution to prevent self-deadlocks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SwitchToSequentialAndLocalExecutionIfPrimaryKeyNameTooLong</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Citus already handles long names for regular tables */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ShardIntervalCount</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Relation has no shards, so we cannot run into "long shard index
		 * name" issue.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>longestNamePartitionId</name> <init>= <expr><call><name>PartitionWithLongestNameRelationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no partitions have been created yet */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>longestPartitionShardName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardIntervalWithLongestShardName</name><argument_list>(
		<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>longestPartitionShardName</name></expr></argument>, <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceOid</name> <init>= <expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>primaryKeyName</name> <init>= <expr><call><name>ChooseIndexName</name><argument_list>(<argument><expr><name>longestPartitionShardName</name></expr></argument>,
										   <argument><expr><name>namespaceOid</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><name>primaryKeyName</name> <operator>&amp;&amp;</operator> <call><name>strnlen</name><argument_list>(<argument><expr><name>primaryKeyName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there has already been a parallel query executed, the sequential mode
			 * would still use the already opened parallel connections to the workers,
			 * thus contradicting our purpose of using sequential mode.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"The primary key name (%s) on a shard is too long and could lead "</literal>
								<literal type="string">"to deadlocks when executed in a transaction "</literal>
								<literal type="string">"block after a parallel query"</literal></expr></argument>, <argument><expr><name>primaryKeyName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
									<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
									<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"the primary key name on the shards of the partition "</literal>
						 <literal type="string">"is too long, switching to sequential and local execution "</literal>
						 <literal type="string">"mode to prevent self deadlocks: %s"</literal></expr></argument>, <argument><expr><name>primaryKeyName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetLocalExecutionStatus</name><argument_list>(<argument><expr><name>LOCAL_EXECUTION_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterTableAddPrimaryKey creates a new primary key constraint name changing the original alterTableCommand run by the utility hook.
 * Then converts the ALTER TABLE ... ADD PRIMARY KEY ... command
 * into ALTER TABLE ... ADD CONSTRAINT &lt;constraint name&gt; PRIMARY KEY format and returns the DDLJob
 * to run this command in the workers.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterTableAddPrimaryKey</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
								  <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We should only preprocess an ADD PRIMARY KEY command if we are changing the it.
	 * This only happens when we have to create a primary key name ourselves in the case that the client does
	 * not specify a name.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>primary</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isconstraint</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Change the alterTableCommand so that the standard utility
	 * hook runs it with the name we created.
	 */</comment>
	<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <call><name>ChooseIndexName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>primary</name></expr></argument>,
										  <argument><expr><name>isconstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ddlCommand</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>alterTableStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SwitchToSequentialAndLocalExecutionIfPrimaryKeyNameTooLong</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>startNewTransaction</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>ddlCommand</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>DDLTaskList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ddlCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterTableStmt determines whether a given ALTER TABLE statement
 * involves a distributed table. If so (and if the statement does not use
 * unsupported options), it modifies the input statement to ensure proper
 * execution against the master node table and creates a DDLJob to encapsulate
 * information needed during the worker node portion of DDL execution before
 * returning that DDLJob in a List. If no distributed table is involved, this
 * function returns NIL.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterTableStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alterTableCommand</name></decl></parameter>,
						 <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* first check whether a distributed relation is affected */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>relation</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>leftRelationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * check whether we are dealing with a sequence or view here
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmtCopy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AlterTableStmtObjType_compat</name><argument_list>(<argument><expr><name>stmtCopy</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>OBJECT_SEQUENCE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name><operator>)</operator></expr></cpp:if>

		<comment type="block">/*
		 * it must be ALTER TABLE .. OWNER TO ..
		 * or ALTER TABLE .. SET LOGGED/UNLOGGED command
		 * since these are the only ALTER commands of a sequence that
		 * pass through an AlterTableStmt
		 */</comment>
		<return>return <expr><call><name>PreprocessSequenceAlterTableStmt</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmtCopy</name></expr></argument>, <argument><expr><name>alterTableCommand</name></expr></argument>,
												<argument><expr><name>processUtilityContext</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

		<comment type="block">/*
		 * it must be ALTER TABLE .. OWNER TO .. command
		 * since this is the only ALTER command of a sequence that
		 * passes through an AlterTableStmt
		 */</comment>
		<return>return <expr><call><name>PreprocessAlterSequenceOwnerStmt</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmtCopy</name></expr></argument>, <argument><expr><name>alterTableCommand</name></expr></argument>,
												<argument><expr><name>processUtilityContext</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * it must be ALTER TABLE .. OWNER TO .. command
		 * since this is the only ALTER command of a view that
		 * passes through an AlterTableStmt
		 */</comment>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmtCopy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AlterTableStmtObjType_compat</name><argument_list>(<argument><expr><name>stmtCopy</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>OBJECT_VIEW</name></expr>;</expr_stmt>
		<return>return <expr><call><name>PreprocessAlterViewStmt</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmtCopy</name></expr></argument>, <argument><expr><name>alterTableCommand</name></expr></argument>,
									   <argument><expr><name>processUtilityContext</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * AlterTableStmt applies also to INDEX relations, and we have support for
	 * SET/SET storage parameters in Citus, so we might have to check for
	 * another relation here.
	 *
	 * ALTER INDEX ATTACH PARTITION also applies to INDEX relation, so we might
	 * check another relation for that option as well.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>leftRelationKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>leftRelationKind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name>leftRelationKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>leftRelationId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ShouldEnableLocalReferenceForeignKeys</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<name>processUtilityContext</name> <operator>!=</operator> <name>PROCESS_UTILITY_SUBCOMMAND</name> <operator>&amp;&amp;</operator>
		<call><name>AlterTableDefinesFKeyBetweenPostgresAndNonDistTable</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't process subcommands generated by postgres.
		 * This is mainly because postgres issues ALTER TABLE commands
		 * for some set of objects that are defined via CREATE TABLE commands.
		 * However, citus already has a separate logic for CREATE TABLE
		 * commands.
		 *
		 * To support foreign keys from/to postgres local tables to/from reference
		 * or citus local tables, we convert given postgres local table -and the
		 * other postgres tables that it is connected via a fkey graph- to a citus
		 * local table.
		 *
		 * Note that we don't convert postgres tables to citus local tables if
		 * coordinator is not added to metadata as CreateCitusLocalTable requires
		 * this. In this case, we assume user is about to create reference or
		 * distributed table from local table and we don't want to break user
		 * experience by asking to add coordinator to metadata.
		 */</comment>
		<expr_stmt><expr><call><name>ConvertPostgresLocalTablesToCitusLocalTables</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * CreateCitusLocalTable converts relation to a shard relation and creates
		 * shell table from scratch.
		 * For this reason we should re-enter to PreprocessAlterTableStmt to operate
		 * on shell table relation id.
		 */</comment>
		<return>return <expr><call><name>PreprocessAlterTableStmt</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>alterTableCommand</name></expr></argument>, <argument><expr><name>processUtilityContext</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AlterTableDropsForeignKey</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The foreign key graph keeps track of the foreign keys including local tables.
		 * So, even if a foreign key on a local table is dropped, we should invalidate
		 * the graph so that the next commands can see the graph up-to-date.
		 * We are aware that utility hook would still invalidate foreign key graph
		 * even when command fails, but currently we are ok with that.
		 */</comment>
		<expr_stmt><expr><call><name>MarkInvalidateForeignKeyGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>referencingIsLocalTable</name> <init>= <expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>referencingIsLocalTable</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The PostgreSQL parser dispatches several commands into the node type
	 * AlterTableStmt, from ALTER INDEX to ALTER SEQUENCE or ALTER VIEW. Here
	 * we have a special implementation for ALTER INDEX, and a specific error
	 * message in case of unsupported sub-command.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftRelationKind</name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		<name>leftRelationKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ErrorIfUnsupportedAlterIndexStmt</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* this function also accepts more than just RELKIND_RELATION... */</comment>
		<expr_stmt><expr><call><name>ErrorIfUnsupportedAlterTableStmt</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* these will be set in below loop according to subcommands */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>rightRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>executeSequentially</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We check if there is:
	 *  - an ADD/DROP FOREIGN CONSTRAINT command in sub commands
	 *    list. If there is we assign referenced relation id to rightRelationId and
	 *    we also set skip_validation to true to prevent PostgreSQL to verify validity
	 *    of the foreign constraint in master. Validity will be checked in workers
	 *    anyway.
	 *  - an ADD COLUMN .. DEFAULT nextval('..') OR
	 *    an ADD COLUMN .. SERIAL pseudo-type OR
	 *    an ALTER COLUMN .. SET DEFAULT nextval('..'). If there is we set
	 *    deparseAT variable to true which means we will deparse the statement
	 *    before we propagate the command to shards. For shards, all the defaults
	 *    coming from a user-defined sequence will be replaced by
	 *    NOT NULL constraint.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * if deparsing is needed, we will use a different version of the original
	 * alterTableStmt
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>deparseAT</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>propagateCommandToWorkers</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Sometimes we want to run a different DDL Command string in MX workers
	 * For example, in cases where worker_nextval should be used instead
	 * of nextval() in column defaults with type int and smallint
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>useInitialDDLCommandString</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>newStmt</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>newCmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableType</name></type> <name>alterTableType</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * if deparsing is needed, we will use a different version of the original
		 * AlterTableCmd
		 */</comment>
		<expr_stmt><expr><name>newCmd</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AddConstraint</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We only support ALTER TABLE ADD CONSTRAINT ... FOREIGN KEY, if it is
				 * only subcommand of ALTER TABLE. It was already checked in
				 * ErrorIfUnsupportedAlterTableStmt.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>rightRelationId</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>pktable</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
												   <argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>processUtilityContext</name> <operator>!=</operator> <name>PROCESS_UTILITY_SUBCOMMAND</name> <operator>&amp;&amp;</operator>
					<call><name>ShouldMarkConnectedRelationsNotAutoConverted</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>,
																 <argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationList</name> <init>= <expr><call><name>list_make2_oid</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>, <argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>UpdateAutoConvertedForConnectedRelations</name><argument_list>(<argument><expr><name>relationList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Foreign constraint validations will be done in workers. If we do not
				 * set this flag, PostgreSQL tries to do additional checking when we drop
				 * to standard_ProcessUtility. standard_ProcessUtility tries to open new
				 * connections to workers to verify foreign constraints while original
				 * transaction is in process, which causes deadlock.
				 */</comment>
				<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Create a constraint name. Convert ALTER TABLE ... ADD PRIMARY ... command into
					 * ALTER TABLE ... ADD CONSTRAINT &lt;conname&gt; PRIMARY KEY ... form and create the ddl jobs
					 * for running this form of the command on the workers.
					 */</comment>
					<return>return <expr><call><name>PreprocessAlterTableAddPrimaryKey</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>,
															 <argument><expr><name>leftRelationId</name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_DropConstraint</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ConstraintIsAForeignKey</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We only support ALTER TABLE DROP CONSTRAINT ... FOREIGN KEY, if it is
				 * only subcommand of ALTER TABLE. It was already checked in
				 * ErrorIfUnsupportedAlterTableStmt.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>foreignKeyId</name> <init>= <expr><call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>,
															   <argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>rightRelationId</name> <operator>=</operator> <call><name>GetReferencedTableId</name><argument_list>(<argument><expr><name>foreignKeyId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AddColumn</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * TODO: This code path is nothing beneficial since we do not
			 * support ALTER TABLE %s ADD COLUMN %s [constraint] for foreign keys.
			 * However, the code is kept in case we fix the constraint
			 * creation without a name and allow foreign key creation with the mentioned
			 * command.
			 */</comment>
			<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>columnDefinition</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnConstraints</name> <init>= <expr><name><name>columnDefinition</name><operator>-&gt;</operator><name>constraints</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>constraint</argument>, <argument>columnConstraints</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>rightRelationId</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>pktable</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
													   <argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Foreign constraint validations will be done in workers. If we do not
					 * set this flag, PostgreSQL tries to do additional checking when we drop
					 * to standard_ProcessUtility. standard_ProcessUtility tries to open new
					 * connections to workers to verify foreign constraints while original
					 * transaction is in process, which causes deadlock.
					 */</comment>
					<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * We check for ADD COLUMN .. DEFAULT expr
			 * if expr contains nextval('user_defined_seq')
			 * we should deparse the statement
			 */</comment>
			<expr_stmt><expr><name>constraint</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>constraint</argument>, <argument>columnConstraints</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name></expr></argument>,
												   <argument><expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>contain_nextval_expression_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>deparseAT</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>useInitialDDLCommandString</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

							<comment type="block">/* the new column definition will have no constraint */</comment>
							<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>newColDef</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>columnDefinition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<expr_stmt><expr><name><name>newColDef</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

							<expr_stmt><expr><name><name>newCmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newColDef</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * We check for ADD COLUMN .. SERIAL pseudo-type
			 * if that's the case, we should deparse the statement
			 * The structure of this check is copied from transformColumnDefinition.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>columnDefinition</name><operator>-&gt;</operator><name>typeName</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(
					<argument><expr><name><name>columnDefinition</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>columnDefinition</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>pct_type</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>columnDefinition</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"smallserial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial4"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"bigserial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>deparseAT</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>newColDef</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>columnDefinition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>newColDef</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"smallserial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>newColDef</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newColDef</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>INT2OID</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
							 <call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial4"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>newColDef</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newColDef</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"bigserial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
							 <call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>newColDef</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newColDef</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>newCmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newColDef</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/*
		 * We check for ALTER COLUMN .. SET/DROP DEFAULT
		 * we should not propagate anything to shards
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_ColumnDefault</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									   <argument><expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>contain_nextval_expression_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>propagateCommandToWorkers</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>useInitialDDLCommandString</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AttachPartition</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>partitionCommand</name> <init>= <expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>attachedRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>partitionCommand</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name>attachedRelationKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>attachedRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We support ALTER INDEX ATTACH PARTITION and ALTER TABLE ATTACH PARTITION
			 * if it is only subcommand of ALTER TABLE command. Since the attached relation
			 * type is index for ALTER INDEX ATTACH PARTITION, we need to use the relation
			 * id this index is created for.
			 *
			 * Both were already checked in ErrorIfUnsupportedAlterIndexStmt and
			 * ErrorIfUnsupportedAlterTableStmt.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attachedRelationKind</name> <operator>==</operator> <name>RELKIND_INDEX</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>rightRelationId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>attachedRelationId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Since left relation is checked above to make sure it is Citus table,
				 * partition of that must be Citus table as well.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>attachedRelationKind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
					 <name>attachedRelationKind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Do not generate tasks if relation is distributed and the partition
				 * is not distributed. Because, we'll manually convert the partition into
				 * distributed table and co-locate with its parent.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>attachedRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>NIL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>rightRelationId</name> <operator>=</operator> <name>attachedRelationId</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_DetachPartition</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>partitionCommand</name> <init>= <expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We only support ALTER TABLE DETACH PARTITION, if it is only subcommand of
			 * ALTER TABLE. It was already checked in ErrorIfUnsupportedAlterTableStmt.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>rightRelationId</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>partitionCommand</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>AlterTableCommandTypeIsTrigger</name><argument_list>(<argument><expr><name>alterTableType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
			<return>return <expr><call><name>CitusCreateTriggerCommandDDLJob</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>, <argument><expr><name>triggerName</name></expr></argument>,
												   <argument><expr><name>alterTableCommand</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We check and set the execution mode only if we fall into either of first two
		 * conditional blocks, otherwise we already continue the loop
		 */</comment>
		<expr_stmt><expr><name>executeSequentially</name> <operator>|=</operator> <call><name>SetupExecutionModeForAlterTable</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>,
															   <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>executeSequentially</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fill them here as it is possible to use them in some conditional blocks below */</comment>
	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlForTaskList</name> <init>= <expr><name>alterTableCommand</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>deparseAT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>newStmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>newCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sqlForTaskList</name> <operator>=</operator> <call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <ternary><condition><expr><name>useInitialDDLCommandString</name></expr> ?</condition><then> <expr><name>alterTableCommand</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>referencedIsLocalTable</name> <init>= <expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>referencedIsLocalTable</name> <operator>||</operator> <operator>!</operator><name>propagateCommandToWorkers</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* if foreign key or attaching partition index related, use specialized task list function ... */</comment>
			<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>InterShardDDLTaskList</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>, <argument><expr><name>rightRelationId</name></expr></argument>,
													 <argument><expr><name>sqlForTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* ... otherwise use standard DDL task list function */</comment>
		<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>DDLTaskList</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>, <argument><expr><name>sqlForTaskList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>propagateCommandToWorkers</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlJobs</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>ddlJobs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTableDefinesFKeyBetweenPostgresAndNonDistTable returns true if given
 * alter table command defines foreign key between a postgres table and a
 * reference or citus local table.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AlterTableDefinesFKeyBetweenPostgresAndNonDistTable</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyConstraintList</name> <init>=
		<expr><call><name>GetAlterTableAddFKeyConstraintList</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>foreignKeyConstraintList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we are not defining any foreign keys */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightRelationIdList</name> <init>=
		<expr><call><name>GetAlterTableAddFKeyRightRelationIdList</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>leftRelationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>RelationIdListContainsCitusTableType</name><argument_list>(<argument><expr><name>rightRelationIdList</name></expr></argument>,
													<argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>RelationIdListContainsPostgresTable</name><argument_list>(<argument><expr><name>rightRelationIdList</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldMarkConnectedRelationsNotAutoConverted takes two relations.
 * If both of them are Citus Local Tables, and one of them is auto-converted while the
 * other one is not; then it returns true. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldMarkConnectedRelationsNotAutoConverted</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>leftRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rightRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>entryLeft</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>entryRight</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>entryLeft</name><operator>-&gt;</operator><name>autoConverted</name></name> <operator>!=</operator> <name><name>entryRight</name><operator>-&gt;</operator><name>autoConverted</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationIdListContainsCitusTableType returns true if given relationIdList
 * contains a citus table with given type.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RelationIdListContainsCitusTableType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>, <parameter><decl><type><name>CitusTableType</name></type> <name>citusTableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>citusTableType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationIdListContainsPostgresTable returns true if given relationIdList
 * contains a postgres table.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RelationIdListContainsPostgresTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConvertPostgresLocalTablesToCitusLocalTables converts each postgres table
 * involved in foreign keys to be defined by given alter table command and the
 * other tables connected to them via a foreign key graph to citus local tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ConvertPostgresLocalTablesToCitusLocalTables</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightRelationRangeVarList</name> <init>=
		<expr><call><name>GetAlterTableAddFKeyRightRelationRangeVarList</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>leftRelationRangeVar</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationRangeVarList</name> <init>= <expr><call><name>lappend</name><argument_list>(<argument><expr><name>rightRelationRangeVarList</name></expr></argument>, <argument><expr><name>leftRelationRangeVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * To prevent deadlocks, sort the list before converting each postgres local
	 * table to a citus local table.
	 */</comment>
	<expr_stmt><expr><name>relationRangeVarList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>relationRangeVarList</name></expr></argument>, <argument><expr><name>CompareRangeVarsByOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>containsAnyUserConvertedLocalRelation</name> <init>=
		<expr><call><name>RangeVarListHasLocalRelationConvertedByUser</name><argument_list>(<argument><expr><name>relationRangeVarList</name></expr></argument>,
													<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Here we should operate on RangeVar objects since relations oid's would
	 * change in below loop due to CreateCitusLocalTable.
	 */</comment>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relationRangeVar</name></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>relationRangeVar</argument>, <argument>relationRangeVarList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relationRangeVar</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * As we are in preprocess, missingOk might be true and relation
			 * might not exist.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>autoConverted</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This citus local table is already added to the metadata
				 * by the user, so no further operation needed.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name>containsAnyUserConvertedLocalRelation</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We are safe to skip this relation because none of the citus local
				 * tables involved are manually added to the metadata by the user.
				 * This implies that all the Citus local tables involved are marked
				 * as autoConverted = true and there is no chance to update
				 * autoConverted = false.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we can directly skip for table types other than citus local tables */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The only reason behind using a try/catch block here is giving a proper
		 * error message. For example, when creating a citus local table we might
		 * give an error telling that partitioned tables are not supported for
		 * citus local table creation. But as a user it wouldn't make much sense
		 * to see such an error. So here we extend error message to tell that we
		 * actually ended up with this error when trying to define the foreign key.
		 *
		 * Also, as CopyErrorData() requires (CurrentMemoryContext != ErrorContext),
		 * so we store CurrentMemoryContext here.
		 */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>savedMemoryContext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>cascade</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Without this check, we would be erroring out in CreateCitusLocalTable
			 * for this case anyway. The purpose of this check&amp;error is to provide
			 * a more meaningful message for the user.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot build foreign key between"</literal>
									   <literal type="string">" reference table and a partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try using parent table: %s"</literal></expr></argument>,
										<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * There might be two scenarios:
				 *
				 *   a) A user created foreign key from a reference table
				 *      to Postgres local table(s) or Citus local table(s)
				 *      where all of the citus local tables involved are auto
				 *      converted. In that case, we mark the new table as auto
				 *      converted as well.
				 *
				 *   b) A user created foreign key from a reference table
				 *      to Postgres local table(s) or Citus local table(s)
				 *      where at least one of the citus local tables
				 *      involved is not auto converted. In that case, we mark
				 *      this new Citus local table as autoConverted = false
				 *      as well. Because our logic is to keep all the connected
				 *      Citus local tables to have the same autoConverted value.
				 */</comment>
				<decl_stmt><decl><type><name>bool</name></type> <name>autoConverted</name> <init>= <expr><ternary><condition><expr><name>containsAnyUserConvertedLocalRelation</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>CreateCitusLocalTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>cascade</name></expr></argument>, <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savedMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>errorData</name> <init>= <expr><call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>errorData</name><operator>-&gt;</operator><name>elevel</name></name> <operator>!=</operator> <name>ERROR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* override error detail */</comment>
			<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>detail</name></name> <operator>=</operator> <literal type="string">"When adding a foreign key from a local table to "</literal>
								<literal type="string">"a reference table, Citus applies a conversion to "</literal>
								<literal type="string">"all the local tables in the foreign key graph"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ThrowErrorData</name><argument_list>(<argument><expr><name>errorData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * RangeVarListHasLocalRelationConvertedByUser takes a list of relations and returns true
 * if any of these relations is marked as auto-converted = false. Returns true otherwise.
 * This function also takes the current alterTableStatement command, to obtain the
 * necessary locks.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RangeVarListHasLocalRelationConvertedByUser</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationRangeVarList</name></decl></parameter>,
											<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relationRangeVar</name></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>relationRangeVar</argument>, <argument>relationRangeVarList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * Here we iterate the relation list, and if at least one of the relations
		 * is marked as not-auto-converted, we should mark all of them as
		 * not-auto-converted. In that case, we return true here.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relationRangeVar</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>autoConverted</name></name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompareRangeVarsByOid is a comparison function to sort RangeVar object list.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CompareRangeVarsByOid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>leftElement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rightElement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>leftRangeVar</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>leftElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rightRangeVar</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>RangeVar</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>rightElement</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Any way we will check their existence, so it's okay to map non-existing
	 * relations to InvalidOid when sorting.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * As this is an object comparator function, there is no way to understand
	 * proper lock mode. So assume caller already locked relations.
	 */</comment>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><name>NoLock</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>leftRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>leftRangeVar</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>rightRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rightRangeVar</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>CompareOids</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leftRelationId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightRelationId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAlterTableAddFKeyRightRelationIdList returns a list of oid's for right
 * relations involved in foreign keys to be defined by given ALTER TABLE command.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetAlterTableAddFKeyRightRelationIdList</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightRelationRangeVarList</name> <init>=
		<expr><call><name>GetAlterTableAddFKeyRightRelationRangeVarList</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightRelationIdList</name> <init>=
		<expr><call><name>GetRelationIdListFromRangeVarList</name><argument_list>(<argument><expr><name>rightRelationRangeVarList</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>rightRelationIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAlterTableAddFKeyRightRelationRangeVarList returns a list of RangeVar
 * objects for right relations involved in foreign keys to be defined by
 * given ALTER TABLE command.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetAlterTableAddFKeyRightRelationRangeVarList</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fKeyConstraintList</name> <init>= <expr><call><name>GetAlterTableAddFKeyConstraintList</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightRelationRangeVarList</name> <init>=
		<expr><call><name>GetRangeVarListFromFKeyConstraintList</name><argument_list>(<argument><expr><name>fKeyConstraintList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>rightRelationRangeVarList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAlterTableAddFKeyConstraintList returns a list of Constraint objects for
 * foreign keys that given ALTER TABLE to be defined by given ALTER TABLE command.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetAlterTableAddFKeyConstraintList</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyConstraintList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandForeignKeyConstraintList</name> <init>=
			<expr><call><name>GetAlterTableCommandFKeyConstraintList</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>foreignKeyConstraintList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>foreignKeyConstraintList</name></expr></argument>,
											   <argument><expr><name>commandForeignKeyConstraintList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>foreignKeyConstraintList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAlterTableCommandFKeyConstraintList returns a list of Constraint objects
 * for the foreign keys that given ALTER TABLE subcommand defines. Note that
 * this is only possible if it is an:
 *  - ADD CONSTRAINT subcommand (explicitly defines) or,
 *  - ADD COLUMN subcommand (implicitly defines by adding a new column that
 *    references to another table.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetAlterTableCommandFKeyConstraintList</name><parameter_list>(<parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fkeyConstraintList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AlterTableType</name></type> <name>alterTableType</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AddConstraint</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>fkeyConstraintList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fkeyConstraintList</name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AddColumn</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>columnDefinition</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnConstraints</name> <init>= <expr><name><name>columnDefinition</name><operator>-&gt;</operator><name>constraints</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>constraint</argument>, <argument>columnConstraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>fkeyConstraintList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fkeyConstraintList</name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>fkeyConstraintList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRangeVarListFromFKeyConstraintList returns a list of RangeVar objects for
 * right relations in fKeyConstraintList.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRangeVarListFromFKeyConstraintList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fKeyConstraintList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightRelationRangeVarList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>fKeyConstraint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>fKeyConstraint</argument>, <argument>fKeyConstraintList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rightRelationRangeVar</name> <init>= <expr><name><name>fKeyConstraint</name><operator>-&gt;</operator><name>pktable</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>rightRelationRangeVarList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rightRelationRangeVarList</name></expr></argument>,
											<argument><expr><name>rightRelationRangeVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>rightRelationRangeVarList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationIdListFromRangeVarList returns relation id list for relations
 * identified by RangeVar objects in given list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRelationIdListFromRangeVarList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rangeVarList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rangeVar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>rangeVar</argument>, <argument>rangeVarList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>rightRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>rangeVar</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>relationIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTableCommandTypeIsTrigger returns true if given alter table command type
 * is identifies an ALTER TABLE .. TRIGGER .. command.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AlterTableCommandTypeIsTrigger</name><parameter_list>(<parameter><decl><type><name>AlterTableType</name></type> <name>alterTableType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>alterTableType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AT_EnableTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrigUser</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrig</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>
		<case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>
		<case>case <expr><name>AT_DisableTrigAll</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * ConstrTypeUsesIndex returns true if the given constraint type uses an index
 */</comment>
<function><type><name>bool</name></type>
<name>ConstrTypeUsesIndex</name><parameter_list>(<parameter><decl><type><name>ConstrType</name></type> <name>constrType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>constrType</name> <operator>==</operator> <name>CONSTR_PRIMARY</name> <operator>||</operator>
		   <name>constrType</name> <operator>==</operator> <name>CONSTR_UNIQUE</name> <operator>||</operator>
		   <name>constrType</name> <operator>==</operator> <name>CONSTR_EXCLUSION</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTableDropsForeignKey returns true if the given AlterTableStmt drops
 * a foreign key. False otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AlterTableDropsForeignKey</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>alterTableStatement-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableType</name></type> <name>alterTableType</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_DropColumn</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>ColumnAppearsInForeignKey</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* dropping a column in the either side of the fkey will drop the fkey */</comment>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In order to drop the foreign key, other than DROP COLUMN, the command must be
		 * DROP CONSTRAINT command.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>alterTableType</name> <operator>!=</operator> <name>AT_DropConstraint</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ConstraintIsAForeignKey</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>ConstraintIsAUniquenessConstraint</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the uniqueness constraint of the column that the foreign key depends on
			 * is getting dropped, then the foreign key will also be dropped.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>uniquenessConstraintId</name> <init>=
				<expr><call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>indexId</name> <init>= <expr><call><name>get_constraint_index</name><argument_list>(<argument><expr><name>uniquenessConstraintId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>AnyForeignKeyDependsOnIndex</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AnyForeignKeyDependsOnIndex scans pg_depend and returns true if given index
 * is valid and any foreign key depends on it.
 */</comment>
<function><type><name>bool</name></type>
<name>AnyForeignKeyDependsOnIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dependentObjectClassId</name> <init>= <expr><name>RelationRelationId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>dependentObjectId</name> <init>= <expr><name>indexId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencyTupleList</name> <init>=
		<expr><call><name>GetPgDependTuplesForDependingObjects</name><argument_list>(<argument><expr><name>dependentObjectClassId</name></expr></argument>, <argument><expr><name>dependentObjectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>dependencyTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>dependencyTuple</argument>, <argument>dependencyTupleList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>dependencyForm</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>dependencyTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>dependingClassId</name> <init>= <expr><name><name>dependencyForm</name><operator>-&gt;</operator><name>classid</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>dependingClassId</name> <operator>!=</operator> <name>ConstraintRelationId</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>dependingObjectId</name> <init>= <expr><name><name>dependencyForm</name><operator>-&gt;</operator><name>objid</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ConstraintWithIdIsOfType</name><argument_list>(<argument><expr><name>dependingObjectId</name></expr></argument>, <argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterTableStmt issues a warning.
 * ALTER TABLE ALL IN TABLESPACE statements have their node type as
 * AlterTableMoveAllStmt. At the moment we do not support this functionality in
 * the distributed environment. We warn out here.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterTableMoveAllStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
								<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>EnableUnsupportedFeatureMessages</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not propagating ALTER TABLE ALL IN TABLESPACE "</literal>
								 <literal type="string">"commands to worker nodes"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Connect to worker nodes directly to manually "</literal>
								  <literal type="string">"move all tables."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterTableSchemaStmt is executed before the statement is applied
 * to the local postgres instance.
 *
 * In this stage we can prepare the commands that will alter the schemas of the
 * shards.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterTableSchemaStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
							   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>addresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>,
														<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We have already asserted that we have exactly 1 address in the addresses. */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check whether we are dealing with a sequence or view here and route queries
	 * accordingly to the right processor function. We need to check both objects here
	 * since PG supports targeting sequences and views with ALTER TABLE commands.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmtCopy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>stmtCopy</name><operator>-&gt;</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_SEQUENCE</name></expr>;</expr_stmt>
		<return>return <expr><call><name>PreprocessAlterSequenceSchemaStmt</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmtCopy</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
												 <argument><expr><name>processUtilityContext</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmtCopy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>stmtCopy</name><operator>-&gt;</operator><name>objectType</name></name> <operator>=</operator> <name>OBJECT_VIEW</name></expr>;</expr_stmt>
		<return>return <expr><call><name>PreprocessAlterViewSchemaStmt</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmtCopy</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>,
											 <argument><expr><name>processUtilityContext</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* first check whether a distributed relation is affected */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>QualifyTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>DDLTaskList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SkipForeignKeyValidationIfConstraintIsFkey checks and processes the alter table
 * statement to be worked on the distributed table. Currently, it only processes
 * ALTER TABLE ... ADD FOREIGN KEY command to skip the validation step.
 */</comment>
<function><type><name>void</name></type>
<name>SkipForeignKeyValidationIfConstraintIsFkey</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* first check whether a distributed relation is affected */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>relation</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>leftRelationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>alterTableStatement-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableType</name></type> <name>alterTableType</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AddConstraint</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip only if the constraint is a foreign key */</comment>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* set the GUC skip_constraint_validation to on */</comment>
				<expr_stmt><expr><call><name>EnableSkippingConstraintValidation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * IsAlterTableRenameStmt returns whether the passed-in RenameStmt is one of
 * the following forms:
 *
 *   - ALTER TABLE RENAME
 *   - ALTER TABLE RENAME COLUMN
 *   - ALTER TABLE RENAME CONSTRAINT
 */</comment>
<function><type><name>bool</name></type>
<name>IsAlterTableRenameStmt</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>renameStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isAlterTableRenameStmt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>renameStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>||</operator>
		<name><name>renameStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isAlterTableRenameStmt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>renameStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_COLUMN</name> <operator>&amp;&amp;</operator>
			 <operator>(</operator><name><name>renameStmt</name><operator>-&gt;</operator><name>relationType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>||</operator>
			  <name><name>renameStmt</name><operator>-&gt;</operator><name>relationType</name></name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isAlterTableRenameStmt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>renameStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TABCONSTRAINT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isAlterTableRenameStmt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>isAlterTableRenameStmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfAlterDropsPartitionColumn checks if any subcommands of the given alter table
 * command is a DROP COLUMN command which drops the partition column of a distributed
 * table. If there is such a subcommand, this function errors out.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfAlterDropsPartitionColumn</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* first check whether a distributed relation is affected */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>relation</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>leftRelationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isCitusRelation</name> <init>= <expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCitusRelation</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* then check if any of subcommands drop partition column.*/</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableType</name></type> <name>alterTableType</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_DropColumn</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>AlterInvolvesPartitionColumn</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute ALTER TABLE command "</literal>
									   <literal type="string">"dropping partition column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessAlterTableStmt runs after the ALTER TABLE command has already run
 * on the master, so we are checking constraints over the table with constraints
 * already defined (to make the constraint check process same for ALTER TABLE and
 * CREATE TABLE). If constraints do not fulfill the rules we defined, they will be
 * removed and the table will return back to the state before the ALTER TABLE command.
 */</comment>
<function><type><name>void</name></type>
<name>PostprocessAlterTableStmt</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * check whether we are dealing with a sequence here
		 * if yes, it must be ALTER TABLE .. OWNER TO .. command
		 * since this is the only ALTER command of a sequence that
		 * passes through an AlterTableStmt
		 */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name>relKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AlterTableStmtObjType_compat</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>OBJECT_SEQUENCE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PostprocessAlterSequenceOwnerStmt</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>alterTableStatement</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>relKind</name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AlterTableStmtObjType_compat</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>OBJECT_VIEW</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PostprocessAlterViewStmt</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>alterTableStatement</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Before ensuring each dependency exist, update dependent sequences
		 * types if necessary.
		 */</comment>
		<expr_stmt><expr><call><name>EnsureRelationHasCompatibleSequenceTypes</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* changing a relation could introduce new dependencies */</comment>
		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>tableAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>tableAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>tableAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* for the new sequences coming with this ALTER TABLE statement */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>needMetadataSyncForNewSequences</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alterTableDefaultNextvalCmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableType</name></type> <name>alterTableType</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AddConstraint</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ErrorIfUnsupportedAlterAddConstraintStmt</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>InvalidateForeignKeyGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AddColumn</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>columnDefinition</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnConstraints</name> <init>= <expr><name><name>columnDefinition</name><operator>-&gt;</operator><name>constraints</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>columnConstraints</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ErrorIfUnsupportedAlterAddConstraintStmt</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>constraint</argument>, <argument>columnConstraints</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name> <operator>||</operator>
					 <name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_UNIQUE</name> <operator>||</operator>
					 <name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name> <operator>||</operator>
					 <name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_CHECK</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ErrorUnsupportedAlterTableAddColumn</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>command</name></expr></argument>,
														<argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * We check for ADD COLUMN .. DEFAULT expr
			 * if expr contains nextval('user_defined_seq')
			 * we should make sure that the type of the column that uses
			 * that sequence is supported
			 */</comment>
			<expr_stmt><expr><name>constraint</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>constraint</argument>, <argument>columnConstraints</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name></expr></argument>,
												   <argument><expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * We should make sure that the type of the column that uses
						 * that sequence is supported
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>contain_nextval_expression_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
														   <argument><expr><name><name>columnDefinition</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Oid</name></type> <name>seqOid</name> <init>= <expr><call><name>GetSequenceOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<if_stmt><if>if <condition>(<expr><name>seqOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<expr_stmt><expr><name>needMetadataSyncForNewSequences</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
									<expr_stmt><expr><name>alterTableDefaultNextvalCmd</name> <operator>=</operator>
										<call><name>GetAddColumnWithNextvalDefaultCmd</name><argument_list>(<argument><expr><name>seqOid</name></expr></argument>,
																		  <argument><expr><name>relationId</name></expr></argument>,
																		  <argument><expr><name><name>columnDefinition</name>
																		  <operator>-&gt;</operator><name>colname</name></name></expr></argument>,
																		  <argument><expr><name><name>columnDefinition</name>
																		  <operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								</block_content>}</block></if></if_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<comment type="block">/*
		 * We check for ALTER COLUMN .. SET DEFAULT nextval('user_defined_seq')
		 * we should make sure that the type of the column that uses
		 * that sequence is supported
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_ColumnDefault</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
									   <argument><expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>contain_nextval_expression_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>seqOid</name> <init>= <expr><call><name>GetSequenceOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>seqOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>needMetadataSyncForNewSequences</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>alterTableDefaultNextvalCmd</name> <operator>=</operator> <call><name>GetAlterColumnWithNextvalDefaultCmd</name><argument_list>(
							<argument><expr><name>seqOid</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>needMetadataSyncForNewSequences</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* prevent recursive propagation */</comment>
		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * It's easy to retrieve the sequence id to create the proper commands
		 * in postprocess, after the dependency between the sequence and the table
		 * has been created. We already return ddlJobs in PreprocessAlterTableStmt,
		 * hence we can't return ddlJobs in PostprocessAlterTableStmt.
		 * That's why we execute the following here instead of
		 * in ExecuteDistributedDDLJob
		 */</comment>
		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>alterTableDefaultNextvalCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FixAlterTableStmtIndexNames runs after the ALTER TABLE command
 * has already run on the coordinator, and also after the distributed DDL
 * Jobs have been executed on the workers.
 *
 * We might have wrong index names generated on indexes of shards of partitions,
 * see https://github.com/citusdata/citus/pull/5397 for the details. So we
 * perform the relevant checks and index renaming here.
 */</comment>
<function><type><name>void</name></type>
<name>FixAlterTableStmtIndexNames</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		  <call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we are only interested in partitioned Citus tables */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableType</name></type> <name>alterTableType</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this a partitioned table, and the constraint type uses an index
		 * UNIQUE, PRIMARY KEY, EXCLUDE constraint,
		 * we have wrong index names generated on indexes of shards of
		 * partitions of this table, so we should fix them
		 */</comment>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AddConstraint</name> <operator>&amp;&amp;</operator>
			<call><name>ConstrTypeUsesIndex</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>constraintId</name> <init>=
				<expr><call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* fix only the relevant index */</comment>
			<decl_stmt><decl><type><name>Oid</name></type> <name>parentIndexOid</name> <init>= <expr><call><name>get_constraint_index</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FixPartitionShardIndexNames</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>parentIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/*
		 * If this is an ALTER TABLE .. ATTACH PARTITION command
		 * we have wrong index names generated on indexes of shards of
		 * the current partition being attached, so we should fix them
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AttachPartition</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>partitionCommand</name> <init>= <expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>partitionMissingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>partitionRelationId</name> <init>=
				<expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>partitionCommand</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
								 <argument><expr><name>partitionMissingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>parentIndexOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* fix all the indexes */</comment>

			<expr_stmt><expr><call><name>FixPartitionShardIndexNames</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>, <argument><expr><name>parentIndexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetSequenceOid returns the oid of the sequence used as default value
 * of the attribute with given attnum of the given table relationId
 * If there is no sequence used it returns InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetSequenceOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* get attrdefoid from the given relationId and attnum */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>attrdefOid</name> <init>= <expr><call><name>get_attrdef_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* retrieve the sequence id of the sequence found in nextval('seq') */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sequencesFromAttrDef</name> <init>= <expr><call><name>GetSequencesFromAttrDef</name><argument_list>(<argument><expr><name>attrdefOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>sequencesFromAttrDef</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need this check because sometimes there are cases where the
		 * dependency between the table and the sequence is not formed
		 * One example is when the default is defined by
		 * DEFAULT nextval('seq_name'::text) (not by DEFAULT nextval('seq_name'))
		 * In these cases, sequencesFromAttrDef with be empty.
		 */</comment>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>sequencesFromAttrDef</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* to simplify and eliminate cases like "DEFAULT nextval('..') - nextval('..')" */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"More than one sequence in a column default"</literal>
							<literal type="string">" is not supported for distribution "</literal>
							<literal type="string">"or for adding local tables to metadata"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>sequencesFromAttrDef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_attrdef_oid gets the oid of the attrdef that has dependency with
 * the given relationId (refobjid) and attnum (refobjsubid).
 * If there is no such attrdef it returns InvalidOid.
 * NOTE: we are iterating pg_depend here since this function is used together
 * with other functions that iterate pg_depend. Normally, a look at pg_attrdef
 * would make more sense.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>get_attrdef_oid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>resultAttrdefOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>depRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>DependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name>attnum</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>deprec</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>deprec</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator> <name>AttrDefaultRelationId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>resultAttrdefOid</name> <operator>=</operator> <name><name>deprec</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>depRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>resultAttrdefOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAlterColumnWithNextvalDefaultCmd returns a string representing:
 * ALTER TABLE ALTER COLUMN .. SET DEFAULT nextval()
 * If sequence type is not bigint, we use worker_nextval() instead of nextval().
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetAlterColumnWithNextvalDefaultCmd</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedSequenceName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nextvalFunctionName</name> <init>= <expr><literal type="string">"nextval"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>useWorkerNextval</name> <init>= <expr><operator>(</operator><call><name>pg_get_sequencedef</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>seqtypid</name> <operator>!=</operator> <name>INT8OID</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>useWorkerNextval</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We use worker_nextval for int and smallint types.
		 * Check issue #5126 and PR #5254 for details.
		 * https://github.com/citusdata/citus/issues/5126
		 */</comment>
		<expr_stmt><expr><name>nextvalFunctionName</name> <operator>=</operator> <literal type="string">"worker_nextval"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s ALTER COLUMN %s "</literal>
						   <literal type="string">"SET DEFAULT %s(%s::regclass)"</literal></expr></argument>,
					 <argument><expr><name>qualifiedRelationName</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>,
					 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>, <argument><expr><name>nextvalFunctionName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedSequenceName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAddColumnWithNextvalDefaultCmd returns a string representing:
 * ALTER TABLE ADD COLUMN .. DEFAULT nextval()
 * If sequence type is not bigint, we use worker_nextval() instead of nextval().
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetAddColumnWithNextvalDefaultCmd</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name></decl></parameter>,
								  <parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedSequenceName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nextvalFunctionName</name> <init>= <expr><literal type="string">"nextval"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>useWorkerNextval</name> <init>= <expr><operator>(</operator><call><name>pg_get_sequencedef</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>seqtypid</name> <operator>!=</operator> <name>INT8OID</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>useWorkerNextval</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We use worker_nextval for int and smallint types.
		 * Check issue #5126 and PR #5254 for details.
		 * https://github.com/citusdata/citus/issues/5126
		 */</comment>
		<expr_stmt><expr><name>nextvalFunctionName</name> <operator>=</operator> <literal type="string">"worker_nextval"</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int32</name></type> <name>typmod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bits16</name></type> <name>formatFlags</name> <init>= <expr><name>FORMAT_TYPE_TYPEMOD_GIVEN</name> <operator>|</operator> <name>FORMAT_TYPE_FORCE_QUALIFY</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>,
					 <argument><expr><literal type="string">"ALTER TABLE %s ADD COLUMN %s %s "</literal>
					 <literal type="string">"DEFAULT %s(%s::regclass)"</literal></expr></argument>, <argument><expr><name>qualifiedRelationName</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>,
					 <argument><expr><call><name>format_type_extended</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>formatFlags</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><literal type="string">"pg_catalog"</literal></expr></argument>, <argument><expr><name>nextvalFunctionName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedSequenceName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ErrorUnsupportedAlterTableAddColumn</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name></decl></parameter>,
									<parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>columnDefinition</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colName</name> <init>= <expr><name><name>columnDefinition</name><operator>-&gt;</operator><name>colname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errMsg</name> <init>=
		<expr><literal type="string">"cannot execute ADD COLUMN command with PRIMARY KEY, UNIQUE, FOREIGN and CHECK constraints"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>errHint</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">"You can issue each command separately such as "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>,
					 <argument><expr><literal type="string">"ALTER TABLE %s ADD COLUMN %s data_type; ALTER TABLE %s ADD CONSTRAINT constraint_name "</literal></expr></argument>,
					 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>colName</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_UNIQUE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">"UNIQUE (%s)"</literal></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">"PRIMARY KEY (%s)"</literal></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_CHECK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">"CHECK (check_expression)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>referencedTable</name> <init>= <expr><name><name>constraint</name><operator>-&gt;</operator><name>pktable</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>referencedColumn</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>pk_attrs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>referencedRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>referencedTable</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN KEY (%s) REFERENCES %s(%s)"</literal></expr></argument>, <argument><expr><name>colName</name></expr></argument>,
						 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>referencedRelationId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>referencedColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETNULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><literal type="string">"ON DELETE SET NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_CASCADE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><literal type="string">"ON DELETE CASCADE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETDEFAULT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><literal type="string">"ON DELETE SET DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>fk_del_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_RESTRICT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><literal type="string">"ON DELETE RESTRICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETNULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><literal type="string">"ON UPDATE SET NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_CASCADE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><literal type="string">"ON UPDATE CASCADE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETDEFAULT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><literal type="string">"ON UPDATE SET DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>fk_upd_action</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_RESTRICT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><literal type="string">"ON UPDATE RESTRICT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>errHint</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errMsg</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>errHint</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Adding a column with a constraint in "</literal>
							  <literal type="string">"one command is not supported because "</literal>
							  <literal type="string">"all constraints in Citus must have "</literal>
							  <literal type="string">"explicit names"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedConstraint runs checks related to unique index / exclude
 * constraints.
 *
 * The function skips the uniqeness checks for reference tables (i.e., distribution
 * method is 'none').
 *
 * Forbid UNIQUE, PRIMARY KEY, or EXCLUDE constraints on append partitioned
 * tables, since currently there is no way of enforcing uniqueness for
 * overlapping shards.
 *
 * Similarly, do not allow such constraints if they do not include partition
 * column. This check is important for two reasons:
 * i. First, currently Citus does not enforce uniqueness constraint on multiple
 * shards.
 * ii. Second, INSERT INTO .. ON CONFLICT (i.e., UPSERT) queries can be executed
 * with no further check for constraints.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfUnsupportedConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>distributionMethod</name></decl></parameter>,
							 <parameter><decl><type><name>char</name></type> <name>referencingReplicationModel</name></decl></parameter>,
							 <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>colocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We first perform check for foreign constraints. It is important to do this
	 * check before next check, because other types of constraints are allowed on
	 * reference tables and we return early for those constraints thanks to next
	 * check. Therefore, for reference tables, we first check for foreign constraints
	 * and if they are OK, we do not error out for other types of constraints.
	 */</comment>
	<expr_stmt><expr><call><name>ErrorIfUnsupportedForeignConstraintExists</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>,
											  <argument><expr><name>referencingReplicationModel</name></expr></argument>,
											  <argument><expr><name>distributionColumn</name></expr></argument>,
											  <argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Citus supports any kind of uniqueness constraints for reference tables
	 * given that they only consist of a single shard and we can simply rely on
	 * Postgres.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>distributionColumn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution column of distributed table is NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexOidList</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>indexOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>indexOid</argument>, <argument>indexOidList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>indexDesc</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>hasDistributionColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* extract index key information from the index's pg_index info */</comment>
		<decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name> <init>= <expr><call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>indexDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* only check unique indexes and exclusion constraints. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexDesc</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Citus cannot enforce uniqueness/exclusion constraints with overlapping shards.
		 * Thus, emit a warning for unique indexes and exclusion constraints on
		 * append partitioned tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>distributionMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_APPEND</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" has a UNIQUE or EXCLUDE constraint"</literal></expr></argument>,
									 <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"UNIQUE constraints, EXCLUDE constraints, "</literal>
										<literal type="string">"and PRIMARY KEYs on "</literal>
										<literal type="string">"append-partitioned tables cannot be enforced."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							  <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using hash partitioning."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>AllowUnsafeConstraints</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The user explicitly wants to allow the constraint without
			 * distribution column.
			 */</comment>
			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexDesc</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>attributeCount</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attributeNumberArray</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>attributeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>attributeIndex</name> <operator>&lt;</operator> <name>attributeCount</name></expr>;</condition> <incr><expr><name>attributeIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attributeNumber</name> <init>= <expr><name><name>attributeNumberArray</name><index>[<expr><name>attributeIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>distributionColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>attributeNumber</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name>uniqueConstraint</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>exclusionConstraintWithEquality</name> <init>= <expr><operator>(</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
													<call><name>OperatorImplementsEquality</name><argument_list>(
														<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name><index>[
															<expr><name>attributeIndex</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>uniqueConstraint</name> <operator>||</operator> <name>exclusionConstraintWithEquality</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>hasDistributionColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasDistributionColumn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator>
						<call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create constraint on \"%s\""</literal></expr></argument>,
							   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distributed relations cannot have UNIQUE, "</literal>
								  <literal type="string">"EXCLUDE, or PRIMARY KEY constraints that do not "</literal>
								  <literal type="string">"include the partition column (with an equality "</literal>
								  <literal type="string">"operator if EXCLUDE)."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexDesc</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedAlterTableStmt checks if the corresponding alter table
 * statement is supported for distributed tables and errors out if it is not.
 * Currently, only the following commands are supported.
 *
 * ALTER TABLE ADD|DROP COLUMN
 * ALTER TABLE ALTER COLUMN SET DATA TYPE
 * ALTER TABLE SET|DROP NOT NULL
 * ALTER TABLE SET|DROP DEFAULT
 * ALTER TABLE ADD|DROP CONSTRAINT
 * ALTER TABLE REPLICA IDENTITY
 * ALTER TABLE SET ()
 * ALTER TABLE ENABLE|DISABLE|NO FORCE|FORCE ROW LEVEL SECURITY
 * ALTER TABLE RESET ()
 * ALTER TABLE ENABLE/DISABLE TRIGGER (if enable_unsafe_triggers is not set, we only support triggers for citus local tables)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedAlterTableStmt</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* error out if any of the subcommands are unsupported */</comment>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableType</name></type> <name>alterTableType</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>alterTableType</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_AddColumn</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Check for SERIAL pseudo-types. The structure of this
					 * check is copied from transformColumnDefinition.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
						<operator>!</operator><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>pct_type</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"smallserial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial4"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"bigserial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
							<call><name>strcmp</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><literal type="string">"serial8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * We currently don't support adding a serial column for an MX table
							 * TODO: record the dependency in the workers
							 */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
												<call><name>errmsg</name><argument_list>(
													<argument><expr><literal type="string">"cannot execute ADD COLUMN commands involving serial"</literal>
													<literal type="string">" pseudotypes when metadata is synchronized to workers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/*
							 * we only allow adding a serial column if it is the only subcommand
							 * and it has no constraints
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name><name>commandList</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>column</name><operator>-&gt;</operator><name>constraints</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(
													<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
												<call><name>errmsg</name><argument_list>(
													<argument><expr><literal type="string">"cannot execute ADD COLUMN commands involving "</literal>
													<literal type="string">"serial pseudotypes with other subcommands/constraints"</literal></expr></argument>)</argument_list></call><operator>,</operator>
												<call><name>errhint</name><argument_list>(
													<argument><expr><literal type="string">"You can issue each subcommand separately"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/*
							 * Currently we don't support backfilling the new column with default values
							 * if the table is not empty
							 */</comment>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TableEmpty</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(
													<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
												<call><name>errmsg</name><argument_list>(
													<argument><expr><literal type="string">"Cannot add a column involving serial pseudotypes "</literal>
													<literal type="string">"because the table is not empty"</literal></expr></argument>)</argument_list></call><operator>,</operator>
												<call><name>errhint</name><argument_list>(
													<argument><expr><literal type="string">"You can first call ALTER TABLE .. ADD COLUMN .. smallint/int/bigint\n"</literal>
													<literal type="string">"Then set the default by ALTER TABLE .. ALTER COLUMN .. SET DEFAULT nextval('..')"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnConstraints</name> <init>= <expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name></expr></init></decl>;</decl_stmt>

					<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<macro><name>foreach_ptr</name><argument_list>(<argument>constraint</argument>, <argument>columnConstraints</argument>)</argument_list></macro>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_DEFAULT</name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
							<block>{<block_content>
								<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name></expr></argument>,
														   <argument><expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

								<if_stmt><if>if <condition>(<expr><call><name>contain_nextval_expression_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<comment type="block">/*
									 * we only allow adding a column with non_const default
									 * if its the only subcommand and has no other constraints
									 */</comment>
									<if_stmt><if>if <condition>(<expr><name><name>commandList</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator>
										<name><name>columnConstraints</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
									<block>{<block_content>
										<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(
															<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
														<call><name>errmsg</name><argument_list>(
															<argument><expr><literal type="string">"cannot execute ADD COLUMN .. DEFAULT nextval('..')"</literal>
															<literal type="string">" command with other subcommands/constraints"</literal></expr></argument>)</argument_list></call><operator>,</operator>
														<call><name>errhint</name><argument_list>(
															<argument><expr><literal type="string">"You can issue each subcommand separately"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									</block_content>}</block></if></if_stmt>

									<comment type="block">/*
									 * Currently we don't support backfilling the new column with default values
									 * if the table is not empty
									 */</comment>
									<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TableEmpty</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
									<block>{<block_content>
										<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(
															<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
														<call><name>errmsg</name><argument_list>(
															<argument><expr><literal type="string">"cannot add a column involving DEFAULT nextval('..') "</literal>
															<literal type="string">"because the table is not empty"</literal></expr></argument>)</argument_list></call><operator>,</operator>
														<call><name>errhint</name><argument_list>(
															<argument><expr><literal type="string">"You can first call ALTER TABLE .. ADD COLUMN .. smallint/int/bigint\n"</literal>
															<literal type="string">"Then set the default by ALTER TABLE .. ALTER COLUMN .. SET DEFAULT nextval('..')"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									</block_content>}</block></if></if_stmt>
								</block_content>}</block></if></if_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AT_ColumnDefault</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>AlterInvolvesPartitionColumn</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute ALTER TABLE command "</literal>
										   <literal type="string">"involving partition column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></argument>,
										   <argument><expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>contain_nextval_expression_walker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * we only allow altering a column's default to non_const expr
					 * if its the only subcommand
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>commandList</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(
											<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
										<call><name>errmsg</name><argument_list>(
											<argument><expr><literal type="string">"cannot execute ALTER COLUMN COLUMN .. SET DEFAULT "</literal>
											<literal type="string">"nextval('..') command with other subcommands"</literal></expr></argument>)</argument_list></call><operator>,</operator>
										<call><name>errhint</name><argument_list>(
											<argument><expr><literal type="string">"You can issue each subcommand separately"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>AlterInvolvesPartitionColumn</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute ALTER TABLE command "</literal>
										   <literal type="string">"involving partition column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We check for ALTER COLUMN TYPE ...
				 * if the column has default coming from a user-defined sequence
				 * changing the type of the column should not be allowed for now
				 */</comment>
				<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attnum</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>seqInfoList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>GetDependentSequencesWithRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqInfoList</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>seqInfoList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute ALTER COLUMN TYPE .. command "</literal>
										   <literal type="string">"because the column involves a default coming "</literal>
										   <literal type="string">"from a sequence"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AT_DropColumn</name></expr>:</case>
			<case>case <expr><name>AT_DropNotNull</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>AlterInvolvesPartitionColumn</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute ALTER TABLE command "</literal>
										   <literal type="string">"involving partition column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AT_AddConstraint</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* we only allow constraints if they are only subcommand */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>commandList</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute ADD CONSTRAINT command with "</literal>
										   <literal type="string">"other subcommands"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can issue each subcommand separately"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We will use constraint name in each placement by extending it at
				 * workers. Therefore we require it to be exist.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We support ALTER TABLE ... ADD PRIMARY ... commands by creating a constraint name
					 * and changing the command into the following form.
					 * ALTER TABLE ... ADD CONSTRAINT &lt;constaint_name&gt; PRIMARY KEY ...
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTR_PRIMARY</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
										<call><name>errmsg</name><argument_list>(
											<argument><expr><literal type="string">"cannot create constraint without a name on a "</literal>
											<literal type="string">"distributed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>partitionCommand</name> <init>= <expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>missingOK</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>partitionRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>partitionCommand</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
														   <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>missingOK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* we only allow partitioning commands if they are only subcommand */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>commandList</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute ATTACH PARTITION command "</literal>
										   <literal type="string">"with other subcommands"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can issue each subcommand "</literal>
											<literal type="string">"separately."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Citus Local Tables cannot be colocated with other tables.
					 * If either of two relations is not a Citus Local Table, then we
					 * don't need to check colocation since CreateCitusLocalTable would
					 * anyway throw an error.
					 */</comment>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>TablesColocated</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributed tables cannot have "</literal>
										   <literal type="string">"non-colocated distributed tables as a "</literal>
										   <literal type="string">"partition "</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
			<case>case <expr><name>AT_DetachPartitionFinalize</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE .. DETACH PARTITION .. FINALIZE "</literal>
									   <literal type="string">"commands are currently unsupported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* we only allow partitioning commands if they are only subcommand */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>commandList</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute DETACH PARTITION command "</literal>
										   <literal type="string">"with other subcommands"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can issue each subcommand "</literal>
											<literal type="string">"separately."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
				<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>partitionCommand</name> <init>= <expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>partitionCommand</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ALTER TABLE .. DETACH PARTITION .. "</literal>
										   <literal type="string">"CONCURRENTLY commands are currently "</literal>
										   <literal type="string">"unsupported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AT_EnableTrig</name></expr>:</case>
			<case>case <expr><name>AT_EnableAlwaysTrig</name></expr>:</case>
			<case>case <expr><name>AT_EnableReplicaTrig</name></expr>:</case>
			<case>case <expr><name>AT_EnableTrigUser</name></expr>:</case>
			<case>case <expr><name>AT_DisableTrig</name></expr>:</case>
			<case>case <expr><name>AT_DisableTrigUser</name></expr>:</case>
			<case>case <expr><name>AT_EnableTrigAll</name></expr>:</case>
			<case>case <expr><name>AT_DisableTrigAll</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Postgres already does not allow executing ALTER TABLE TRIGGER
				 * commands with other subcommands, but let's be on the safe side.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>commandList</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute ENABLE/DISABLE TRIGGER "</literal>
										   <literal type="string">"command with other subcommands"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can issue each subcommand separately"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>ErrorOutForTriggerIfNotSupported</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
			<case>case <expr><name>AT_SetAccessMethod</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<case>case <expr><name>AT_SetNotNull</name></expr>:</case>
			<case>case <expr><name>AT_ReplicaIdentity</name></expr>:</case>
			<case>case <expr><name>AT_ChangeOwner</name></expr>:</case>
			<case>case <expr><name>AT_EnableRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_DisableRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_ForceRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_NoForceRowSecurity</name></expr>:</case>
			<case>case <expr><name>AT_ValidateConstraint</name></expr>:</case>
			<case>case <expr><name>AT_DropConstraint</name></expr>:</case> <comment type="block">/* we do the check for invalidation in AlterTableDropsForeignKey */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
			<case>case <expr><name>AT_SetCompression</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<block>{<block_content>
					<comment type="block">/*
					 * We will not perform any special check for:
					 * ALTER TABLE .. SET ACCESS METHOD ..
					 * ALTER TABLE .. ALTER COLUMN .. SET NOT NULL
					 * ALTER TABLE .. REPLICA IDENTITY ..
					 * ALTER TABLE .. VALIDATE CONSTRAINT ..
					 * ALTER TABLE .. ALTER COLUMN .. SET COMPRESSION ..
					 */</comment>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>AT_SetRelOptions</name></expr>:</case>  <comment type="block">/* SET (...) */</comment>
			<case>case <expr><name>AT_ResetRelOptions</name></expr>:</case>    <comment type="block">/* RESET (...) */</comment>
			<case>case <expr><name>AT_ReplaceRelOptions</name></expr>:</case>  <comment type="block">/* replace entire option list */</comment>
			<case>case <expr><name>AT_SetLogged</name></expr>:</case>
			<case>case <expr><name>AT_SetUnLogged</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* this command is supported by Citus */</comment>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AT_GenericOptions</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* fallthrough */</comment>

			<default>default:</default>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"alter table command is currently unsupported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Only ADD|DROP COLUMN, SET|DROP NOT NULL, "</literal>
								   <literal type="string">"SET|DROP DEFAULT, ADD|DROP|VALIDATE CONSTRAINT, "</literal>
								   <literal type="string">"SET (), RESET (), "</literal>
								   <literal type="string">"ENABLE|DISABLE|NO FORCE|FORCE ROW LEVEL SECURITY, "</literal>
								   <literal type="string">"ATTACH|DETACH PARTITION and TYPE subcommands "</literal>
								   <literal type="string">"are supported."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SetupExecutionModeForAlterTable is the function that is responsible
 * for two things for practical purpose for not doing the same checks
 * twice:
 *     (a) For any command, decide and return whether we should
 *         run the command in sequential mode
 *     (b) For commands in a transaction block, set the transaction local
 *         multi-shard modify mode to sequential when necessary
 *
 * The commands that operate on the same reference table shard in parallel
 * is in the interest of (a), where the return value indicates the executor
 * to run the command sequentially to prevent self-deadlocks.
 *
 * The commands that both operate on the same reference table shard in parallel
 * and cascades to run any parallel operation is in the interest of (b). By
 * setting the multi-shard mode, we ensure that the cascading parallel commands
 * are executed sequentially to prevent self-deadlocks.
 *
 * One final note on the function is that if the function decides to execute
 * the command in sequential mode, and a parallel command has already been
 * executed in the same transaction, the function errors out. See the comment
 * in the function for the rationale.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SetupExecutionModeForAlterTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>executeSequentially</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableType</name></type> <name>alterTableType</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>subtype</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_DropConstraint</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ConstraintIsAForeignKeyToReferenceTable</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>executeSequentially</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AddColumn</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * TODO: This code path will never be executed since we do not
		 * support foreign constraint creation via
		 * ALTER TABLE %s ADD COLUMN %s [constraint]. However, the code
		 * is kept in case we fix the constraint creation without a name
		 * and allow foreign key creation with the mentioned command.
		 */</comment>
		<decl_stmt><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>columnDefinition</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnConstraints</name> <init>= <expr><name><name>columnDefinition</name><operator>-&gt;</operator><name>constraints</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>constraint</argument>, <argument>columnConstraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>rightRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>pktable</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>executeSequentially</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_DropColumn</name> <operator>||</operator> <name>alterTableType</name> <operator>==</operator> <name>AT_AlterColumnType</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>affectedColumnName</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ColumnAppearsInForeignKeyToReferenceTable</name><argument_list>(<argument><expr><name>affectedColumnName</name></expr></argument>,
													  <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AlterColumnType</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>executeSequentially</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_AddConstraint</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need to execute the ddls working with reference tables on the
		 * right side sequentially, because parallel ddl operations
		 * relating to one and only shard of a reference table on a worker
		 * may cause self-deadlocks.
		 */</comment>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>command</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>rightRelationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>pktable</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>executeSequentially</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>alterTableType</name> <operator>==</operator> <name>AT_DetachPartition</name> <operator>||</operator> <name>alterTableType</name> <operator>==</operator> <name>AT_AttachPartition</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check if there are foreign constraints to reference tables */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HasForeignKeyToReferenceTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>executeSequentially</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there has already been a parallel query executed, the sequential mode
	 * would still use the already opened parallel connections to the workers for
	 * the distributed tables, thus contradicting our purpose of using
	 * sequential mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>executeSequentially</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot modify table \"%s\" because there "</literal>
							   <literal type="string">"was a parallel operation on a distributed table "</literal>
							   <literal type="string">"in the transaction"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"When there is a foreign key to a reference "</literal>
								  <literal type="string">"table, Citus needs to perform all operations "</literal>
								  <literal type="string">"over a single connection per node to ensure "</literal>
								  <literal type="string">"consistency."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
								<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
								<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>executeSequentially</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InterShardDDLTaskList builds a list of tasks to execute a inter shard DDL command on a
 * shards of given list of distributed table. At the moment this function is used to run
 * foreign key, partitioning and attaching partition index command on worker node.
 *
 * leftRelationId is the relation id of actual distributed table which given command is
 * applied. rightRelationId is the relation id of either index or distributed table which
 * given command refers to.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>InterShardDDLTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>leftRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rightRelationId</name></decl></parameter>,
					  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>leftShardList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightShardList</name> <init>= <expr><call><name>CreateRightShardListForInterShardDDLTask</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>,
																	<argument><expr><name>leftRelationId</name></expr></argument>,
																	<argument><expr><name>leftShardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* lock metadata before getting placement lists */</comment>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>leftShardList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>leftSchemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>leftSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>leftSchemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedLeftSchemaName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>leftSchemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>rightSchemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rightSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>rightSchemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedRightSchemaName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>rightSchemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedCommandString</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth_ptr</name><argument_list>(<argument>leftShardInterval</argument>, <argument>leftShardList</argument>, <argument>rightShardInterval</argument>, <argument>rightShardList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>leftShardId</name> <init>= <expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>rightShardId</name> <init>= <expr><name><name>rightShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>applyCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>applyCommand</name></expr></argument>, <argument><expr><name>WORKER_APPLY_INTER_SHARD_DDL_COMMAND</name></expr></argument>,
						 <argument><expr><name>leftShardId</name></expr></argument>, <argument><expr><name>escapedLeftSchemaName</name></expr></argument>, <argument><expr><name>rightShardId</name></expr></argument>,
						 <argument><expr><name>escapedRightSchemaName</name></expr></argument>, <argument><expr><name>escapedCommandString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>DDL_TASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name><name>applyCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>leftShardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetInterShardDDLTaskPlacementList</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>leftShardInterval</name></expr></argument>, <argument><expr><name>rightShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetInterShardDDLTaskRelationShardList</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>leftShardInterval</name></expr></argument>,
											  <argument><expr><name>rightShardInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateRightShardListForInterShardDDLTask is a helper function that creates
 * shard list for the right relation for InterShardDDLTaskList.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CreateRightShardListForInterShardDDLTask</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rightRelationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>leftRelationId</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>leftShardList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rightShardList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the right relation is a reference table and left relation is not
		 * a citus local table, we need to make sure that the tasks are created
		 * in a way that the right shard stays the same since we only have one
		 * placement per worker.
		 * If left relation is a citus local table, then we don't need to populate
		 * reference table shards as we will execute ADD/DROP constraint command
		 * only for coordinator placement of reference table.
		 */</comment>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShard</name> <init>= <expr><operator>(</operator><name>ShardInterval</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>rightShardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>leftShardCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>leftShardList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>rightShardList</name> <operator>=</operator> <call><name>GenerateListFromElement</name><argument_list>(<argument><expr><name>rightShard</name></expr></argument>, <argument><expr><name>leftShardCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rightShardList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetInterShardDDLTaskPlacementList sets taskPlacementList field of given
 * inter-shard DDL task according to passed shard interval arguments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetInterShardDDLTaskPlacementList</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name></decl></parameter>,
								  <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>leftRelationId</name> <init>= <expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>rightRelationId</name> <init>= <expr><name><name>rightShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>leftRelationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>rightRelationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are defining/dropping a foreign key from a reference table
		 * to a citus local table, then we will execute ADD/DROP constraint
		 * command only for coordinator placement of reference table.
		 */</comment>
		<decl_stmt><decl><type><name>uint64</name></type> <name>leftShardId</name> <init>= <expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>ActiveShardPlacementListOnGroup</name><argument_list>(<argument><expr><name>leftShardId</name></expr></argument>,
																  <argument><expr><name>COORDINATOR_GROUP_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>leftShardId</name> <init>= <expr><name><name>leftShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>leftShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SetInterShardDDLTaskRelationShardList sets relationShardList field of given
 * inter-shard DDL task according to passed shard interval arguments.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetInterShardDDLTaskRelationShardList</name><parameter_list>(<parameter><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name></decl></parameter>, <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>leftShardInterval</name></decl></parameter>,
									  <parameter><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>rightShardInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>leftRelationShard</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>RelationShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>leftRelationShard</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>leftShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>leftRelationShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>leftShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RelationShard</name> <modifier>*</modifier></type><name>rightRelationShard</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>RelationShard</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rightRelationShard</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>rightShardInterval</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rightRelationShard</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name><name>rightShardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>relationShardList</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>leftRelationShard</name></expr></argument>, <argument><expr><name>rightRelationShard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AlterInvolvesPartitionColumn checks if the given alter table command
 * involves relation's partition column.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>AlterInvolvesPartitionColumn</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>,
							 <parameter><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>involvesPartitionColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alterColumnName</name> <init>= <expr><name><name>command</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>alterColumnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>targetAttr</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* reference tables do not have partition column, so allow them */</comment>
		<if_stmt><if>if <condition>(<expr><name>partitionColumn</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>targetAttr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>==</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>involvesPartitionColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>involvesPartitionColumn</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedAlterAddConstraintStmt runs the constraint checks on distributed
 * table using the same logic with create_distributed_table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedAlterAddConstraintStmt</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockmode</name> <init>= <expr><call><name>AlterTableGetLockLevel</name><argument_list>(<argument><expr><name><name>alterTableStatement</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>AlterTableLookupRelation</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>distributionMethod</name> <init>= <expr><call><name>PartitionMethod</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>referencingReplicationModel</name> <init>= <expr><call><name>TableReplicationModel</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfUnsupportedConstraint</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>,
								 <argument><expr><name>referencingReplicationModel</name></expr></argument>,
								 <argument><expr><name>distributionColumn</name></expr></argument>, <argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTableSchemaStmtObjectAddress returns the ObjectAddress of the table that
 * is the object of the AlterObjectSchemaStmt.
 *
 * This could be called both before or after it has been applied locally. It will
 * look in the old schema first, if the table cannot be found in that schema it
 * will look in the new schema. Errors if missing_ok is false and the table cannot
 * be found in either of the schemas.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterTableSchemaStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tableName</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tableOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>schemaOid</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>tableOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>tableOid</name> <operator>=</operator> <call><name>RelnameGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>tableOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newSchemaName</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>newSchemaOid</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>newSchemaName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>tableOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>newSchemaOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name> <operator>&amp;&amp;</operator> <name>tableOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedTableName</name> <init>=
				<expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist"</literal></expr></argument>,
								   <argument><expr><name>quotedTableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>tableOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MakeNameListFromRangeVar makes a namelist from a RangeVar. Its behaviour
 * should be the exact opposite of postgres' makeRangeVarFromNameList.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>MakeNameListFromRangeVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>catalogname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>catalogname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
