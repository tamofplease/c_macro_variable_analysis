<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/commands/multi_copy.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * multi_copy.c
 *     This file contains implementation of COPY utility for distributed
 *     tables.
 *
 * The CitusCopyFrom function should be called from the utility hook to process
 * COPY ... FROM commands on distributed tables. CitusCopyFrom parses the input
 * from stdin, a program, or a file, and decides to copy new rows to existing
 * shards or new shards based on the partition method of the distributed table.
 *
 * If this is the first command in the transaction, we open a new connection for
 * every shard placement. Otherwise we open as many connections as we can to
 * not conflict with previous commands in transactions, in which case some shards
 * may share connections. See the comments of CopyConnectionState for how we
 * operate in that case.
 *
 * We use the PQputCopyData function to copy the data. Because PQputCopyData
 * transmits data asynchronously, the workers will ingest data at least partially
 * in parallel.
 *
 * For hash-partitioned tables, if it fails to connect to a worker, the master
 * rollbacks the distributed transaction, similar to the way DML statements
 * are handled. If a failure occurs after connecting, the transaction
 * is rolled back on all the workers. Note that,
 * in the case of append-partitioned tables, if a fail occurs, immediately
 * metadata changes are rolled back on the master node, but shard placements
 * are left on the worker nodes.
 *
 * By default, COPY uses normal transactions on the workers. In the case of
 * hash or range-partitioned tables, this can cause a problem when some of the
 * transactions fail to commit while others have succeeded. To ensure no data
 * is lost, COPY uses two-phase commit.
 *
 * Parsing options are processed and enforced on the node where copy command
 * is run, while constraints are enforced on the worker. In either case,
 * failure causes the whole COPY to roll back.
 *
 * Copyright (c) Citus Data, Inc.
 *
 * With contributions from Postgres Professional.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include> <comment type="block">/* for htons */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include> <comment type="block">/* for htons */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sdir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/multi_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/intermediate_results.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/log_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_router_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/locally_reserved_shared_connections.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/placement_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_pruning.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_connection_stats.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_multi_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transmit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/cmdtag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/* constant used in binary protocol */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>BinarySignature</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <init>= <expr><literal type="string">"PGCOPY\n\377\r\n\0"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* if true, skip validation of JSONB columns during COPY */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>SkipJsonbValidationInCopy</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* custom Citus option for appending to a shard */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_TO_SHARD_OPTION</name></cpp:macro> <cpp:value>"append_to_shard"</cpp:value></cpp:define>

<comment type="block">/*
 * Data size threshold to switch over the active placement for a connection.
 * If this is too low, overhead of starting COPY commands will hurt the
 * performance. If this is too high, buffered data will use lots of memory.
 * 4MB is a good balance between memory usage and performance. Note that this
 * is irrelevant in the common case where we open one connection per placement.
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>CopySwitchOverThresholdBytes</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_IS_OPEN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x &gt; -1)</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>CopyShardState</name></name></type> <name>CopyShardState</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>CopyPlacementState</name></name></type> <name>CopyPlacementState</name>;</typedef>

<comment type="block">/*
 * Multiple shard placements can share one connection. Each connection has one
 * of those placements as the activePlacementState, and others in the
 * bufferedPlacementList. When we want to send a tuple to a CopyPlacementState,
 * we check if it is the active one in its connectionState, and in this case we
 * directly put data on wire. Otherwise, we buffer it so we can put it on wire
 * later, when copy ends or a switch-over happens. See CitusSendTupleToPlacements()
 * for more details.
 *
 * This is done so we are compatible with adaptive_executor. If a previous command
 * in the current transaction has been executed using adaptive_executor.c, then
 * CopyGetPlacementConnection() might return the same connection for multiple
 * placements. We support that case by the buffering mechanism described above.
 *
 * If no previous command in the current transaction has used adaptive_executor.c,
 * then CopyGetPlacementConnection() returns one connection per placement and no
 * buffering happens and we put the copy data directly on connection.
 */</comment>
<typedef>typedef <type><struct>struct <name>CopyConnectionState</name>
<block>{
	<comment type="block">/* Used as hash key. Equal to PQsocket(connection-&gt;pgConn). */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>socket</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Placement for which we have an active COPY going on over connection.
	 * Can be NULL.
	 */</comment>
	<decl_stmt><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>activePlacementState</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Other placements that we are buffering data for. Later when a switch-over
	 * happens, we remove an item from this list and set it to activePlacementState.
	 * In this case, old activePlacementState isn't NULL, is added to this list.
	 */</comment>
	<decl_stmt><decl><type><name>dlist_head</name></type> <name>bufferedPlacementList</name></decl>;</decl_stmt>

	<comment type="block">/* length of bufferedPlacementList, to avoid iterations over the list when needed */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>bufferedPlacementCount</name></decl>;</decl_stmt>
}</block></struct></type> <name>CopyConnectionState</name>;</typedef>


<struct>struct <name>CopyPlacementState</name>
<block>{
	<comment type="block">/* Connection state to which the placemement is assigned to. */</comment>
	<decl_stmt><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name></decl>;</decl_stmt>

	<comment type="block">/* State of shard to which the placement belongs to. */</comment>
	<decl_stmt><decl><type><name>CopyShardState</name> <modifier>*</modifier></type><name>shardState</name></decl>;</decl_stmt>

	<comment type="block">/* node group ID of the placement */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>groupId</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Buffered COPY data. When the placement is activePlacementState of
	 * some connection, this is empty. Because in that case we directly
	 * send the data over connection.
	 */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>data</name></decl>;</decl_stmt>

	<comment type="block">/* List node for CopyConnectionState-&gt;bufferedPlacementList. */</comment>
	<decl_stmt><decl><type><name>dlist_node</name></type> <name>bufferedPlacementNode</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>CopyShardState</name>
<block>{
	<comment type="block">/* Used as hash key. */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name></decl>;</decl_stmt>

	<comment type="block">/* used for doing local copy, either for a shard or a co-located file */</comment>
	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl>;</decl_stmt>

	<comment type="block">/* used when copy is targeting co-located file */</comment>
	<decl_stmt><decl><type><name>FileCompat</name></type> <name>fileDest</name></decl>;</decl_stmt>

	<comment type="block">/* containsLocalPlacement is true if we have a local placement for the shard id of this state */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>containsLocalPlacement</name></decl>;</decl_stmt>

	<comment type="block">/* List of CopyPlacementStates for all active placements of the shard. */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>placementStateList</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/*
 * Represents the state for allowing copy via local
 * execution.
 */</comment>
<typedef>typedef <type><enum>enum <name>LocalCopyStatus</name>
<block>{
	<decl><name>LOCAL_COPY_REQUIRED</name></decl>,
	<decl><name>LOCAL_COPY_OPTIONAL</name></decl>,
	<decl><name>LOCAL_COPY_DISABLED</name></decl>
}</block></enum></type> <name>LocalCopyStatus</name>;</typedef>


<comment type="block">/* Local functions forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyToExistingShards</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>,
								 <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsCopyInBinaryFormat</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FindJsonbInputColumns</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
									<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>inputColumnNameList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>RemoveOptionFromList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>optionList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>optionName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>BinaryOutputFunctionDefined</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>BinaryInputFunctionDefined</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyBinaryHeaders</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyBinaryFooters</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>,
								  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>ConstructCopyStatement</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyDataToAll</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>dataBuffer</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyDataToPlacement</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>dataBuffer</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>,
									<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>AvailableColumnCount</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>TypeForColumnName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name> <modifier>*</modifier></type> <name>TypeArrayFromTupleDescriptor</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CopyCoercionData</name> <modifier>*</modifier></type> <name>ColumnCoercionPaths</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>destTupleDescriptor</name></decl></parameter>,
											  <parameter><decl><type><name>TupleDesc</name></type> <name>inputTupleDescriptor</name></decl></parameter>,
											  <parameter><decl><type><name>Oid</name></type> <name>destRelId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name></decl></parameter>,
											  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>finalColumnTypeArray</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FmgrInfo</name> <modifier>*</modifier></type> <name>TypeOutputFunctions</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeIdArray</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>binaryFormat</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CopyGetAttnums</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CopyStatementHasFormat</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>formatName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusCopyFrom</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureCopyCanRunOnRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>CreateConnectionStateHash</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>memoryContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type> <name>CreateShardStateHash</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>memoryContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CopyConnectionState</name> <modifier>*</modifier></type> <name>GetConnectionState</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>,
												<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CopyShardState</name> <modifier>*</modifier></type> <name>GetShardState</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardStateHash</name></decl></parameter>,
									  <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shouldUseLocalCopy</name></decl></parameter>, <parameter><decl><type><name>CopyOutState</name></type>
									  <name>copyOutState</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isColocatedIntermediateResult</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiConnection</name> <modifier>*</modifier></type> <name>CopyGetPlacementConnection</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>,
													<parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>,
													<parameter><decl><type><name>bool</name></type> <name>colocatedIntermediateResult</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasReachedAdaptiveExecutorPoolSize</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MultiConnection</name> <modifier>*</modifier></type> <name>GetLeastUtilisedCopyConnection</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStateList</name></decl></parameter>,
														<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ConnectionStateList</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ConnectionStateListToNode</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeCopyShardState</name><parameter_list>(<parameter><decl><type><name>CopyShardState</name> <modifier>*</modifier></type><name>shardState</name></decl></parameter>,
									 <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>,
									 <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>canUseLocalCopy</name></decl></parameter>,
									 <parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>colocatedIntermediateResult</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StartPlacementStateCopyCommand</name><parameter_list>(<parameter><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>placementState</name></decl></parameter>,
										   <parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>,
										   <parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EndPlacementStateCopyCommand</name><parameter_list>(<parameter><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>placementState</name></decl></parameter>,
										 <parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UnclaimCopyConnections</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStateList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShutdownCopyConnectionState</name><parameter_list>(<parameter><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name></decl></parameter>,
										<parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SelectStmt</name> <modifier>*</modifier></type> <name>CitusCopySelect</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusCopyTo</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>ForwardCopyDataFromConnection</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>,
										   <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Private functions copied and adapted from copy.c in PostgreSQL */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyBegin</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendCopyEnd</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendData</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>databuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datasize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendString</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendChar</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendInt32</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendInt16</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopySendEndOfRow</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>includeEndOfLine</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CopyAttributeOutText</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>CopyFlushOutput</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CitusSendTupleToPlacements</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
									   <parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddPlacementStateToCopyConnectionStateBuffer</name><parameter_list>(<parameter><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type>
														 <name>connectionState</name></decl></parameter>,
														 <parameter><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type>
														 <name>placementState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemovePlacementStateFromCopyConnectionStateBuffer</name><parameter_list>(<parameter><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type>
															  <name>connectionState</name></decl></parameter>,
															  <parameter><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type>
															  <name>placementState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>ProcessAppendToShardOption</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>ShardIdForTuple</name><parameter_list>(<parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* CitusCopyDestReceiver functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusCopyDestReceiverStartup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>,
										 <parameter><decl><type><name>TupleDesc</name></type> <name>inputTupleDesc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CitusCopyDestReceiverReceive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
										 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusCopyDestReceiverShutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>destReceiver</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CitusCopyDestReceiverDestroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>destReceiver</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsLocalPlacement</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CompleteCopyQueryTagCompat</name><parameter_list>(<parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type>
									   <name>processedRowCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FinishLocalCopy</name><parameter_list>(<parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateLocalColocatedIntermediateFile</name><parameter_list>(<parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>,
												 <parameter><decl><type><name>CopyShardState</name> <modifier>*</modifier></type><name>shardState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FinishLocalColocatedIntermediateFiles</name><parameter_list>(<parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CloneCopyOutStateForLocalCopy</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>CopyOutState</name></type> <name>to</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LocalCopyStatus</name></type> <name>GetLocalCopyStatus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShardIntervalListHasLocalPlacements</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LogLocalCopyToRelationExecution</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LogLocalCopyToFileExecution</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* exports for SQL callable functions */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_text_send_as_jsonb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * CitusCopyFrom implements the COPY table_name FROM. It dispacthes the copy
 * statement to related subfunctions based on where the copy command is run
 * and the partition method of the distributed table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusCopyFrom</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* disallow COPY to/from file or program except for superusers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>copyStatement</name><operator>-&gt;</operator><name>filename</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>copyStatement</name><operator>-&gt;</operator><name>is_program</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to COPY to or from an external program"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Anyone can COPY to stdout or from stdin. "</literal>
							 <literal type="string">"psql's \\copy command also works for anyone."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to COPY to or from a file"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Anyone can COPY to stdout or from stdin. "</literal>
							 <literal type="string">"psql's \\copy command also works for anyone."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>


	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureCopyCanRunOnRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* disallow modifications to a partition table which have rep. factor &gt; 1 */</comment>
	<expr_stmt><expr><call><name>EnsurePartitionTableNotReplicated</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopyToExistingShards</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported partition method"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>XactModificationLevel</name> <operator>=</operator> <name>XACT_MODIFICATION_DATA</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureCopyCanRunOnRelation throws error is the database in read-only mode.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureCopyCanRunOnRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* first, do the regular check and give consistent errors with regular queries */</comment>
	<expr_stmt><expr><call><name>EnsureModificationsCanRunOnRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We use 2PC for all COPY commands. It means that we cannot allow any COPY
	 * on replicas even if the user allows via WritableStandbyCoordinator GUC.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>WritableStandbyCoordinator</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY command to Citus tables is not allowed in "</literal>
							   <literal type="string">"read-only mode"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"All COPY commands to citus tables happen via 2PC, "</literal>
								<literal type="string">"and 2PC requires the database to be in a writable state."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"the database is read-only"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CopyToExistingShards implements the COPY table_name FROM ... for hash or
 * range-partitioned tables where there are already shards into which to copy
 * rows.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyToExistingShards</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>tableId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>partitionColumnIndex</name> <init>= <expr><name>INVALID_PARTITION_COLUMN_INDEX</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isInputFormatBinary</name> <init>= <expr><call><name>IsCopyInBinaryFormat</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>processedRowCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>errorCallback</name></decl>;</decl_stmt>

	<comment type="block">/* allocate column values and nulls arrays */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>distributedRelation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set up a virtual tuple table slot */</comment>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleTableSlot</name> <init>= <expr><call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
															  <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>tupleTableSlot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>=</operator> <name>columnCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tupleTableSlot</name><operator>-&gt;</operator><name>tts_values</name></name> <operator>=</operator> <name>columnValues</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tupleTableSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name> <operator>=</operator> <name>columnNulls</name></expr>;</expr_stmt>

	<comment type="block">/* determine the partition column index in the tuple descriptor */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>partitionColumn</name> <init>= <expr><call><name>PartitionColumn</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>partitionColumn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partitionColumnIndex</name> <operator>=</operator> <name><name>partitionColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* build the list of column names for remote COPY statements */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>currentColumn</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator>
			<name><name>currentColumn</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>
			)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>columnNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columnNameList</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>executorTupleContext</name> <init>= <expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>executorExpressionContext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set up the destination for the COPY */</comment>
	<decl_stmt><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name> <init>= <expr><call><name>CreateCitusCopyDestReceiver</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>columnNameList</name></expr></argument>,
																  <argument><expr><name>partitionColumnIndex</name></expr></argument>,
																  <argument><expr><name>executorState</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if the user specified an explicit append-to_shard option, write to it */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>appendShardId</name> <init>= <expr><call><name>ProcessAppendToShardOption</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>copyStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>appendShardId</name> <operator>!=</operator> <name>INVALID_SHARD_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>appendShardId</name></name> <operator>=</operator> <name>appendShardId</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>copyDest</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Below, we change a few fields in the Relation to control the behaviour
	 * of BeginCopyFrom. However, we obviously should not do this in relcache
	 * and therefore make a copy of the Relation.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>copiedDistributedRelation</name> <init>= <expr><operator>(</operator><name>Relation</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>copiedDistributedRelationTuple</name> <init>=
		<expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>CLASS_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * There is no need to deep copy everything. We will just deep copy of the fields
	 * we will change.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>copiedDistributedRelation</name> <operator>=</operator> <operator>*</operator><name>distributedRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>copiedDistributedRelationTuple</name> <operator>=</operator> <operator>*</operator><name><name>distributedRelation</name><operator>-&gt;</operator><name>rd_rel</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>copiedDistributedRelation</name><operator>-&gt;</operator><name>rd_rel</name></name> <operator>=</operator> <name>copiedDistributedRelationTuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copiedDistributedRelation</name><operator>-&gt;</operator><name>rd_att</name></name> <operator>=</operator> <call><name>CreateTupleDescCopyConstr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * BeginCopyFrom opens all partitions of given partitioned table with relation_open
	 * and it expects its caller to close those relations. We do not have direct access
	 * to opened relations, thus we are changing relkind of partitioned tables so that
	 * Postgres will treat those tables as regular relations and will not open its
	 * partitions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>copiedDistributedRelationTuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We make an optimisation to skip JSON parsing for JSONB columns, because many
	 * Citus users have large objects in this column and parsing it on the coordinator
	 * causes significant CPU overhead. We do this by forcing BeginCopyFrom and
	 * NextCopyFrom to parse the column as text and then encoding it as JSON again
	 * by using citus_text_send_as_jsonb as the binary output function.
	 *
	 * The main downside of enabling this optimisation is that it defers validation
	 * until the object is parsed by the worker, which is unable to give an accurate
	 * line number.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>SkipJsonbValidationInCopy</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isInputFormatBinary</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>jsonbColumnIndexCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* get the column indices for all JSONB columns that appear in the input */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jsonbColumnIndexList</name> <init>= <expr><call><name>FindJsonbInputColumns</name><argument_list>(
			<argument><expr><name><name>copiedDistributedRelation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
			<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>jsonbColumnIndexCell</argument>, <argument>jsonbColumnIndexList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>jsonbColumnIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>jsonbColumnIndexCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>currentColumn</name> <init>=
				<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>copiedDistributedRelation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>jsonbColumnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>jsonbColumnIndex</name> <operator>==</operator> <name>partitionColumnIndex</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * In the curious case of using a JSONB column as partition column,
				 * we leave it as is because we want to make sure the hashing works
				 * correctly.
				 */</comment>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parsing JSONB column %s as text"</literal></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* parse the column as text instead of JSONB */</comment>
			<expr_stmt><expr><name><name>currentColumn</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>textSendAsJsonbFunctionId</name> <init>= <expr><call><name>CitusTextSendAsJsonbFunctionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If we're using binary encoding between coordinator and workers
				 * then we should honour the format expected by jsonb_recv, which
				 * is a version number followed by text. We therefore use an output
				 * function which sends the text as if it were jsonb, namely by
				 * prepending a version number.
				 */</comment>
				<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>textSendAsJsonbFunctionId</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>copyDest</name><operator>-&gt;</operator><name>columnOutputFunctions</name><index>[<expr><name>jsonbColumnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>textoutFunctionId</name> <init>= <expr><call><name>TextOutFunctionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>textoutFunctionId</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>copyDest</name><operator>-&gt;</operator><name>columnOutputFunctions</name><index>[<expr><name>jsonbColumnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* initialize copy state to read from COPY data source */</comment>
	<decl_stmt><decl><type><name>CopyFromState</name></type> <name>copyState</name> <init>= <expr><call><name>BeginCopyFrom_compat</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name>copiedDistributedRelation</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
												   <argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>is_program</name></name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>,
												   <argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set up callback to identify error line number */</comment>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>CopyFromErrorCallback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>copyState</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorCallback</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>errorCallback</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>executorTupleContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* parse a row from the input */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>nextRowFound</name> <init>= <expr><call><name>NextCopyFrom</name><argument_list>(<argument><expr><name>copyState</name></expr></argument>, <argument><expr><name>executorExpressionContext</name></expr></argument>,
										 <argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nextRowFound</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>receiveSlot</name></name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>++</operator><name>processedRowCount</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
		<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_COPY_TUPLES_PROCESSED</name></expr></argument>, <argument><expr><name>processedRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>EndCopyFrom</name><argument_list>(<argument><expr><name>copyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* all lines have been copied, stop showing line number in errors */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>errorCallback</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/* finish the COPY commands */</comment>
	<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rShutdown</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>dest</name><operator>-&gt;</operator><name>rDestroy</name></name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>completionTag</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CompleteCopyQueryTagCompat</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>processedRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsCopyInBinaryFormat determines whether the given COPY statement has the
 * WITH (format binary) option.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsCopyInBinaryFormat</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>optionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>optionCell</argument>, <argument>copyStatement-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>optionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindJsonbInputColumns finds columns in the tuple descriptor that have
 * the JSONB type and appear in inputColumnNameList. If the list is empty then
 * all JSONB columns are returned.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FindJsonbInputColumns</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>inputColumnNameList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>jsonbColumnIndexList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>currentColumn</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentColumn</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>JSONBOID</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>inputColumnNameList</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>inputColumnCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>isInputColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>inputColumnCell</argument>, <argument>inputColumnNameList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>inputColumnName</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>inputColumnCell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>currentColumn</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><name>inputColumnName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>isInputColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isInputColumn</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>jsonbColumnIndexList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>jsonbColumnIndexList</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>jsonbColumnIndexList</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>CompleteCopyQueryTagCompat</name><parameter_list>(<parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>processedRowCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SetQueryCompletion</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>CMDTAG_COPY</name></expr></argument>, <argument><expr><name>processedRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemoveOptionFromList removes an option from a list of options in a
 * COPY .. WITH (..) statement by name and returns the resulting list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>RemoveOptionFromList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>optionList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>optionName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>optionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>optionCell</argument>, <argument>optionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>optionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>optionName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>list_delete_cell</name><argument_list>(<argument><expr><name>optionList</name></expr></argument>, <argument><expr><name>optionCell</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>optionList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CanUseBinaryCopyFormat iterates over columns of the relation and looks for a
 * column whose type is array of user-defined type or composite type. If it finds
 * such column, that means we cannot use binary format for COPY, because binary
 * format sends Oid of the types, which are generally not same in master and
 * worker nodes for user-defined types. If the function can not detect a binary
 * output function for any of the column, it returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>CanUseBinaryCopyFormat</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescription</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>useBinaryCopyFormat</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>totalColumnCount</name> <init>= <expr><name><name>tupleDescription</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>totalColumnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>currentColumn</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescription</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator>
			<name><name>currentColumn</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>
			)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>typeId</name> <init>= <expr><name><name>currentColumn</name><operator>-&gt;</operator><name>atttypid</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CanUseBinaryCopyFormatForType</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>useBinaryCopyFormat</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>useBinaryCopyFormat</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CanUseBinaryCopyFormatForTargetList returns true if we can use binary
 * copy format for all columns of the given target list.
 */</comment>
<function><type><name>bool</name></type>
<name>CanUseBinaryCopyFormatForTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetEntryList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>targetEntryCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>targetEntryCell</argument>, <argument>targetEntryList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>targetEntry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>targetEntryCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>targetExpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>targetEntry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>columnType</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>targetExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CanUseBinaryCopyFormatForType</name><argument_list>(<argument><expr><name>columnType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CanUseBinaryCopyFormatForType determines whether it is safe to use the
 * binary copy format for the given type. See contents of the function for
 * details of when it's safe to use binary copy.
 */</comment>
<function><type><name>bool</name></type>
<name>CanUseBinaryCopyFormatForType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BinaryOutputFunctionDefined</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BinaryInputFunctionDefined</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * A row type can contain any types, possibly types that don't have
	 * the binary input and output functions defined.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * TODO: Inspect the types inside the record and check if all of them
		 * can be binary encoded. If so, it's safe to use binary encoding.
		 *
		 * IMPORTANT: When implementing this todo keep the following in mind:
		 *
		 * In PG versions before PG14 the record_recv function would error out
		 * more than necessary.
		 *
		 * It errors out when any of the columns in the row have a type oid
		 * that doesn't match with the oid in the received data. This happens
		 * pretty much always for non built in types, because their oids differ
		 * between postgres intallations. So for those Postgres versions we
		 * would need a check like the following for each column:
		 *
		 * if (columnType &gt;= FirstNormalObjectId) {
		 *     return false
		 * }
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>typeTup</name> <init>= <expr><call><name>typeidType</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>type</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>elementType</name> <init>= <expr><name><name>type</name><operator>-&gt;</operator><name>typelem</name></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<decl_stmt><decl><type><name>char</name></type> <name>typeCategory</name> <init>= <expr><name><name>type</name><operator>-&gt;</operator><name>typcategory</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name></expr></cpp:if>

	<comment type="block">/*
	 * In PG versions before PG14 the array_recv function would error out more
	 * than necessary.
	 *
	 * It errors out when the element type its oids don't match with the oid in
	 * the received data. This happens pretty much always for non built in
	 * types, because their oids differ between postgres intallations. So we
	 * skip binary encoding when the element type is a non built in type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>typeCategory</name> <operator>==</operator> <name>TYPCATEGORY_ARRAY</name> <operator>&amp;&amp;</operator> <name>elementType</name> <operator>&gt;=</operator> <name>FirstNormalObjectId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Any type that is a wrapper around an element type (e.g. arrays and
	 * ranges) require the element type to also has support for binary
	 * encoding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>elementType</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CanUseBinaryCopyFormatForType</name><argument_list>(<argument><expr><name>elementType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For domains, make sure that the underlying type can be binary copied.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>baseTypeId</name> <init>= <expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>typeId</name> <operator>!=</operator> <name>baseTypeId</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CanUseBinaryCopyFormatForType</name><argument_list>(<argument><expr><name>baseTypeId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BinaryOutputFunctionDefined checks whether binary output function is defined
 * for the given type.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>BinaryOutputFunctionDefined</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeFunctionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeIoParam</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>typeLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typeByVal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>typeAlign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>typeDelim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>IOFunc_send</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeLength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeByVal</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>typeAlign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeDelim</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeIoParam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeFunctionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typeFunctionId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BinaryInputFunctionDefined checks whether binary output function is defined
 * for the given type.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>BinaryInputFunctionDefined</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeFunctionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeIoParam</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>typeLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>typeByVal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>typeAlign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>typeDelim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>IOFunc_receive</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeLength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeByVal</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>typeAlign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeDelim</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeIoParam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeFunctionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typeFunctionId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Send copy binary headers to given connections */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyBinaryHeaders</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendCopyBinaryHeaders</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SendCopyDataToAll</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Send copy binary footers to given connections */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyBinaryFooters</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendCopyBinaryFooters</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SendCopyDataToAll</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>connectionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ConstructCopyStatement constructs the text of a COPY statement for a particular
 * shard.
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>ConstructCopyStatement</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>command</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardQualifiedName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"COPY %s "</literal></expr></argument>, <argument><expr><name>shardQualifiedName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>copyStatement</name><operator>-&gt;</operator><name>attlist</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>columnNameCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>appendedFirstName</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>columnNameCell</argument>, <argument>copyStatement-&gt;attlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>columnNameCell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedColumnName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>appendedFirstName</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"(%s"</literal></expr></argument>, <argument><expr><name>quotedColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>appendedFirstName</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">", %s"</literal></expr></argument>, <argument><expr><name>quotedColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>copyStatement</name><operator>-&gt;</operator><name>is_from</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"FROM STDIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"TO STDOUT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>optionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" WITH ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>optionCell</argument>, <argument>copyStatement-&gt;options</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>optionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>optionCell</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* option without value */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* make sure strings are quoted (may contain reserved characters) */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nameList</name> <init>= <expr><call><name>defGetStringList</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" (%s)"</literal></expr></argument>, <argument><expr><call><name>NameListToQuotedString</name><argument_list>(<argument><expr><name>nameList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* numeric options or * should not have quotes */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>command</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SendCopyDataToAll sends copy data to all connections in a list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyDataToAll</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>dataBuffer</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>connectionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>connectionCell</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><operator>(</operator><name>MultiConnection</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>connectionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SendCopyDataToPlacement</name><argument_list>(<argument><expr><name>dataBuffer</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * SendCopyDataToPlacement sends serialized COPY data to a specific shard placement
 * over the given connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyDataToPlacement</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>dataBuffer</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PutRemoteCopyData</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>dataBuffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>dataBuffer</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IO_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to COPY to shard "</literal> <name>INT64_FORMAT</name> <literal type="string">" on %s:%d"</literal></expr></argument>,
							   <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"failed to send %d bytes %s"</literal></expr></argument>, <argument><expr><name><name>dataBuffer</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
								  <argument><expr><name><name>dataBuffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EndRemoteCopy ends the COPY input on all connections, and unclaims connections.
 * This reports an error on failure.
 */</comment>
<function><type><name>void</name></type>
<name>EndRemoteCopy</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>connectionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>connectionCell</argument>, <argument>connectionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><operator>(</operator><name>MultiConnection</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>connectionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* end the COPY input */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PutRemoteCopyEnd</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IO_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to COPY to shard "</literal> <name>INT64_FORMAT</name> <literal type="string">" on %s:%d"</literal></expr></argument>,
								   <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check whether there were any COPY errors */</comment>
		<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportCopyError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ForgetResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnclaimConnection</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ReportCopyError tries to report a useful error message for the user from
 * the remote COPY error messages.
 */</comment>
<function><type><name>void</name></type>
<name>ReportCopyError</name><parameter_list>(<parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>, <parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>remoteMessage</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>remoteMessage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* probably a constraint violation, show remote message and detail */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>remoteDetail</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>haveDetail</name> <init>= <expr><name>remoteDetail</name> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>remoteMessage</name></expr></argument>)</argument_list></call><operator>,</operator>
						<ternary><condition><expr><name>haveDetail</name></expr> ?</condition><then> <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>remoteDetail</name></expr></argument>)</argument_list></call></expr> </then><else>:
						<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* trim the trailing characters */</comment>
		<expr_stmt><expr><name>remoteMessage</name> <operator>=</operator> <call><name>pchomp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_IO_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to complete COPY on %s:%d"</literal></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>,
							   <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>remoteMessage</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ConversionPathForTypes fills *result with all the data necessary for converting
 * Datums of type inputType to Datums of type destType.
 */</comment>
<function><type><name>void</name></type>
<name>ConversionPathForTypes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>inputType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>destType</name></decl></parameter>, <parameter><decl><type><name>CopyCoercionData</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>coercionFuncId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>coercionType</name> <init>= <expr><name>COERCION_PATH_RELABELTYPE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>destType</name> <operator>==</operator> <name>inputType</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coercionType</name></name> <operator>=</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>coercionType</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>destType</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>,
										 <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>coercionFuncId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>coercionType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>COERCION_PATH_NONE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast %d to %d"</literal></expr></argument>, <argument><expr><name>inputType</name></expr></argument>, <argument><expr><name>destType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block>

		<case>case <expr><name>COERCION_PATH_ARRAYCOERCE</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>inputBaseType</name> <init>= <expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><name>inputType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>destBaseType</name> <init>= <expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><name>destType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>baseCoercionType</name> <init>= <expr><name>COERCION_PATH_NONE</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>inputBaseType</name> <operator>!=</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name>destBaseType</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>baseCoercionType</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>inputBaseType</name></expr></argument>, <argument><expr><name>destBaseType</name></expr></argument>,
														 <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>coercionFuncId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>baseCoercionType</name> <operator>!=</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can not run query which uses an implicit coercion"</literal>
									   <literal type="string">" between array types"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* fallthrough */</comment>

		<case>case <expr><name>COERCION_PATH_COERCEVIAIO</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coercionType</name></name> <operator>=</operator> <name>COERCION_PATH_COERCEVIAIO</name></expr>;</expr_stmt>

			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>typisvarlena</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* ignored */</comment>
				<decl_stmt><decl><type><name>Oid</name></type> <name>iofunc</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>inputType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>outputFunction</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>iofunc</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name>destType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>typioparam</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>inputFunction</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<return>return;</return>
		</block_content>}</block>

		<case>case <expr><name>COERCION_PATH_FUNC</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coercionType</name></name> <operator>=</operator> <name>COERCION_PATH_FUNC</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>coercionFuncId</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>coerceFunction</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block>

		<case>case <expr><name>COERCION_PATH_RELABELTYPE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coercionType</name></name> <operator>=</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>;</expr_stmt>
			<return>return;</return> <comment type="block">/* the types are binary compatible, no need to call a function */</comment>
		</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* there are no other options for this enum */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * Returns the type of the provided column of the provided tuple. Throws an error if the
 * column does not exist or is dropped.
 *
 * tupleDescriptor and relationId must refer to the same table.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>TypeForColumnName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>destAttrNumber</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>destAttrNumber</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid attr? %s"</literal></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>destAttrNumber</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Walks a TupleDesc and returns an array of the types of each attribute.
 * Returns InvalidOid in the place of dropped or generated attributes.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name> <modifier>*</modifier></type>
<name>TypeArrayFromTupleDescriptor</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator>
			<name><name>attr</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>
			)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>typeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>typeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>typeArray</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnCoercionPaths scans the input and output tuples looking for mismatched types,
 * it then returns an array of coercion functions to use on the input tuples, and an
 * array of types which descript the output tuple
 */</comment>
<function><type><specifier>static</specifier> <name>CopyCoercionData</name> <modifier>*</modifier></type>
<name>ColumnCoercionPaths</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>destTupleDescriptor</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>inputTupleDescriptor</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>destRelId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>finalColumnTypeArray</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> <init>= <expr><name><name>inputTupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyCoercionData</name> <modifier>*</modifier></type><name>coercePaths</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CopyCoercionData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>inputTupleTypes</name> <init>= <expr><call><name>TypeArrayFromTupleDescriptor</name><argument_list>(<argument><expr><name>inputTupleDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>currentColumnName</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>columnNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>inputTupleType</name> <init>= <expr><name><name>inputTupleTypes</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>currentColumnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>inputTupleType</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* TypeArrayFromTupleDescriptor decided to skip this column */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>destTupleType</name> <init>= <expr><call><name>TypeForColumnName</name><argument_list>(<argument><expr><name>destRelId</name></expr></argument>, <argument><expr><name>destTupleDescriptor</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>finalColumnTypeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>destTupleType</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ConversionPathForTypes</name><argument_list>(<argument><expr><name>inputTupleType</name></expr></argument>, <argument><expr><name>destTupleType</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>coercePaths</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>currentColumnName</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>columnNameList</name></expr></argument>, <argument><expr><name>currentColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>currentColumnName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* the rest of inputTupleDescriptor are dropped columns, return early! */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>coercePaths</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TypeOutputFunctions takes an array of types and returns an array of output functions
 * for those types.
 */</comment>
<function><type><specifier>static</specifier> <name>FmgrInfo</name> <modifier>*</modifier></type>
<name>TypeOutputFunctions</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typeIdArray</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>binaryFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>columnOutputFunctions</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>currentOutputFunction</name> <init>= <expr><operator>&amp;</operator><name><name>columnOutputFunctions</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>columnTypeId</name> <init>= <expr><name><name>typeIdArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>typeVariableLength</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>outputFunctionId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>columnTypeId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* TypeArrayFromTupleDescriptor decided to skip this column */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>binaryFormat</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>getTypeBinaryOutputInfo</name><argument_list>(<argument><expr><name>columnTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outputFunctionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeVariableLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>columnTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outputFunctionId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeVariableLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>outputFunctionId</name></expr></argument>, <argument><expr><name>currentOutputFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>columnOutputFunctions</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnOutputFunctions is a wrapper around TypeOutputFunctions, it takes a
 * tupleDescriptor and returns an array of output functions, one for each column in
 * the tuple.
 */</comment>
<function><type><name>FmgrInfo</name> <modifier>*</modifier></type>
<name>ColumnOutputFunctions</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>rowDescriptor</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>binaryFormat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>rowDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>columnTypes</name> <init>= <expr><call><name>TypeArrayFromTupleDescriptor</name><argument_list>(<argument><expr><name>rowDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>outputFunctions</name> <init>=
		<expr><call><name>TypeOutputFunctions</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>columnTypes</name></expr></argument>, <argument><expr><name>binaryFormat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>outputFunctions</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * citus_text_send_as_jsonb sends a text as if it was a JSONB. This should only
 * be used if the text is indeed valid JSON.
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_text_send_as_jsonb</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>inputText</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>version</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>inputText</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>inputText</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AppendCopyRowData serializes one row using the column output functions,
 * and appends the data to the row output state object's message buffer.
 * This function is modeled after the CopyOneRowTo() function in
 * commands/copy.c, but only implements a subset of that functionality.
 * Note that the caller of this function should reset row memory context
 * to not bloat memory usage.
 */</comment>
<function><type><name>void</name></type>
<name>AppendCopyRowData</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>valueArray</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isNullArray</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>rowDescriptor</name></decl></parameter>,
				  <parameter><decl><type><name>CopyOutState</name></type> <name>rowOutputState</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>columnOutputFunctions</name></decl></parameter>,
				  <parameter><decl><type><name>CopyCoercionData</name> <modifier>*</modifier></type><name>columnCoercionPaths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>totalColumnCount</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <name><name>rowDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>availableColumnCount</name> <init>= <expr><call><name>AvailableColumnCount</name><argument_list>(<argument><expr><name>rowDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>appendedColumnCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rowOutputState</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rowOutputState</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopySendInt16</name><argument_list>(<argument><expr><name>rowOutputState</name></expr></argument>, <argument><expr><name>availableColumnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>totalColumnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>currentColumn</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>rowDescriptor</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>value</name> <init>= <expr><name><name>valueArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name><name>isNullArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>lastColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name> <operator>&amp;&amp;</operator> <name>columnCoercionPaths</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>CoerceColumnValue</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>columnCoercionPaths</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator>
			<name><name>currentColumn</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>
			)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rowOutputState</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>outputFunctionPointer</name> <init>= <expr><operator>&amp;</operator><name><name>columnOutputFunctions</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bytea</name> <modifier>*</modifier></type><name>outputBytes</name> <init>= <expr><call><name>SendFunctionCall</name><argument_list>(<argument><expr><name>outputFunctionPointer</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>rowOutputState</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputBytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>rowOutputState</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>outputBytes</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>outputBytes</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>rowOutputState</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>outputFunctionPointer</name> <init>= <expr><operator>&amp;</operator><name><name>columnOutputFunctions</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnText</name> <init>= <expr><call><name>OutputFunctionCall</name><argument_list>(<argument><expr><name>outputFunctionPointer</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>CopyAttributeOutText</name><argument_list>(<argument><expr><name>rowOutputState</name></expr></argument>, <argument><expr><name>columnText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>CopySendString</name><argument_list>(<argument><expr><name>rowOutputState</name></expr></argument>, <argument><expr><name><name>rowOutputState</name><operator>-&gt;</operator><name>null_print_client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>lastColumn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>appendedColumnCount</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>availableColumnCount</name><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lastColumn</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>rowOutputState</name></expr></argument>, <argument><expr><name><name>rowOutputState</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>appendedColumnCount</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rowOutputState</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* append default line termination string depending on the platform */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>rowOutputState</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>CopySendString</name><argument_list>(<argument><expr><name>rowOutputState</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CoerceColumnValue follows the instructions in *coercionPath and uses them to convert
 * inputValue into a Datum of the correct type.
 */</comment>
<function><type><name>Datum</name></type>
<name>CoerceColumnValue</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>inputValue</name></decl></parameter>, <parameter><decl><type><name>CopyCoercionData</name> <modifier>*</modifier></type><name>coercionPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>coercionPath</name><operator>-&gt;</operator><name>coercionType</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>inputValue</name></expr>;</return> <comment type="block">/* this was a dropped column */</comment>
		</block_content>}</block>

		<case>case <expr><name>COERCION_PATH_RELABELTYPE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>inputValue</name></expr>;</return> <comment type="block">/* no need to do anything */</comment>
		</block_content>}</block>

		<case>case <expr><name>COERCION_PATH_FUNC</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>coerceFunction</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>coercionPath</name><operator>-&gt;</operator><name>coerceFunction</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>outputValue</name> <init>= <expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><name>coerceFunction</name></expr></argument>, <argument><expr><name>inputValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<return>return <expr><name>outputValue</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>COERCION_PATH_COERCEVIAIO</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>outFunction</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>coercionPath</name><operator>-&gt;</operator><name>outputFunction</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>textRepr</name> <init>= <expr><call><name>FunctionCall1</name><argument_list>(<argument><expr><name>outFunction</name></expr></argument>, <argument><expr><name>inputValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>inFunction</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>coercionPath</name><operator>-&gt;</operator><name>inputFunction</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>typioparam</name> <init>= <expr><name><name>coercionPath</name><operator>-&gt;</operator><name>typioparam</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>outputValue</name> <init>= <expr><call><name>FunctionCall3</name><argument_list>(<argument><expr><name>inFunction</name></expr></argument>, <argument><expr><name>textRepr</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>,
											  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<return>return <expr><name>outputValue</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<comment type="block">/* this should never happen */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported coercion type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * AvailableColumnCount returns the number of columns in a tuple descriptor, excluding
 * columns that were dropped.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>AvailableColumnCount</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>currentColumn</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>currentColumn</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>&amp;&amp;</operator>
			<name><name>currentColumn</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>!=</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>
			)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>columnCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>columnCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AppendCopyBinaryHeaders appends binary headers to the copy buffer in
 * headerOutputState.
 */</comment>
<function><type><name>void</name></type>
<name>AppendCopyBinaryHeaders</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>headerOutputState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int32</name></type> <name>zero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>headerOutputState</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Signature */</comment>
	<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>headerOutputState</name></expr></argument>, <argument><expr><name>BinarySignature</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Flags field (no OIDs) */</comment>
	<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>headerOutputState</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No header extension */</comment>
	<expr_stmt><expr><call><name>CopySendInt32</name><argument_list>(<argument><expr><name>headerOutputState</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AppendCopyBinaryFooters appends binary footers to the copy buffer in
 * footerOutputState.
 */</comment>
<function><type><name>void</name></type>
<name>AppendCopyBinaryFooters</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>footerOutputState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type> <name>negative</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>footerOutputState</name><operator>-&gt;</operator><name>rowcontext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CopySendInt16</name><argument_list>(<argument><expr><name>footerOutputState</name></expr></argument>, <argument><expr><name>negative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* *INDENT-OFF* */</comment>


<comment type="block">/*
 * Send copy start/stop messages for frontend copies.  These have changed
 * in past protocol redesigns.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyBegin</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* old way */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY BINARY is not supported to stdout or from stdin"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* grottiness needed for old COPY OUT protocol */</comment>
		<expr_stmt><expr><call><name>pq_startcopyout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_OLD_FE</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>attnumlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>format</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'H'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* overall format */</comment>
	<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_sendint16</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> <comment type="block">/* per-column formats */</comment>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name>COPY_FRONTEND</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* End a copy stream sent to the client */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendCopyEnd</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>!=</operator> <name>COPY_NEW_FE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"\\."</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Need to flush out the trailer (this also appends a newline) */</comment>
		<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_endcopyout</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Shouldn't have any unsent data */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Send Copy Done message */</comment>
	<expr_stmt><expr><call><name>pq_putemptymessage</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Append data to the copy buffer in outputState */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendData</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>databuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datasize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>outputState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>databuf</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Append a striong to the copy buffer in outputState. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendString</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>outputState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Append a char to the copy buffer in outputState. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendChar</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name><name>outputState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Append an int32 to the copy buffer in outputState. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendInt32</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>buf</name> <init>= <expr><call><name>htonl</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>outputState</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Append an int16 to the copy buffer in outputState. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendInt16</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>outputState</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16</name></type> <name>buf</name> <init>= <expr><call><name>htons</name><argument_list>(<argument><expr><operator>(</operator><name>uint16</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>outputState</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Send the row to the appropriate destination */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopySendEndOfRow</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>includeEndOfLine</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>fe_msgbuf</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>copy_dest</name></name></expr>)</condition>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name></expr></cpp:if>
		<case>case <expr><name>COPY_OLD_FE</name></expr>:</case>
			<comment type="block">/* The FE/BE protocol uses \n as newline for all platforms */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>&amp;&amp;</operator> <name>includeEndOfLine</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pq_putbytes</name><argument_list>(<argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no hope of recovering connection sync, so FATAL */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connection lost during COPY to stdout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<case>case <expr><name>COPY_FRONTEND</name></expr>:</case>
			<comment type="block">/* The FE/BE protocol uses \n as newline for all platforms */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>binary</name></name> <operator>&amp;&amp;</operator> <name>includeEndOfLine</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Dump the accumulated row as one CopyData message */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COPY_FILE</name></expr>:</case>
		<case>case <expr><name>COPY_CALLBACK</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* Not yet supported. */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>fe_msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Send text representation of one column, with conversion and escaping.
 *
 * NB: This function is based on commands/copy.c and doesn't fully conform to
 * our coding style. The function should be kept in sync with copy.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyAttributeOutText</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pointer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>delimc</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pointer</name> <operator>=</operator> <call><name>pg_server_to_any</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>file_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>pointer</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * We have to grovel through the string searching for control characters
	 * and instances of the delimiter character.  In most cases, though, these
	 * are infrequent.  To avoid overhead from calling CopySendData once per
	 * character, we dump out all characters between escaped characters in a
	 * single call.  The loop invariant is that the data from "start" to "pointer"
	 * can be sent literally, but hasn't yet been.
	 *
	 * As all encodings here are safe, i.e. backend supported ones, we can
	 * skip doing pg_encoding_mblen(), because in valid backend encodings,
	 * extra bytes of a multibyte character never look like ASCII.
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>pointer</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>pointer</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <literal type="number">0x20</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * \r and \n must be escaped, the others are traditional. We
			 * prefer to dump these using the C-like notation, rather than
			 * a backslash and the literal character, because it makes the
			 * dump file a bit more proof against Microsoftish data
			 * mangling.
			 */</comment>
			<switch>switch <condition>(<expr><name>c</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'\b'</literal></expr>:</case>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'\f'</literal></expr>:</case>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'\r'</literal></expr>:</case>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'\t'</literal></expr>:</case>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'\v'</literal></expr>:</case>
					<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'v'</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* If it's the delimiter, must backslash it */</comment>
					<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
					<comment type="block">/* All ASCII control chars are length 1 */</comment>
					<expr_stmt><expr><name>pointer</name><operator>++</operator></expr>;</expr_stmt>
					<continue>continue;</continue>		<comment type="block">/* fall to end of loop */</comment>
			</block_content>}</block></switch>
			<comment type="block">/* if we get here, we need to convert the control char */</comment>
			<expr_stmt><expr><call><name>CopyFlushOutput</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>pointer</name></expr>;</expr_stmt>	<comment type="block">/* do not include char in next run */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CopyFlushOutput</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CopySendChar</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>start</name> <operator>=</operator> <name>pointer</name><operator>++</operator></expr>;</expr_stmt>	<comment type="block">/* we include char in next run */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>pointer</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>CopyFlushOutput</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* *INDENT-ON* */</comment>
<comment type="block">/* Helper function to send pending copy output */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>CopyFlushOutput</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>pointer</name> <operator>&gt;</operator> <name>start</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>pointer</name> <operator>-</operator> <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateCitusCopyDestReceiver creates a DestReceiver that copies into
 * a distributed table.
 *
 * The caller should provide the list of column names to use in the
 * remote COPY statement, and the partition column index in the tuple
 * descriptor (*not* the column name list).
 *
 * If intermediateResultIdPrefix is not NULL, the COPY will go into a set
 * of intermediate results that are co-located with the actual table.
 * The names of the intermediate results with be of the form:
 * intermediateResultIdPrefix_&lt;shardid&gt;
 */</comment>
<function><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type>
<name>CreateCitusCopyDestReceiver</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partitionColumnIndex</name></decl></parameter>,
							<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>intermediateResultIdPrefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name> <init>= <expr><operator>(</operator><name>CitusCopyDestReceiver</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CitusCopyDestReceiver</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set up the DestReceiver function pointers */</comment>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>receiveSlot</name></name> <operator>=</operator> <name>CitusCopyDestReceiverReceive</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rStartup</name></name> <operator>=</operator> <name>CitusCopyDestReceiverStartup</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rShutdown</name></name> <operator>=</operator> <name>CitusCopyDestReceiverShutdown</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rDestroy</name></name> <operator>=</operator> <name>CitusCopyDestReceiverDestroy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name> <operator>=</operator> <name>DestCopyOut</name></expr>;</expr_stmt>

	<comment type="block">/* set up output parameters */</comment>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>distributedRelationId</name></name> <operator>=</operator> <name>tableId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnNameList</name></name> <operator>=</operator> <name>columnNameList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>partitionColumnIndex</name></name> <operator>=</operator> <name>partitionColumnIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>executorState</name></name> <operator>=</operator> <name>executorState</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>colocatedIntermediateResultIdPrefix</name></name> <operator>=</operator> <name>intermediateResultIdPrefix</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<return>return <expr><name>copyDest</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetLocalCopyStatus returns the status for executing copy locally.
 * If LOCAL_COPY_DISABLED or LOCAL_COPY_REQUIRED, the caller has to
 * follow that. Else, the caller may decide to use local or remote
 * execution depending on other information.
 */</comment>
<function><type><specifier>static</specifier> <name>LocalCopyStatus</name></type>
<name>GetLocalCopyStatus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableLocalExecution</name> <operator>||</operator>
		<call><name>GetCurrentLocalExecutionStatus</name><argument_list>()</argument_list></call> <operator>==</operator> <name>LOCAL_EXECUTION_DISABLED</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>LOCAL_COPY_DISABLED</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>GetCurrentLocalExecutionStatus</name><argument_list>()</argument_list></call> <operator>==</operator> <name>LOCAL_EXECUTION_REQUIRED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For various reasons, including the transaction visibility
		 * rules (e.g., read-your-own-writes), we have to use local
		 * execution again if it has already happened within this
		 * transaction block.
		 *
		 * We might error out later in the execution if it is not suitable
		 * to execute the tasks locally.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsMultiStatementTransaction</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>InCoordinatedTransaction</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * TODO: A future improvement could be to keep track of which placements
		 * have been locally executed. At this point, only use local execution for
		 * those placements. That'd help to benefit more from parallelism.
		 */</comment>

		<return>return <expr><name>LOCAL_COPY_REQUIRED</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsMultiStatementTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>LOCAL_COPY_REQUIRED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>LOCAL_COPY_OPTIONAL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardIntervalListHasLocalPlacements returns true if any of the input
 * shard placement has a local placement;
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShardIntervalListHasLocalPlacements</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>localGroupId</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ActiveShardPlacementOnGroup</name><argument_list>(<argument><expr><name>localGroupId</name></expr></argument>, <argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusCopyDestReceiverStartup implements the rStartup interface of
 * CitusCopyDestReceiver. It opens the relation, acquires necessary
 * locks, and initializes the state required for doing the copy.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusCopyDestReceiverStartup</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>,
							 <parameter><decl><type><name>TupleDesc</name></type> <name>inputTupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name> <init>= <expr><operator>(</operator><name>CitusCopyDestReceiver</name> <operator>*</operator><operator>)</operator> <name>dest</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>tableId</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>distributedRelationId</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaOid</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnNameList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attributeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>columnNameCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delimiterCharacter</name> <init>= <expr><literal type="string">"\t"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nullPrintCharacter</name> <init>= <expr><literal type="string">"\\N"</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* look up table properties */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>distributedRelation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>distributedRelation</name></name> <operator>=</operator> <name>distributedRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>tupleDescriptor</name></name> <operator>=</operator> <name>inputTupleDescriptor</name></expr>;</expr_stmt>

	<comment type="block">/* load the list of shards and verify that we have shards to copy into */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shardIntervalList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find any shards into which to copy"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"No shards exist for distributed table \"%s\"."</literal></expr></argument>,
									  <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Run master_create_worker_shards to create shards "</literal>
									<literal type="string">"and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find any shards into which to copy"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"No shards exist for distributed table \"%s\"."</literal></expr></argument>,
									  <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* error if any shard missing min/max values */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>hasUninitializedShardInterval</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>RANGE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not start copy"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distributed relation \"%s\" has shards "</literal>
									  <literal type="string">"with missing shardminvalue/shardmaxvalue."</literal></expr></argument>,
									  <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* prevent concurrent placement changes and non-commutative DML statements */</comment>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prevent concurrent UPDATE/DELETE on replication factor &gt;1
	 * (see AcquireExecutorMultiShardLocks() at multi_router_executor.c)
	 */</comment>
	<expr_stmt><expr><call><name>SerializeNonCommutativeWrites</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UseCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* all modifications use 2PC */</comment>
	<expr_stmt><expr><call><name>Use2PCForCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* define how tuples will be serialised */</comment>
	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name> <init>= <expr><operator>(</operator><name>CopyOutState</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyOutStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>delim</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>delimiterCharacter</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>null_print</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>nullPrintCharacter</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>null_print_client</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>nullPrintCharacter</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <call><name>CanUseBinaryCopyFormat</name><argument_list>(<argument><expr><name>inputTupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>rowcontext</name></name> <operator>=</operator> <call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>executorState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>copyOutState</name></name> <operator>=</operator> <name>copyOutState</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>multiShardCopy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* prepare functions to call on received tuples */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>destTupleDescriptor</name> <init>= <expr><name><name>distributedRelation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> <init>= <expr><name><name>inputTupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>finalTypeArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnCoercionPaths</name></name> <operator>=</operator>
			<call><name>ColumnCoercionPaths</name><argument_list>(<argument><expr><name>destTupleDescriptor</name></expr></argument>, <argument><expr><name>inputTupleDescriptor</name></expr></argument>,
								<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>columnNameList</name></expr></argument>, <argument><expr><name>finalTypeArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnOutputFunctions</name></name> <operator>=</operator>
			<call><name>TypeOutputFunctions</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>finalTypeArray</name></expr></argument>, <argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* wrap the column names as Values */</comment>
	<macro><name>foreach</name><argument_list>(<argument>columnNameCell</argument>, <argument>columnNameList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>columnNameCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>columnNameValue</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>attributeList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>attributeList</name></expr></argument>, <argument><expr><name>columnNameValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>copyDest</name><operator>-&gt;</operator><name>partitionColumnIndex</name></name> <operator>==</operator> <name>INVALID_PARTITION_COLUMN_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the partition column of table %s should have a value"</literal></expr></argument>,
							   <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* define the template for the COPY statement that is sent to workers */</comment>
	<decl_stmt><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CopyStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>colocatedIntermediateResults</name> <init>=
		<expr><name><name>copyDest</name><operator>-&gt;</operator><name>colocatedIntermediateResultIdPrefix</name></name> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>colocatedIntermediateResults</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name><name>copyDest</name><operator>-&gt;</operator>
											   <name>colocatedIntermediateResultIdPrefix</name></name></expr></argument>,
											   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>formatResultOption</name> <init>= <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"result"</literal></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>formatResultOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>binaryFormatOption</name> <init>=
				<expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>binaryFormatOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>


	<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>attlist</name></name> <operator>=</operator> <name>attributeList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>is_from</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>is_program</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>copyStatement</name></name> <operator>=</operator> <name>copyStatement</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>shardStateHash</name></name> <operator>=</operator> <call><name>CreateShardStateHash</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>connectionStateHash</name></name> <operator>=</operator> <call><name>CreateConnectionStateHash</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RecordRelationAccessIfNonDistTable</name><argument_list>(<argument><expr><name>tableId</name></expr></argument>, <argument><expr><name>PLACEMENT_ACCESS_DML</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Colocated intermediate results do not honor citus.max_shared_pool_size,
	 * so we don't need to reserve any connections. Each result file is sent
	 * over a single connection.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>colocatedIntermediateResults</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For all the primary (e.g., writable) remote nodes, reserve a shared
		 * connection. We do this upfront because we cannot know which nodes
		 * are going to be accessed. Since the order of the reservation is
		 * important, we need to do it right here. For the details on why the
		 * order important, see EnsureConnectionPossibilityForNodeList().
		 *
		 * We don't need to care about local node because we either get a
		 * connection or use local connection, so it cannot be part of
		 * the starvation. As an edge case, if it cannot get a connection
		 * and cannot switch to local execution (e.g., disabled by user),
		 * COPY would fail hinting the user to change the relevant settiing.
		 */</comment>
		<expr_stmt><expr><call><name>EnsureConnectionPossibilityForRemotePrimaryNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>LocalCopyStatus</name></type> <name>localCopyStatus</name> <init>= <expr><call><name>GetLocalCopyStatus</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>localCopyStatus</name> <operator>==</operator> <name>LOCAL_COPY_DISABLED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>shouldUseLocalCopy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>localCopyStatus</name> <operator>==</operator> <name>LOCAL_COPY_REQUIRED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>shouldUseLocalCopy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>localCopyStatus</name> <operator>==</operator> <name>LOCAL_COPY_OPTIONAL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At this point, there is no requirements for doing the copy locally.
		 * However, if there are local placements, we can try to reserve
		 * a connection to local node. If we cannot reserve, we can still use
		 * local execution.
		 *
		 * NB: It is not advantageous to use remote execution just with a
		 * single remote connection. In other words, a single remote connection
		 * would not perform better than local execution. However, we prefer to
		 * do this because it is likely that the COPY would get more connections
		 * to parallelize the operation. In the future, we might relax this
		 * requirement and failover to local execution as on connection attempt
		 * failures as the executor does.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ShardIntervalListHasLocalPlacements</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>reservedConnection</name> <init>= <expr><call><name>TryConnectionPossibilityForLocalPrimaryNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>shouldUseLocalCopy</name></name> <operator>=</operator> <operator>!</operator><name>reservedConnection</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusCopyDestReceiverReceive implements the receiveSlot function of
 * CitusCopyDestReceiver. It takes a TupleTableSlot and sends the contents to
 * the appropriate shard placement(s).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CitusCopyDestReceiverReceive</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name> <init>= <expr><operator>(</operator><name>CitusCopyDestReceiver</name> <operator>*</operator><operator>)</operator> <name>dest</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CitusSendTupleToPlacements</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>copyDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * We might be able to recover from errors with ROLLBACK TO SAVEPOINT,
		 * so unclaim the connections before throwing errors.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStateList</name> <init>= <expr><call><name>ConnectionStateList</name><argument_list>(<argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>connectionStateHash</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>UnclaimCopyConnections</name><argument_list>(<argument><expr><name>connectionStateList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusSendTupleToPlacements sends the given TupleTableSlot to the appropriate
 * shard placement(s).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CitusSendTupleToPlacements</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>copyStatement</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>columnOutputFunctions</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnOutputFunctions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyCoercionData</name> <modifier>*</modifier></type><name>columnCoercionPaths</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnCoercionPaths</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>placementStateCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>cachedShardStateFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>firstTupleInShard</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>executorState</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>executorState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>executorTupleContext</name> <init>= <expr><call><name>GetPerTupleMemoryContext</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>executorTupleContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>shardId</name> <init>= <expr><call><name>ShardIdForTuple</name><argument_list>(<argument><expr><name>copyDest</name></expr></argument>, <argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* connections hash is kept in memory context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isColocatedIntermediateResult</name> <init>=
		<expr><name><name>copyDest</name><operator>-&gt;</operator><name>colocatedIntermediateResultIdPrefix</name></name> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CopyShardState</name> <modifier>*</modifier></type><name>shardState</name> <init>= <expr><call><name>GetShardState</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>shardStateHash</name></name></expr></argument>,
											   <argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>connectionStateHash</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>cachedShardStateFound</name></expr></argument>,
											   <argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>shouldUseLocalCopy</name></name></expr></argument>,
											   <argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></argument>,
											   <argument><expr><name>isColocatedIntermediateResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cachedShardStateFound</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>firstTupleInShard</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>firstTupleInShard</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>copyDest</name><operator>-&gt;</operator><name>multiShardCopy</name></name> <operator>&amp;&amp;</operator>
		<call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>shardStateHash</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>distributedRelationId</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* mark as multi shard to skip doing the same thing over and over */</comment>
		<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>multiShardCopy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>MultiShardConnectionType</name> <operator>!=</operator> <name>SEQUENTIAL_CONNECTION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* when we see multiple shard connections, we mark COPY as parallel modify */</comment>
			<expr_stmt><expr><call><name>RecordParallelModifyAccess</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>isColocatedIntermediateResult</name> <operator>&amp;&amp;</operator> <name><name>copyDest</name><operator>-&gt;</operator><name>shouldUseLocalCopy</name></name> <operator>&amp;&amp;</operator>
		<name><name>shardState</name><operator>-&gt;</operator><name>containsLocalPlacement</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>firstTupleInShard</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CreateLocalColocatedIntermediateFile</name><argument_list>(<argument><expr><name>copyDest</name></expr></argument>, <argument><expr><name>shardState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>WriteTupleToLocalFile</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>copyDest</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
							  <argument><expr><name><name>shardState</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>shardState</name><operator>-&gt;</operator><name>fileDest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>copyDest</name><operator>-&gt;</operator><name>shouldUseLocalCopy</name></name> <operator>&amp;&amp;</operator> <name><name>shardState</name><operator>-&gt;</operator><name>containsLocalPlacement</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WriteTupleToLocalShard</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>copyDest</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name><name>shardState</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>placementStateCell</argument>, <argument>shardState-&gt;placementStateList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>currentPlacementState</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>placementStateCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name> <init>= <expr><name><name>currentPlacementState</name><operator>-&gt;</operator><name>connectionState</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>activePlacementState</name> <init>= <expr><name><name>connectionState</name><operator>-&gt;</operator><name>activePlacementState</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>switchToCurrentPlacement</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>sendTupleOverConnection</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>activePlacementState</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>switchToCurrentPlacement</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>currentPlacementState</name> <operator>!=</operator> <name>activePlacementState</name> <operator>&amp;&amp;</operator>
				 <name><name>currentPlacementState</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <name>CopySwitchOverThresholdBytes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>switchToCurrentPlacement</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/* before switching, make sure to finish the copy */</comment>
			<expr_stmt><expr><call><name>EndPlacementStateCopyCommand</name><argument_list>(<argument><expr><name>activePlacementState</name></expr></argument>, <argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AddPlacementStateToCopyConnectionStateBuffer</name><argument_list>(<argument><expr><name>connectionState</name></expr></argument>,
														 <argument><expr><name>activePlacementState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>switchToCurrentPlacement</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>StartPlacementStateCopyCommand</name><argument_list>(<argument><expr><name>currentPlacementState</name></expr></argument>, <argument><expr><name>copyStatement</name></expr></argument>,
										   <argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>RemovePlacementStateFromCopyConnectionStateBuffer</name><argument_list>(<argument><expr><name>connectionState</name></expr></argument>,
															  <argument><expr><name>currentPlacementState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>activePlacementState</name></name> <operator>=</operator> <name>currentPlacementState</name></expr>;</expr_stmt>

			<comment type="block">/* send previously buffered tuples */</comment>
			<expr_stmt><expr><call><name>SendCopyDataToPlacement</name><argument_list>(<argument><expr><name><name>currentPlacementState</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
									<argument><expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>currentPlacementState</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* additionaly, we need to send the current tuple too */</comment>
			<expr_stmt><expr><name>sendTupleOverConnection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>currentPlacementState</name> <operator>!=</operator> <name>activePlacementState</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* buffer data */</comment>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>copyBuffer</name> <init>= <expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>copyBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AppendCopyRowData</name><argument_list>(<argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>,
							  <argument><expr><name>copyOutState</name></expr></argument>, <argument><expr><name>columnOutputFunctions</name></expr></argument>,
							  <argument><expr><name>columnCoercionPaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>currentPlacementState</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>copyBuffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
								   <argument><expr><name><name>copyBuffer</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>currentPlacementState</name> <operator>==</operator> <name>activePlacementState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sendTupleOverConnection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>sendTupleOverConnection</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AppendCopyRowData</name><argument_list>(<argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>,
							  <argument><expr><name>copyOutState</name></expr></argument>, <argument><expr><name>columnOutputFunctions</name></expr></argument>, <argument><expr><name>columnCoercionPaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SendCopyDataToPlacement</name><argument_list>(<argument><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
									<argument><expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>copyDest</name><operator>-&gt;</operator><name>tuplesSent</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release per tuple memory allocated in this function. If we're writing
	 * the results of an INSERT ... SELECT then the SELECT execution will use
	 * its own executor state and reset the per tuple expression context
	 * separately.
	 */</comment>
	<expr_stmt><expr><call><name>ResetPerTupleExprContext</name><argument_list>(<argument><expr><name>executorState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddPlacementStateToCopyConnectionStateBuffer is a helper function to add a placement
 * state to connection state's placement buffer. In addition to that, keep the counter
 * up to date.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddPlacementStateToCopyConnectionStateBuffer</name><parameter_list>(<parameter><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name></decl></parameter>,
											 <parameter><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>placementState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>connectionState</name><operator>-&gt;</operator><name>bufferedPlacementList</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>placementState</name><operator>-&gt;</operator><name>bufferedPlacementNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>bufferedPlacementCount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemovePlacementStateFromCopyConnectionStateBuffer is a helper function to removes a placement
 * state from connection state's placement buffer. In addition to that, keep the counter
 * up to date.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemovePlacementStateFromCopyConnectionStateBuffer</name><parameter_list>(<parameter><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name></decl></parameter>,
												  <parameter><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>placementState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>placementState</name><operator>-&gt;</operator><name>bufferedPlacementNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>bufferedPlacementCount</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessAppendToShardOption returns the value of append_to_shard if set,
 * and removes the option from the options list.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>ProcessAppendToShardOption</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>appendShardId</name> <init>= <expr><name>INVALID_SHARD_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>appendToShardSet</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>defel</argument>, <argument>copyStatement-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>APPEND_TO_SHARD_OPTION</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>appendShardId</name> <operator>=</operator> <call><name>defGetInt64</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>appendToShardSet</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>appendToShardSet</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><name>APPEND_TO_SHARD_OPTION</name> <literal type="string">" is only valid for "</literal>
														  <literal type="string">"append-distributed tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* throws an error if shard does not exist */</comment>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>LoadShardInterval</name><argument_list>(<argument><expr><name>appendShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* also check whether shard belongs to table */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>shardInterval</name><operator>-&gt;</operator><name>relationId</name></name> <operator>!=</operator> <name>relationId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard "</literal> <name>UINT64_FORMAT</name> <literal type="string">" does not belong to table %s"</literal></expr></argument>,
								   <argument><expr><name>appendShardId</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator>
			<call><name>RemoveOptionFromList</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>APPEND_TO_SHARD_OPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"COPY into append-distributed table requires using the "</literal>
							   <name>APPEND_TO_SHARD_OPTION</name> <literal type="string">" option"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>appendShardId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsLocalPlacement returns true if the current node has
 * a local placement for the given shard id.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsLocalPlacement</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>placementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activePlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>localGroupId</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>placementCell</argument>, <argument>activePlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>placementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>localGroupId</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShardIdForTuple returns id of the shard to which the given tuple belongs to.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>ShardIdForTuple</name><parameter_list>(<parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>partitionColumnIndex</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>partitionColumnIndex</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>partitionColumnValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyCoercionData</name> <modifier>*</modifier></type><name>columnCoercionPaths</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnCoercionPaths</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>=
		<expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>distributedRelationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>cacheEntry</name></expr></argument>, <argument><expr><name>APPEND_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>copyDest</name><operator>-&gt;</operator><name>appendShardId</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find the partition column value and corresponding shard interval
	 * for non-reference tables.
	 * Get the existing (and only a single) shard interval for the reference
	 * tables. Note that, reference tables has NULL partition column values so
	 * skip the check.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partitionColumnIndex</name> <operator>!=</operator> <name>INVALID_PARTITION_COLUMN_INDEX</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CopyCoercionData</name> <modifier>*</modifier></type><name>coercePath</name> <init>= <expr><operator>&amp;</operator><name><name>columnCoercionPaths</name><index>[<expr><name>partitionColumnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>columnNulls</name><index>[<expr><name>partitionColumnIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>distributedRelationId</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>schemaOid</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedTableName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>,
																  <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the partition column of table %s cannot be NULL"</literal></expr></argument>,
								   <argument><expr><name>qualifiedTableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* find the partition column value */</comment>
		<expr_stmt><expr><name>partitionColumnValue</name> <operator>=</operator> <name><name>columnValues</name><index>[<expr><name>partitionColumnIndex</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* annoyingly this is evaluated twice, but at least we don't crash! */</comment>
		<expr_stmt><expr><name>partitionColumnValue</name> <operator>=</operator> <call><name>CoerceColumnValue</name><argument_list>(<argument><expr><name>partitionColumnValue</name></expr></argument>, <argument><expr><name>coercePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find the shard interval and id for the partition column value for
	 * non-reference tables.
	 *
	 * For reference table, this function blindly returns the tables single
	 * shard.
	 */</comment>
	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>FindShardInterval</name><argument_list>(<argument><expr><name>partitionColumnValue</name></expr></argument>, <argument><expr><name>cacheEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>shardInterval</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find shard for partition column "</literal>
							   <literal type="string">"value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusCopyDestReceiverShutdown implements the rShutdown interface of
 * CitusCopyDestReceiver. It ends the COPY on all the open connections and closes
 * the relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusCopyDestReceiverShutdown</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>destReceiver</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name> <init>= <expr><operator>(</operator><name>CitusCopyDestReceiver</name> <operator>*</operator><operator>)</operator> <name>destReceiver</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>connectionStateHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>connectionStateCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>distributedRelation</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>distributedRelation</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStateList</name> <init>= <expr><call><name>ConnectionStateList</name><argument_list>(<argument><expr><name>connectionStateHash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FinishLocalColocatedIntermediateFiles</name><argument_list>(<argument><expr><name>copyDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FinishLocalCopy</name><argument_list>(<argument><expr><name>copyDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>connectionStateCell</argument>, <argument>connectionStateList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name> <init>=
				<expr><operator>(</operator><name>CopyConnectionState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>connectionStateCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ShutdownCopyConnectionState</name><argument_list>(<argument><expr><name>connectionState</name></expr></argument>, <argument><expr><name>copyDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * We might be able to recover from errors with ROLLBACK TO SAVEPOINT,
		 * so unclaim the connections before throwing errors.
		 */</comment>
		<expr_stmt><expr><call><name>UnclaimCopyConnections</name><argument_list>(<argument><expr><name>connectionStateList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FinishLocalCopy sends the remaining copies for local placements.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishLocalCopy</name><parameter_list>(<parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardStateHash</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>shardStateHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyShardState</name> <modifier>*</modifier></type><name>copyShardState</name></decl>;</decl_stmt>

	<macro><name>foreach_htab</name><argument_list>(<argument>copyShardState</argument>, <argument>&amp;status</argument>, <argument>shardStateHash</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>copyShardState</name><operator>-&gt;</operator><name>copyOutState</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>copyShardState</name><operator>-&gt;</operator><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FinishLocalCopyToShard</name><argument_list>(<argument><expr><name>copyDest</name></expr></argument>, <argument><expr><name><name>copyShardState</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>,
								   <argument><expr><name><name>copyShardState</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CreateLocalColocatedIntermediateFile creates a co-located file for the given
 * shard, and appends the binary headers if needed. The function also modifies
 * shardState to set the fileDest and copyOutState.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateLocalColocatedIntermediateFile</name><parameter_list>(<parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>,
									 <parameter><decl><type><name>CopyShardState</name> <modifier>*</modifier></type><name>shardState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* make sure the directory exists */</comment>
	<expr_stmt><expr><call><name>CreateIntermediateResultsDirectory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fileFlags</name> <init>= <expr><operator>(</operator><name>O_CREAT</name> <operator>|</operator> <name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fileMode</name> <init>= <expr><operator>(</operator><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>filePath</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>filePath</name></expr></argument>, <argument><expr><literal type="string">"%s_%ld"</literal></expr></argument>, <argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>colocatedIntermediateResultIdPrefix</name></name></expr></argument>,
					 <argument><expr><name><name>shardState</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fileName</name> <init>= <expr><call><name>QueryResultFileName</name><argument_list>(<argument><expr><name><name>filePath</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>shardState</name><operator>-&gt;</operator><name>fileDest</name></name> <operator>=</operator>
		<call><name>FileCompatFromFileStart</name><argument_list>(<argument><expr><call><name>FileOpenForTransmit</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>, <argument><expr><name>fileMode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>localFileCopyOutState</name> <init>= <expr><name><name>shardState</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isBinaryCopy</name> <init>= <expr><name><name>localFileCopyOutState</name><operator>-&gt;</operator><name>binary</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isBinaryCopy</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendCopyBinaryHeaders</name><argument_list>(<argument><expr><name>localFileCopyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FinishLocalColocatedIntermediateFiles iterates over all the colocated
 * intermediate files and finishes the COPY on all of them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishLocalColocatedIntermediateFiles</name><parameter_list>(<parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardStateHash</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>shardStateHash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyShardState</name> <modifier>*</modifier></type><name>copyShardState</name></decl>;</decl_stmt>

	<macro><name>foreach_htab</name><argument_list>(<argument>copyShardState</argument>, <argument>&amp;status</argument>, <argument>shardStateHash</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>copyShardState</name><operator>-&gt;</operator><name>copyOutState</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>FILE_IS_OPEN</name><argument_list>(<argument><expr><name><name>copyShardState</name><operator>-&gt;</operator><name>fileDest</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FinishLocalCopyToFile</name><argument_list>(<argument><expr><name><name>copyShardState</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>copyShardState</name><operator>-&gt;</operator><name>fileDest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ShutdownCopyConnectionState ends the copy command for the current active
 * placement on connection, and then sends the rest of the buffers over the
 * connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShutdownCopyConnectionState</name><parameter_list>(<parameter><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name></decl></parameter>,
							<parameter><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name> <init>= <expr><name><name>copyDest</name><operator>-&gt;</operator><name>copyStatement</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>activePlacementState</name> <init>= <expr><name><name>connectionState</name><operator>-&gt;</operator><name>activePlacementState</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>activePlacementState</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EndPlacementStateCopyCommand</name><argument_list>(<argument><expr><name>activePlacementState</name></expr></argument>, <argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;connectionState-&gt;bufferedPlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>placementState</name> <init>=
			<expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>CopyPlacementState</name></expr></argument>, <argument><expr><name>bufferedPlacementNode</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>placementState</name><operator>-&gt;</operator><name>shardState</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>StartPlacementStateCopyCommand</name><argument_list>(<argument><expr><name>placementState</name></expr></argument>, <argument><expr><name>copyStatement</name></expr></argument>,
									   <argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SendCopyDataToPlacement</name><argument_list>(<argument><expr><name><name>placementState</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
								<argument><expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EndPlacementStateCopyCommand</name><argument_list>(<argument><expr><name>placementState</name></expr></argument>, <argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CitusCopyDestReceiverDestroy frees the DestReceiver
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusCopyDestReceiverDestroy</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>destReceiver</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusCopyDestReceiver</name> <modifier>*</modifier></type><name>copyDest</name> <init>= <expr><operator>(</operator><name>CitusCopyDestReceiver</name> <operator>*</operator><operator>)</operator> <name>destReceiver</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>copyDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnOutputFunctions</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnOutputFunctions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnCoercionPaths</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>columnCoercionPaths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>copyDest</name><operator>-&gt;</operator><name>shardStateHash</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>shardStateHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>copyDest</name><operator>-&gt;</operator><name>connectionStateHash</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>copyDest</name><operator>-&gt;</operator><name>connectionStateHash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>copyDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsCopyResultStmt determines whether the given copy statement is a
 * COPY "resultkey" FROM STDIN WITH (format result) statement, which is used
 * to copy query results from the coordinator into workers.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCopyResultStmt</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CopyStatementHasFormat</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>, <argument><expr><literal type="string">"result"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyStatementHasFormat checks whether the COPY statement has the given
 * format.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CopyStatementHasFormat</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>formatName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>optionCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasFormat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* extract WITH (...) options from the COPY statement */</comment>
	<macro><name>foreach</name><argument_list>(<argument>optionCell</argument>, <argument>copyStatement-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>optionCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>formatName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hasFormat</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>hasFormat</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessCopyStmt handles Citus specific concerns for COPY like supporting
 * COPYing from distributed tables and preventing unsupported actions. The
 * function returns a modified COPY statement to be executed, or NULL if no
 * further processing is needed.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>ProcessCopyStmt</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier>
				<name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Handle special COPY "resultid" FROM STDIN WITH (format result) commands
	 * for sending intermediate results to workers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCopyResultStmt</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resultId</name> <init>= <expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>copyStatement</name><operator>-&gt;</operator><name>is_from</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReceiveQueryResultViaCopy</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>SendQueryResultViaCopy</name><argument_list>(<argument><expr><name>resultId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We check whether a distributed relation is affected. For that, we need to open the
	 * relation. To prevent race conditions with later lookups, lock the table, and modify
	 * the rangevar to include the schema.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isFrom</name> <init>= <expr><name><name>copyStatement</name><operator>-&gt;</operator><name>is_from</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* consider using RangeVarGetRelidExtended to check perms before locking */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>copiedRelation</name> <init>= <expr><call><name>table_openrv</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
											   <argument><expr><ternary><condition><expr><name>isFrom</name></expr> ?</condition><then> <expr><name>RowExclusiveLock</name></expr> </then><else>:
											   <expr><name>AccessShareLock</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>isCitusRelation</name> <init>= <expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>copiedRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ensure future lookups hit the same relation */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>copiedRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* ensure we copy string into proper context */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>relationContext</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(
			<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>schemaName</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>relationContext</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <name>schemaName</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>copiedRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isCitusRelation</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>copyStatement</name><operator>-&gt;</operator><name>is_from</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>copyStatement</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Update progress reporting for tuples progressed so that the
					 * progress is reflected on pg_stat_progress_copy. Citus currently
					 * does not support COPY .. WHERE clause so TUPLES_EXCLUDED is not
					 * handled. When we remove this check, we should implement progress
					 * reporting as well.
					 */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
										<argument><expr><literal type="string">"Citus does not support COPY FROM with WHERE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* check permissions, we're bypassing postgres' normal checks */</comment>
				<expr_stmt><expr><call><name>CheckCopyPermissions</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CitusCopyFrom</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>copyStatement</name><operator>-&gt;</operator><name>filename</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>copyStatement</name><operator>-&gt;</operator><name>is_program</name></name> <operator>&amp;&amp;</operator>
					 <operator>!</operator><call><name>CopyStatementHasFormat</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * COPY table TO STDOUT is handled by specialized logic to
				 * avoid buffering the table on the coordinator. This enables
				 * pg_dump of large tables.
				 */</comment>
				<expr_stmt><expr><call><name>CitusCopyTo</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * COPY table TO PROGRAM / file is handled by wrapping the table
				 * in a SELECT and going through the resulting COPY logic.
				 */</comment>
				<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>selectStmt</name> <init>= <expr><call><name>CitusCopySelect</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* replace original statement */</comment>
				<expr_stmt><expr><name>copyStatement</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>selectStmt</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>copyStatement</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusCopySelect generates a SelectStmt such that table may be replaced in
 * "COPY table FROM" for an equivalent result.
 */</comment>
<function><type><specifier>static</specifier> <name>SelectStmt</name> <modifier>*</modifier></type>
<name>CitusCopySelect</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SelectStmt</name> <modifier>*</modifier></type><name>selectStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>selectStmt</name><operator>-&gt;</operator><name>fromClause</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>distributedRelation</name> <init>= <expr><call><name>table_openrv</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><operator>&amp;</operator><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>||</operator>
			<name><name>attr</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>
			)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ResTarget</name> <modifier>*</modifier></type><name>selectTarget</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>selectTarget</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>selectTarget</name><operator>-&gt;</operator><name>indirection</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>selectTarget</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>column</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>selectTarget</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>selectTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>selectStmt</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>targetList</name></expr>;</expr_stmt>
	<return>return <expr><name>selectStmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusCopyTo runs a COPY .. TO STDOUT command on each shard to do a full
 * table dump.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CitusCopyTo</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardIntervalCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>tuplesSent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>distributedRelation</name> <init>= <expr><call><name>table_openrv</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CopyOutState</name></type> <name>copyOutState</name> <init>= <expr><operator>(</operator><name>CopyOutState</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyOutStateData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copyOutState</name><operator>-&gt;</operator><name>attnumlist</name></name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>distributedRelation</name></expr></argument>,
											  <argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SendCopyBegin</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>shardIntervalCell</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>shardIntervalCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardPlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>shardPlacementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>placementIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>copyCommand</name> <init>= <expr><call><name>ConstructCopyStatement</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>,
														<argument><expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>shardPlacementCell</argument>, <argument>shardPlacementList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>shardPlacement</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>shardPlacementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>connectionFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>userName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><call><name>GetPlacementConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
																 <argument><expr><name>shardPlacement</name></expr></argument>,
																 <argument><expr><name>userName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * This code-path doesn't support optional connections, so we don't expect
			 * NULL connections.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>connection</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>placementIndex</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>shardPlacementList</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* last chance for this shard */</comment>
				<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>RemoteTransactionBeginIfNecessary</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>copyCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuplesSent</name> <operator>+=</operator> <call><name>ForwardCopyDataFromConnection</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>shardIntervalCell</name> <operator>==</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* remove header after the first shard */</comment>
			<expr_stmt><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator>
				<call><name>RemoveOptionFromList</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><literal type="string">"header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>SendCopyEnd</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>distributedRelation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>completionTag</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CompleteCopyQueryTagCompat</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>tuplesSent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ForwardCopyDataFromConnection forwards copy data received over the given connection
 * to the client or file descriptor.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>ForwardCopyDataFromConnection</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>, <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>receiveBuffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>useAsync</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>raiseErrors</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>tuplesSent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* receive copy data message in a synchronous manner */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>receiveLength</name> <init>= <expr><call><name>PQgetCopyData</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>receiveBuffer</name></expr></argument>, <argument><expr><name>useAsync</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>receiveLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>includeEndOfLine</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CopySendData</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>, <argument><expr><name>receiveBuffer</name></expr></argument>, <argument><expr><name>receiveLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CopySendEndOfRow</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>, <argument><expr><name>includeEndOfLine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuplesSent</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>receiveBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>receiveLength</name> <operator>=</operator> <call><name>PQgetCopyData</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>receiveBuffer</name></expr></argument>, <argument><expr><name>useAsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>receiveLength</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResponseOK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ClearResults</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuplesSent</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Check whether the current user has the permission to execute a COPY
 * statement, raise ERROR if not. In some cases we have to do this separately
 * from postgres' copy.c, because we have to execute the copy with elevated
 * privileges.
 *
 * Copied from postgres, where it's part of DoCopy().
 */</comment>
<function><type><name>void</name></type>
<name>CheckCopyPermissions</name><parameter_list>(<parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* *INDENT-OFF* */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_from</name> <init>= <expr><name><name>copyStatement</name><operator>-&gt;</operator><name>is_from</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>range_table</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclMode</name></type>		<name>required_access</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>is_from</name></expr> ?</condition><then> <expr><name>ACL_INSERT</name></expr> </then><else>: <expr><name>ACL_SELECT</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_openrv</name><argument_list>(<argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
	                  <argument><expr><ternary><condition><expr><name>is_from</name></expr> ?</condition><then> <expr><name>RowExclusiveLock</name></expr> </then><else>: <expr><name>AccessShareLock</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>range_table</name> <operator>=</operator> <call><name>CreateRangeTable</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name><operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>range_table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>CopyGetAttnums</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>copyStatement</name><operator>-&gt;</operator><name>attlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cur</argument>, <argument>attnums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_from</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ExecCheckRTPerms</name><argument_list>(<argument><expr><name>range_table</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* TODO: Perform RLS checks once supported */</comment>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* *INDENT-ON* */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * CreateRangeTable creates a range table with the given relation.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CreateRangeTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AclMode</name></type> <name>requiredAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>requiredAccess</name></expr>;</expr_stmt>
	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name></expr></cpp:if>

<comment type="block">/* Helper for CheckCopyPermissions(), copied from postgres */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CopyGetAttnums</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>attnamelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* *INDENT-OFF* */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnamelist</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Generate default column list */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>attr_count</name> <init>= <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attgenerated</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Validate the user-supplied list and extract attnums */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>attnamelist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/* Lookup column name */</comment>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>namestrcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>att</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is a generated column"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Generated columns cannot be used in COPY."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>att</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
							               <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" does not exist"</literal></expr></argument>,
							               <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Check for duplicates */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" specified more than once"</literal></expr></argument>,
						               <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>attnums</name></expr>;</return>
	<comment type="block">/* *INDENT-ON* */</comment>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * CreateConnectionStateHash constructs a hash table which maps from socket
 * number to CopyConnectionState, passing the provided MemoryContext to
 * hash_create for hash allocations.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>CreateConnectionStateHash</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>memoryContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CopyConnectionState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>memoryContext</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Copy Connection State Hash"</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
											<argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>connectionStateHash</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateShardStateHash constructs a hash table which maps from shard
 * identifier to CopyShardState, passing the provided MemoryContext to
 * hash_create for hash allocations.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>CreateShardStateHash</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>memoryContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CopyShardState</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>memoryContext</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>hashFlags</name> <init>= <expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_CONTEXT</name> <operator>|</operator> <name>HASH_BLOBS</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardStateHash</name> <init>= <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Copy Shard State Hash"</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hashFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>shardStateHash</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetConnectionState finds existing CopyConnectionState for a connection in the
 * provided hash. If not found, then a default structure is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>CopyConnectionState</name> <modifier>*</modifier></type>
<name>GetConnectionState</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>, <parameter><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sock</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name> <init>= <expr><operator>(</operator><name>CopyConnectionState</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
		<argument><expr><name>connectionStateHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sock</name></expr></argument>,
		<argument><expr><name>HASH_ENTER</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>socket</name></name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name> <operator>=</operator> <name>connection</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>activePlacementState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>connectionState</name><operator>-&gt;</operator><name>bufferedPlacementCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>connectionState</name><operator>-&gt;</operator><name>bufferedPlacementList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>connectionState</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConnectionStateList returns all CopyConnectionState structures in
 * the given hash.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ConnectionStateList</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStateList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>connectionStateHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name> <init>= <expr><operator>(</operator><name>CopyConnectionState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(
		<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>connectionState</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>connectionStateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionStateList</name></expr></argument>, <argument><expr><name>connectionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>connectionState</name> <operator>=</operator> <operator>(</operator><name>CopyConnectionState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>connectionStateList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConnectionStateListToNode returns all CopyConnectionState structures in
 * the given hash for a given hostname and port values.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ConnectionStateListToNode</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStateList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>connectionStateHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name> <init>=
		<expr><operator>(</operator><name>CopyConnectionState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>connectionState</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>connectionHostname</name> <init>= <expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>hostname</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>connectionHostname</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>MAX_NODE_LENGTH</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>connectionState</name><operator>-&gt;</operator><name>connection</name><operator>-&gt;</operator><name>port</name></name> <operator>==</operator> <name>port</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>connectionStateList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>connectionStateList</name></expr></argument>, <argument><expr><name>connectionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>connectionState</name> <operator>=</operator> <operator>(</operator><name>CopyConnectionState</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>connectionStateList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetShardState finds existing CopyShardState for a shard in the provided
 * hash. If not found, then a new shard state is returned with all related
 * CopyPlacementStates initialized.
 */</comment>
<function><type><specifier>static</specifier> <name>CopyShardState</name> <modifier>*</modifier></type>
<name>GetShardState</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>shardStateHash</name></decl></parameter>,
			  <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>found</name></decl></parameter>, <parameter><decl><type><name>bool</name></type>
			  <name>shouldUseLocalCopy</name></decl></parameter>, <parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>isColocatedIntermediateResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CopyShardState</name> <modifier>*</modifier></type><name>shardState</name> <init>= <expr><operator>(</operator><name>CopyShardState</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>shardStateHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shardId</name></expr></argument>,
																<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitializeCopyShardState</name><argument_list>(<argument><expr><name>shardState</name></expr></argument>, <argument><expr><name>connectionStateHash</name></expr></argument>,
								 <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>shouldUseLocalCopy</name></expr></argument>,
								 <argument><expr><name>copyOutState</name></expr></argument>, <argument><expr><name>isColocatedIntermediateResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>shardState</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InitializeCopyShardState initializes the given shardState. It finds all
 * placements for the given shardId, assignes connections to them, and
 * adds them to shardState-&gt;placementStateList.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeCopyShardState</name><parameter_list>(<parameter><decl><type><name>CopyShardState</name> <modifier>*</modifier></type><name>shardState</name></decl></parameter>,
						 <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>shouldUseLocalCopy</name></decl></parameter>,
						 <parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>colocatedIntermediateResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>placementCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>failedPlacementCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasRemoteCopy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>localContext</name> <init>=
		<expr><call><name>AllocSetContextCreateInternal</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									  <argument><expr><literal type="string">"InitializeCopyShardState"</literal></expr></argument>,
									  <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
									  <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
									  <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


	<comment type="block">/* release active placement list at the end of this function */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>activePlacementList</name> <init>= <expr><call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>shardState</name><operator>-&gt;</operator><name>shardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardState</name><operator>-&gt;</operator><name>placementStateList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardState</name><operator>-&gt;</operator><name>copyOutState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardState</name><operator>-&gt;</operator><name>containsLocalPlacement</name></name> <operator>=</operator> <call><name>ContainsLocalPlacement</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shardState</name><operator>-&gt;</operator><name>fileDest</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>placementCell</argument>, <argument>activePlacementList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name> <init>= <expr><operator>(</operator><name>ShardPlacement</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>placementCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>shouldUseLocalCopy</name> <operator>&amp;&amp;</operator> <name><name>placement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>shardState</name><operator>-&gt;</operator><name>copyOutState</name></name> <operator>=</operator> <operator>(</operator><name>CopyOutState</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>copyOutState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CloneCopyOutStateForLocalCopy</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>, <argument><expr><name><name>shardState</name><operator>-&gt;</operator><name>copyOutState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>colocatedIntermediateResult</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LogLocalCopyToFileExecution</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>LogLocalCopyToRelationExecution</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>hasRemoteCopy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
			<expr><call><name>CopyGetPlacementConnection</name><argument_list>(<argument><expr><name>connectionStateHash</name></expr></argument>, <argument><expr><name>placement</name></expr></argument>,
									   <argument><expr><name>colocatedIntermediateResult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>failedPlacementCount</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name> <init>= <expr><call><name>GetConnectionState</name><argument_list>(<argument><expr><name>connectionStateHash</name></expr></argument>,
																  <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If this is the first time we are using this connection for copying a
		 * shard, send begin if necessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>connectionState</name><operator>-&gt;</operator><name>activePlacementState</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RemoteTransactionBeginIfNecessary</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>placementState</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CopyPlacementState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>placementState</name><operator>-&gt;</operator><name>shardState</name></name> <operator>=</operator> <name>shardState</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementState</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementState</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name><name>placement</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placementState</name><operator>-&gt;</operator><name>connectionState</name></name> <operator>=</operator> <name>connectionState</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't set connectionState-&gt;activePlacementState here even if it
		 * is NULL. Later in CitusSendTupleToPlacements() we set it at the
		 * same time as calling StartPlacementStateCopyCommand() so we actually
		 * know the COPY operation for the placement is ongoing.
		 */</comment>
		<expr_stmt><expr><call><name>AddPlacementStateToCopyConnectionStateBuffer</name><argument_list>(<argument><expr><name>connectionState</name></expr></argument>, <argument><expr><name>placementState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shardState</name><operator>-&gt;</operator><name>placementStateList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>shardState</name><operator>-&gt;</operator><name>placementStateList</name></name></expr></argument>,
												 <argument><expr><name>placementState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* if all placements failed, error out */</comment>
	<if_stmt><if>if <condition>(<expr><name>failedPlacementCount</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>activePlacementList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to any active placements"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureTaskExecutionAllowed</name><argument_list>(<argument><expr><name>hasRemoteCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We just error out and code execution should never reach to this
	 * point. This is the case for all tables.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>failedPlacementCount</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>localContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CloneCopyOutStateForLocalCopy creates a shallow copy of the CopyOutState with a new
 * fe_msgbuf. We keep a separate CopyOutState for every local shard placement, because
 * in case of local copy we serialize and buffer incoming tuples into fe_msgbuf for each
 * placement and the serialization functions take a CopyOutState as a parameter.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CloneCopyOutStateForLocalCopy</name><parameter_list>(<parameter><decl><type><name>CopyOutState</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>CopyOutState</name></type> <name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attnumlist</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>attnumlist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>binary</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>binary</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>copy_dest</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>copy_dest</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>delim</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>delim</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>file_encoding</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>file_encoding</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>need_transcoding</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>need_transcoding</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>null_print</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>null_print</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>null_print_client</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>null_print_client</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>rowcontext</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>rowcontext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>fe_msgbuf</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LogLocalCopyToRelationExecution logs that the copy will be done
 * locally for the given shard.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogLocalCopyToRelationExecution</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>LogRemoteCommands</name> <operator>||</operator> <name>LogLocalCommands</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"executing the copy locally for shard %lu"</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LogLocalCopyToFileExecution logs that the copy will be done locally for
 * a file colocated to the given shard.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogLocalCopyToFileExecution</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>LogRemoteCommands</name> <operator>||</operator> <name>LogLocalCommands</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"executing the copy locally for colocated file with "</literal>
							<literal type="string">"shard %lu"</literal></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CopyGetPlacementConnection assigns a connection to the given placement. If
 * a connection has already been assigned the placement in the current transaction
 * then it reuses the connection. Otherwise, it requests a connection for placement.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiConnection</name> <modifier>*</modifier></type>
<name>CopyGetPlacementConnection</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>connectionStateHash</name></decl></parameter>, <parameter><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>placement</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>colocatedIntermediateResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>colocatedIntermediateResult</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Colocated intermediate results are just files and not required to use
		 * the same connections with their co-located shards. So, we are free to
		 * use any connection we can get.
		 *
		 * Also, the current connection re-use logic does not know how to handle
		 * intermediate results as the intermediate results always truncates the
		 * existing files. That's why we we use one connection per intermediate
		 * result.
		 *
		 * Also note that we are breaking the guarantees of citus.shared_pool_size
		 * as we cannot rely on optional connections.
		 */</comment>
		<decl_stmt><decl><type><name>uint32</name></type> <name>connectionFlagsForIntermediateResult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
			<expr><call><name>GetNodeConnection</name><argument_list>(<argument><expr><name>connectionFlagsForIntermediateResult</name></expr></argument>, <argument><expr><name><name>placement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></argument>,
							  <argument><expr><name><name>placement</name><operator>-&gt;</operator><name>nodePort</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * As noted above, we want each intermediate file to go over
		 * a separate connection.
		 */</comment>
		<expr_stmt><expr><call><name>ClaimConnectionExclusively</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and, we cannot afford to handle failures when anything goes wrong */</comment>
		<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>connection</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine whether the task has to be assigned to a particular connection
	 * due to a preceding access to the placement in the same transaction.
	 */</comment>
	<decl_stmt><decl><type><name>ShardPlacementAccess</name> <modifier>*</modifier></type><name>placementAccess</name> <init>= <expr><call><name>CreatePlacementAccess</name><argument_list>(<argument><expr><name>placement</name></expr></argument>,
																  <argument><expr><name>PLACEMENT_ACCESS_DML</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>connectionFlags</name> <init>= <expr><name>FOR_DML</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>=
		<expr><call><name>GetConnectionIfPlacementAccessedInXact</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>,
											   <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>placementAccess</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Errors are supposed to cause immediate aborts (i.e. we don't
		 * want to/can't invalidate placements), mark the connection as
		 * critical so later errors cause failures.
		 */</comment>
		<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>connection</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we exceeded citus.max_adaptive_executor_pool_size, we should re-use the
	 * existing connections to multiplex multiple COPY commands on shards over a
	 * single connection.
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name> <init>= <expr><name><name>placement</name><operator>-&gt;</operator><name>nodeName</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nodePort</name> <init>= <expr><name><name>placement</name><operator>-&gt;</operator><name>nodePort</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>copyConnectionStateList</name> <init>=
		<expr><call><name>ConnectionStateListToNode</name><argument_list>(<argument><expr><name>connectionStateHash</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HasReachedAdaptiveExecutorPoolSize</name><argument_list>(<argument><expr><name>copyConnectionStateList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we've already reached the executor pool size, there should be at
		 * least one connection to any given node.
		 *
		 * Note that we don't need to mark the connection as critical, since the
		 * connection was already returned by this function before.
		 */</comment>
		<expr_stmt><expr><name>connection</name> <operator>=</operator> <call><name>GetLeastUtilisedCopyConnection</name><argument_list>(<argument><expr><name>copyConnectionStateList</name></expr></argument>,
													<argument><expr><name>nodeName</name></expr></argument>,
													<argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make sure that the connection management remembers that Citus
		 * accesses this placement over the connection.
		 */</comment>
		<expr_stmt><expr><call><name>AssignPlacementListToConnection</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>placementAccess</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>connection</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsReservationPossible</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Enforce the requirements for adaptive connection management
		 * (a.k.a., throttle connections if citus.max_shared_pool_size
		 * reached).
		 *
		 * Given that we have done reservations per node, we do not ever
		 * need to pass WAIT_FOR_CONNECTION, we are sure that there is a
		 * connection either reserved for this backend or already established
		 * by the previous commands in the same transaction block.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>adaptiveConnectionManagementFlag</name> <init>= <expr><name>OPTIONAL_CONNECTION</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>connectionFlags</name> <operator>|=</operator> <name>adaptiveConnectionManagementFlag</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * For placements that haven't been assigned a connection by a previous command
	 * in the current transaction, we use a separate connection per placement for
	 * hash-distributed tables in order to get the maximum performance.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>placement</name><operator>-&gt;</operator><name>partitionMethod</name></name> <operator>==</operator> <name>DISTRIBUTE_BY_HASH</name> <operator>&amp;&amp;</operator>
		<name>MultiShardConnectionType</name> <operator>!=</operator> <name>SEQUENTIAL_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Claiming the connection exclusively (done below) would also have the
		 * effect of opening multiple connections, but claiming the connection
		 * exclusively prevents GetConnectionIfPlacementAccessedInXact from returning
		 * the connection if it is needed for a different shard placement.
		 *
		 * By setting the REQUIRE_CLEAN_CONNECTION flag we are guaranteed to get
		 * connection that will not be returned by GetConnectionIfPlacementAccessedInXact
		 * for the remainder of the COPY, hence it safe to claim the connection
		 * exclusively. Claiming a connection exclusively prevents it from being
		 * used in other distributed queries that happen during the COPY (e.g. if
		 * the copy logic calls a function to calculate a default value, and the
		 * function does a distributed query).
		 */</comment>
		<expr_stmt><expr><name>connectionFlags</name> <operator>|=</operator> <name>REQUIRE_CLEAN_CONNECTION</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeUser</name> <init>= <expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>connection</name> <operator>=</operator> <call><name>GetPlacementConnection</name><argument_list>(<argument><expr><name>connectionFlags</name></expr></argument>, <argument><expr><name>placement</name></expr></argument>, <argument><expr><name>nodeUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>copyConnectionStateList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The connection manager throttled any new connections, so pick an existing
			 * connection with least utilization.
			 *
			 * Note that we don't need to mark the connection as critical, since the
			 * connection was already returned by this function before.
			 */</comment>
			<expr_stmt><expr><name>connection</name> <operator>=</operator>
				<call><name>GetLeastUtilisedCopyConnection</name><argument_list>(<argument><expr><name>copyConnectionStateList</name></expr></argument>, <argument><expr><name>nodeName</name></expr></argument>,
											   <argument><expr><name>nodePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Make sure that the connection management remembers that Citus
			 * accesses this placement over the connection.
			 */</comment>
			<expr_stmt><expr><call><name>AssignPlacementListToConnection</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>placementAccess</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * For this COPY command, we have not established any connections
			 * and adaptive connection management throttled the new connection
			 * request. This could only happen if this COPY command is the
			 * second (or later) COPY command in a transaction block as the
			 * first COPY command always gets a connection per node thanks to
			 * the connection reservation.
			 *
			 * As we know that there has been at least one COPY command happened
			 * earlier, we need to find the connection to that node, and use it.
			 */</comment>
			<expr_stmt><expr><name>connection</name> <operator>=</operator>
				<call><name>ConnectionAvailableToNode</name><argument_list>(<argument><expr><name>nodeName</name></expr></argument>, <argument><expr><name>nodePort</name></expr></argument>, <argument><expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></argument>,
										  <argument><expr><call><name>CurrentDatabaseName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We do not expect this to happen, but still instead of an assert,
			 * we prefer explicit error message.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>connection</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find an available connection"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Set citus.max_shared_pool_size TO -1 to let "</literal>
										<literal type="string">"COPY command finish"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return <expr><name>connection</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>pgConn</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Errors are supposed to cause immediate aborts (i.e. we don't
	 * want to/can't invalidate placements), mark the connection as
	 * critical so later errors cause failures.
	 */</comment>
	<expr_stmt><expr><call><name>MarkRemoteTransactionCritical</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MultiShardConnectionType</name> <operator>!=</operator> <name>SEQUENTIAL_CONNECTION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ClaimConnectionExclusively</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasReachedAdaptiveExecutorPoolSize returns true if the number of entries in input
 * connection list has greater than or equal to citus.max_adaptive_executor_pool_size.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasReachedAdaptiveExecutorPoolSize</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStateList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>connectionStateList</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>MaxAdaptiveExecutorPoolSize</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We've not reached MaxAdaptiveExecutorPoolSize number of
		 * connections, so we're allowed to establish a new
		 * connection to the given node.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetLeastUtilisedCopyConnection returns a MultiConnection to the given node
 * with the least number of placements assigned to it.
 *
 * It is assumed that there exists at least one connection to the node.
 */</comment>
<function><type><specifier>static</specifier> <name>MultiConnection</name> <modifier>*</modifier></type>
<name>GetLeastUtilisedCopyConnection</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStateList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodeName</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>nodePort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>minPlacementCount</name> <init>= <expr><name>PG_INT32_MAX</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>connectionStateCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only pick the least utilised connection when some connection limits are
	 * reached such as max_shared_pool_size or max_adaptive_executor_pool_size.
	 *
	 * Therefore there should be some connections to choose from.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>connectionStateList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>connectionStateCell</argument>, <argument>connectionStateList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>connectionStateCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>currentConnectionPlacementCount</name> <init>= <expr><name><name>connectionState</name><operator>-&gt;</operator><name>bufferedPlacementCount</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connectionState</name><operator>-&gt;</operator><name>activePlacementState</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>currentConnectionPlacementCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>currentConnectionPlacementCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>currentConnectionPlacementCount</name> <operator>&lt;</operator> <name>minPlacementCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>minPlacementCount</name> <operator>=</operator> <name>currentConnectionPlacementCount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>connection</name> <operator>=</operator> <name><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>connection</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StartPlacementStateCopyCommand sends the COPY for the given placement. It also
 * sends binary headers if this is a binary COPY.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StartPlacementStateCopyCommand</name><parameter_list>(<parameter><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>placementState</name></decl></parameter>,
							   <parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>copyStatement</name></decl></parameter>, <parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>placementState</name><operator>-&gt;</operator><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>placementState</name><operator>-&gt;</operator><name>shardState</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>raiseInterrupts</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>binaryCopy</name> <init>= <expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>copyCommand</name> <init>= <expr><call><name>ConstructCopyStatement</name><argument_list>(<argument><expr><name>copyStatement</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendRemoteCommand</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>copyCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportConnectionError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>GetRemoteCommandResult</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>raiseInterrupts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COPY_IN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReportResultError</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>binaryCopy</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendCopyBinaryHeaders</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EndPlacementStateCopyCommand ends the COPY for the given placement. It also
 * sends binary footers if this is a binary COPY.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EndPlacementStateCopyCommand</name><parameter_list>(<parameter><decl><type><name>CopyPlacementState</name> <modifier>*</modifier></type><name>placementState</name></decl></parameter>,
							 <parameter><decl><type><name>CopyOutState</name></type> <name>copyOutState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MultiConnection</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>placementState</name><operator>-&gt;</operator><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>placementState</name><operator>-&gt;</operator><name>shardState</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>binaryCopy</name> <init>= <expr><name><name>copyOutState</name><operator>-&gt;</operator><name>binary</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* send footers and end copy command */</comment>
	<if_stmt><if>if <condition>(<expr><name>binaryCopy</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SendCopyBinaryFooters</name><argument_list>(<argument><expr><name>copyOutState</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EndRemoteCopy</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UnclaimCopyConnections unclaims all the connections used for COPY.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnclaimCopyConnections</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>connectionStateList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>connectionStateCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>connectionStateCell</argument>, <argument>connectionStateList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CopyConnectionState</name> <modifier>*</modifier></type><name>connectionState</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>connectionStateCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>UnclaimConnection</name><argument_list>(<argument><expr><name><name>connectionState</name><operator>-&gt;</operator><name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>
</unit>
