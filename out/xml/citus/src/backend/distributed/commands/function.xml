<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/commands/function.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * function.c
 *    Commands for FUNCTION statements.
 *
 *    We currently support replicating function definitions on the
 *    coordinator in all the worker nodes in the form of
 *
 *    CREATE OR REPLACE FUNCTION ... queries and
 *    GRANT ... ON FUNCTION queries
 *
 *
 *    ALTER or DROP operations are not yet propagated.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_depended_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/maintenanced.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/pg_dist_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/namespace_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_dist_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_create_or_replace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISABLE_LOCAL_CHECK_FUNCTION_BODIES</name></cpp:macro> <cpp:value>"SET LOCAL check_function_bodies TO off;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESET_CHECK_FUNCTION_BODIES</name></cpp:macro> <cpp:value>"RESET check_function_bodies;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>argumentStartsWith</name><parameter_list>(<parameter><type><name>arg</name></type></parameter>, <parameter><type><name>prefix</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(strncmp(arg, prefix, strlen(prefix)) == 0)</cpp:value></cpp:define>

<comment type="block">/* forward declaration for helper functions*/</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>RecreateSameNonColocatedFunction</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>functionAddress</name></decl></parameter>,
											 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionArgumentName</name></decl></parameter>,
											 <parameter><decl><type><name>bool</name></type> <name>colocateWithTableNameDefault</name></decl></parameter>,
											 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceDelegationAddress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfAnyNodeDoesNotHaveMetadata</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetAggregateDDLCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RegProcedure</name></type> <name>funcOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useCreateOrReplace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetFunctionAlterOwnerCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RegProcedure</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>GetDistributionArgIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionArgumentName</name></decl></parameter>,
								   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>distributionArgumentOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>GetFunctionColocationId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
								   <name>distributionArgumentOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureFunctionCanBeColocatedWithTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
												  <name>distributionColumnType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>
												  <name>sourceRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldPropagateCreateFunction</name><parameter_list>(<parameter><decl><type><name>CreateFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldPropagateAlterFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldAddFunctionSignature</name><parameter_list>(<parameter><decl><type><name>FunctionParameterMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FunctionToObjectAddress</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objectType</name></decl></parameter>,
									  <parameter><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>objectWithArgs</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedAlterFunctionStmt</name><parameter_list>(<parameter><decl><type><name>AlterFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>quote_qualified_func_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DistributeFunctionWithDistributionArgument</name><parameter_list>(<parameter><decl><type><name>RegProcedure</name></type> <name>funcOid</name></decl></parameter>,
													   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionArgumentName</name></decl></parameter>,
													   <parameter><decl><type><name>Oid</name></type> <name>distributionArgumentOid</name></decl></parameter>,
													   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>,
													   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceDelegationAddress</name></decl></parameter>,
													   <parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type>
													   <name>functionAddress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DistributeFunctionColocatedWithDistributedTable</name><parameter_list>(<parameter><decl><type><name>RegProcedure</name></type> <name>funcOid</name></decl></parameter>,
															<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>,
															<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type>
															<name>functionAddress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DistributeFunctionColocatedWithReferenceTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier>
														  <name>ObjectAddress</name> <modifier>*</modifier></type><name>functionAddress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FilterDistributedFunctions</name><parameter_list>(<parameter><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureExtensionFunctionCanBeDistributed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name></type> <name>functionAddress</name></decl></parameter>,
													<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name></type> <name>extensionAddress</name></decl></parameter>,
													<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionArgumentName</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>create_distributed_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * create_distributed_function gets a function or procedure name with their list of
 * argument types in parantheses, then it creates a new distributed function.
 */</comment>
<function><type><name>Datum</name></type>
<name>create_distributed_function</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>funcOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>distributionArgumentNameText</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* optional */</comment>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>colocateWithText</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* optional */</comment>

	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>ddlCommand</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>functionAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>distributionArgumentOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>colocatedWithReferenceTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionArgumentName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>colocateWithTableNameDefault</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceDelegationAddress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>forceDelegation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>extensionAddress</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if called on NULL input, error out */</comment>
	<if_stmt><if>if <condition>(<expr><name>funcOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the first parameter for create_distributed_function() "</literal>
							   <literal type="string">"should be a single a valid function or procedure name "</literal>
							   <literal type="string">"followed by a list of parameters in parantheses"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"skip the parameters with OUT argtype as they are not "</literal>
								<literal type="string">"part of the signature in PostgreSQL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Using the default value, so distribute the function but do not set
		 * the distribution argument.
		 */</comment>
		<expr_stmt><expr><name>distributionArgumentName</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>distributionArgumentNameText</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>distributionArgumentName</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>distributionArgumentNameText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"colocate_with parameter should not be NULL"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To use the default value, set colocate_with option "</literal>
								<literal type="string">"to \"default\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>colocateWithText</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colocateWithTableName</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>colocateWithText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>colocateWithTableNameDefault</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check if the colocation belongs to a reference table */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>colocateWithTableNameDefault</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>colocationRelationId</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>colocateWithText</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>colocatedWithReferenceTable</name> <operator>=</operator> <call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>colocationRelationId</name></expr></argument>,
														   <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* check if the force_delegation flag is explicitly set (default is NULL) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>forceDelegationAddress</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>forceDelegation</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>forceDelegationAddress</name> <operator>=</operator> <operator>&amp;</operator><name>forceDelegation</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureFunctionOwner</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>functionAddress</name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RecreateSameNonColocatedFunction</name><argument_list>(<argument><expr><operator>*</operator><name>functionAddress</name></expr></argument>,
										 <argument><expr><name>distributionArgumentName</name></expr></argument>,
										 <argument><expr><name>colocateWithTableNameDefault</name></expr></argument>,
										 <argument><expr><name>forceDelegationAddress</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_func_namespace</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>functionName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"procedure %s is already distributed"</literal></expr></argument>, <argument><expr><name>qualifiedName</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Citus distributes procedures with CREATE "</literal>
								   <literal type="string">"[PROCEDURE|FUNCTION|AGGREGATE] commands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the function is owned by an extension, only update the
	 * pg_dist_object, and not propagate the CREATE FUNCTION. Function
	 * will be created by the virtue of the extension creation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>functionAddress</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>extensionAddress</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureExtensionFunctionCanBeDistributed</name><argument_list>(<argument><expr><operator>*</operator><name>functionAddress</name></expr></argument>, <argument><expr><name>extensionAddress</name></expr></argument>,
												<argument><expr><name>distributionArgumentName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * when we allow propagation within a transaction block we should make sure
		 * to only allow this in sequential mode.
		 */</comment>
		<expr_stmt><expr><call><name>EnsureSequentialMode</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>functionAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>createFunctionSQL</name> <init>= <expr><call><name>GetFunctionDDLCommand</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alterFunctionOwnerSQL</name> <init>= <expr><call><name>GetFunctionAlterOwnerCommand</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlCommand</name></expr></argument>, <argument><expr><literal type="string">"%s;%s;%s"</literal></expr></argument>, <argument><expr><name>DISABLE_METADATA_SYNC</name></expr></argument>,
						 <argument><expr><name>createFunctionSQL</name></expr></argument>, <argument><expr><name>alterFunctionOwnerSQL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>grantDDLCommands</name> <init>= <expr><call><name>GrantOnFunctionDDLCommands</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>grantOnFunctionSQL</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>grantOnFunctionSQL</argument>, <argument>grantDDLCommands</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlCommand</name></expr></argument>, <argument><expr><literal type="string">";%s"</literal></expr></argument>, <argument><expr><name>grantOnFunctionSQL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ddlCommand</name></expr></argument>, <argument><expr><literal type="string">";%s"</literal></expr></argument>, <argument><expr><name>ENABLE_METADATA_SYNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SendCommandToWorkersAsUser</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><call><name>CurrentUserName</name><argument_list>()</argument_list></call></expr></argument>,
								   <argument><expr><name><name>ddlCommand</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MarkObjectDistributed</name><argument_list>(<argument><expr><name>functionAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>distributionArgumentName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Prior to Citus 11, this code was triggering metadata
		 * syncing. However, with Citus 11+, we expect the metadata
		 * has already been synced.
		 */</comment>
		<expr_stmt><expr><call><name>ErrorIfAnyNodeDoesNotHaveMetadata</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DistributeFunctionWithDistributionArgument</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><name>distributionArgumentName</name></expr></argument>,
												   <argument><expr><name>distributionArgumentOid</name></expr></argument>,
												   <argument><expr><name>colocateWithTableName</name></expr></argument>,
												   <argument><expr><name>forceDelegationAddress</name></expr></argument>,
												   <argument><expr><name>functionAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>colocatedWithReferenceTable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DistributeFunctionColocatedWithDistributedTable</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><name>colocateWithTableName</name></expr></argument>,
														<argument><expr><name>functionAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>colocatedWithReferenceTable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Prior to Citus 11, this code was triggering metadata
		 * syncing. However, with Citus 11+, we expect the metadata
		 * has already been synced.
		 */</comment>
		<expr_stmt><expr><call><name>ErrorIfAnyNodeDoesNotHaveMetadata</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DistributeFunctionColocatedWithReferenceTable</name><argument_list>(<argument><expr><name>functionAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RecreateSameNonColocatedFunction returns true if the given parameters of
 * create_distributed_function will not change anything on the given function.
 * Returns false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RecreateSameNonColocatedFunction</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name></type> <name>functionAddress</name></decl></parameter>,
								 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionArgumentName</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>colocateWithTableNameDefault</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceDelegationAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistObjectCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>=
		<expr><call><name>LookupDistObjectCacheEntry</name><argument_list>(<argument><expr><name>ProcedureRelationId</name></expr></argument>,
								   <argument><expr><name><name>functionAddress</name><operator>.</operator><name>objectId</name></name></expr></argument>,
								   <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cacheEntry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>cacheEntry</name><operator>-&gt;</operator><name>isValid</name></name> <operator>||</operator> <operator>!</operator><name><name>cacheEntry</name><operator>-&gt;</operator><name>isDistributed</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the colocationId, forceDelegation and distributionArgIndex fields of a
	 * pg_dist_object entry of a distributed function are all set to zero, it means
	 * that function is either automatically distributed by ddl propagation, without
	 * calling create_distributed_function. Or, it could be distributed via
	 * create_distributed_function, but with no parameters.
	 *
	 * For these cases, calling create_distributed_function for that function,
	 * without parameters would be idempotent. Hence we can simply early return here,
	 * by providing a notice message to the user.
	 */</comment>

	<comment type="block">/* are pg_dist_object fields set to zero? */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>functionDistributedWithoutParams</name> <init>=
		<expr><name><name>cacheEntry</name><operator>-&gt;</operator><name>colocationId</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>cacheEntry</name><operator>-&gt;</operator><name>forceDelegation</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>cacheEntry</name><operator>-&gt;</operator><name>distributionArgIndex</name></name> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* called create_distributed_function without parameters? */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>distributingAgainWithNoParams</name> <init>=
		<expr><name>distributionArgumentName</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name>colocateWithTableNameDefault</name> <operator>&amp;&amp;</operator>
		<name>forceDelegationAddress</name> <operator>==</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>functionDistributedWithoutParams</name> <operator>&amp;&amp;</operator> <name>distributingAgainWithNoParams</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfAnyNodeDoesNotHaveMetadata throws error if any
 * of the worker nodes does not have the metadata.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfAnyNodeDoesNotHaveMetadata</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodeList</name> <init>=
		<expr><call><name>ActivePrimaryNonCoordinatorNodeList</name><argument_list>(<argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workerNode</name><operator>-&gt;</operator><name>hasMetadata</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot process the distributed function "</literal>
								   <literal type="string">"since the node %s:%d does not have metadata "</literal>
								   <literal type="string">"synced and this command requires all the nodes "</literal>
								   <literal type="string">"have the metadata sycned"</literal></expr></argument>, <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr></argument>,
								   <argument><expr><name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To sync the metadata execute: "</literal>
									<literal type="string">"SELECT enable_citus_mx_for_pre_citus11();"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * DistributeFunctionWithDistributionArgument updates pg_dist_object records for
 * a function/procedure that has a distribution argument, and triggers metadata
 * sync so that the functions can be delegated on workers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DistributeFunctionWithDistributionArgument</name><parameter_list>(<parameter><decl><type><name>RegProcedure</name></type> <name>funcOid</name></decl></parameter>,
										   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionArgumentName</name></decl></parameter>,
										   <parameter><decl><type><name>Oid</name></type> <name>distributionArgumentOid</name></decl></parameter>,
										   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceDelegationAddress</name></decl></parameter>,
										   <parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>functionAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* get the argument index, or error out if we cannot find a valid index */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>distributionArgumentIndex</name> <init>=
		<expr><call><name>GetDistributionArgIndex</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><name>distributionArgumentName</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>distributionArgumentOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get the colocation id, or error out if we cannot find an appropriate one */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>=
		<expr><call><name>GetFunctionColocationId</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><name>colocateWithTableName</name></expr></argument>,
								<argument><expr><name>distributionArgumentOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* record the distribution argument and colocationId */</comment>
	<expr_stmt><expr><call><name>UpdateFunctionDistributionInfo</name><argument_list>(<argument><expr><name>functionAddress</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>distributionArgumentIndex</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>colocationId</name></expr></argument>,
								   <argument><expr><name>forceDelegationAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DistributeFunctionColocatedWithDistributedTable updates pg_dist_object records for
 * a function/procedure that is colocated with a distributed table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DistributeFunctionColocatedWithDistributedTable</name><parameter_list>(<parameter><decl><type><name>RegProcedure</name></type> <name>funcOid</name></decl></parameter>,
												<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>,
												<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>functionAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * cannot provide colocate_with without distribution_arg_name when the function
	 * is not colocated with a reference table
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute the function \"%s\" since the "</literal>
							   <literal type="string">"distribution argument is not valid "</literal></expr></argument>, <argument><expr><name>functionName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To provide \"colocate_with\" option with a"</literal>
								<literal type="string">" distributed table, the distribution argument"</literal>
								<literal type="string">" parameter should also be provided"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set distribution argument and colocationId to NULL */</comment>
	<expr_stmt><expr><call><name>UpdateFunctionDistributionInfo</name><argument_list>(<argument><expr><name>functionAddress</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DistributeFunctionColocatedWithReferenceTable updates pg_dist_object records for
 * a function/procedure that is colocated with a reference table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DistributeFunctionColocatedWithReferenceTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>functionAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* get the reference table colocation id */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><call><name>CreateReferenceTableColocationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set distribution argument to NULL and colocationId to the reference table colocation id */</comment>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>distributionArgumentIndex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>UpdateFunctionDistributionInfo</name><argument_list>(<argument><expr><name>functionAddress</name></expr></argument>, <argument><expr><name>distributionArgumentIndex</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>colocationId</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateFunctionDDLCommandsIdempotent returns a list of DDL statements (const char *) to be
 * executed on a node to recreate the function addressed by the functionAddress.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CreateFunctionDDLCommandsIdempotent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>functionAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>functionAddress</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name>ProcedureRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ddlCommand</name> <init>= <expr><call><name>GetFunctionDDLCommand</name><argument_list>(<argument><expr><name><name>functionAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alterFunctionOwnerSQL</name> <init>= <expr><call><name>GetFunctionAlterOwnerCommand</name><argument_list>(<argument><expr><name><name>functionAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>list_make4</name><argument_list>(
		<argument><expr><name>DISABLE_LOCAL_CHECK_FUNCTION_BODIES</name></expr></argument>,
		<argument><expr><name>ddlCommand</name></expr></argument>,
		<argument><expr><name>alterFunctionOwnerSQL</name></expr></argument>,
		<argument><expr><name>RESET_CHECK_FUNCTION_BODIES</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDistributionArgIndex calculates the distribution argument with the given
 * parameters. The function errors out if no valid argument is found.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetDistributionArgIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionArgumentName</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>distributionArgumentOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>distributionArgumentIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argTypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argNames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argModes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


	<expr_stmt><expr><operator>*</operator><name>distributionArgumentOid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>numberOfArgs</name> <init>= <expr><call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argTypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argNames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argModes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>argumentStartsWith</name><argument_list>(<argument><expr><name>distributionArgumentName</name></expr></argument>, <argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* skip the first character, we're safe because text_to_cstring pallocs */</comment>
		<expr_stmt><expr><name>distributionArgumentName</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* throws error if the input is not an integer */</comment>
		<expr_stmt><expr><name>distributionArgumentIndex</name> <operator>=</operator> <call><name>pg_strtoint32</name><argument_list>(<argument><expr><name>distributionArgumentName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>distributionArgumentIndex</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>distributionArgumentIndex</name></expr></argument> &gt;</argument_list></name> <name>numberOfArgs</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute the function \"%s\" since "</literal>
								   <literal type="string">"the distribution argument is not valid"</literal></expr></argument>,
								   <argument><expr><name>functionName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Either provide a valid function argument name "</literal>
									<literal type="string">"or a valid \"$paramIndex\" to "</literal>
									<literal type="string">"create_distributed_function()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Internal representation for the distributionArgumentIndex
		 * starts from 0 whereas user facing API starts from 1.
		 */</comment>
		<expr_stmt><expr><name>distributionArgumentIndex</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>distributionArgumentOid</name> <operator>=</operator> <name><name>argTypes</name><index>[<expr><name>distributionArgumentIndex</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>distributionArgumentOid</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>distributionArgumentIndex</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The user didn't provid "$paramIndex" but potentially the name of the parameter.
	 * So, loop over the arguments and try to find the argument name that matches
	 * the parameter that user provided.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>argIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>argIndex</name> <operator>&lt;</operator> <name>numberOfArgs</name></expr>;</condition> <incr><expr><operator>++</operator><name>argIndex</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argNameOnIndex</name> <init>= <expr><ternary><condition><expr><name>argNames</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>argNames</name><index>[<expr><name>argIndex</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>argNameOnIndex</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>argNameOnIndex</name></expr></argument>, <argument><expr><name>distributionArgumentName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>distributionArgumentIndex</name> <operator>=</operator> <name>argIndex</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>distributionArgumentOid</name> <operator>=</operator> <name><name>argTypes</name><index>[<expr><name>argIndex</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* we found, no need to continue */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* we still couldn't find the argument, so error out */</comment>
	<if_stmt><if>if <condition>(<expr><name>distributionArgumentIndex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute the function \"%s\" since the "</literal>
							   <literal type="string">"distribution argument is not valid "</literal></expr></argument>, <argument><expr><name>functionName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Either provide a valid function argument name "</literal>
								<literal type="string">"or a valid \"$paramIndex\" to "</literal>
								<literal type="string">"create_distributed_function()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>distributionArgumentOid</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>distributionArgumentIndex</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetFunctionColocationId gets the parameters for deciding the colocationId
 * of the function that is being distributed. The function errors out if it is
 * not possible to assign a colocationId to the input function.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetFunctionColocationId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWithTableName</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>distributionArgumentOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>colocationId</name> <init>= <expr><name>INVALID_COLOCATION_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistColocation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistColocationRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check for default colocation group */</comment>
		<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <call><name>ColocationId</name><argument_list>(<argument><expr><name>ShardCount</name></expr></argument>, <argument><expr><name>ShardReplicationFactor</name></expr></argument>,
									<argument><expr><name>distributionArgumentOid</name></expr></argument>, <argument><expr><call><name>get_typcollation</name><argument_list>(
										<argument><expr><name>distributionArgumentOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot distribute the function \"%s\" since there "</literal>
								   <literal type="string">"is no table to colocate with"</literal></expr></argument>, <argument><expr><name>functionName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Provide a distributed table via \"colocate_with\" "</literal>
									<literal type="string">"option to create_distributed_function()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><call><name>ColocatedTableId</name><argument_list>(<argument><expr><name>colocationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>colocatedTableId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EnsureFunctionCanBeColocatedWithTable</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>, <argument><expr><name>distributionArgumentOid</name></expr></argument>,
												  <argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sourceRelationId</name> <init>=
			<expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>colocateWithTableName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>EnsureFunctionCanBeColocatedWithTable</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>, <argument><expr><name>distributionArgumentOid</name></expr></argument>,
											  <argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>colocationId</name> <operator>=</operator> <call><name>TableColocationId</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* keep the lock */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistColocation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>colocationId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureFunctionCanBeColocatedWithTable checks whether the given arguments are
 * suitable to distribute the function to be colocated with given source table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureFunctionCanBeColocatedWithTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>functionOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distributionColumnType</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>sourceTableEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>sourceReplicationModel</name> <init>= <expr><name><name>sourceTableEntry</name><operator>-&gt;</operator><name>replicationModel</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>sourceTableEntry</name></expr></argument>, <argument><expr><name>HASH_DISTRIBUTED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>sourceTableEntry</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate function \"%s\" and table \"%s\" because "</literal>
							   <literal type="string">"colocate_with option is only supported for hash "</literal>
							   <literal type="string">"distributed tables and reference tables."</literal></expr></argument>,
							   <argument><expr><name>functionName</name></expr></argument>, <argument><expr><name>sourceRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableTypeCacheEntry</name><argument_list>(<argument><expr><name>sourceTableEntry</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>distributionColumnType</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate function \"%s\" and table \"%s\" because "</literal>
							   <literal type="string">"distribution arguments are not supported when "</literal>
							   <literal type="string">"colocating with reference tables."</literal></expr></argument>,
							   <argument><expr><name>functionName</name></expr></argument>, <argument><expr><name>sourceRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sourceReplicationModel</name> <operator>!=</operator> <name>REPLICATION_MODEL_STREAMING</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate function \"%s\" and table \"%s\""</literal></expr></argument>,
							   <argument><expr><name>functionName</name></expr></argument>, <argument><expr><name>sourceRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Citus currently only supports colocating function "</literal>
								  <literal type="string">"with distributed tables that are created using "</literal>
								  <literal type="string">"streaming replication model."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"When distributing tables make sure that "</literal>
								<literal type="string">"citus.shard_replication_factor = 1"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the types are the same, we're good. If not, we still check if there
	 * is any coercion path between the types.
	 */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>sourceDistributionColumn</name> <init>= <expr><call><name>DistPartitionKeyOrError</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sourceDistributionColumnType</name> <init>= <expr><name><name>sourceDistributionColumn</name><operator>-&gt;</operator><name>vartype</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>sourceDistributionColumnType</name> <operator>!=</operator> <name>distributionColumnType</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>coercionFuncId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>coercionType</name> <init>=
			<expr><call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>distributionColumnType</name></expr></argument>, <argument><expr><name>sourceDistributionColumnType</name></expr></argument>,
								  <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coercionFuncId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if there is no path for coercion, error out*/</comment>
		<if_stmt><if>if <condition>(<expr><name>coercionType</name> <operator>==</operator> <name>COERCION_PATH_NONE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>functionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate function \"%s\" and table \"%s\" "</literal>
								   <literal type="string">"because distribution column types don't match and "</literal>
								   <literal type="string">"there is no coercion path"</literal></expr></argument>, <argument><expr><name>sourceRelationName</name></expr></argument>,
								   <argument><expr><name>functionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateFunctionDistributionInfo gets object address of a function and
 * updates its distribution_argument_index and colocationId in pg_dist_object.
 * Then update pg_dist_object on nodes with metadata if object propagation is on.
 */</comment>
<function><type><name>void</name></type>
<name>UpdateFunctionDistributionInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>distAddress</name></decl></parameter>,
							   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>distribution_argument_index</name></decl></parameter>,
							   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>colocationId</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>forceDelegation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>indexOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_pg_dist_object</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isnull</name><index>[<expr><name>Natts_pg_dist_object</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>replace</name><index>[<expr><name>Natts_pg_dist_object</name></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDistObjectRel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>DistObjectRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgDistObjectRel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* scan pg_dist_object for classid = $1 AND objid = $2 AND objsubid = $3 via index */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_object_classid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>distAddress</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_object_objid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>distAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_dist_object_objsubid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>distAddress</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDistObjectRel</name></expr></argument>,
													<argument><expr><call><name>DistObjectPrimaryKeyIndexId</name><argument_list>()</argument_list></call></expr></argument>,
													<argument><expr><name>indexOK</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find valid entry for node \"%d,%d,%d\" "</literal>
							   <literal type="string">"in pg_dist_object"</literal></expr></argument>, <argument><expr><name><name>distAddress</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>,
							   <argument><expr><name><name>distAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>, <argument><expr><name><name>distAddress</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_dist_object_distribution_argument_index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>distribution_argument_index</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_object_distribution_argument_index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(
			<argument><expr><operator>*</operator><name>distribution_argument_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>Anum_pg_dist_object_distribution_argument_index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>Anum_pg_dist_object_distribution_argument_index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_dist_object_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_object_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>*</operator><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>Anum_pg_dist_object_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>Anum_pg_dist_object_colocationid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_dist_object_force_delegation</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>forceDelegation</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_dist_object_force_delegation</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(
			<argument><expr><operator>*</operator><name>forceDelegation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>Anum_pg_dist_object_force_delegation</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>Anum_pg_dist_object_force_delegation</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pgDistObjectRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CitusInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><call><name>DistObjectRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDistObjectRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>EnableMetadataSync</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>objectAddressList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator> <name>distAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distArgumentIndexList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>forceDelegationList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>distribution_argument_index</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>distArgumentIndexList</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>INVALID_DISTRIBUTION_ARGUMENT_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>distArgumentIndexList</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><operator>*</operator><name>distribution_argument_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>colocationId</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>colocationIdList</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>INVALID_COLOCATION_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>colocationIdList</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><operator>*</operator><name>colocationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>forceDelegation</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>forceDelegationList</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>NO_FORCE_PUSHDOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>forceDelegationList</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><operator>*</operator><name>forceDelegation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>workerPgDistObjectUpdateCommand</name> <init>=
			<expr><call><name>MarkObjectsDistributedCreateCommand</name><argument_list>(<argument><expr><name>objectAddressList</name></expr></argument>,
												<argument><expr><name>distArgumentIndexList</name></expr></argument>,
												<argument><expr><name>colocationIdList</name></expr></argument>,
												<argument><expr><name>forceDelegationList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>workerPgDistObjectUpdateCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetFunctionDDLCommand returns the complete "CREATE OR REPLACE FUNCTION ..." statement for
 * the specified function.
 *
 * useCreateOrReplace is ignored for non-aggregate functions.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetFunctionDDLCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RegProcedure</name></type> <name>funcOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useCreateOrReplace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>createFunctionSQL</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_func_prokind</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROKIND_AGGREGATE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>createFunctionSQL</name> <operator>=</operator> <call><name>GetAggregateDDLCommand</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>, <argument><expr><name>useCreateOrReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>sqlTextDatum</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PushOverrideEmptySearchPath</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sqlTextDatum</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_get_functiondef</name></expr></argument>,
										   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>createFunctionSQL</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>sqlTextDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* revert back to original search_path */</comment>
		<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>createFunctionSQL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetFunctionAlterOwnerCommand returns "ALTER FUNCTION .. SET OWNER .." statement for
 * the specified function.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetFunctionAlterOwnerCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RegProcedure</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>alterCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>procOwner</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>


	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>procOwner</name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>proowner</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot find function with oid: %d"</literal></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the function exists we want to use format_procedure_qualified to
	 * serialize its canonical arguments
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionSignature</name> <init>= <expr><call><name>format_procedure_qualified</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionOwner</name> <init>= <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>procOwner</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>alterCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER ROUTINE %s OWNER TO %s;"</literal></expr></argument>,
					 <argument><expr><name>functionSignature</name></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>functionOwner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>alterCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAggregateDDLCommand returns a string for creating an aggregate.
 * A second parameter useCreateOrReplace signals whether to
 * to create a plain CREATE AGGREGATE or not.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetAggregateDDLCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RegProcedure</name></type> <name>funcOid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useCreateOrReplace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argmodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>insertorderbyat</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>argsprinted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>inputargno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for %d"</literal></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proc</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>prokind</name></name> <operator>==</operator> <name>PROKIND_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nsp</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pronamespace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>useCreateOrReplace</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE AGGREGATE %s("</literal></expr></argument>,
						 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"CREATE AGGREGATE %s("</literal></expr></argument>,
						 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Parameters, borrows heavily from print_function_arguments in postgres */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>numargs</name> <init>= <expr><call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>aggtup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggtup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for %d"</literal></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>agg</name> <init>= <expr><operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggkind</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>insertorderbyat</name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggnumdirectargs</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For zero-argument aggregate, write * in place of the list of arguments
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numargs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>argtype</name> <init>= <expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argname</name> <init>= <expr><ternary><condition><expr><name>argnames</name></expr> ?</condition><then> <expr><name><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name>argmode</name> <init>= <expr><ternary><condition><expr><name>argmodes</name></expr> ?</condition><then> <expr><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>PROARGMODE_IN</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modename</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>argmode</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PROARGMODE_IN</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>modename</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>PROARGMODE_VARIADIC</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>modename</name> <operator>=</operator> <literal type="string">"VARIADIC "</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<default>default:</default>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected parameter mode '%c'"</literal></expr></argument>, <argument><expr><name>argmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>modename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		</block_content>}</block></switch>

		<expr_stmt><expr><name>inputargno</name><operator>++</operator></expr>;</expr_stmt>       <comment type="block">/* this is a 1-based counter */</comment>
		<if_stmt><if>if <condition>(<expr><name>argsprinted</name> <operator>==</operator> <name>insertorderbyat</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>argsprinted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>modename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>argname</name> <operator>&amp;&amp;</operator> <name><name>argname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>argname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>argsprinted</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* nasty hack: print the last arg twice for variadic ordered-set agg */</comment>
		<if_stmt><if>if <condition>(<expr><name>argsprinted</name> <operator>==</operator> <name>insertorderbyat</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>numargs</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") (STYPE = %s,SFUNC = %s"</literal></expr></argument>,
					 <argument><expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_qualified_func_name</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtransfn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggtransspace</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", SSPACE = %d"</literal></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtransspace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggfinalfn</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>finalmodifystring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggfinalmodify</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AGGMODIFY_READ_ONLY</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>finalmodifystring</name> <operator>=</operator> <literal type="string">"READ_ONLY"</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AGGMODIFY_SHAREABLE</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>finalmodifystring</name> <operator>=</operator> <literal type="string">"SHAREABLE"</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AGGMODIFY_READ_WRITE</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>finalmodifystring</name> <operator>=</operator> <literal type="string">"READ_WRITE"</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", FINALFUNC = %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_qualified_func_name</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggfinalfn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>finalmodifystring</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", FINALFUNC_MODIFY = %s"</literal></expr></argument>, <argument><expr><name>finalmodifystring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggfinalextra</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", FINALFUNC_EXTRA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggmtransspace</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", MSSPACE = %d"</literal></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggmtransspace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggmfinalfn</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mfinalmodifystring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggfinalmodify</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AGGMODIFY_READ_ONLY</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>mfinalmodifystring</name> <operator>=</operator> <literal type="string">"READ_ONLY"</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AGGMODIFY_SHAREABLE</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>mfinalmodifystring</name> <operator>=</operator> <literal type="string">"SHAREABLE"</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>AGGMODIFY_READ_WRITE</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>mfinalmodifystring</name> <operator>=</operator> <literal type="string">"READ_WRITE"</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", MFINALFUNC = %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_qualified_func_name</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggmfinalfn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>mfinalmodifystring</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", MFINALFUNC_MODIFY = %s"</literal></expr></argument>, <argument><expr><name>mfinalmodifystring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggmfinalextra</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", MFINALFUNC_EXTRA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggmtransfn</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", MSFUNC = %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_qualified_func_name</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggmtransfn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggmtranstype</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", MSTYPE = %s"</literal></expr></argument>,
							 <argument><expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggmtranstype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggtransspace</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", SSPACE = %d"</literal></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtransspace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggminvtransfn</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", MINVFUNC = %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_qualified_func_name</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggminvtransfn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", COMBINEFUNC = %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_qualified_func_name</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggcombinefn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggserialfn</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", SERIALFUNC = %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_qualified_func_name</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggserialfn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggdeserialfn</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", DESERIALFUNC = %s"</literal></expr></argument>,
						 <argument><expr><call><name>quote_qualified_func_name</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggdeserialfn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggsortop</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", SORTOP = %s"</literal></expr></argument>,
						 <argument><expr><call><name>generate_operator_name</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggsortop</name></name></expr></argument>, <argument><expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
												<argument><expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parallelstring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>proparallel</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PROPARALLEL_SAFE</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>parallelstring</name> <operator>=</operator> <literal type="string">"SAFE"</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>PROPARALLEL_RESTRICTED</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>parallelstring</name> <operator>=</operator> <literal type="string">"RESTRICTED"</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>PROPARALLEL_UNSAFE</name></expr>:</case>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block>

			<default>default:</default>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Unknown parallel option, ignoring: %c"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>proparallel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>parallelstring</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", PARALLEL = %s"</literal></expr></argument>, <argument><expr><name>parallelstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>textInitVal</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name>aggtup</name></expr></argument>,
											<argument><expr><name>Anum_pg_aggregate_agginitval</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strInitVal</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>textInitVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strInitValQuoted</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>strInitVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", INITCOND = %s"</literal></expr></argument>, <argument><expr><name>strInitValQuoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strInitValQuoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strInitVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>textInitVal</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name>aggtup</name></expr></argument>,
											<argument><expr><name>Anum_pg_aggregate_aggminitval</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strInitVal</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>textInitVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strInitValQuoted</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>strInitVal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", MINITCOND = %s"</literal></expr></argument>, <argument><expr><name>strInitValQuoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strInitValQuoted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strInitVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>==</operator> <name>AGGKIND_HYPOTHETICAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", HYPOTHETICAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldPropagateCreateFunction tests if we need to propagate a CREATE FUNCTION
 * statement.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldPropagateCreateFunction</name><parameter_list>(<parameter><decl><type><name>CreateFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateCreateInCoordinatedTransction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldPropagateAlterFunction returns, based on the address of a function, if alter
 * statements targeting the function should be propagated.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldPropagateAlterFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>creating_extension</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * extensions should be created separately on the workers, functions cascading
		 * from an extension should therefore not be propagated.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableMetadataSync</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we are configured to disable object propagation, should not propagate anything
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>(</operator><name>ObjectAddress</name> <operator>*</operator><operator>)</operator> <name>address</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* do not propagate alter function for non-distributed functions */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessCreateFunctionStmt is called during the planning phase for CREATE [OR REPLACE]
 * FUNCTION before it is created on the local node internally.
 *
 * Since we use pg_get_functiondef to get the ddl command we actually do not do any
 * planning here, instead we defer the plan creation to the postprocessing step.
 *
 * Instead we do our basic housekeeping where we make sure we are on the coordinator and
 * can propagate the function in sequential mode.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessCreateFunctionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
							 <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateFunctionStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateCreateFunction</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EnsureSequentialMode</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * ddl jobs will be generated during the postprocessing phase as we need the function to
	 * be updated in the catalog to get its sql representation
	 */</comment>
	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessCreateFunctionStmt actually creates the plan we need to execute for function
 * propagation. This is the downside of using pg_get_functiondef to get the sql statement.
 *
 * If function depends on any non-distributed relation (except sequence and composite type),
 * Citus can not distribute it. In order to not to prevent users from creating local
 * functions on the coordinator WARNING message will be sent to the customer about the case
 * instead of erroring out.
 *
 * Besides creating the plan we also make sure all (new) dependencies of the function are
 * created on all nodes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessCreateFunctionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateFunctionStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateCreateFunction</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
																<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>functionAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><name>functionAddresses</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If the function has any unsupported dependency, create it locally */</comment>
	<decl_stmt><decl><type><name>DeferredErrorMessage</name> <modifier>*</modifier></type><name>errMsg</name> <init>= <expr><call><name>DeferErrorIfAnyObjectHasUnsupportedDependency</name><argument_list>(
		<argument><expr><name>functionAddresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>errMsg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>EnableUnsupportedFeatureMessages</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RaiseDeferredError</name><argument_list>(<argument><expr><name>errMsg</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><name>functionAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We have already asserted that we have exactly 1 address in the addresses. */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>functionAddress</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>functionAddresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><call><name>CreateFunctionDDLCommandsIdempotent</name><argument_list>(
							   <argument><expr><name>functionAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateFunctionStmtObjectAddress returns the ObjectAddress for the subject of the
 * CREATE [OR REPLACE] FUNCTION statement. If missing_ok is false it will error with the
 * normal postgres error for unfound functions.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CreateFunctionStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateFunctionStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectType</name></type> <name>objectType</name> <init>= <expr><name>OBJECT_FUNCTION</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_procedure</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>objectType</name> <operator>=</operator> <name>OBJECT_PROCEDURE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>objectWithArgs</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objname</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>funcname</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>FunctionParameter</name> <modifier>*</modifier></type><name>funcParam</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>funcParam</argument>, <argument>stmt-&gt;parameters</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ShouldAddFunctionSignature</name><argument_list>(<argument><expr><name><name>funcParam</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objargs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objargs</name></name></expr></argument>,
											  <argument><expr><name><name>funcParam</name><operator>-&gt;</operator><name>argType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>int</name></type> <name>OldClientMinMessage</name> <init>= <expr><name>client_min_messages</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* suppress NOTICE if running under pg vanilla tests */</comment>
	<expr_stmt><expr><call><name>SetLocalClientMinMessagesIfRunningPGTests</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcAddresses</name> <init>= <expr><call><name>FunctionToObjectAddress</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>, <argument><expr><name>objectWithArgs</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set it back */</comment>
	<expr_stmt><expr><call><name>SetLocalClientMinMessagesIfRunningPGTests</name><argument_list>(<argument><expr><name>OldClientMinMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>funcAddresses</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DefineAggregateStmtObjectAddress finds the ObjectAddress for the composite type described
 * by the DefineStmtObjectAddress. If missing_ok is false this function throws an error if the
 * aggregate does not exist.
 *
 * objectId in the address can be invalid if missing_ok was set to true.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>DefineAggregateStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DefineStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DefineStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>OBJECT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>objectWithArgs</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objname</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>defnames</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FunctionParameter</name> <modifier>*</modifier></type><name>funcParam</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>funcParam</argument>, <argument>linitial(stmt-&gt;args)</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objargs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objargs</name></name></expr></argument>,
											  <argument><expr><name><name>funcParam</name><operator>-&gt;</operator><name>argType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>defItem</argument>, <argument>stmt-&gt;definition</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * If no explicit args are given, pg includes basetype in the signature.
			 * If the basetype given is a type, like int4, we should include it in the
			 * signature. In that case, defItem-&gt;arg would be a TypeName.
			 * If the basetype given is a string, like "ANY", we shouldn't include it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defItem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"basetype"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>defItem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>TypeName</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objargs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objargs</name></name></expr></argument>,
												  <argument><expr><name><name>defItem</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>FunctionToObjectAddress</name><argument_list>(<argument><expr><name>OBJECT_AGGREGATE</name></expr></argument>, <argument><expr><name>objectWithArgs</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterFunctionStmt is invoked for alter function statements with actions. Here we
 * plan the jobs to be executed on the workers for functions that have been distributed in
 * the cluster.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterFunctionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
							<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterFunctionStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AssertObjectTypeIsFunctional</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>addresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We have already asserted that we have exactly 1 address in the addresses. */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateAlterFunction</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorIfUnsupportedAlterFunctionStmt</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureSequentialMode</name><argument_list>(<argument><expr><name>OBJECT_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QualifyTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>sql</name></expr></argument>,
								<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterFunctionDependsStmt is called during the planning phase of an
 * ALTER FUNCION ... DEPENDS ON EXTENSION ... statement. Since functions depending on
 * extensions are assumed to be Owned by an extension we assume the extension to keep the
 * function in sync.
 *
 * If we would allow users to create a dependency between a distributed function and an
 * extension our pruning logic for which objects to distribute as dependencies of other
 * objects will change significantly which could cause issues adding new workers. Hence we
 * don't allow this dependency to be created.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterFunctionDependsStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
								   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectDependsStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AssertObjectTypeIsFunctional</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>creating_extension</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * extensions should be created separately on the workers, types cascading from an
		 * extension should therefore not be propagated here.
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableMetadataSync</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we are configured to disable object propagation, should not propagate anything
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>addresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We have already asserted that we have exactly 1 address in the addresses. */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Distributed objects should not start depending on an extension, this will break
	 * the dependency resolving mechanism we use to replicate distributed objects to new
	 * workers
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>=
		<expr><call><name>getObjectIdentity_compat</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <comment type="block">/* missingOk: */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distrtibuted functions are not allowed to depend on an "</literal>
						   <literal type="string">"extension"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Function \"%s\" is already distributed. Functions from "</literal>
							  <literal type="string">"extensions are expected to be created on the workers by "</literal>
							  <literal type="string">"the extension they depend on."</literal></expr></argument>, <argument><expr><name>functionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AlterFunctionDependsStmtObjectAddress resolves the ObjectAddress of the function that
 * is the subject of an ALTER FUNCTION ... DEPENS ON EXTENSION ... statement. If
 * missing_ok is set to false the lookup will raise an error.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterFunctionDependsStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectDependsStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AssertObjectTypeIsFunctional</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>FunctionToObjectAddress</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>,
								   <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterFunctionStmtObjectAddress returns the ObjectAddress of the subject in the
 * AlterFunctionStmt. If missing_ok is set to false an error will be raised if postgres
 * was unable to find the function/procedure that was the target of the statement.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterFunctionStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterFunctionStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>FunctionToObjectAddress</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RenameFunctionStmtObjectAddress returns the ObjectAddress of the function that is the
 * subject of the RenameStmt. Errors if missing_ok is false.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RenameFunctionStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>FunctionToObjectAddress</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name></expr></argument>,
								   <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterFunctionOwnerObjectAddress returns the ObjectAddress of the function that is the
 * subject of the AlterOwnerStmt. Errors if missing_ok is false.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterFunctionOwnerObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterOwnerStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>FunctionToObjectAddress</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>,
								   <argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterFunctionSchemaStmtObjectAddress returns the ObjectAddress of the function that is
 * the subject of the AlterObjectSchemaStmt. Errors if missing_ok is false.
 *
 * This could be called both before or after it has been applied locally. It will look in
 * the old schema first, if the function cannot be found in that schema it will look in
 * the new schema. Errors if missing_ok is false and the type cannot be found in either of
 * the schemas.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterFunctionSchemaStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AssertObjectTypeIsFunctional</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>objectWithArgs</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>funcOid</name> <init>= <expr><call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>, <argument><expr><name>objectWithArgs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name> <init>= <expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objname</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>funcOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * couldn't find the function, might have already been moved to the new schema, we
		 * construct a new objname that uses the new schema to search in.
		 */</comment>

		<comment type="block">/* the name of the function is the last in the list of names */</comment>
		<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>funcNameStr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_tail</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newNames</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>funcNameStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * we don't error here either, as the error would be not a good user facing
		 * error if the type didn't exist in the first place.
		 */</comment>
		<expr_stmt><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objname</name></name> <operator>=</operator> <name>newNames</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>funcOid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>, <argument><expr><name>objectWithArgs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objname</name></name> <operator>=</operator> <name>names</name></expr>;</expr_stmt> <comment type="block">/* restore the original names */</comment>

		<comment type="block">/*
		 * if the function is still invalid we couldn't find the function, cause postgres
		 * to error by preforming a lookup once more. Since we know the
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name> <operator>&amp;&amp;</operator> <name>funcOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * this will most probably throw an error, unless for some reason the function
			 * has just been created (if possible at all). For safety we assign the
			 * funcOid.
			 */</comment>
			<expr_stmt><expr><name>funcOid</name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name></expr></argument>, <argument><expr><name>objectWithArgs</name></expr></argument>,
										 <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateBackupNameForProcCollision generates a new proc name for an existing proc. The
 * name is generated in such a way that the new name doesn't overlap with an existing proc
 * by adding a suffix with incrementing number after the new name.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GenerateBackupNameForProcCollision</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newName</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>suffix</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>namespace</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_func_namespace</name><argument_list>(
														  <argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>baseName</name> <init>= <expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>baseLength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>baseName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argmodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"citus cache lookup failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>numargs</name> <init>= <expr><call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>suffixLength</name> <init>= <expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"(citus_backup_%d)"</literal></expr></argument>,
										<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* trim the base name at the end to leave space for the suffix and trailing \0 */</comment>
		<expr_stmt><expr><name>baseLength</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>baseLength</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <name>suffixLength</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* clear newName before copying the potentially trimmed baseName and suffix */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>newName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy_s</name><argument_list>(<argument><expr><name>newName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><name>baseName</name></expr></argument>, <argument><expr><name>baseLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy_s</name><argument_list>(<argument><expr><name>newName</name> <operator>+</operator> <name>baseLength</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <name>baseLength</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>,
				  <argument><expr><name>suffixLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newProcName</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* don't need to rename if the input arguments don't match */</comment>
		<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name> <init>= <expr><call><name>FuncnameGetCandidates_compat</name><argument_list>(<argument><expr><name>newProcName</name></expr></argument>, <argument><expr><name>numargs</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
															   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>clist</name></expr>;</condition> <incr><expr><name>clist</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>clist</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numargs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>clist</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>newName</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * ObjectWithArgsFromOid returns the corresponding ObjectWithArgs node for a given pg_proc oid
 */</comment>
<function><type><name>ObjectWithArgs</name> <modifier>*</modifier></type>
<name>ObjectWithArgsFromOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>objectWithArgs</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>objargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argTypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argNames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argModes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>proctup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"citus cache lookup failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>numargs</name> <init>= <expr><call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argTypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argNames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argModes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objname</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(
		<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_func_namespace</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>argModes</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ShouldAddFunctionSignature</name><argument_list>(<argument><expr><name><name>argModes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>objargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>objargs</name></expr></argument>, <argument><expr><call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name><name>argTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>objectWithArgs</name><operator>-&gt;</operator><name>objargs</name></name> <operator>=</operator> <name>objargs</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>objectWithArgs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldAddFunctionSignature takes a FunctionParameterMode and returns true if it should
 * be included in the function signature. Returns false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldAddFunctionSignature</name><parameter_list>(<parameter><decl><type><name>FunctionParameterMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* only input parameters should be added to the generated signature */</comment>
	<switch>switch <condition>(<expr><name>mode</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FUNC_PARAM_IN</name></expr>:</case>
		<case>case <expr><name>FUNC_PARAM_INOUT</name></expr>:</case>
		<case>case <expr><name>FUNC_PARAM_VARIADIC</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>FUNC_PARAM_OUT</name></expr>:</case>
		<case>case <expr><name>FUNC_PARAM_TABLE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
			<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * FunctionToObjectAddress returns the ObjectAddress of a Function, Procedure or
 * Aggregate based on its type and ObjectWithArgs describing the
 * Function/Procedure/Aggregate. If missing_ok is set to false an error will be
 * raised by postgres explaining the Function/Procedure could not be found.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FunctionToObjectAddress</name><parameter_list>(<parameter><decl><type><name>ObjectType</name></type> <name>objectType</name></decl></parameter>, <parameter><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>objectWithArgs</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertObjectTypeIsFunctional</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>funcOid</name> <init>= <expr><call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>, <argument><expr><name>objectWithArgs</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>ProcedureRelationId</name></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedAlterFunctionStmt raises an error if the AlterFunctionStmt contains a
 * construct that is not supported to be altered on a distributed function. It is assumed
 * the statement passed in is already tested to be targeting a distributed function, and
 * will only execute the checks to error on unsupported constructs.
 *
 * Unsupported Constructs:
 *  - ALTER FUNCTION ... SET ... FROM CURRENT
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedAlterFunctionStmt</name><parameter_list>(<parameter><decl><type><name>AlterFunctionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>action</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>action</argument>, <argument>stmt-&gt;actions</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>action</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"set"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>VariableSetStmt</name> <modifier>*</modifier></type><name>setStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>VariableSetStmt</name></expr></argument>, <argument><expr><name><name>action</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>setStmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>VAR_SET_CURRENT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* check if the set action is a SET ... FROM CURRENT */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported ALTER FUNCTION ... SET ... FROM "</literal>
									   <literal type="string">"CURRENT for a distributed function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"SET FROM CURRENT is not supported for "</literal>
										<literal type="string">"distributed functions, instead use the SET ... "</literal>
										<literal type="string">"TO ... syntax with a constant value."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/* returns the quoted qualified name of a given function oid */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>quote_qualified_func_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>quote_qualified_identifier</name><argument_list>(
		<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_func_namespace</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureExtensionFuncionCanBeCreated checks if the dependent objects
 * (including extension) exists on all nodes, if not, creates them. In
 * addition, it also checks if distribution argument is passed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureExtensionFunctionCanBeDistributed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name></type> <name>functionAddress</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name></type> <name>extensionAddress</name></decl></parameter>,
										<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionArgumentName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>CitusExtensionObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extensionAddress</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Citus extension is a special case. It's the extension that
		 * provides the 'distributed capabilities' in the first place.
		 * Trying to distribute its own function(s) doesn't make sense.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Citus extension functions(%s) "</literal>
							   <literal type="string">"cannot be distributed."</literal></expr></argument>,
							   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>functionAddress</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Distributing functions from extensions has the most benefit when
	 * distribution argument is specified.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>distributionArgumentName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Extension functions(%s) "</literal>
							   <literal type="string">"without distribution argument "</literal>
							   <literal type="string">"are not supported."</literal></expr></argument>,
							   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>functionAddress</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Ensure corresponding extension is in pg_dist_object.
	 * Functions owned by an extension are depending internally on that extension,
	 * hence EnsureAllObjectDependenciesExistOnAllNodes() creates the extension, which in
	 * turn creates the function, and thus we don't have to create it ourself like
	 * we do for non-extension functions.
	 */</comment>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Extension(%s) owning the "</literal>
							<literal type="string">"function(%s) is not distributed, "</literal>
							<literal type="string">"attempting to propogate the extension"</literal></expr></argument>,
							<argument><expr><call><name>get_extension_name</name><argument_list>(<argument><expr><name><name>extensionAddress</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>functionAddress</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>copyFunctionAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>*</operator><name>copyFunctionAddress</name> <operator>=</operator> <name>functionAddress</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>copyFunctionAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessGrantOnFunctionStmt is executed before the statement is applied to the local
 * postgres instance.
 *
 * In this stage we can prepare the commands that need to be run on all workers to grant
 * on distributed functions, procedures, routines.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessGrantOnFunctionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
							  <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>isFunction</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedFunctions</name> <init>= <expr><call><name>FilterDistributedFunctions</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>distributedFunctions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>grantFunctionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>functionAddress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>functionAddress</argument>, <argument>distributedFunctions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>distFunction</name> <init>= <expr><call><name>ObjectWithArgsFromOid</name><argument_list>(
			<argument><expr><name><name>functionAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>grantFunctionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>grantFunctionList</name></expr></argument>, <argument><expr><name>distFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>originalObjects</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GrantTargetType</name></type> <name>originalTargtype</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>grantFunctionList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>=</operator> <name>ACL_TARGET_OBJECT</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>originalObjects</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>=</operator> <name>originalTargtype</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>sql</name></expr></argument>,
								   <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessGrantOnFunctionStmt makes sure dependencies of each
 * distributed function in the statement exist on all nodes
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessGrantOnFunctionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedFunctions</name> <init>= <expr><call><name>FilterDistributedFunctions</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>distributedFunctions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>functionAddress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>functionAddress</argument>, <argument>distributedFunctions</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>functionAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FilterDistributedFunctions determines and returns a list of distributed functions
 * ObjectAddress-es from given grant statement.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FilterDistributedFunctions</name><parameter_list>(<parameter><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>grantStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>grantFunctionList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>grantOnFunctionCommand</name> <init>= <expr><operator>(</operator><name><name>grantStmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>==</operator> <name>ACL_TARGET_OBJECT</name> <operator>&amp;&amp;</operator>
								   <call><name>isFunction</name><argument_list>(<argument><expr><name><name>grantStmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>grantAllFunctionsOnSchemaCommand</name> <init>= <expr><operator>(</operator><name><name>grantStmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>==</operator>
											 <name>ACL_TARGET_ALL_IN_SCHEMA</name> <operator>&amp;&amp;</operator>
											 <call><name>isFunction</name><argument_list>(<argument><expr><name><name>grantStmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we are only interested in function/procedure/routine level grants */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>grantOnFunctionCommand</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>grantAllFunctionsOnSchemaCommand</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>grantAllFunctionsOnSchemaCommand</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedFunctionList</name> <init>= <expr><call><name>DistributedFunctionList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>distributedFunction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>namespaceOidList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* iterate over all namespace names provided to get their oid's */</comment>
		<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>namespaceValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>namespaceValue</argument>, <argument>grantStmt-&gt;objects</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><name>namespaceValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>missing_ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceOid</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>namespaceOidList</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>namespaceOidList</name></expr></argument>, <argument><expr><name>namespaceOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * iterate over all distributed functions to filter the ones
		 * that belong to one of the namespaces from above
		 */</comment>
		<macro><name>foreach_ptr</name><argument_list>(<argument>distributedFunction</argument>, <argument>distributedFunctionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>namespaceOid</name> <init>= <expr><call><name>get_func_namespace</name><argument_list>(<argument><expr><name><name>distributedFunction</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * if this distributed function's schema is one of the schemas
			 * specified in the GRANT .. ALL FUNCTIONS IN SCHEMA ..
			 * add it to the list
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>namespaceOidList</name></expr></argument>, <argument><expr><name>namespaceOid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>grantFunctionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>grantFunctionList</name></expr></argument>, <argument><expr><name>distributedFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectWithArgs</name> <modifier>*</modifier></type><name>objectWithArgs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>objectWithArgs</argument>, <argument>grantStmt-&gt;objects</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>functionAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>functionAddress</name><operator>-&gt;</operator><name>classId</name></name> <operator>=</operator> <name>ProcedureRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>functionAddress</name><operator>-&gt;</operator><name>objectId</name></name> <operator>=</operator> <call><name>LookupFuncWithArgs</name><argument_list>(<argument><expr><name><name>grantStmt</name><operator>-&gt;</operator><name>objtype</name></name></expr></argument>,
														   <argument><expr><name>objectWithArgs</name></expr></argument>,
														   <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>functionAddress</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * if this function from GRANT .. ON FUNCTION .. is a distributed
			 * function, add it to the list
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>functionAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>grantFunctionList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>grantFunctionList</name></expr></argument>, <argument><expr><name>functionAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>grantFunctionList</name></expr>;</return>
</block_content>}</block></function>
</unit>
