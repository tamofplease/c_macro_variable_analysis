<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/commands/foreign_constraint.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * foreign_constraint.c
 *
 * This file contains functions to create, alter and drop foreign
 * constraints on distributed tables.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_join_order.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/namespace_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/utils/array_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BehaviorIsRestrictOrNoAction</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((x) == FKCONSTR_ACTION_NOACTION || (x) == FKCONSTR_ACTION_RESTRICT)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_CREATE_REFERENCE_TABLE_HINT</name></cpp:macro> \
	<cpp:value>"You could use SELECT create_reference_table('%s') " \
	"to replicate the referenced table to all nodes or " \
	"consider dropping the foreign key"</cpp:value></cpp:define>


<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>CheckRelationFunc</name>)<parameter_list>(<parameter><decl><type><name>Oid</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>


<comment type="block">/* Local functions forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureReferencingTableNotReplicated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>referencingTableId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureSupportedFKeyOnDistKey</name><parameter_list>(<parameter><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ForeignKeySetsNextValColumnToDefault</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>pgConstraintTuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ForeignKeyGetDefaultingAttrs</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>pgConstraintTuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureSupportedFKeyBetweenCitusLocalAndRefTable</name><parameter_list>(<parameter><decl><type><name>Form_pg_constraint</name></type>
															<name>constraintForm</name></decl></parameter>,
															<parameter><decl><type><name>char</name></type>
															<name>referencingReplicationModel</name></decl></parameter>,
															<parameter><decl><type><name>char</name></type>
															<name>referencedReplicationModel</name></decl></parameter>,
															<parameter><decl><type><name>Oid</name></type> <name>referencedTableId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HeapTupleOfForeignConstraintIncludesColumn</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>,
													   <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
													   <parameter><decl><type><name>int</name></type> <name>pgConstraintKey</name></decl></parameter>,
													   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>FindForeignKeyOidWithName</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyOids</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier>
									 <name>char</name> <modifier>*</modifier></type><name>inputConstraintName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ForeignConstraintFindDistKeys</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>pgConstraintTuple</name></decl></parameter>,
										  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>referencingDistColumn</name></decl></parameter>,
										  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>referencedDistColumn</name></decl></parameter>,
										  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>referencingAttrIndex</name></decl></parameter>,
										  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>referencedAttrIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetForeignKeyIdsForColumn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>searchForeignKeyColumnFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetForeignKeysWithLocalTables</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsTableTypeIncluded</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ConstraintIsAForeignKeyToReferenceTable checks if the given constraint is a
 * foreign key constraint from the given relation to any reference table.
 */</comment>
<function><type><name>bool</name></type>
<name>ConstraintIsAForeignKeyToReferenceTable</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>inputConstaintName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_REFERENCE_TABLES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyOids</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>foreignKeyOid</name> <init>= <expr><call><name>FindForeignKeyOidWithName</name><argument_list>(<argument><expr><name>foreignKeyOids</name></expr></argument>, <argument><expr><name>inputConstaintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>foreignKeyOid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureNoFKeyFromTableType ensures that given relation is not referenced by any table specified
 * by table type flag.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureNoFKeyFromTableType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tableTypeFlag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCED_CONSTRAINTS</name> <operator>|</operator> <name>EXCLUDE_SELF_REFERENCES</name> <operator>|</operator>
				<name>tableTypeFlag</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencedFKeyOids</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>referencedFKeyOids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>referencingFKeyOid</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>referencedFKeyOids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>referencingTableId</name> <init>= <expr><call><name>GetReferencingTableId</name><argument_list>(<argument><expr><name>referencingFKeyOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>referencingRelName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>referencingTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>referencedRelName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>referencingTableTypeName</name> <init>= <expr><call><name>GetTableTypeName</name><argument_list>(<argument><expr><name>referencingTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation %s is referenced by a foreign key from %s"</literal></expr></argument>,
							   <argument><expr><name>referencedRelName</name></expr></argument>, <argument><expr><name>referencingRelName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"foreign keys from a %s to a distributed table are not supported."</literal></expr></argument>,
							<argument><expr><name>referencingTableTypeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureNoFKeyToTableType ensures that given relation is not referencing by any table specified
 * by table type flag.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureNoFKeyToTableType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tableTypeFlag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>EXCLUDE_SELF_REFERENCES</name> <operator>|</operator>
				<name>tableTypeFlag</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencingFKeyOids</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>referencingFKeyOids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>referencedFKeyOid</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>referencingFKeyOids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>referencedTableId</name> <init>= <expr><call><name>GetReferencedTableId</name><argument_list>(<argument><expr><name>referencedFKeyOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>referencedRelName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>referencingRelName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>referencedTableTypeName</name> <init>= <expr><call><name>GetTableTypeName</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation %s is referenced by a foreign key from %s"</literal></expr></argument>,
							   <argument><expr><name>referencedRelName</name></expr></argument>, <argument><expr><name>referencingRelName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"foreign keys from a distributed table to a %s are not supported."</literal></expr></argument>,
							<argument><expr><name>referencedTableTypeName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedForeignConstraintExists runs checks related to foreign
 * constraints and errors out if it is not possible to create one of the
 * foreign constraint in distributed environment.
 *
 * To support foreign constraints, we require that;
 * - If referencing and referenced tables are hash-distributed
 *		- Referencing and referenced tables are co-located.
 *      - Foreign constraint is defined over distribution column.
 *		- ON DELETE/UPDATE SET NULL, ON DELETE/UPDATE SET DEFAULT and
 *        ON UPDATE CASCADE options
 *        are not used.
 *      - Replication factors of referencing and referenced table are 1.
 * - If referenced table is a reference table
 *      - ON DELETE/UPDATE SET NULL, ON DELETE/UPDATE SET DEFAULT and
 *        ON UPDATE CASCADE options are not used on the distribution key
 *        of the referencing column.
 * - If referencing table is a reference table, error out if the referenced
 *   table is a distributed table.
 * - If referencing table is a reference table and referenced table is a
 *   citus local table:
 *      - ON DELETE/UPDATE SET NULL, ON DELETE/UPDATE SET DEFAULT and
 *        ON CASCADE options are not used.
 * - If referencing or referenced table is distributed table, then the
 *   other table is not a citus local table.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfUnsupportedForeignConstraintExists</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>referencingDistMethod</name></decl></parameter>,
										  <parameter><decl><type><name>char</name></type> <name>referencingReplicationModel</name></decl></parameter>,
										  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>referencingDistKey</name></decl></parameter>,
										  <parameter><decl><type><name>uint32</name></type> <name>referencingColocationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>referencingTableId</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_ALL_TABLE_TYPES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyOids</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>referencingTableId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>foreignKeyOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>foreignKeyOid</argument>, <argument>foreignKeyOids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>foreignKeyOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>referencingAttrIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>referencedDistKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>referencedAttrIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>referencedColocationId</name> <init>= <expr><name>INVALID_COLOCATION_ID</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>referencedTableId</name> <init>= <expr><name><name>constraintForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>referencedIsCitus</name> <init>= <expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>selfReferencingTable</name> <init>= <expr><operator>(</operator><name>referencingTableId</name> <operator>==</operator> <name>referencedTableId</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>referencedIsCitus</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>selfReferencingTable</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IsCitusLocalTableByDistParams</name><argument_list>(<argument><expr><name>referencingDistMethod</name></expr></argument>,
											  <argument><expr><name>referencingReplicationModel</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ErrorOutForFKeyBetweenPostgresAndCitusLocalTable</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>referencedTableName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"referenced table \"%s\" must be a distributed table"</literal>
								   <literal type="string">" or a reference table"</literal></expr></argument>,
								   <argument><expr><name>referencedTableName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"To enforce foreign keys, the referencing and "</literal>
									  <literal type="string">"referenced rows need to be stored on the same "</literal>
									  <literal type="string">"node."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><name>USE_CREATE_REFERENCE_TABLE_HINT</name></expr></argument>,
									<argument><expr><name>referencedTableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* set referenced table related variables here if table is referencing itself */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name>referencedDistMethod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name>referencedReplicationModel</name> <init>= <expr><name>REPLICATION_MODEL_INVALID</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>selfReferencingTable</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>referencedDistMethod</name> <operator>=</operator> <call><name>PartitionMethod</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>referencedDistKey</name> <operator>=</operator> <ternary><condition><expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>,
												 <argument><expr><name>CITUS_TABLE_WITH_NO_DIST_KEY</name></expr></argument>)</argument_list></call></expr> ?</condition><then>
								<expr><name>NULL</name></expr> </then><else>:
								<expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>referencedColocationId</name> <operator>=</operator> <call><name>TableColocationId</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>referencedReplicationModel</name> <operator>=</operator> <call><name>TableReplicationModel</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>referencedDistMethod</name> <operator>=</operator> <name>referencingDistMethod</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>referencedDistKey</name> <operator>=</operator> <name>referencingDistKey</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>referencedColocationId</name> <operator>=</operator> <name>referencingColocationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>referencedReplicationModel</name> <operator>=</operator> <name>referencingReplicationModel</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Given that we drop DEFAULT nextval('sequence') expressions from
		 * shard relation columns, allowing ON DELETE/UPDATE SET DEFAULT
		 * on such columns causes inserting NULL values to referencing relation
		 * as a result of a delete/update operation on referenced relation.
		 *
		 * For this reason, we disallow ON DELETE/UPDATE SET DEFAULT actions
		 * on columns that default to sequences.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ForeignKeySetsNextValColumnToDefault</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign key constraint "</literal>
								   <literal type="string">"since Citus does not support ON DELETE "</literal>
								   <literal type="string">"/ UPDATE SET DEFAULT actions on the "</literal>
								   <literal type="string">"columns that default to sequences"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>referencingIsCitusLocalOrRefTable</name> <init>=
			<expr><operator>(</operator><name>referencingDistMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>referencedIsCitusLocalOrRefTable</name> <init>=
			<expr><operator>(</operator><name>referencedDistMethod</name> <operator>==</operator> <name>DISTRIBUTE_BY_NONE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>referencingIsCitusLocalOrRefTable</name> <operator>&amp;&amp;</operator> <name>referencedIsCitusLocalOrRefTable</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EnsureSupportedFKeyBetweenCitusLocalAndRefTable</name><argument_list>(<argument><expr><name>constraintForm</name></expr></argument>,
															<argument><expr><name>referencingReplicationModel</name></expr></argument>,
															<argument><expr><name>referencedReplicationModel</name></expr></argument>,
															<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Foreign keys from citus local tables or reference tables to distributed
		 * tables are not supported.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>referencingIsCitusLocalOrRefTable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>referencedIsCitusLocalOrRefTable</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign key constraint "</literal>
								   <literal type="string">"since foreign keys from reference tables "</literal>
								   <literal type="string">"and local tables to distributed tables "</literal>
								   <literal type="string">"are not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Reference tables and local tables "</literal>
									  <literal type="string">"can only have foreign keys to reference "</literal>
									  <literal type="string">"tables and local tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * To enforce foreign constraints, tables must be co-located unless a
		 * reference table is referenced.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>referencedIsReferenceTable</name> <init>=
			<expr><operator>(</operator><name>referencedReplicationModel</name> <operator>==</operator> <name>REPLICATION_MODEL_2PC</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>referencedIsReferenceTable</name> <operator>&amp;&amp;</operator> <operator>(</operator>
				<name>referencingColocationId</name> <operator>==</operator> <name>INVALID_COLOCATION_ID</name> <operator>||</operator>
				<name>referencingColocationId</name> <operator>!=</operator> <name>referencedColocationId</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign key constraint since "</literal>
								   <literal type="string">"relations are not colocated or not referencing "</literal>
								   <literal type="string">"a reference table"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(
								<argument><expr><literal type="string">"A distributed table can only have foreign keys "</literal>
								<literal type="string">"if it is referencing another colocated hash "</literal>
								<literal type="string">"distributed table or a reference table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ForeignConstraintFindDistKeys</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>,
									  <argument><expr><name>referencingDistKey</name></expr></argument>,
									  <argument><expr><name>referencedDistKey</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>referencingAttrIndex</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>referencedAttrIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>referencingColumnsIncludeDistKey</name> <init>= <expr><operator>(</operator><name>referencingAttrIndex</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>foreignConstraintOnDistKey</name> <init>=
			<expr><operator>(</operator><name>referencingColumnsIncludeDistKey</name> <operator>&amp;&amp;</operator> <name>referencingAttrIndex</name> <operator>==</operator>
			 <name>referencedAttrIndex</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If columns in the foreign key includes the distribution key from the
		 * referencing side, we do not allow update/delete operations through
		 * foreign key constraints (e.g. ... ON UPDATE SET NULL)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>referencingColumnsIncludeDistKey</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EnsureSupportedFKeyOnDistKey</name><argument_list>(<argument><expr><name>constraintForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * if tables are hash-distributed and colocated, we need to make sure that
		 * the distribution key is included in foreign constraint.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>referencedIsCitusLocalOrRefTable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>foreignConstraintOnDistKey</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign key constraint"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Foreign keys are supported in two cases, "</literal>
									  <literal type="string">"either in between two colocated tables including "</literal>
									  <literal type="string">"partition column in the same ordinal in the both "</literal>
									  <literal type="string">"tables or from distributed to reference tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We do not allow to create foreign constraints if shard replication factor is
		 * greater than 1. Because in our current design, multiple replicas may cause
		 * locking problems and inconsistent shard contents.
		 *
		 * Note that we allow referenced table to be a reference table (e.g., not a
		 * single replicated table). This is allowed since (a) we are sure that
		 * placements always be in the same state (b) executors are aware of reference
		 * tables and handle concurrency related issues accordingly.
		 */</comment>
		<expr_stmt><expr><call><name>EnsureReferencingTableNotReplicated</name><argument_list>(<argument><expr><name>referencingTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ForeignKeySetsNextValColumnToDefault returns true if at least one of the
 * columns specified in ON DELETE / UPDATE SET DEFAULT clauses default to
 * nextval().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ForeignKeySetsNextValColumnToDefault</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>pgConstraintTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>pgConstraintForm</name> <init>=
		<expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pgConstraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>setDefaultAttrs</name> <init>= <expr><call><name>ForeignKeyGetDefaultingAttrs</name><argument_list>(<argument><expr><name>pgConstraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>setDefaultAttr</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_int</name><argument_list>(<argument>setDefaultAttr</argument>, <argument>setDefaultAttrs</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ColumnDefaultsToNextVal</name><argument_list>(<argument><expr><name><name>pgConstraintForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>, <argument><expr><name>setDefaultAttr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ForeignKeyGetDefaultingAttrs returns a list of AttrNumbers
 * might be set to default ON DELETE or ON UPDATE.
 *
 * For example; if the foreign key has SET DEFAULT clause for
 * both actions, then returns a superset of the attributes that
 * might be set to DEFAULT on either of those actions.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ForeignKeyGetDefaultingAttrs</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>pgConstraintTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>referencingColumnsDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>pgConstraintTuple</name></expr></argument>,
													<argument><expr><name>Anum_pg_constraint_conkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"got NULL conkey from catalog"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencingColumns</name> <init>=
		<expr><call><name>IntegerArrayTypeToList</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>referencingColumnsDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>pgConstraintForm</name> <init>=
		<expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pgConstraintTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pgConstraintForm</name><operator>-&gt;</operator><name>confupdtype</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETDEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Postgres doesn't allow specifying SET DEFAULT for a subset of
		 * the referencing columns for ON UPDATE action, so in that case
		 * we return all referencing columns regardless of what ON DELETE
		 * action says.
		 */</comment>
		<return>return <expr><name>referencingColumns</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pgConstraintForm</name><operator>-&gt;</operator><name>confdeltype</name></name> <operator>!=</operator> <name>FKCONSTR_ACTION_SETDEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>onDeleteSetDefColumnList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<decl_stmt><decl><type><name>Datum</name></type> <name>onDeleteSetDefColumnsDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>pgConstraintTuple</name></expr></argument>,
													   <argument><expr><name>Anum_pg_constraint_confdelsetcols</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * confdelsetcols being NULL means that "ON DELETE SET DEFAULT" doesn't
	 * specify which subset of columns should be set to DEFAULT, so fetching
	 * NULL from the catalog is also possible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>onDeleteSetDefColumnList</name> <operator>=</operator>
			<call><name>IntegerArrayTypeToList</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>onDeleteSetDefColumnsDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>onDeleteSetDefColumnList</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * That means that all referencing columns need to be set to
		 * DEFAULT.
		 */</comment>
		<return>return <expr><name>referencingColumns</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>onDeleteSetDefColumnList</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureSupportedFKeyBetweenCitusLocalAndRefTable is a helper function that
 * takes a foreign key constraint form for a foreign key between two citus
 * tables that are either citus local table or reference table and errors
 * out if it it an unsupported foreign key from a reference table to a citus
 * local table according to given replication model parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureSupportedFKeyBetweenCitusLocalAndRefTable</name><parameter_list>(<parameter><decl><type><name>Form_pg_constraint</name></type> <name>fKeyConstraintForm</name></decl></parameter>,
												<parameter><decl><type><name>char</name></type> <name>referencingReplicationModel</name></decl></parameter>,
												<parameter><decl><type><name>char</name></type> <name>referencedReplicationModel</name></decl></parameter>,
												<parameter><decl><type><name>Oid</name></type> <name>referencedTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>referencingIsReferenceTable</name> <init>=
		<expr><operator>(</operator><name>referencingReplicationModel</name> <operator>==</operator> <name>REPLICATION_MODEL_2PC</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>referencedIsCitusLocalTable</name> <init>=
		<expr><operator>(</operator><name>referencedReplicationModel</name> <operator>!=</operator> <name>REPLICATION_MODEL_2PC</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>referencingIsReferenceTable</name> <operator>&amp;&amp;</operator> <name>referencedIsCitusLocalTable</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We only support RESTRICT and NO ACTION behaviors for the
		 * foreign keys from reference tables to citus local tables.
		 * This is because, we can't cascade dml operations from citus
		 * local tables's coordinator placement to the remote placements
		 * of the reference table.
		 * Note that for the foreign keys from citus local tables to
		 * reference tables, we support all foreign key behaviors.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>BehaviorIsRestrictOrNoAction</name><argument_list>(<argument><expr><name><name>fKeyConstraintForm</name><operator>-&gt;</operator><name>confdeltype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			  <call><name>BehaviorIsRestrictOrNoAction</name><argument_list>(<argument><expr><name><name>fKeyConstraintForm</name><operator>-&gt;</operator><name>confupdtype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>referencedTableName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot define foreign key constraint, "</literal>
								   <literal type="string">"foreign keys from reference tables to "</literal>
								   <literal type="string">"local tables can only be defined "</literal>
								   <literal type="string">"with NO ACTION or RESTRICT behaviors"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><name>USE_CREATE_REFERENCE_TABLE_HINT</name></expr></argument>,
									<argument><expr><name>referencedTableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureSupportedFKeyOnDistKey errors out if given foreign key constraint form
 * implies an unsupported ON DELETE/UPDATE behavior assuming the referencing column
 * is the distribution column of the referencing distributed table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureSupportedFKeyOnDistKey</name><parameter_list>(<parameter><decl><type><name>Form_pg_constraint</name></type> <name>fKeyConstraintForm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * ON DELETE SET NULL and ON DELETE SET DEFAULT is not supported. Because we do
	 * not want to set partition column to NULL or default value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fKeyConstraintForm</name><operator>-&gt;</operator><name>confdeltype</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETNULL</name> <operator>||</operator>
		<name><name>fKeyConstraintForm</name><operator>-&gt;</operator><name>confdeltype</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETDEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign key constraint"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"SET NULL or SET DEFAULT is not supported "</literal>
								  <literal type="string">"in ON DELETE operation when distribution "</literal>
								  <literal type="string">"key is included in the foreign key constraint"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * ON UPDATE SET NULL, ON UPDATE SET DEFAULT and UPDATE CASCADE is not supported.
	 * Because we do not want to set partition column to NULL or default value. Also
	 * cascading update operation would require re-partitioning. Updating partition
	 * column value is not allowed anyway even outside of foreign key concept.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fKeyConstraintForm</name><operator>-&gt;</operator><name>confupdtype</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETNULL</name> <operator>||</operator>
		<name><name>fKeyConstraintForm</name><operator>-&gt;</operator><name>confupdtype</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_SETDEFAULT</name> <operator>||</operator>
		<name><name>fKeyConstraintForm</name><operator>-&gt;</operator><name>confupdtype</name></name> <operator>==</operator> <name>FKCONSTR_ACTION_CASCADE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign key constraint"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"SET NULL, SET DEFAULT or CASCADE is not "</literal>
								  <literal type="string">"supported in ON UPDATE operation when "</literal>
								  <literal type="string">"distribution key included in the foreign "</literal>
								  <literal type="string">"constraint."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureReferencingTableNotReplicated takes referencingTableId for the
 * referencing table of the foreign key and errors out if it's not a single
 * replicated table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureReferencingTableNotReplicated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>referencingTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>referencingNotReplicated</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>referencingIsCitus</name> <init>= <expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>referencingTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>referencingIsCitus</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ALTER TABLE command is applied over single replicated table */</comment>
		<expr_stmt><expr><name>referencingNotReplicated</name> <operator>=</operator> <call><name>SingleReplicatedTable</name><argument_list>(<argument><expr><name>referencingTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Creating single replicated table with foreign constraint */</comment>
		<expr_stmt><expr><name>referencingNotReplicated</name> <operator>=</operator> <operator>!</operator><call><name>DistributedTableReplicationIsEnabled</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>referencingNotReplicated</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign key constraint"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Citus currently supports foreign key constraints "</literal>
								  <literal type="string">"only for \"citus.shard_replication_factor = 1\"."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Please change \"citus.shard_replication_factor to "</literal>
								<literal type="string">"1\". To learn more about using foreign keys with "</literal>
								<literal type="string">"other replication factors, please contact us at "</literal>
								<literal type="string">"https://citusdata.com/about/contact_us."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorOutForFKeyBetweenPostgresAndCitusLocalTable is a helper function to
 * error out for foreign keys between postgres local tables and citus local
 * tables.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorOutForFKeyBetweenPostgresAndCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>localTableId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>localTableName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>localTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create foreign key constraint as \"%s\" is "</literal>
						   <literal type="string">"a postgres local table"</literal></expr></argument>, <argument><expr><name>localTableName</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"first add local table to citus metadata "</literal>
							<literal type="string">"by using SELECT citus_add_local_table_to_metadata('%s') "</literal>
							<literal type="string">"and execute the ALTER TABLE command to create the "</literal>
							<literal type="string">"foreign key to local table"</literal></expr></argument>, <argument><expr><name>localTableName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ForeignConstraintFindDistKeys finds the index of the given distribution columns
 * in the given foreign key constraint and returns them in referencingAttrIndex
 * and referencedAttrIndex. If one of them is not found, it returns -1 instead.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ForeignConstraintFindDistKeys</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>pgConstraintTuple</name></decl></parameter>,
							  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>referencingDistColumn</name></decl></parameter>,
							  <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>referencedDistColumn</name></decl></parameter>,
							  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>referencingAttrIndex</name></decl></parameter>,
							  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>referencedAttrIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>referencingColumnArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>referencingColumnCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>referencedColumnArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>referencedColumnCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>referencedAttrIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>referencedAttrIndex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Column attributes are not available in Form_pg_constraint, therefore we need
	 * to find them in the system catalog. After finding them, we iterate over column
	 * attributes together because partition column must be at the same place in both
	 * referencing and referenced side of the foreign key constraint.
	 */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>referencingColumnsDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>pgConstraintTuple</name></expr></argument>,
													<argument><expr><name>Anum_pg_constraint_conkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>referencedColumnsDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>pgConstraintTuple</name></expr></argument>,
												   <argument><expr><name>Anum_pg_constraint_confkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>referencingColumnsDatum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>,
					  <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>referencingColumnArray</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referencingColumnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>referencedColumnsDatum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>,
					  <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>referencedColumnArray</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referencedColumnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>referencingColumnCount</name> <operator>==</operator> <name>referencedColumnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>attrIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>attrIdx</name> <operator>&lt;</operator> <name>referencingColumnCount</name></expr>;</condition> <incr><expr><operator>++</operator><name>attrIdx</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>referencingAttrNo</name> <init>= <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>referencingColumnArray</name><index>[<expr><name>attrIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>referencedAttrNo</name> <init>= <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>referencedColumnArray</name><index>[<expr><name>attrIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>referencedDistColumn</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>referencedDistColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>referencedAttrNo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>referencedAttrIndex</name> <operator>=</operator> <name>attrIdx</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>referencingDistColumn</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>referencingDistColumn</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>referencingAttrNo</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>referencingAttrIndex</name> <operator>=</operator> <name>attrIdx</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnAppearsInForeignKey returns true if there is a foreign key constraint
 * from/to given column. False otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>ColumnAppearsInForeignKey</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>searchForeignKeyColumnFlags</name> <init>= <expr><name>SEARCH_REFERENCING_RELATION</name> <operator>|</operator>
									  <name>SEARCH_REFERENCED_RELATION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeysColumnAppeared</name> <init>=
		<expr><call><name>GetForeignKeyIdsForColumn</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>searchForeignKeyColumnFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>foreignKeysColumnAppeared</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnAppearsInForeignKeyToReferenceTable checks if there is a foreign key
 * constraint from/to any reference table on the given column.
 */</comment>
<function><type><name>bool</name></type>
<name>ColumnAppearsInForeignKeyToReferenceTable</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>searchForeignKeyColumnFlags</name> <init>= <expr><name>SEARCH_REFERENCING_RELATION</name> <operator>|</operator>
									  <name>SEARCH_REFERENCED_RELATION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyIdsColumnAppeared</name> <init>=
		<expr><call><name>GetForeignKeyIdsForColumn</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>searchForeignKeyColumnFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>foreignKeyId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>foreignKeyId</argument>, <argument>foreignKeyIdsColumnAppeared</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>referencedTableId</name> <init>= <expr><call><name>GetReferencedTableId</name><argument_list>(<argument><expr><name>foreignKeyId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>referencedTableId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetForeignKeyIdsForColumn takes columnName and relationId for the owning
 * relation, and returns a list of OIDs for foreign constraints that the column
 * with columnName is involved according to "searchForeignKeyColumnFlags" argument.
 * See SearchForeignKeyColumnFlags enum definition for usage.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetForeignKeyIdsForColumn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>searchForeignKeyColumnFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>searchReferencing</name> <init>= <expr><name>searchForeignKeyColumnFlags</name> <operator>&amp;</operator> <name>SEARCH_REFERENCING_RELATION</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>searchReferenced</name> <init>= <expr><name>searchForeignKeyColumnFlags</name> <operator>&amp;</operator> <name>SEARCH_REFERENCED_RELATION</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* at least one of them should be true */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>searchReferencing</name> <operator>||</operator> <name>searchReferenced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyIdsColumnAppeared</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgConstraint</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_constraint_contype</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_CHAREQ</name></expr></argument>, <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>pgConstraintKey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>referencedTableId</name> <init>= <expr><name><name>constraintForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>referencingTableId</name> <init>= <expr><name><name>constraintForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>referencedTableId</name> <operator>==</operator> <name>relationId</name> <operator>&amp;&amp;</operator> <name>searchReferenced</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pgConstraintKey</name> <operator>=</operator> <name>Anum_pg_constraint_confkey</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>referencingTableId</name> <operator>==</operator> <name>relationId</name> <operator>&amp;&amp;</operator> <name>searchReferencing</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pgConstraintKey</name> <operator>=</operator> <name>Anum_pg_constraint_conkey</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * If the constraint is not from/to the given relation, we should simply
			 * skip.
			 */</comment>
			<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleOfForeignConstraintIncludesColumn</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>,
													   <argument><expr><name>pgConstraintKey</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>foreignKeyIdsColumnAppeared</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>foreignKeyIdsColumnAppeared</name></expr></argument>,
													  <argument><expr><name><name>constraintForm</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* clean up scan and close system catalog */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>foreignKeyIdsColumnAppeared</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetReferencingForeignConstaintCommands takes in a relationId, and
 * returns the list of foreign constraint commands needed to reconstruct
 * foreign key constraints that the table is involved in as the "referencing"
 * one.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetReferencingForeignConstaintCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_ALL_TABLE_TYPES</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>GetForeignConstraintCommandsInternal</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetForeignConstraintToReferenceTablesCommands takes in a relationId, and
 * returns the list of foreign constraint commands needed to reconstruct
 * foreign key constraints that the table is involved in as the "referencing"
 * one and the "referenced" table is a reference table.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetForeignConstraintToReferenceTablesCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_REFERENCE_TABLES</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>GetForeignConstraintCommandsInternal</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetForeignConstraintToDistributedTablesCommands takes in a relationId, and
 * returns the list of foreign constraint commands needed to reconstruct
 * foreign key constraints that the table is involved in as the "referencing"
 * one and the "referenced" table is a distributed table.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetForeignConstraintToDistributedTablesCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_DISTRIBUTED_TABLES</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>GetForeignConstraintCommandsInternal</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetForeignConstraintFromDistributedTablesCommands takes in a relationId, and
 * returns the list of foreign constraint commands needed to reconstruct
 * foreign key constraints that the table is involved in as the "referenced"
 * one and the "referencing" table is a distributed table.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetForeignConstraintFromDistributedTablesCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCED_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_DISTRIBUTED_TABLES</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>GetForeignConstraintCommandsInternal</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetForeignConstraintCommandsInternal is a wrapper function to get the
 * DDL commands to recreate the foreign key constraints returned by
 * GetForeignKeyOids. See more details at the underlying function.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetForeignConstraintCommandsInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyOids</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PushOverrideEmptySearchPath</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>foreignKeyOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>foreignKeyOid</argument>, <argument>foreignKeyOids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>statementDef</name> <init>= <expr><call><name>pg_get_constraintdef_command</name><argument_list>(<argument><expr><name>foreignKeyOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>foreignKeyCommands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>foreignKeyCommands</name></expr></argument>, <argument><expr><name>statementDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* revert back to original search_path */</comment>
	<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>foreignKeyCommands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasForeignKeyWithLocalTable returns true if relation has foreign key
 * relationship with a local table.
 */</comment>
<function><type><name>bool</name></type>
<name>HasForeignKeyWithLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeysWithLocalTables</name> <init>= <expr><call><name>GetForeignKeysWithLocalTables</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>foreignKeysWithLocalTables</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetForeignKeysWithLocalTables returns a list of foreign keys for foreign key
 * relationships that relation has with local tables.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetForeignKeysWithLocalTables</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>referencingFKeysFlag</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator>
							   <name>INCLUDE_LOCAL_TABLES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencingFKeyList</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>referencingFKeysFlag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* already captured self referencing foreign keys, so use EXCLUDE_SELF_REFERENCES */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>referencedFKeysFlag</name> <init>= <expr><name>INCLUDE_REFERENCED_CONSTRAINTS</name> <operator>|</operator>
							  <name>EXCLUDE_SELF_REFERENCES</name> <operator>|</operator>
							  <name>INCLUDE_LOCAL_TABLES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencedFKeyList</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>referencedFKeysFlag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>referencingFKeyList</name></expr></argument>, <argument><expr><name>referencedFKeyList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetForeignKeysFromLocalTables returns a list of foreign keys where the referencing
 * relation is a local table.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetForeignKeysFromLocalTables</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>referencedFKeysFlag</name> <init>= <expr><name>INCLUDE_REFERENCED_CONSTRAINTS</name> <operator>|</operator>
							  <name>INCLUDE_LOCAL_TABLES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencingFKeyList</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>referencedFKeysFlag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>referencingFKeyList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasForeignKeyToReferenceTable returns true if any of the foreign key
 * constraints on the relation with relationId references to a reference
 * table.
 */</comment>
<function><type><name>bool</name></type>
<name>HasForeignKeyToReferenceTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_REFERENCE_TABLES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyOids</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>foreignKeyOids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TableReferenced function checks whether given table is referenced by another table
 * via foreign constraints. If it is referenced, this function returns true.
 */</comment>
<function><type><name>bool</name></type>
<name>TableReferenced</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCED_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_ALL_TABLE_TYPES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyOids</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>foreignKeyOids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HeapTupleOfForeignConstraintIncludesColumn fetches the columns from the foreign
 * constraint and checks if the given column name matches one of them.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HeapTupleOfForeignConstraintIncludesColumn</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>pgConstraintKey</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>columnCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>columnsDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>pgConstraintKey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>columnsDatum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>,
					  <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>columnArray</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>attrIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>attrIdx</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><operator>++</operator><name>attrIdx</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attrNo</name> <init>= <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>columnArray</name><index>[<expr><name>attrIdx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colName</name> <init>= <expr><call><name>get_attname</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>attrNo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>colName</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TableReferencing function checks whether given table is referencing to another
 * table via foreign key constraints. If it is referencing, this function returns
 * true.
 */</comment>
<function><type><name>bool</name></type>
<name>TableReferencing</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_ALL_TABLE_TYPES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyOids</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name>foreignKeyOids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConstraintIsAUniquenessConstraint is a wrapper around ConstraintWithNameIsOfType
 * that returns true if given constraint name identifies a uniqueness constraint, i.e:
 *   - primary key constraint, or
 *   - unique constraint
 */</comment>
<function><type><name>bool</name></type>
<name>ConstraintIsAUniquenessConstraint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>inputConstaintName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isUniqueConstraint</name> <init>= <expr><call><name>ConstraintWithNameIsOfType</name><argument_list>(<argument><expr><name>inputConstaintName</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>,
														 <argument><expr><name>CONSTRAINT_UNIQUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isPrimaryConstraint</name> <init>= <expr><call><name>ConstraintWithNameIsOfType</name><argument_list>(<argument><expr><name>inputConstaintName</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>,
														  <argument><expr><name>CONSTRAINT_PRIMARY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>isUniqueConstraint</name> <operator>||</operator> <name>isPrimaryConstraint</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConstraintIsAForeignKey is a wrapper around ConstraintWithNameIsOfType that returns true
 * if given constraint name identifies a foreign key constraint.
 */</comment>
<function><type><name>bool</name></type>
<name>ConstraintIsAForeignKey</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>inputConstaintName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ConstraintWithNameIsOfType</name><argument_list>(<argument><expr><name>inputConstaintName</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CONSTRAINT_FOREIGN</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConstraintWithNameIsOfType is a wrapper around get_relation_constraint_oid that
 * returns true if given constraint name identifies a valid constraint defined
 * on relation with relationId and its type matches the input constraint type.
 */</comment>
<function><type><name>bool</name></type>
<name>ConstraintWithNameIsOfType</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>inputConstaintName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
						   <parameter><decl><type><name>char</name></type> <name>targetConstraintType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>constraintId</name> <init>=
		<expr><call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>inputConstaintName</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>ConstraintWithIdIsOfType</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>, <argument><expr><name>targetConstraintType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConstraintWithIdIsOfType returns true if constraint with constraintId exists
 * and is of type targetConstraintType.
 */</comment>
<function><type><name>bool</name></type>
<name>ConstraintWithIdIsOfType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>constraintId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>targetConstraintType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no such constraint */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>constraintType</name> <init>= <expr><name><name>constraintForm</name><operator>-&gt;</operator><name>contype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>constraintTypeMatches</name> <init>= <expr><operator>(</operator><name>constraintType</name> <operator>==</operator> <name>targetConstraintType</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>constraintTypeMatches</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindForeignKeyOidWithName searches the foreign key constraint with
 * inputConstraintName in the given list of foreign key constraint OIDs.
 * Returns the OID of the matching constraint. If there no matching constraint
 * in the given list, then returns InvalidOid.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>FindForeignKeyOidWithName</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyOids</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>inputConstraintName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>foreignKeyOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>foreignKeyOid</argument>, <argument>foreignKeyOids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><call><name>get_constraint_name</name><argument_list>(<argument><expr><name>foreignKeyOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>constraintName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>inputConstraintName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>foreignKeyOid</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TableHasExternalForeignKeys returns true if the relation with relationId is
 * involved in a foreign key relationship other than the self-referencing ones.
 */</comment>
<function><type><name>bool</name></type>
<name>TableHasExternalForeignKeys</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><operator>(</operator><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>EXCLUDE_SELF_REFERENCES</name> <operator>|</operator>
				 <name>INCLUDE_ALL_TABLE_TYPES</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyIdsTableReferencing</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>INCLUDE_REFERENCED_CONSTRAINTS</name> <operator>|</operator> <name>EXCLUDE_SELF_REFERENCES</name> <operator>|</operator>
			 <name>INCLUDE_ALL_TABLE_TYPES</name><operator>)</operator></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyIdsTableReferenced</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeysWithOtherTables</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>foreignKeyIdsTableReferencing</name></expr></argument>,
												   <argument><expr><name>foreignKeyIdsTableReferenced</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>foreignKeysWithOtherTables</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetForeignKeyOids takes in a relationId, and returns a list of OIDs for
 * foreign constraints that the relation with relationId is involved according
 * to "flags" argument. See ExtractForeignKeyConstraintsMode enum definition
 * for usage of the flags.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetForeignKeyOids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>pgConstraintTargetAttrNumber</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>extractReferencing</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INCLUDE_REFERENCING_CONSTRAINTS</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>extractReferenced</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INCLUDE_REFERENCED_CONSTRAINTS</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only one of them should be passed at a time since the way we scan
	 * pg_constraint differs for those columns. Anum_pg_constraint_conrelid
	 * supports index scan while Anum_pg_constraint_confrelid does not.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>extractReferencing</name> <operator>&amp;&amp;</operator> <name>extractReferenced</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>extractReferencing</name> <operator>||</operator> <name>extractReferenced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>useIndex</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>indexOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>extractReferencing</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pgConstraintTargetAttrNumber</name> <operator>=</operator> <name>Anum_pg_constraint_conrelid</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>useIndex</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexOid</name> <operator>=</operator> <name>ConstraintRelidTypidNameIndexId</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>extractReferenced</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pgConstraintTargetAttrNumber</name> <operator>=</operator> <name>Anum_pg_constraint_confrelid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>excludeSelfReference</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EXCLUDE_SELF_REFERENCES</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyOids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgConstraint</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pgConstraintTargetAttrNumber</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>useIndex</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>constraintForm</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>inheritedConstraint</name> <init>= <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>constraintForm</name><operator>-&gt;</operator><name>conparentid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>inheritedConstraint</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We only consider the constraints that are explicitly created on
			 * the table as we already process the constraints from parent tables
			 * implicitly when a command is issued
			 */</comment>
			<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>constraintId</name> <init>= <expr><name><name>constraintForm</name><operator>-&gt;</operator><name>oid</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>isSelfReference</name> <init>= <expr><operator>(</operator><name><name>constraintForm</name><operator>-&gt;</operator><name>conrelid</name></name> <operator>==</operator> <name><name>constraintForm</name><operator>-&gt;</operator><name>confrelid</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>excludeSelfReference</name> <operator>&amp;&amp;</operator> <name>isSelfReference</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>otherTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>extractReferencing</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>otherTableId</name> <operator>=</operator> <name><name>constraintForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>extractReferenced</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>otherTableId</name> <operator>=</operator> <name><name>constraintForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTableTypeIncluded</name><argument_list>(<argument><expr><name>otherTableId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>foreignKeyOids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>foreignKeyOids</name></expr></argument>, <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do not release AccessShareLock yet to prevent modifications to be done
	 * on pg_constraint to make sure that caller will process valid foreign key
	 * constraints through the transaction.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>foreignKeyOids</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetReferencedTableId returns OID of the referenced relation for the foreign
 * key with foreignKeyId. If there is no such foreign key, then this function
 * returns InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetReferencedTableId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>foreignKeyId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>foreignKeyId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no such foreign key */</comment>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>referencedTableId</name> <init>= <expr><name><name>constraintForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>referencedTableId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetReferencingTableId returns OID of the referencing relation for the foreign
 * key with foreignKeyId. If there is no such foreign key, then this function
 * returns InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetReferencingTableId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>foreignKeyId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>foreignKeyId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no such foreign key */</comment>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>referencingTableId</name> <init>= <expr><name><name>constraintForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>referencingTableId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsTableTypeIncluded returns true if type of the table with relationId (distributed,
 * reference, Citus local or Postgres local) is included in the flags, false if not
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsTableTypeIncluded</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INCLUDE_LOCAL_TABLES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INCLUDE_DISTRIBUTED_TABLES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INCLUDE_REFERENCE_TABLES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INCLUDE_CITUS_LOCAL_TABLES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnableSkippingConstraintValidation is simply a C interface for setting the following:
 *      SET LOCAL citus.skip_constraint_validation TO on;
 */</comment>
<function><type><name>void</name></type>
<name>EnableSkippingConstraintValidation</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"citus.skip_constraint_validation"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>,
					  <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
					  <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RelationInvolvedInAnyNonInheritedForeignKeys returns true if relation involved
 * in a foreign key that is not inherited from its parent relation.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationInvolvedInAnyNonInheritedForeignKeys</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencingForeignKeys</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
													 <argument><expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator>
													 <name>INCLUDE_ALL_TABLE_TYPES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We already capture self-referencing foreign keys above, so use
	 * EXCLUDE_SELF_REFERENCES here
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencedForeignKeys</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
													<argument><expr><name>INCLUDE_REFERENCED_CONSTRAINTS</name> <operator>|</operator>
													<name>EXCLUDE_SELF_REFERENCES</name> <operator>|</operator>
													<name>INCLUDE_ALL_TABLE_TYPES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeysRelationInvolved</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>referencingForeignKeys</name></expr></argument>,
													<argument><expr><name>referencedForeignKeys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>foreignKeyId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>foreignKeyId</argument>, <argument>foreignKeysRelationInvolved</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>foreignKeyId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not possible but be on the safe side */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>parentConstraintId</name> <init>= <expr><name><name>constraintForm</name><operator>-&gt;</operator><name>conparentid</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentConstraintId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
