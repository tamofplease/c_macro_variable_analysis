<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/commands/vacuum.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * vacuum.c
 *    Commands for vacuuming distributed tables.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/adaptive_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VACUUM_PARALLEL_NOTSET</name></cpp:macro> <cpp:value>-2</cpp:value></cpp:define>

<comment type="block">/*
 * Subset of VacuumParams we care about
 */</comment>
<typedef>typedef <type><struct>struct <name>CitusVacuumParams</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacOptValue</name></type> <name>truncate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacOptValue</name></type> <name>index_cleanup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nworkers</name></decl>;</decl_stmt>
}</block></struct></type> <name>CitusVacuumParams</name>;</typedef>

<comment type="block">/* Local functions forward declarations for processing distributed table commands */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsDistributedVacuumStmt</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>vacuumRelationIdList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>VacuumTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>CitusVacuumParams</name></type> <name>vacuumParams</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>vacuumColumnList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>DeparseVacuumStmtPrefix</name><parameter_list>(<parameter><decl><type><name>CitusVacuumParams</name></type> <name>vacuumParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>DeparseVacuumColumnNames</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>VacuumColumnList</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relationIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ExtractVacuumTargetRels</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteVacuumOnDistributedTables</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>,
											 <parameter><decl><type><name>CitusVacuumParams</name></type> <name>vacuumParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteUnqualifiedVacuumTasks</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name></decl></parameter>,
										  <parameter><decl><type><name>CitusVacuumParams</name></type> <name>vacuumParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CitusVacuumParams</name></type> <name>VacuumStmtParams</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacstmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>VacuumRelationIdList</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name></decl></parameter>, <parameter><decl><type><name>CitusVacuumParams</name></type>
								   <name>vacuumParams</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * PostprocessVacuumStmt processes vacuum statements that may need propagation to
 * citus tables only if ddl propagation is enabled. If a VACUUM or ANALYZE command
 * references a citus table or no table, it is propagated to all involved nodes; otherwise,
 * the statements will not be propagated.
 *
 * Unlike most other Process functions within this file, this function does not
 * return a modified parse node, as it is expected that the local VACUUM or
 * ANALYZE has already been processed.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessVacuumStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vacuumCommand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>VacuumStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CitusVacuumParams</name></type> <name>vacuumParams</name> <init>= <expr><call><name>VacuumStmtParams</name><argument_list>(<argument><expr><name>vacuumStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>vacuumParams</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We commit the current transaction here so that the global lock
		 * taken from the shell table for VACUUM is released, which would block execution
		 * of shard placements. We don't do this in case of "ANALYZE &lt;table&gt;" command because
		 * its semantics are different than VACUUM and it doesn't acquire the global lock.
		 */</comment>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * when no table is specified propagate the command as it is;
	 * otherwise, only propagate when there is at least 1 citus table
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><call><name>VacuumRelationIdList</name><argument_list>(<argument><expr><name>vacuumStmt</name></expr></argument>, <argument><expr><name>vacuumParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>vacuumStmt</name><operator>-&gt;</operator><name>rels</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no table is specified (unqualified vacuum) */</comment>

		<expr_stmt><expr><call><name>ExecuteUnqualifiedVacuumTasks</name><argument_list>(<argument><expr><name>vacuumStmt</name></expr></argument>, <argument><expr><name>vacuumParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsDistributedVacuumStmt</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* there is at least 1 citus table specified */</comment>

		<expr_stmt><expr><call><name>ExecuteVacuumOnDistributedTables</name><argument_list>(<argument><expr><name>vacuumStmt</name></expr></argument>, <argument><expr><name>relationIdList</name></expr></argument>,
										 <argument><expr><name>vacuumParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* else only local tables are specified */</comment>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * VacuumRelationIdList returns the oid of the relations in the given vacuum statement.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>VacuumRelationIdList</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name></decl></parameter>, <parameter><decl><type><name>CitusVacuumParams</name></type> <name>vacuumParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>vacuumParams</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>AccessExclusiveLock</name></expr> </then><else>:
						<expr><name>ShareUpdateExclusiveLock</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>skipLocked</name> <init>= <expr><operator>(</operator><name><name>vacuumParams</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_SKIP_LOCKED</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vacuumRelationList</name> <init>= <expr><call><name>ExtractVacuumTargetRels</name><argument_list>(<argument><expr><name>vacuumStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>vacuumRelation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>vacuumRelation</argument>, <argument>vacuumRelationList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * If skip_locked option is enabled, we are skipping that relation
		 * if the lock for it is currently not available; else, we get the lock.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelidExtended</name><argument_list>(<argument><expr><name>vacuumRelation</name></expr></argument>,
												  <argument><expr><name>lockMode</name></expr></argument>,
												  <argument><expr><ternary><condition><expr><name>skipLocked</name></expr> ?</condition><then> <expr><name>RVR_SKIP_LOCKED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>relationIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsDistributedVacuumStmt returns true if there is any citus table in the relation id list;
 * otherwise, it returns false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsDistributedVacuumStmt</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>vacuumRelationIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>vacuumRelationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteVacuumOnDistributedTables executes the vacuum for the shard placements of given tables
 * if they are citus tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteVacuumOnDistributedTables</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>,
								 <parameter><decl><type><name>CitusVacuumParams</name></type> <name>vacuumParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>relationIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>executedVacuumCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vacuumColumnList</name> <init>= <expr><call><name>VacuumColumnList</name><argument_list>(<argument><expr><name>vacuumStmt</name></expr></argument>, <argument><expr><name>relationIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><call><name>VacuumTaskList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>vacuumParams</name></expr></argument>, <argument><expr><name>vacuumColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* local execution is not implemented for VACUUM commands */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ExecuteUtilityTaskList</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>executedVacuumCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>relationIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * VacuumTaskList returns a list of tasks to be executed as part of processing
 * a VacuumStmt which targets a distributed relation.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>VacuumTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>CitusVacuumParams</name></type> <name>vacuumParams</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>vacuumColumnList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>vacuumParams</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_FULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>AccessExclusiveLock</name></expr> </then><else>:
						<expr><name>ShareUpdateExclusiveLock</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/* resulting task list */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* enumerate the tasks when putting them to the taskList */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vacuumStringPrefix</name> <init>= <expr><call><name>DeparseVacuumStmtPrefix</name><argument_list>(<argument><expr><name>vacuumParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>columnNames</name> <init>= <expr><call><name>DeparseVacuumColumnNames</name><argument_list>(<argument><expr><name>vacuumColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We obtain ShareUpdateExclusiveLock here to not conflict with INSERT's
	 * RowExclusiveLock. However if VACUUM FULL is used, we already obtain
	 * AccessExclusiveLock before reaching to that point and INSERT's will be
	 * blocked anyway. This is inline with PostgreSQL's own behaviour.
	 * Also note that if skip locked option is enabled, we try to acquire the lock
	 * in nonblocking way. If lock is not available, vacuum just skip that relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>vacuumParams</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_SKIP_LOCKED</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* grab shard lock before getting placement list */</comment>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardRelationName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* build shard relation name */</comment>
		<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardRelationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>quotedShardName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>shardRelationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* copy base vacuum string and build the shard specific command */</comment>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>vacuumStringForShard</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumStringForShard</name></expr></argument>, <argument><expr><name>vacuumStringPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumStringForShard</name></expr></argument>, <argument><expr><name>quotedShardName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumStringForShard</name></expr></argument>, <argument><expr><name>columnNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>INVALID_JOB_ID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>VACUUM_ANALYZE_TASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name><name>vacuumStringForShard</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>cannotBeExecutedInTransction</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>vacuumParams</name><operator>.</operator><name>options</name></name><operator>)</operator> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeparseVacuumStmtPrefix returns a StringInfo appropriate for use as a prefix
 * during distributed execution of a VACUUM or ANALYZE statement. Callers may
 * reuse this prefix within a loop to generate shard-specific VACUUM or ANALYZE
 * statements.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>DeparseVacuumStmtPrefix</name><parameter_list>(<parameter><decl><type><name>CitusVacuumParams</name></type> <name>vacuumParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>vacuumFlags</name> <init>= <expr><name><name>vacuumParams</name><operator>.</operator><name>options</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>vacuumPrefix</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* determine actual command and block out its bits */</comment>
	<if_stmt><if>if <condition>(<expr><name>vacuumFlags</name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"VACUUM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vacuumFlags</name> <operator>&amp;=</operator> <operator>~</operator><name>VACOPT_VACUUM</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>vacuumFlags</name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"ANALYZE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vacuumFlags</name> <operator>&amp;=</operator> <operator>~</operator><name>VACOPT_ANALYZE</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>vacuumFlags</name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"VERBOSE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>vacuumFlags</name> <operator>&amp;=</operator> <operator>~</operator><name>VACOPT_VERBOSE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* if no flags remain, exit early */</comment>
	<if_stmt><if>if <condition>(<expr><name>vacuumFlags</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>vacuumParams</name><operator>.</operator><name>truncate</name></name> <operator>==</operator> <name>VACOPTVALUE_UNSPECIFIED</name> <operator>&amp;&amp;</operator>
		<name><name>vacuumParams</name><operator>.</operator><name>index_cleanup</name></name> <operator>==</operator> <name>VACOPTVALUE_UNSPECIFIED</name> <operator>&amp;&amp;</operator>
		<name><name>vacuumParams</name><operator>.</operator><name>nworkers</name></name> <operator>==</operator> <name>VACUUM_PARALLEL_NOTSET</name></expr>
		)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>vacuumPrefix</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* otherwise, handle options */</comment>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>vacuumFlags</name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"ANALYZE,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>vacuumFlags</name> <operator>&amp;</operator> <name>VACOPT_DISABLE_PAGE_SKIPPING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"DISABLE_PAGE_SKIPPING,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>vacuumFlags</name> <operator>&amp;</operator> <name>VACOPT_FREEZE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"FREEZE,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>vacuumFlags</name> <operator>&amp;</operator> <name>VACOPT_FULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"FULL,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>vacuumFlags</name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"VERBOSE,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>vacuumFlags</name> <operator>&amp;</operator> <name>VACOPT_SKIP_LOCKED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"SKIP_LOCKED,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>vacuumFlags</name> <operator>&amp;</operator> <name>VACOPT_PROCESS_TOAST</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"PROCESS_TOAST,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name><name>vacuumParams</name><operator>.</operator><name>truncate</name></name> <operator>!=</operator> <name>VACOPTVALUE_UNSPECIFIED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>,
							   <argument><expr><ternary><condition><expr><name><name>vacuumParams</name><operator>.</operator><name>truncate</name></name> <operator>==</operator> <name>VACOPTVALUE_ENABLED</name></expr> ?</condition><then>
							   <expr><literal type="string">"TRUNCATE,"</literal></expr> </then><else>: <expr><literal type="string">"TRUNCATE false,"</literal></expr></else></ternary></expr></argument>
							   )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>vacuumParams</name><operator>.</operator><name>index_cleanup</name></name> <operator>!=</operator> <name>VACOPTVALUE_UNSPECIFIED</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>vacuumParams</name><operator>.</operator><name>index_cleanup</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>VACOPTVALUE_ENABLED</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"INDEX_CLEANUP true,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>VACOPTVALUE_DISABLED</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"INDEX_CLEANUP false,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
			<case>case <expr><name>VACOPTVALUE_AUTO</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"INDEX_CLEANUP auto,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
			<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<default>default:</default>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>vacuumParams</name><operator>.</operator><name>nworkers</name></name> <operator>!=</operator> <name>VACUUM_PARALLEL_NOTSET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="string">"PARALLEL %d,"</literal></expr></argument>, <argument><expr><name><name>vacuumParams</name><operator>.</operator><name>nworkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>vacuumPrefix</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>vacuumPrefix</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">')'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>vacuumPrefix</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>vacuumPrefix</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeparseVacuumColumnNames joins the list of strings using commas as a
 * delimiter. The whole thing is placed in parenthesis and set off with a
 * single space in order to facilitate appending it to the end of any VACUUM
 * or ANALYZE command which uses explicit column names. If the provided list
 * is empty, this function returns an empty string to keep the calling code
 * simplest.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>DeparseVacuumColumnNames</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>columnNames</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>columnNameList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>columnNames</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>columnNames</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>columnName</argument>, <argument>columnNameList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>columnNames</name></expr></argument>, <argument><expr><literal type="string">"%s,"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>columnNames</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>columnNames</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">')'</literal></expr>;</expr_stmt>

	<return>return <expr><name><name>columnNames</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * VacuumColumnList returns list of columns from relation
 * in the vacuum statement at specified relationIndex.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>VacuumColumnList</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relationIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>vacuumRelation</name> <init>= <expr><operator>(</operator><name>VacuumRelation</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>vacuumStmt</name><operator>-&gt;</operator><name>rels</name></name></expr></argument>,
																 <argument><expr><name>relationIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>vacuumRelation</name><operator>-&gt;</operator><name>va_cols</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractVacuumTargetRels returns list of target
 * relations from vacuum statement.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExtractVacuumTargetRels</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vacuumList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>vacuumRelation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>vacuumRelation</argument>, <argument>vacuumStmt-&gt;rels</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>vacuumList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vacuumList</name></expr></argument>, <argument><expr><name><name>vacuumRelation</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>vacuumList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * VacuumStmtParams returns a CitusVacuumParams based on the supplied VacuumStmt.
 */</comment>

<comment type="block">/*
 * This is mostly ExecVacuum from Postgres's commands/vacuum.c
 * Note that ExecVacuum does an actual vacuum as well and we don't want
 * that to happen in the coordinator hence we copied the rest here.
 */</comment>
<function><type><specifier>static</specifier> <name>CitusVacuumParams</name></type>
<name>VacuumStmtParams</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CitusVacuumParams</name></type> <name>params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>verbose</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>skip_locked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>analyze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>freeze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>full</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>disable_page_skipping</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<decl_stmt><decl><type><name>bool</name></type> <name>process_toast</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Set default value */</comment>
	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>index_cleanup</name></name> <operator>=</operator> <name>VACOPTVALUE_UNSPECIFIED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>truncate</name></name> <operator>=</operator> <name>VACOPTVALUE_UNSPECIFIED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>nworkers</name></name> <operator>=</operator> <name>VACUUM_PARALLEL_NOTSET</name></expr>;</expr_stmt>

	<comment type="block">/* Parse options list */</comment>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>opt</argument>, <argument>vacstmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* Parse common options for VACUUM and ANALYZE */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"verbose"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>verbose</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"skip_locked"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>skip_locked</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>vacstmt</name><operator>-&gt;</operator><name>is_vacuumcmd</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized ANALYZE option \"%s\""</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/* Parse options available on VACUUM */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>analyze</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"freeze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>freeze</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"full"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>full</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"disable_page_skipping"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>disable_page_skipping</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"process_toast"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>process_toast</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"index_cleanup"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>

			<comment type="block">/* Interpret no string as the default, which is 'auto' */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opt</name><operator>-&gt;</operator><name>arg</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>params</name><operator>.</operator><name>index_cleanup</name></name> <operator>=</operator> <name>VACOPTVALUE_AUTO</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sval</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Try matching on 'auto' string, or fall back on boolean */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>sval</name></expr></argument>, <argument><expr><literal type="string">"auto"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>params</name><operator>.</operator><name>index_cleanup</name></name> <operator>=</operator> <name>VACOPTVALUE_AUTO</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>params</name><operator>.</operator><name>index_cleanup</name></name> <operator>=</operator> <ternary><condition><expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>VACOPTVALUE_ENABLED</name></expr> </then><else>:
										   <expr><name>VACOPTVALUE_DISABLED</name></expr></else></ternary></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name><name>params</name><operator>.</operator><name>index_cleanup</name></name> <operator>=</operator> <ternary><condition><expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>VACOPTVALUE_ENABLED</name></expr> </then><else>:
								   <expr><name>VACOPTVALUE_DISABLED</name></expr></else></ternary></expr>;</expr_stmt>
			<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"truncate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>params</name><operator>.</operator><name>truncate</name></name> <operator>=</operator> <ternary><condition><expr><call><name>defGetBoolean</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>VACOPTVALUE_ENABLED</name></expr> </then><else>:
							  <expr><name>VACOPTVALUE_DISABLED</name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"parallel"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parallel option requires a value between 0 and %d"</literal></expr></argument>,
								<argument><expr><name>MAX_PARALLEL_WORKER_LIMIT</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>nworkers</name> <init>= <expr><call><name>defGetInt32</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>nworkers</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nworkers</name></expr></argument> &gt;</argument_list></name> <name>MAX_PARALLEL_WORKER_LIMIT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parallel vacuum degree must be between 0 and %d"</literal></expr></argument>,
									<argument><expr><name>MAX_PARALLEL_WORKER_LIMIT</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>params</name><operator>.</operator><name>nworkers</name></name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized VACUUM option \"%s\""</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call>
					<operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>params</name><operator>.</operator><name>options</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>vacstmt</name><operator>-&gt;</operator><name>is_vacuumcmd</name></name></expr> ?</condition><then> <expr><name>VACOPT_VACUUM</name></expr> </then><else>: <expr><name>VACOPT_ANALYZE</name></expr></else></ternary><operator>)</operator> <operator>|</operator>
					 <operator>(</operator><ternary><condition><expr><name>verbose</name></expr> ?</condition><then> <expr><name>VACOPT_VERBOSE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
					 <operator>(</operator><ternary><condition><expr><name>skip_locked</name></expr> ?</condition><then> <expr><name>VACOPT_SKIP_LOCKED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
					 <operator>(</operator><ternary><condition><expr><name>analyze</name></expr> ?</condition><then> <expr><name>VACOPT_ANALYZE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
					 <operator>(</operator><ternary><condition><expr><name>freeze</name></expr> ?</condition><then> <expr><name>VACOPT_FREEZE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
					 <operator>(</operator><ternary><condition><expr><name>full</name></expr> ?</condition><then> <expr><name>VACOPT_FULL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
					 <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
					 <operator>(</operator><ternary><condition><expr><name>process_toast</name></expr> ?</condition><then> <expr><name>VACOPT_PROCESS_TOAST</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
					 <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					 <operator>(</operator><ternary><condition><expr><name>disable_page_skipping</name></expr> ?</condition><then> <expr><name>VACOPT_DISABLE_PAGE_SKIPPING</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>params</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteUnqualifiedVacuumTasks executes tasks for unqualified vacuum commands
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteUnqualifiedVacuumTasks</name><parameter_list>(<parameter><decl><type><name>VacuumStmt</name> <modifier>*</modifier></type><name>vacuumStmt</name></decl></parameter>, <parameter><decl><type><name>CitusVacuumParams</name></type> <name>vacuumParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* don't allow concurrent node list changes that require an exclusive lock */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodes</name> <init>= <expr><call><name>TargetWorkerSetNodeList</name><argument_list>(<argument><expr><name>ALL_SHARD_NODES</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>workerNodes</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vacuumStringPrefix</name> <init>= <expr><call><name>DeparseVacuumStmtPrefix</name><argument_list>(<argument><expr><name>vacuumParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>vacuumCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>vacuumCommand</name></expr></argument>, <argument><expr><name>vacuumStringPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>unqualifiedVacuumCommands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
												 <argument><expr><name><name>vacuumCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
												 <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>INVALID_JOB_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>VACUUM_ANALYZE_TASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetTaskQueryStringList</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>unqualifiedVacuumCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>cannotBeExecutedInTransction</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>vacuumParams</name><operator>.</operator><name>options</name></name><operator>)</operator> <operator>&amp;</operator> <name>VACOPT_VACUUM</name><operator>)</operator></expr>;</expr_stmt>


	<decl_stmt><decl><type><name>bool</name></type> <name>hasPeerWorker</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>localNodeGroupId</name> <init>= <expr><call><name>GetLocalGroupId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>localNodeGroupId</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>targetPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>targetPlacement</name><operator>-&gt;</operator><name>nodeName</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>targetPlacement</name><operator>-&gt;</operator><name>nodePort</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>targetPlacement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>,
											  <argument><expr><name>targetPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hasPeerWorker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>hasPeerWorker</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>localExecution</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExecuteUtilityTaskList</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>localExecution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
