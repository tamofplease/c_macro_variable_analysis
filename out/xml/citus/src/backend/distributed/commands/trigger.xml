<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/commands/trigger.c"><comment type="block">/*-------------------------------------------------------------------------
 * trigger.c
 *
 * This file contains functions to create and process trigger objects on
 * citus tables.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/namespace_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/* appropriate lock modes for the owner relation according to postgres */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREATE_TRIGGER_LOCK_MODE</name></cpp:macro> <cpp:value>ShareRowExclusiveLock</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALTER_TRIGGER_LOCK_MODE</name></cpp:macro> <cpp:value>AccessExclusiveLock</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DROP_TRIGGER_LOCK_MODE</name></cpp:macro> <cpp:value>AccessExclusiveLock</cpp:value></cpp:define>


<comment type="block">/* local function forward declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetAlterTriggerStateCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>triggerId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsCreateCitusTruncateTriggerStmt</name><parameter_list>(<parameter><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>createTriggerStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type> <name>GetAlterTriggerDependsTriggerNameValue</name><parameter_list>(<parameter><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type>
													   <name>alterTriggerDependsStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedDropTriggerCommand</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTriggerStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeVar</name> <modifier>*</modifier></type> <name>GetDropTriggerStmtRelation</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTriggerStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExtractDropStmtTriggerAndRelationName</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTriggerStmt</name></decl></parameter>,
												  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>triggerName</name></decl></parameter>,
												  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfDropStmtDropsMultipleTriggers</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTriggerStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetTriggerNameById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>triggerId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int16</name></type> <name>GetTriggerTypeById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>triggerId</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_15</name><operator>)</operator></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorOutIfCloneTrigger</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tgrelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tgname</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* GUC that overrides trigger checks for distributed tables and reference tables */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableUnsafeTriggers</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * GetExplicitTriggerCommandList returns the list of DDL commands to create
 * triggers that are explicitly created for the table with relationId. See
 * comment of GetExplicitTriggerIdList function.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetExplicitTriggerCommandList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>createTriggerCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PushOverrideEmptySearchPath</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggerIdList</name> <init>= <expr><call><name>GetExplicitTriggerIdList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>triggerId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>triggerId</argument>, <argument>triggerIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>prettyOutput</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>commandText</name> <init>= <expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>pg_get_triggerdef_ext</name></expr></argument>,
												<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>prettyOutput</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * pg_get_triggerdef_ext doesn't throw an error if there is no such
		 * trigger, be on the safe side.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>commandText</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger with oid %u does not exist"</literal></expr></argument>,
								   <argument><expr><name>triggerId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>createTriggerCommand</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>commandText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>createTriggerCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(
			<argument><expr><name>createTriggerCommandList</name></expr></argument>,
			<argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(<argument><expr><name>createTriggerCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Appends the commands for the trigger settings that are not covered
		 * by CREATE TRIGGER command, such as ALTER TABLE ENABLE/DISABLE &lt;trigger&gt;.
		 */</comment>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alterTriggerStateCommand</name> <init>=
			<expr><call><name>GetAlterTriggerStateCommand</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>createTriggerCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(
			<argument><expr><name>createTriggerCommandList</name></expr></argument>,
			<argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(<argument><expr><name>alterTriggerStateCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* revert back to original search_path */</comment>
	<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>createTriggerCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAlterTriggerStateCommand returns the DDL command to set enable/disable
 * state for given trigger. Throws an error if no such trigger exists.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetAlterTriggerStateCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>triggerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>alterTriggerStateCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>triggerTuple</name> <init>= <expr><call><name>GetTriggerTupleById</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>triggerForm</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name><name>triggerForm</name><operator>-&gt;</operator><name>tgrelid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedTrigName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>triggerForm</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>enableDisableState</name> <init>= <expr><name><name>triggerForm</name><operator>-&gt;</operator><name>tgenabled</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alterTriggerStateStr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>enableDisableState</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* default mode */</comment>
			<expr_stmt><expr><name>alterTriggerStateStr</name> <operator>=</operator> <literal type="string">"ENABLE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>TRIGGER_FIRES_ALWAYS</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>alterTriggerStateStr</name> <operator>=</operator> <literal type="string">"ENABLE ALWAYS"</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>TRIGGER_FIRES_ON_REPLICA</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>alterTriggerStateStr</name> <operator>=</operator> <literal type="string">"ENABLE REPLICA"</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>TRIGGER_DISABLED</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><name>alterTriggerStateStr</name> <operator>=</operator> <literal type="string">"DISABLE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected trigger state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>alterTriggerStateCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s %s TRIGGER %s;"</literal></expr></argument>,
					 <argument><expr><name>qualifiedRelName</name></expr></argument>, <argument><expr><name>alterTriggerStateStr</name></expr></argument>, <argument><expr><name>quotedTrigName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free triggerTuple at the end since quote_identifier() might not return
	 * a palloc'd string if given identifier doesn't need to be quoted, and in
	 * that case quotedTrigName would still be bound to triggerTuple.
	 */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>alterTriggerStateCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTriggerTupleById returns copy of the heap tuple from pg_trigger for
 * the trigger with triggerId. If no such trigger exists, this function returns
 * NULL or errors out depending on missingOk.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>GetTriggerTupleById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>triggerId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgTrigger</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attrNumber</name> <init>= <expr><name>Anum_pg_trigger_oid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>attrNumber</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>useIndex</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgTrigger</name></expr></argument>, <argument><expr><name>TriggerOidIndexId</name></expr></argument>,
													<argument><expr><name>useIndex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>,
													<argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>targetHeapTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>targetHeapTuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgTrigger</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>targetHeapTuple</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>missingOk</name> <operator>==</operator> <name>false</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find heap tuple for trigger with "</literal>
							   <literal type="string">"OID %d"</literal></expr></argument>, <argument><expr><name>triggerId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>targetHeapTuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetExplicitTriggerIdList returns a list of OIDs corresponding to the triggers
 * that are explicitly created on the relation with relationId. That means,
 * this function discards internal triggers implicitly created by postgres for
 * foreign key constraint validation and the citus_truncate_trigger.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetExplicitTriggerIdList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggerIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgTrigger</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>useIndex</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgTrigger</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>,
													<argument><expr><name>useIndex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>,
													<argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>triggerForm</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note that we mark truncate trigger that we create on citus tables as
		 * internal. Hence, below we discard citus_truncate_trigger as well as
		 * the implicit triggers created by postgres for foreign key validation.
		 *
		 * Pre PG15, tgisinternal is true for a "child" trigger on a partition
		 * cloned from the trigger on the parent.
		 * In PG15, tgisinternal is false in that case. However, we don't want to
		 * create this trigger on the partition since it will create a conflict
		 * when we try to attach the partition to the parent table:
		 * ERROR: trigger "..." for relation "{partition_name}" already exists
		 * Hence we add an extra check on whether the parent id is invalid to
		 * make sure this is not a child trigger
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>triggerForm</name><operator>-&gt;</operator><name>tgisinternal</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>triggerForm</name><operator>-&gt;</operator><name>tgparentid</name></name> <operator>==</operator> <name>InvalidOid</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>triggerIdList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>triggerIdList</name></expr></argument>, <argument><expr><name><name>triggerForm</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgTrigger</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>triggerIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessCreateTriggerStmt is called after a CREATE TRIGGER command has
 * been executed by standard process utility. This function errors out for
 * unsupported commands or creates ddl job for supported CREATE TRIGGER commands.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessCreateTriggerStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>createTriggerStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsCreateCitusTruncateTriggerStmt</name><argument_list>(<argument><expr><name>createTriggerStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>createTriggerStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>CREATE_TRIGGER_LOCK_MODE</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorOutForTriggerIfNotSupported</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>objectAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>objectAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><name>objectAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name> <init>= <expr><name><name>createTriggerStmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>CitusCreateTriggerCommandDDLJob</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>triggerName</name></expr></argument>,
										   <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateTriggerStmtObjectAddress finds the ObjectAddress for the trigger that
 * is created by given CreateTriggerStmt. If missingOk is false and if trigger
 * does not exist, then it errors out.
 *
 * Never returns NULL, but the objid in the address can be invalid if missingOk
 * was set to true.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CreateTriggerStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>createTriggerStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>createTriggerStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>CREATE_TRIGGER_LOCK_MODE</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name> <init>= <expr><name><name>createTriggerStmt</name><operator>-&gt;</operator><name>trigname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>triggerId</name> <init>= <expr><call><name>get_trigger_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>triggerName</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>triggerId</name> <operator>==</operator> <name>InvalidOid</name> <operator>&amp;&amp;</operator> <name>missingOk</name> <operator>==</operator> <name>false</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" on relation \"%s\" does not exist"</literal></expr></argument>,
							   <argument><expr><name>triggerName</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>triggerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCreateCitusTruncateTriggerStmt returns true if given createTriggerStmt
 * creates citus_truncate_trigger.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsCreateCitusTruncateTriggerStmt</name><parameter_list>(<parameter><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>createTriggerStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>functionNameList</name> <init>= <expr><name><name>createTriggerStmt</name><operator>-&gt;</operator><name>funcname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>functionRangeVar</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>functionNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>functionName</name> <init>= <expr><name><name>functionRangeVar</name><operator>-&gt;</operator><name>relname</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>functionName</name></expr></argument>, <argument><expr><name>CITUS_TRUNCATE_TRIGGER_NAME</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateTriggerEventExtendNames extends relation name and trigger name with
 * shardId, and sets schema name in given CreateTrigStmt.
 */</comment>
<function><type><name>void</name></type>
<name>CreateTriggerEventExtendNames</name><parameter_list>(<parameter><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>createTriggerStmt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>,
							  <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>createTriggerStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>triggerName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>createTriggerStmt</name><operator>-&gt;</operator><name>trigname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>triggerName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterTriggerRenameStmt is called before a ALTER TRIGGER RENAME
 * command has been executed by standard process utility. This function errors
 * out if we are trying to rename a child trigger on a partition of a distributed
 * table. In PG15, this is not allowed anyway.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterTriggerRenameStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
								 <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_15</name><operator>)</operator></expr></cpp:if>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>renameTriggerStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>renameTriggerStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>renameTriggerStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ALTER_TRIGGER_LOCK_MODE</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorOutForTriggerIfNotSupported</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ErrorOutIfCloneTrigger</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name><name>renameTriggerStmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessAlterTriggerRenameStmt is called after a ALTER TRIGGER RENAME
 * command has been executed by standard process utility. This function errors
 * out for unsupported commands or creates ddl job for supported ALTER TRIGGER
 * RENAME commands.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessAlterTriggerRenameStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>renameTriggerStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>renameTriggerStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>renameTriggerStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ALTER_TRIGGER_LOCK_MODE</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorOutForTriggerIfNotSupported</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* use newname as standard process utility already renamed it */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name> <init>= <expr><name><name>renameTriggerStmt</name><operator>-&gt;</operator><name>newname</name></name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>CitusCreateTriggerCommandDDLJob</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>triggerName</name></expr></argument>,
										   <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTriggerRenameEventExtendNames extends relation name, old and new trigger
 * name with shardId, and sets schema name in given RenameStmt.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTriggerRenameEventExtendNames</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>renameTriggerStmt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>,
								   <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>renameTriggerStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>renameTriggerStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>triggerOldName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>renameTriggerStmt</name><operator>-&gt;</operator><name>subname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>triggerOldName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>triggerNewName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>renameTriggerStmt</name><operator>-&gt;</operator><name>newname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>triggerNewName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterTriggerDependsStmt is called during the planning phase of an
 * ALTER TRIGGER ... DEPENDS ON EXTENSION ... statement. Since triggers depending on
 * extensions are assumed to be Owned by an extension we assume the extension to keep
 * the trigger in sync.
 *
 * If we would allow users to create a dependency between a distributed trigger and an
 * extension, our pruning logic for which objects to distribute as dependencies of other
 * objects will change significantly, which could cause issues adding new workers. Hence
 * we don't allow this dependency to be created.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterTriggerDependsStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
								  <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>alterTriggerDependsStmt</name> <init>=
		<expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectDependsStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>alterTriggerDependsStmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>creating_extension</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * extensions should be created separately on the workers, triggers cascading
		 * from an extension should therefore not be propagated here.
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableMetadataSync</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * we are configured to disable object propagation, should not propagate anything
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>alterTriggerDependsStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ALTER_TRIGGER_LOCK_MODE</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Distributed objects should not start depending on an extension, this will break
	 * the dependency resolving mechanism we use to replicate distributed objects to new
	 * workers
	 */</comment>

	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>triggerNameValue</name> <init>=
		<expr><call><name>GetAlterTriggerDependsTriggerNameValue</name><argument_list>(<argument><expr><name>alterTriggerDependsStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" depends on an extension and this "</literal>
						   <literal type="string">"is not supported for distributed tables and "</literal>
						   <literal type="string">"local tables added to metadata"</literal></expr></argument>,
						   <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>triggerNameValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Triggers from extensions are expected to be "</literal>
							  <literal type="string">"created on the workers by the extension they "</literal>
							  <literal type="string">"depend on."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* not reachable, keep compiler happy */</comment>
	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessAlterTriggerDependsStmt is called after a ALTER TRIGGER DEPENDS ON
 * command has been executed by standard process utility. This function errors out
 * for unsupported commands or creates ddl job for supported ALTER TRIGGER DEPENDS
 * ON commands.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessAlterTriggerDependsStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>alterTriggerDependsStmt</name> <init>=
		<expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectDependsStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>alterTriggerDependsStmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>alterTriggerDependsStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ALTER_TRIGGER_LOCK_MODE</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorOutForTriggerIfNotSupported</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>triggerNameValue</name> <init>=
		<expr><call><name>GetAlterTriggerDependsTriggerNameValue</name><argument_list>(<argument><expr><name>alterTriggerDependsStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>CitusCreateTriggerCommandDDLJob</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>triggerNameValue</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTriggerDependsEventExtendNames extends relation name and trigger name
 * with shardId, and sets schema name in given AlterObjectDependsStmt.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTriggerDependsEventExtendNames</name><parameter_list>(<parameter><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>alterTriggerDependsStmt</name></decl></parameter>,
									<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>alterTriggerDependsStmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><name><name>alterTriggerDependsStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>triggerNameValue</name> <init>=
		<expr><call><name>GetAlterTriggerDependsTriggerNameValue</name><argument_list>(<argument><expr><name>alterTriggerDependsStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>strVal</name><argument_list>(<argument><expr><name>triggerNameValue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationSchemaName</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetSchemaNameIfNotExist</name><argument_list>(<argument><expr><name>relationSchemaName</name></expr></argument>, <argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetAlterTriggerDependsTriggerName returns Value object for the trigger
 * name that given AlterObjectDependsStmt is executed for.
 */</comment>
<function><type><specifier>static</specifier> <name>String</name> <modifier>*</modifier></type>
<name>GetAlterTriggerDependsTriggerNameValue</name><parameter_list>(<parameter><decl><type><name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>alterTriggerDependsStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggerObjectNameList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>alterTriggerDependsStmt</name><operator>-&gt;</operator><name>object</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Before standard process utility, we only have trigger name in "object"
	 * list. However, standard process utility prepends that list with the
	 * relationNameList retrieved from AlterObjectDependsStmt-&gt;RangeVar and
	 * we call this method after standard process utility. So, for the further
	 * usages, it is certain that the last element in "object" list will always
	 * be the name of the trigger in either before or after standard process
	 * utility.
	 */</comment>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>triggerNameValue</name> <init>= <expr><call><name>llast</name><argument_list>(<argument><expr><name>triggerObjectNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>triggerNameValue</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessDropTriggerStmt is called before a DROP TRIGGER command has been
 * executed by standard process utility. This function errors out for
 * unsupported commands or creates ddl job for supported DROP TRIGGER commands.
 * The reason we process drop trigger commands before standard process utility
 * (unlike the other type of trigger commands) is that we act according to trigger
 * type in CitusCreateTriggerCommandDDLJob but trigger wouldn't exist after
 * standard process utility.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessDropTriggerStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						  <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTriggerStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dropTriggerStmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>GetDropTriggerStmtRelation</name><argument_list>(<argument><expr><name>dropTriggerStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>DROP_TRIGGER_LOCK_MODE</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* let standard process utility to error out */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ErrorIfUnsupportedDropTriggerCommand</name><argument_list>(<argument><expr><name>dropTriggerStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExtractDropStmtTriggerAndRelationName</name><argument_list>(<argument><expr><name>dropTriggerStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>triggerName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>CitusCreateTriggerCommandDDLJob</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>triggerName</name></expr></argument>,
										   <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedDropTriggerCommand errors out for unsupported
 * "DROP TRIGGER triggerName ON relationName" commands.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedDropTriggerCommand</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTriggerStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name> <init>= <expr><call><name>GetDropTriggerStmtRelation</name><argument_list>(<argument><expr><name>dropTriggerStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>DROP_TRIGGER_LOCK_MODE</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorOutForTriggerIfNotSupported</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorOutForTriggerIfNotSupported is a helper function to error
 * out for unsupported trigger commands depending on the citus table type.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorOutForTriggerIfNotSupported</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>EnableUnsafeTriggers</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* user really wants triggers */</comment>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"triggers are not supported on reference tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"triggers are not supported on distributed tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we always support triggers on citus local tables */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfRelationHasUnsupportedTrigger throws an error if given relation has
 * a trigger that is not supported by Citus.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfRelationHasUnsupportedTrigger</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationTriggerList</name> <init>= <expr><call><name>GetExplicitTriggerIdList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>triggerId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>triggerId</argument>, <argument>relationTriggerList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>triggerObjectAddress</name> <init>= <expr><name>InvalidObjectAddress</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>triggerObjectAddress</name></expr></argument>, <argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>triggerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* triggers that depend on extensions are not supported */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ObjectAddressDependsOnExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>triggerObjectAddress</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger \"%s\" depends on an extension and this "</literal>
								   <literal type="string">"is not supported for distributed tables and "</literal>
								   <literal type="string">"local tables added to metadata"</literal></expr></argument>,
								   <argument><expr><call><name>GetTriggerNameById</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_15</name><operator>)</operator></expr></cpp:if>

<comment type="block">/*
 * ErrorOutIfCloneTrigger is a helper function to error
 * out if we are trying to rename a child trigger on a
 * partition of a distributed table.
 * A lot of this code is borrowed from PG15 because
 * renaming clone triggers isn't allowed in PG15 anymore.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorOutIfCloneTrigger</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tgrelid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tgname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>tgrel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search for the trigger to modify.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tgrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_tgname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>tgname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerRelidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>trigform</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the trigger descends from a trigger on a parent partitioned
		 * table, reject the rename.
		 * Appended shard ids to find the trigger on the partition's shards
		 * are not correct. Hence we would fail to find the trigger on the
		 * partition's shard.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>trigform</name><operator>-&gt;</operator><name>tgparentid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"cannot rename child triggers on distributed partitions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * GetDropTriggerStmtRelation takes a DropStmt for a trigger object and returns
 * RangeVar for the relation that owns the trigger.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeVar</name> <modifier>*</modifier></type>
<name>GetDropTriggerStmtRelation</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTriggerStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dropTriggerStmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ErrorIfDropStmtDropsMultipleTriggers</name><argument_list>(<argument><expr><name>dropTriggerStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetObjectList</name> <init>= <expr><name><name>dropTriggerStmt</name><operator>-&gt;</operator><name>objects</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggerObjectNameList</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>targetObjectList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The name list that identifies the trigger to be dropped looks like:
	 * [catalogName, schemaName, relationName, triggerName], where, the first
	 * two elements are optional. We should take all elements except the
	 * triggerName to create the range var object that defines the owner
	 * relation.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>relationNameListLength</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>triggerObjectNameList</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationNameList</name> <init>= <expr><call><name>list_truncate</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>triggerObjectNameList</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>relationNameListLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>relationNameList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropTriggerEventExtendNames extends relation name and trigger name with
 * shardId, and sets schema name in given DropStmt by recreating "objects"
 * list.
 */</comment>
<function><type><name>void</name></type>
<name>DropTriggerEventExtendNames</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTriggerStmt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dropTriggerStmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExtractDropStmtTriggerAndRelationName</name><argument_list>(<argument><expr><name>dropTriggerStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>triggerName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>triggerName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>triggerNameValue</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name>triggerName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>relationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>relationNameValue</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>schemaNameValue</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardTriggerNameList</name> <init>=
		<expr><call><name>list_make3</name><argument_list>(<argument><expr><name>schemaNameValue</name></expr></argument>, <argument><expr><name>relationNameValue</name></expr></argument>, <argument><expr><name>triggerNameValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>dropTriggerStmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>shardTriggerNameList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractDropStmtTriggerAndRelationName extracts triggerName and relationName
 * from given dropTriggerStmt if arguments are passed as non-null pointers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExtractDropStmtTriggerAndRelationName</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTriggerStmt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>triggerName</name></decl></parameter>,
									  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>relationName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ErrorIfDropStmtDropsMultipleTriggers</name><argument_list>(<argument><expr><name>dropTriggerStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetObjectList</name> <init>= <expr><name><name>dropTriggerStmt</name><operator>-&gt;</operator><name>objects</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggerObjectNameList</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>targetObjectList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>objectNameListLength</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>triggerObjectNameList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>triggerName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>triggerNameindex</name> <init>= <expr><name>objectNameListLength</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>triggerName</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>safe_list_nth</name><argument_list>(<argument><expr><name>triggerObjectNameList</name></expr></argument>, <argument><expr><name>triggerNameindex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>relationName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>relationNameIndex</name> <init>= <expr><name>objectNameListLength</name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>relationName</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>safe_list_nth</name><argument_list>(<argument><expr><name>triggerObjectNameList</name></expr></argument>, <argument><expr><name>relationNameIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfDropStmtDropsMultipleTriggers errors out if given drop trigger
 * command drops more than one trigger. Actually, this can't be the case
 * as postgres doesn't support dropping multiple triggers, but we should
 * be on the safe side.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfDropStmtDropsMultipleTriggers</name><parameter_list>(<parameter><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropTriggerStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetObjectList</name> <init>= <expr><name><name>dropTriggerStmt</name><operator>-&gt;</operator><name>objects</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>targetObjectList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute DROP TRIGGER command for multiple "</literal>
							   <literal type="string">"triggers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CitusCreateTriggerCommandDDLJob creates a ddl job to execute given
 * queryString trigger command on shell relation(s) in mx worker(s) and to
 * execute necessary ddl task on citus local table shard (if needed).
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CitusCreateTriggerCommandDDLJob</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>triggerName</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * ENABLE/DISABLE TRIGGER ALL/USER commands do not specify trigger
		 * name.
		 */</comment>
		<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>DDLTaskList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>triggerId</name> <init>= <expr><call><name>get_trigger_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>triggerName</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For DROP, ENABLE/DISABLE, ENABLE REPLICA/ALWAYS TRIGGER commands,
		 * we create ddl job in preprocess. So trigger may not exist.
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int16</name></type> <name>triggerType</name> <init>= <expr><call><name>GetTriggerTypeById</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't have truncate triggers on shard relations */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name>triggerType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>DDLTaskList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTriggerNameById returns name of given trigger if such a trigger exists.
 * Otherwise, errors out.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetTriggerNameById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>triggerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>triggerTuple</name> <init>= <expr><call><name>GetTriggerTupleById</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>triggerForm</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>triggerForm</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>triggerName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTriggerTypeById returns trigger type (tgtype) of the trigger identified
 * by triggerId if it exists. Otherwise, errors out.
 */</comment>
<function><type><specifier>static</specifier> <name>int16</name></type>
<name>GetTriggerTypeById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>triggerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>triggerTuple</name> <init>= <expr><call><name>GetTriggerTupleById</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>triggerForm</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>triggerType</name> <init>= <expr><name><name>triggerForm</name><operator>-&gt;</operator><name>tgtype</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>triggerType</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTriggerFunctionId returns OID of the function that the trigger with
 * triggerId executes if the trigger exists. Otherwise, errors out.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetTriggerFunctionId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>triggerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>triggerTuple</name> <init>= <expr><call><name>GetTriggerTupleById</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>triggerForm</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>functionId</name> <init>= <expr><name><name>triggerForm</name><operator>-&gt;</operator><name>tgfoid</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>functionId</name></expr>;</return>
</block_content>}</block></function>
</unit>
