<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/commands/utility_hook.c"><comment type="block">/*-------------------------------------------------------------------------
 * utility_hook.c
 *	  Citus utility hook and related functionality.
 *
 * The utility hook is called by PostgreSQL when processing any command
 * that is not SELECT, UPDATE, DELETE, INSERT, in place of the regular
 * PostprocessUtility function. We use this primarily to implement (or in
 * some cases prevent) DDL commands and COPY on distributed tables.
 *
 * For DDL commands that affect distributed tables, we check whether
 * they are valid (and implemented) for the distributed table and then
 * propagate the command to all shards and, in case of MX, to distributed
 * tables on other nodes. We still call the original ProcessUtility
 * function to apply catalog changes on the coordinator.
 *
 * For COPY into a distributed table, we provide an alternative
 * implementation in ProcessCopyStmt that sends rows to shards based
 * on their distribution column value instead of writing it to the local
 * table on the coordinator. For COPY from a distributed table, we
 * replace the table with a SELECT * FROM table and pass it back to
 * PostprocessUtility, which will plan the query via the distributed planner
 * hook.
 *
 * Copyright (c) Citus Data, Inc.
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/attnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"citus_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/adaptive_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/backend_data.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_depended_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/multi_copy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include> <comment type="block">/* IWYU pragma: keep */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparse_shard_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/foreign_key_relationship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/maintenanced.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_replication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_explain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_physical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/resource_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/string_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_shard_visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><name>bool</name></type> <name>EnableDDLPropagation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt> <comment type="block">/* ddl propagation is enabled */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>CreateObjectPropagationMode</name> <init>= <expr><name>CREATE_OBJECT_PROPAGATION_IMMEDIATE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PropSetCmdBehavior</name></type> <name>PropagateSetCommands</name> <init>= <expr><name>PROPSETCMD_NONE</name></expr></init></decl>;</decl_stmt> <comment type="block">/* SET prop off */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>shouldInvalidateForeignKeyGraph</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>activeAlterTables</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>activeDropSchemaOrDBs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ConstraintDropped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ProcessUtility_hook_type</name></type> <name>PrevProcessUtility</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>UtilityHookLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/* Local functions forward declarations for helper functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessUtilityInternal</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
								   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
								   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
								   <parameter><decl><type><name><name>struct</name> <name>QueryEnvironment</name></name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
								   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
								   <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_indexsafe_procflags</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>CurrentSearchPath</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IncrementUtilityHookCountersIfNecessary</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PostStandardProcessUtility</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DecrementUtilityHookCountersIfNecessary</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsDropSchemaOrDB</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldCheckUndistributeCitusLocalTables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldAddNewTableToMetadata</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ServerUsesPostgresFDW</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>serverName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfOptionListHasNoTableName</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>optionList</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ProcessUtilityParseTree is a convenience method to create a PlannedStmt out of
 * pieces of a utility statement before invoking ProcessUtility.
 */</comment>
<function><type><name>void</name></type>
<name>ProcessUtilityParseTree</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ProcessUtilityContext</name></type>
						<name>context</name></decl></parameter>,
						<parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
						<parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>plannedStmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plannedStmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ProcessUtility_compat</name><argument_list>(<argument><expr><name>plannedStmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>,
						  <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * multi_ProcessUtility is the main entry hook for implementing Citus-specific
 * utility behavior. Its primary responsibilities are intercepting COPY and DDL
 * commands and augmenting the coordinator's command with corresponding tasks
 * to be run on worker nodes, after suitably ensuring said commands' options
 * are fully supported by Citus. Much of the DDL behavior is toggled by Citus'
 * enable_ddl_propagation GUC. In addition to DDL and COPY, utilities such as
 * TRUNCATE and VACUUM are also supported.
 */</comment>
<function><type><name>void</name></type>
<name>multi_ProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
					 <parameter><decl><type><name>bool</name></type> <name>readOnlyTree</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					 <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
					 <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
					 <parameter><decl><type><name><name>struct</name> <name>QueryEnvironment</name></name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
					 <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
					 <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>readOnlyTree</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransactionStmt</name> <modifier>*</modifier></type><name>transactionStmt</name> <init>= <expr><operator>(</operator><name>TransactionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>transactionStmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_BEGIN</name> <operator>||</operator>
			 <name><name>transactionStmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>TRANS_STMT_START</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SaveBeginCommandProperties</name><argument_list>(<argument><expr><name>transactionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>TransactionStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>ListenStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>ExecuteStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>PrepareStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>DiscardStmt</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>DeallocateStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Skip additional checks for common commands that do not have any
		 * Citus-specific logic.
		 *
		 * Transaction statements (e.g. ABORT, COMMIT) can be run in aborted
		 * transactions in which case a lot of checks cannot be done safely in
		 * that state. Since we never need to intercept transaction statements,
		 * skip our checks and immediately fall into standard_ProcessUtility.
		 */</comment>
		<expr_stmt><expr><call><name>PrevProcessUtility_compat</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
								  <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isCreateAlterExtensionUpdateCitusStmt</name> <init>= <expr><call><name>IsCreateAlterExtensionUpdateCitusStmt</name><argument_list>(
		<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>EnableVersionChecks</name> <operator>&amp;&amp;</operator> <name>isCreateAlterExtensionUpdateCitusStmt</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ErrorIfUnstableCreateOrAlterExtensionStmt</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CreateExtensionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Postgres forbids creating/altering other extensions from within an extension script, so we use a utility hook instead
		 * This preprocess check whether citus_columnar should be installed first before citus
		 */</comment>
		<expr_stmt><expr><call><name>PreprocessCreateExtensionStmtForCitusColumnar</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ensure that utility commands do not behave any differently until CREATE
		 * EXTENSION is invoked.
		 */</comment>
		<expr_stmt><expr><call><name>PrevProcessUtility_compat</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
								  <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CallStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CallStmt</name> <modifier>*</modifier></type><name>callStmt</name> <init>= <expr><operator>(</operator><name>CallStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the procedure is distributed and we are using MX then we have the
		 * possibility of calling it on the worker. If the data is located on
		 * the worker this can avoid making many network round trips.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name> <operator>&amp;&amp;</operator>
			<call><name>CallDistributedProcedureRemotely</name><argument_list>(<argument><expr><name>callStmt</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Stored procedures are a bit strange in the sense that some statements
		 * are not in a transaction block, but can be rolled back. We need to
		 * make sure we send all statements in a transaction block. The
		 * StoredProcedureLevel variable signals this to the router executor
		 * and indicates how deep in the call stack we are in case of nested
		 * stored procedures.
		 */</comment>
		<expr_stmt><expr><name>StoredProcedureLevel</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PrevProcessUtility_compat</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>StoredProcedureLevel</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>InDelegatedProcedureCall</name> <operator>&amp;&amp;</operator> <name>StoredProcedureLevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>InDelegatedProcedureCall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>StoredProcedureLevel</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>InDelegatedProcedureCall</name> <operator>&amp;&amp;</operator> <name>StoredProcedureLevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>InDelegatedProcedureCall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>DoStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * All statements in a DO block are executed in a single transaction,
		 * so we need to keep track of whether we are inside a DO block.
		 */</comment>
		<expr_stmt><expr><name>DoBlockLevel</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PrevProcessUtility_compat</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>DoBlockLevel</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>DoBlockLevel</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>UtilityHookLevel</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ProcessUtilityInternal</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>,
							   <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>UtilityHookLevel</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * When Citus local tables are disconnected from the foreign key graph, which
			 * can happen due to various kinds of drop commands, we immediately
			 * undistribute them at the end of the command.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ShouldCheckUndistributeCitusLocalTables</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>UndistributeDisconnectedCitusLocalTables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>ResetConstraintDropped</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PROCESS_UTILITY_TOPLEVEL</name> <operator>&amp;&amp;</operator>
				<call><name>ShouldAddNewTableToMetadata</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Here we need to increment command counter so that next command
				 * can see the new table.
				 */</comment>
				<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createTableStmt</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>createTableStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
												  <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Here we set autoConverted to false, since the user explicitly
				 * wants these tables to be added to metadata, by setting the
				 * GUC use_citus_managed_tables to true.
				 */</comment>
				<decl_stmt><decl><type><name>bool</name></type> <name>autoConverted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type> <name>cascade</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>CreateCitusLocalTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>cascade</name></expr></argument>, <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>UtilityHookLevel</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>UtilityHookLevel</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetConstraintDropped</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>UtilityHookLevel</name><operator>--</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ProcessUtilityInternal is a helper function for multi_ProcessUtility where majority
 * of the Citus specific utility statements are handled here. The distinction between
 * both functions is that Citus_ProcessUtility does not handle CALL and DO statements.
 * The reason for the distinction is implemented to be able to find the "top-level" DDL
 * commands (not internal/cascading ones). UtilityHookLevel variable is used to achieve
 * this goal.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessUtilityInternal</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
					   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
					   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
					   <parameter><decl><type><name><name>struct</name> <name>QueryEnvironment</name></name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
					   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
					   <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlJobs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistOpsValidationState</name></type> <name>distOpsValidationState</name> <init>= <expr><name>HasNoneValidObject</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>oldSkipConstraintsValidationValue</name> <init>= <expr><name>SkipConstraintValidation</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>ExplainStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>explainStmt</name> <init>= <expr><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>analyze</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>option</argument>, <argument>explainStmt-&gt;options</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"analyze"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>analyze</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* don't "break", as explain.c will use the last value */</comment>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>analyze</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Since we cannot execute EXPLAIN ANALYZE locally, we
				 * cannot continue.
				 */</comment>
				<expr_stmt><expr><call><name>ErrorIfTransactionAccessedPlacementsLocally</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * EXPLAIN ANALYZE is tricky with local execution, and there is not
		 * much difference between the local and distributed execution in terms
		 * of the actual EXPLAIN output.
		 *
		 * TODO: It might be nice to have a way to show that the query is locally
		 * executed. Shall we add a INFO output?
		 */</comment>
		<expr_stmt><expr><call><name>DisableLocalExecution</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CreateSubscriptionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CreateSubscriptionStmt</name> <modifier>*</modifier></type><name>createSubStmt</name> <init>= <expr><operator>(</operator><name>CreateSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <call><name>ProcessCreateSubscriptionStmt</name><argument_list>(<argument><expr><name>createSubStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For security and reliability reasons we disallow altering and dropping
	 * subscriptions created by citus by non superusers. We could probably
	 * disallow this for all subscriptions without issues. But out of an
	 * abundance of caution for breaking subscription logic created by users
	 * for other purposes, we only disallow it for the subscriptions that we
	 * create i.e. ones that start with "citus_".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterSubscriptionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterSubscriptionStmt</name> <modifier>*</modifier></type><name>alterSubStmt</name> <init>= <expr><operator>(</operator><name>AlterSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>StringStartsWith</name><argument_list>(<argument><expr><name><name>alterSubStmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><literal type="string">"citus_"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator>
						<call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"Only superusers can alter subscriptions that are created by citus"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>DropSubscriptionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DropSubscriptionStmt</name> <modifier>*</modifier></type><name>dropSubStmt</name> <init>= <expr><operator>(</operator><name>DropSubscriptionStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>StringStartsWith</name><argument_list>(<argument><expr><name><name>dropSubStmt</name><operator>-&gt;</operator><name>subname</name></name></expr></argument>, <argument><expr><literal type="string">"citus_"</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator>
						<call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"Only superusers can drop subscriptions that are created by citus"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Process SET LOCAL and SET TRANSACTION statements in multi-statement
	 * transactions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>VariableSetStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VariableSetStmt</name> <modifier>*</modifier></type><name>setStmt</name> <init>= <expr><operator>(</operator><name>VariableSetStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* at present, we only implement the NONE and LOCAL behaviors */</comment>
		<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>PropagateSetCommands</name> <operator>==</operator> <name>PROPSETCMD_NONE</name> <operator>||</operator>
					<name>PropagateSetCommands</name> <operator>==</operator> <name>PROPSETCMD_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsMultiStatementTransaction</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ShouldPropagateSetCommand</name><argument_list>(<argument><expr><name>setStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PostprocessVariableSetStmt</name><argument_list>(<argument><expr><name>setStmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CopyStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>planContext</name> <init>= <expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <call><name>ProcessCopyStmt</name><argument_list>(<argument><expr><operator>(</operator><name>CopyStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>parsetree</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>previousContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>planContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>previousContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * we need to set the parsetree here already as we copy and replace the original
		 * parsetree during ddl propagation. In reality we need to refactor the code above
		 * to not juggle copy the parsetree and leak it to a potential cache above the
		 * utility hook.
		 */</comment>
		<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>parsetree</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we're mostly in DDL (and VACUUM/TRUNCATE) territory at this point... */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CreateSeqStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ErrorIfUnsupportedSeqStmt</name><argument_list>(<argument><expr><operator>(</operator><name>CreateSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ErrorIfDistributedAlterSeqOwnedBy</name><argument_list>(<argument><expr><operator>(</operator><name>AlterSeqStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>TruncateStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PreprocessTruncateStatement</name><argument_list>(<argument><expr><operator>(</operator><name>TruncateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>LockStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * PreprocessLockStatement might lock the relations locally if the
		 * node executing the command is in pg_dist_node. Even though the process
		 * utility will re-acquire the locks across the same relations if the node
		 * is in the metadata (in the pg_dist_node table) that should not be a problem,
		 * plus it ensures consistent locking order between the nodes.
		 */</comment>
		<expr_stmt><expr><call><name>PreprocessLockStatement</name><argument_list>(<argument><expr><operator>(</operator><name>LockStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We only process ALTER TABLE ... ATTACH PARTITION commands in the function below
	 * and distribute the partition if necessary.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStatement</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PreprocessAlterTableStmtAttachPartition</name><argument_list>(<argument><expr><name>alterTableStatement</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* only generate worker DDLJobs if propagation is enabled */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>DistributeObjectOps</name> <modifier>*</modifier></type><name>ops</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>EnableDDLPropagation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* copy planned statement since we might scribble on it or its utilityStmt */</comment>
		<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ops</name> <operator>=</operator> <call><name>GetDistributeObjectOps</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Preprocess and qualify steps can cause pg tests to fail because of the
		 * unwanted citus related warnings or early error logs related to invalid address.
		 * Therefore, we first check if any address in the given statement is valid.
		 * Then, we do not execute qualify and preprocess if none of the addresses are valid
		 * or any address violates ownership rules to prevent before-mentioned citus related
		 * messages. PG will complain about the invalid address or ownership violation, so we
		 * are safe to not execute qualify and preprocess. Also note that we should not guard
		 * any step after standardProcess_Utility with the enum state distOpsValidationState
		 * because PG would have already failed the transaction.
		 */</comment>
		<expr_stmt><expr><name>distOpsValidationState</name> <operator>=</operator> <call><name>DistOpsValidityState</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For some statements Citus defines a Qualify function. The goal of this function
		 * is to take any ambiguity from the statement that is contextual on either the
		 * search_path or current settings.
		 * Instead of relying on the search_path and settings we replace any deduced bits
		 * and fill them out how postgres would resolve them. This makes subsequent
		 * deserialize calls for the statement portable to other postgres servers, the
		 * workers in our case.
		 * If there are no valid objects or any object violates ownership, let's skip
		 * the qualify and preprocess, and do not diverge from Postgres in terms of
		 * error messages.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ops</name> <operator>&amp;&amp;</operator> <name><name>ops</name><operator>-&gt;</operator><name>qualify</name></name> <operator>&amp;&amp;</operator> <call><name>DistOpsInValidState</name><argument_list>(<argument><expr><name>distOpsValidationState</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name><name>ops</name><operator>-&gt;</operator><name>qualify</name></name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ops</name> <operator>&amp;&amp;</operator> <name><name>ops</name><operator>-&gt;</operator><name>preprocess</name></name> <operator>&amp;&amp;</operator> <call><name>DistOpsInValidState</name><argument_list>(<argument><expr><name>distOpsValidationState</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ddlJobs</name> <operator>=</operator> <call><name><name>ops</name><operator>-&gt;</operator><name>preprocess</name></name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * citus.enable_ddl_propagation is disabled, which means that PostgreSQL
		 * should handle the DDL command on a distributed table directly, without
		 * Citus intervening. The only exception is partition column drop, in
		 * which case we error out. Advanced Citus users use this to implement their
		 * own DDL propagation. We also use it to avoid re-propagating DDL commands
		 * when changing MX tables on workers.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStmt</name> <init>= <expr><operator>(</operator><name>AlterTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>AlterTableStmtObjType_compat</name><argument_list>(<argument><expr><name>alterTableStmt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBJECT_TABLE</name> <operator>||</operator>
				<call><name>AlterTableStmtObjType_compat</name><argument_list>(<argument><expr><name>alterTableStmt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ErrorIfAlterDropsPartitionColumn</name><argument_list>(<argument><expr><name>alterTableStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * When issuing an ALTER TABLE ... ADD FOREIGN KEY command, the
				 * the validation step should be skipped on the distributed table.
				 * Therefore, we check whether the given ALTER TABLE statement is a
				 * FOREIGN KEY constraint and if so disable the validation step.
				 * Note validation is done on the shard level when DDL propagation
				 * is enabled. The following eagerly executes some tasks on workers.
				 */</comment>
				<expr_stmt><expr><call><name>SkipForeignKeyValidationIfConstraintIsFkey</name><argument_list>(<argument><expr><name>alterTableStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* inform the user about potential caveats */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CreatedbStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>EnableUnsupportedFeatureMessages</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Citus partially supports CREATE DATABASE for "</literal>
									<literal type="string">"distributed databases"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Citus does not propagate CREATE DATABASE "</literal>
									   <literal type="string">"command to workers"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You can manually create a database and its "</literal>
									 <literal type="string">"extensions on workers."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CreateRoleStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>EnableCreateRolePropagation</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not propagating CREATE ROLE/USER commands to worker"</literal>
								<literal type="string">" nodes"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Connect to worker nodes directly to manually create all"</literal>
								 <literal type="string">" necessary users and roles."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make sure that on DROP DATABASE we terminate the background daemon
	 * associated with it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>DropdbStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>missingOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DropdbStmt</name> <modifier>*</modifier></type><name>dropDbStatement</name> <init>= <expr><operator>(</operator><name>DropdbStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dbname</name> <init>= <expr><name><name>dropDbStatement</name><operator>-&gt;</operator><name>dbname</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>databaseOid</name> <init>= <expr><call><name>get_database_oid</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>missingOK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>databaseOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>StopMaintenanceDaemon</name><argument_list>(<argument><expr><name>databaseOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsDropCitusExtensionStmt</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>StopMaintenanceDaemon</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make sure that dropping the role deletes the pg_dist_object entries. There is a
	 * separate logic for roles, since roles are not included as dropped objects in the
	 * drop event trigger. To handle it both on worker and coordinator nodes, it is not
	 * implemented as a part of process functions but here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>DropRoleStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DropRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropRoleStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allDropRoles</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedDropRoles</name> <init>= <expr><call><name>FilterDistributedRoles</name><argument_list>(<argument><expr><name>allDropRoles</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>distributedDropRoles</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnmarkRolesDistributed</name><argument_list>(<argument><expr><name>distributedDropRoles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>parsetree</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>IncrementUtilityHookCountersIfNecessary</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check if we are running ALTER EXTENSION citus UPDATE (TO "&lt;version&gt;") command and
		 * the available version is different than the current version of Citus. In this case,
		 * ALTER EXTENSION citus UPDATE command can actually update Citus to a new version.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>isCreateAlterExtensionUpdateCitusStmt</name> <init>=
			<expr><call><name>IsCreateAlterExtensionUpdateCitusStmt</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isAlterExtensionUpdateCitusStmt</name> <init>= <expr><name>isCreateAlterExtensionUpdateCitusStmt</name> <operator>&amp;&amp;</operator>
											   <call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterExtensionStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>citusCanBeUpdatedToAvailableVersion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isAlterExtensionUpdateCitusStmt</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>citusCanBeUpdatedToAvailableVersion</name> <operator>=</operator> <operator>!</operator><call><name>InstalledAndAvailableVersionsSame</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check whether need to install/drop citus_columnar when upgrade/downgrade citus
			 */</comment>
			<expr_stmt><expr><call><name>PreprocessAlterExtensionCitusStmtForCitusColumnar</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PrevProcessUtility_compat</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
								  <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isAlterExtensionUpdateCitusStmt</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Post process, upgrade citus_columnar from fake internal version to normal version if upgrade citus
			 * or drop citus_columnar fake version when downgrade citus to older version that do not support
			 * citus_columnar
			 */</comment>
			<expr_stmt><expr><call><name>PostprocessAlterExtensionCitusStmtForCitusColumnar</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * if we are running ALTER EXTENSION citus UPDATE (to "&lt;version&gt;") command, we may need
		 * to mark existing objects as distributed depending on the "version" parameter if
		 * specified in "ALTER EXTENSION citus UPDATE" command
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>isAlterExtensionUpdateCitusStmt</name> <operator>&amp;&amp;</operator> <name>citusCanBeUpdatedToAvailableVersion</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PostprocessAlterExtensionCitusUpdateStmt</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PostStandardProcessUtility</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PostStandardProcessUtility</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Post process for ddl statements
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>EnableDDLPropagation</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ops</name> <operator>&amp;&amp;</operator> <name><name>ops</name><operator>-&gt;</operator><name>postprocess</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>processJobs</name> <init>= <expr><call><name><name>ops</name><operator>-&gt;</operator><name>postprocess</name></name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>processJobs</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ddlJobs</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* jobs should not have been set before */</comment>
				<expr_stmt><expr><name>ddlJobs</name> <operator>=</operator> <name>processJobs</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>RenameStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>renameType</name> <operator>==</operator>
			<name>OBJECT_ROLE</name> <operator>&amp;&amp;</operator> <name>EnableAlterRolePropagation</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>EnableUnsupportedFeatureMessages</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
									 <argument><expr><literal type="string">"not propagating ALTER ROLE ... RENAME TO commands "</literal>
									 <literal type="string">"to worker nodes"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Connect to worker nodes directly to manually "</literal>
										 <literal type="string">"rename the role"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStatement</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PostprocessCreateTableStmt</name><argument_list>(<argument><expr><name>createStatement</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CreateForeignTableStmt</name> <modifier>*</modifier></type><name>createForeignTableStmt</name> <init>=
			<expr><operator>(</operator><name>CreateForeignTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createTableStmt</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name><name>createForeignTableStmt</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Error out with a hint if the foreign table is using postgres_fdw and
		 * the option table_name is not provided.
		 * Citus relays all the Citus local foreign table logic to the placement of the
		 * Citus local table. If table_name is NOT provided, Citus would try to talk to
		 * the foreign postgres table over the shard's table name, which would not exist
		 * on the remote server.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ServerUsesPostgresFDW</name><argument_list>(<argument><expr><name><name>createForeignTableStmt</name><operator>-&gt;</operator><name>servername</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ErrorIfOptionListHasNoTableName</name><argument_list>(<argument><expr><name><name>createForeignTableStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PostprocessCreateTableStmt</name><argument_list>(<argument><expr><name>createTableStmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* after local command has completed, finish by executing worker DDLJobs, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>ddlJobs</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PostprocessAlterTableStmt</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>GrantStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GrantStmt</name> <modifier>*</modifier></type><name>grantStmt</name> <init>= <expr><operator>(</operator><name>GrantStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>grantStmt</name><operator>-&gt;</operator><name>targtype</name></name> <operator>==</operator> <name>ACL_TARGET_ALL_IN_SCHEMA</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Grant .. IN SCHEMA causes a deadlock if we don't use local execution
				 * because standard process utility processes the shard placements as well
				 * and the row-level locks in pg_class will not be released until the current
				 * transaction commits. We could skip the local shard placements after standard
				 * process utility, but for simplicity we just prefer using local execution.
				 */</comment>
				<expr_stmt><expr><call><name>SetLocalExecutionStatus</name><argument_list>(<argument><expr><name>LOCAL_EXECUTION_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>ddlJob</argument>, <argument>ddlJobs</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecuteDistributedDDLJob</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This postprocess needs to be done after the distributed ddl jobs have
			 * been executed in the workers, hence is separate from PostprocessAlterTableStmt.
			 * We might have wrong index names generated on indexes of shards of partitions,
			 * so we perform the relevant checks and index renaming here.
			 */</comment>
			<expr_stmt><expr><call><name>FixAlterTableStmtIndexNames</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For CREATE/DROP/REINDEX CONCURRENTLY we mark the index as valid
		 * after successfully completing the distributed DDL job.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>indexStmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>indexStmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no failures during CONCURRENTLY, mark the index as valid */</comment>
				<expr_stmt><expr><call><name>MarkIndexValid</name><argument_list>(<argument><expr><name>indexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We make sure schema name is not null in the PreprocessIndexStmt.
			 */</comment>
			<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If this a partitioned table, and CREATE INDEX was not run with ONLY,
			 * we have wrong index names generated on indexes of shards of
			 * partitions of this table, so we should fix them.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* only fix this specific index */</comment>
				<decl_stmt><decl><type><name>Oid</name></type> <name>indexRelationId</name> <init>=
					<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>idxname</name></name></expr></argument>, <argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FixPartitionShardIndexNames</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Since we must have objects on workers before distributing them,
		 * mark object distributed as the last step.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ops</name> <operator>&amp;&amp;</operator> <name><name>ops</name><operator>-&gt;</operator><name>markDistributed</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>addresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>address</argument>, <argument>addresses</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>MarkObjectDistributed</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsDropCitusExtensionStmt</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>DropdbStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ensure value is valid, we can't do some checks during CREATE
		 * EXTENSION. This is important to register some invalidation callbacks.
		 */</comment>
		<expr_stmt><expr><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* lgtm[cpp/return-value-ignored] */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>SkipConstraintValidation</name> <operator>=</operator> <name>oldSkipConstraintsValidationValue</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UndistributeDisconnectedCitusLocalTables undistributes citus local tables that
 * are not connected to any reference tables via their individual foreign key
 * subgraphs. Note that this function undistributes only the auto-converted tables,
 * i.e the ones that are converted by Citus by cascading through foreign keys.
 */</comment>
<function><type><name>void</name></type>
<name>UndistributeDisconnectedCitusLocalTables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>citusLocalTableIdList</name> <init>= <expr><call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>citusLocalTableIdList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>citusLocalTableIdList</name></expr></argument>, <argument><expr><name>CompareOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>citusLocalTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>citusLocalTableId</argument>, <argument>citusLocalTableIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* acquire ShareRowExclusiveLock to prevent concurrent foreign key creation */</comment>
		<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><name>ShareRowExclusiveLock</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>=
			<expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * UndistributeTable drops relation, skip if already undistributed
			 * via cascade.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we skip here, we'll undistribute from the parent if necessary */</comment>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldUndistributeCitusLocalTable</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* still connected to a reference table, skip it */</comment>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Citus local table is not connected to any reference tables, then
		 * undistribute it via cascade. Here, instead of first dropping foreing
		 * keys then undistributing the table, we just set cascadeViaForeignKeys
		 * to true for simplicity.
		 *
		 * We suppress notices messages not to be too verbose. On the other hand,
		 * as UndistributeTable moves data to a new table, we want to inform user
		 * as it might take some time.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing table %s from metadata as it is not "</literal>
								<literal type="string">"connected to any reference tables via foreign keys"</literal></expr></argument>,
								<argument><expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>TableConversionParameters</name></type> <name>params</name> <init>= <expr><block>{
			<expr><operator>.</operator><name>relationId</name> <operator>=</operator> <name>citusLocalTableId</name></expr>,
			<expr><operator>.</operator><name>cascadeViaForeignKeys</name> <operator>=</operator> <name>true</name></expr>,
			<expr><operator>.</operator><name>suppressNoticeMessages</name> <operator>=</operator> <name>true</name></expr>
		}</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>UndistributeTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldCheckUndistributeCitusLocalTables returns true if we might need to check
 * citus local tables for undistributing automatically.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldCheckUndistributeCitusLocalTables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ConstraintDropped</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * citus_drop_trigger executes notify_constraint_dropped to set
		 * ConstraintDropped to true, which means that last command dropped
		 * a table constraint.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are dropping citus, we should not try to undistribute citus
		 * local tables as they will also be dropped.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>InCoordinatedTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not interacting with any Citus objects */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusInternalBackend</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsRebalancerInternalBackend</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* connection from the coordinator operating on a shard */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldEnableLocalReferenceForeignKeys</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If foreign keys between reference tables and local tables are
		 * disabled, then user might be using citus_add_local_table_to_metadata for
		 * their own purposes. In that case, we should not undistribute
		 * citus local tables.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCoordinator</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we should not perform this operation in worker nodes */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldAddNewTableToMetadata takes a Node* and returns true if we need to add a
 * newly created table to metadata, false otherwise.
 * This function checks whether the given Node* is a CREATE TABLE statement.
 * For partitions and temporary tables, ShouldAddNewTableToMetadata returns false.
 * For other tables created, returns true, if we are on a coordinator that is added
 * as worker, and ofcourse, if the GUC use_citus_managed_tables is set to on.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldAddNewTableToMetadata</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createTableStmt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>createTableStmt</name> <operator>=</operator> <operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CreateForeignTableStmt</name> <modifier>*</modifier></type><name>createForeignTableStmt</name> <init>=
			<expr><operator>(</operator><name>CreateForeignTableStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>createTableStmt</name> <operator>=</operator> <operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>createForeignTableStmt</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* if the command is not CREATE [FOREIGN] TABLE, we can early return false */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>createTableStmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name> <operator>||</operator>
		<name><name>createTableStmt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Shouldn't add table to metadata if it's a temp table, or a partition.
		 * Creating partitions of a table that is added to metadata is already handled.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>AddAllLocalTablesToMetadata</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>IsBinaryUpgrade</name> <operator>&amp;&amp;</operator>
		<call><name>IsCoordinator</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CoordinatorAddedAsWorkerNode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have verified that the GUC is set to true, and we are not upgrading,
		 * and we are on the coordinator that is added as worker node.
		 * So return true here, to add this newly created table to metadata.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ServerUsesPostgresFDW gets a foreign server name and returns true if the FDW that
 * the server depends on is postgres_fdw. Returns false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ServerUsesPostgresFDW</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>serverName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ForeignServer</name> <modifier>*</modifier></type><name>server</name> <init>= <expr><call><name>GetForeignServerByName</name><argument_list>(<argument><expr><name>serverName</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ForeignDataWrapper</name> <modifier>*</modifier></type><name>fdw</name> <init>= <expr><call><name>GetForeignDataWrapper</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>fdwid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fdw</name><operator>-&gt;</operator><name>fdwname</name></name></expr></argument>, <argument><expr><literal type="string">"postgres_fdw"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfOptionListHasNoTableName gets an option list (DefElem) and errors out
 * if the list does not contain a table_name element.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfOptionListHasNoTableName</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>optionList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>table_nameString</name> <init>= <expr><literal type="string">"table_name"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>option</argument>, <argument>optionList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>optionName</name> <init>= <expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>optionName</name></expr></argument>, <argument><expr><name>table_nameString</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
						<argument><expr><literal type="string">"table_name option must be provided when using postgres_fdw with Citus"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Provide the option \"table_name\" with value target table's"</literal>
							<literal type="string">" name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * NotifyUtilityHookConstraintDropped sets ConstraintDropped to true to tell us
 * last command dropped a table constraint.
 */</comment>
<function><type><name>void</name></type>
<name>NotifyUtilityHookConstraintDropped</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>ConstraintDropped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ResetConstraintDropped sets ConstraintDropped to false.
 */</comment>
<function><type><name>void</name></type>
<name>ResetConstraintDropped</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>ConstraintDropped</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsDropSchemaOrDB returns true if parsetree represents DROP SCHEMA ...or
 * a DROP DATABASE.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsDropSchemaOrDB</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>DropStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropStatement</name> <init>= <expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>(</operator><name><name>dropStatement</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_SCHEMA</name><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name><name>dropStatement</name><operator>-&gt;</operator><name>removeType</name></name> <operator>==</operator> <name>OBJECT_DATABASE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteDistributedDDLJob simply executes a provided DDLJob in a distributed trans-
 * action, including metadata sync if needed. If the multi shard commit protocol is
 * in its default value of '1pc', then a notice message indicating that '2pc' might be
 * used for extra safety. In the commit protocol, a BEGIN is sent after connection to
 * each shard placement and COMMIT/ROLLBACK is handled by
 * CoordinatedTransactionCallback function.
 *
 * The function errors out if the node is not the coordinator or if the DDL is on
 * a partitioned table which has replication factor &gt; 1.
 *
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteDistributedDDLJob</name><parameter_list>(<parameter><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>shouldSyncMetadata</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>targetObjectAddress</name> <init>= <expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>targetObjectAddress</name><operator>.</operator><name>classId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Only for ddlJobs that are targetting an object we want to sync
		 * its metadata.
		 */</comment>
		<expr_stmt><expr><name>shouldSyncMetadata</name> <operator>=</operator> <call><name>ShouldSyncUserCommandForObject</name><argument_list>(<argument><expr><name>targetObjectAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>targetObjectAddress</name><operator>.</operator><name>classId</name></name> <operator>==</operator> <name>RelationRelationId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EnsurePartitionTableNotReplicated</name><argument_list>(<argument><expr><name><name>targetObjectAddress</name><operator>.</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>localExecutionSupported</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TaskListCannotBeExecutedInTransaction</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>shouldSyncMetadata</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>currentSearchPath</name> <init>= <expr><call><name>CurrentSearchPath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Given that we're relaying the query to the worker nodes directly,
			 * we should set the search path exactly the same when necessary.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>currentSearchPath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(
					<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"SET LOCAL search_path TO %s;"</literal></expr></argument>, <argument><expr><name>currentSearchPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecuteUtilityTaskList</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>localExecutionSupported</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start a new transaction to make sure CONCURRENTLY commands
		 * on localhost do not block waiting for this transaction to finish.
		 *
		 * In addition to doing that, we also need to tell other backends
		 * --including the ones spawned for connections opened to localhost to
		 * build indexes on shards of this relation-- that concurrent index
		 * builds can safely ignore us.
		 *
		 * Normally, DefineIndex() only does that if index doesn't have any
		 * predicates (i.e.: where clause) and no index expressions at all.
		 * However, now that we already called standard process utility,
		 * index build on the shell table is finished anyway.
		 *
		 * The reason behind doing so is that we cannot guarantee not
		 * grabbing any snapshots via adaptive executor, and the backends
		 * creating indexes on local shards (if any) might block on waiting
		 * for current xact of the current backend to finish, which would
		 * cause self deadlocks that are not detectable.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ddlJob</name><operator>-&gt;</operator><name>startNewTransaction</name></name></expr>)</condition>
		<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:if>

			<comment type="block">/*
			 * Older versions of postgres doesn't have PROC_IN_SAFE_IC flag
			 * so we cannot use set_indexsafe_procflags in those versions.
			 *
			 * For this reason, we do our best to ensure not grabbing any
			 * snapshots later in the executor.
			 */</comment>

			<comment type="block">/*
			 * If cache is not populated, system catalog lookups will cause
			 * the xmin of current backend to change. Then the last phase
			 * of CREATE INDEX CONCURRENTLY, which is in a separate backend,
			 * will hang waiting for our backend and result in a deadlock.
			 *
			 * We populate the cache before starting the next transaction to
			 * avoid this. Most of the metadata has already been resolved in
			 * planning phase, we only need to lookup metadata needed for
			 * connection establishment.
			 */</comment>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CurrentDatabaseName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * ConnParams (AuthInfo and PoolInfo) gets a snapshot, which
			 * will blocks the remote connections to localhost. Hence we warm up
			 * the cache here so that after we start a new transaction, the entries
			 * will already be in the hash table, hence we won't be holding any snapshots.
			 */</comment>
			<expr_stmt><expr><call><name>WarmUpConnParamsHash</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/*
			 * Since it is not certain whether the code-path that we followed
			 * until reaching here caused grabbing any snapshots or not, we
			 * need to pop the active snapshot if we had any, to ensure not
			 * leaking any snapshots.
			 *
			 * For example, EnsureCoordinator might return without grabbing
			 * any snapshots if we didn't receive any invalidation messages
			 * but the otherwise is also possible.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>

			<comment type="block">/*
			 * Tell other backends to ignore us, even if we grab any
			 * snapshots via adaptive executor.
			 */</comment>
			<expr_stmt><expr><call><name>set_indexsafe_procflags</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We should not have any CREATE INDEX commands go through the
			 * local backend as we signaled other backends that this backend
			 * is executing a "safe" index command (PROC_IN_SAFE_IC), which
			 * is NOT true, we are only faking postgres based on the reasoning
			 * given above.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>localExecutionSupported</name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>savedContext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExecuteUtilityTaskList</name><argument_list>(<argument><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name></expr></argument>, <argument><expr><name>localExecutionSupported</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>shouldSyncMetadata</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>currentSearchPath</name> <init>= <expr><call><name>CurrentSearchPath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Given that we're relaying the query to the worker nodes directly,
				 * we should set the search path exactly the same when necessary.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>currentSearchPath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>,
										  <argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"SET search_path TO %s;"</literal></expr></argument>,
												   <argument><expr><name>currentSearchPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SendBareCommandListToMetadataWorkers</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/* CopyErrorData() requires (CurrentMemoryContext != ErrorContext) */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savedContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * In concurrent index creation, if a worker index with the same name already
			 * exists, prompt to DROP the current index and retry the original command
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>==</operator> <name>ERRCODE_DUPLICATE_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CONCURRENTLY-enabled index command failed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(
							 <argument><expr><literal type="string">"CONCURRENTLY-enabled index commands can fail partially, "</literal>
							 <literal type="string">"leaving behind an INVALID index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use DROP INDEX CONCURRENTLY IF EXISTS to remove the "</literal>
								 <literal type="string">"invalid index, then retry the original command."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
							 <argument><expr><literal type="string">"CONCURRENTLY-enabled index commands can fail partially, "</literal>
							 <literal type="string">"leaving behind an INVALID index.\n Use DROP INDEX "</literal>
							 <literal type="string">"CONCURRENTLY IF EXISTS to remove the invalid index."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>

<comment type="block">/*
 * set_indexsafe_procflags sets PROC_IN_SAFE_IC flag in MyProc-&gt;statusFlags.
 *
 * The flag is reset automatically at transaction end, so it must be set
 * for each transaction.
 *
 * Copied from pg/src/backend/commands/indexcmds.c
 * Also see pg commit c98763bf51bf610b3ee7e209fc76c3ff9a6b3163.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_indexsafe_procflags</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>xid</name></name> <operator>==</operator> <name>InvalidTransactionId</name> <operator>&amp;&amp;</operator>
		   <name><name>MyProc</name><operator>-&gt;</operator><name>xmin</name></name> <operator>==</operator> <name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>statusFlags</name></name> <operator>|=</operator> <name>PROC_IN_SAFE_IC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>statusFlags</name><index>[<expr><name><name>MyProc</name><operator>-&gt;</operator><name>pgxactoff</name></name></expr>]</index></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>statusFlags</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * CurrentSearchPath is a C interface for calling current_schemas(bool) that
 * PostgreSQL exports.
 *
 * CurrentSchemas returns all the schemas in the seach_path that are seperated
 * with comma (,) sign. The returned string can be used to set the search_path.
 *
 * The function omits implicit schemas.
 *
 * The function returns NULL if there are no valid schemas in the search_path,
 * mimicing current_schemas(false) function.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CurrentSearchPath</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>currentSearchPath</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>searchPathList</name> <init>= <expr><call><name>fetch_search_path</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>schemaAdded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>searchPathOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>searchPathOid</argument>, <argument>searchPathList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>searchPathOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* watch out for deleted namespace */</comment>
		<if_stmt><if>if <condition>(<expr><name>schemaName</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>schemaAdded</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>currentSearchPath</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>schemaAdded</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>currentSearchPath</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>schemaAdded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* fetch_search_path() returns a palloc'd list that we should free now */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>searchPathList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>currentSearchPath</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>currentSearchPath</name><operator>-&gt;</operator><name>data</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IncrementUtilityHookCountersIfNecessary increments activeAlterTables and
 * activeDropSchemaOrDBs counters if utility command being processed implies
 * to do so.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>IncrementUtilityHookCountersIfNecessary</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>activeAlterTables</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsDropSchemaOrDB</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>activeDropSchemaOrDBs</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PostStandardProcessUtility performs operations to alter (backend) global
 * state of citus utility hook. Those operations should be done after standard
 * process utility executes even if it errors out.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PostStandardProcessUtility</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>DecrementUtilityHookCountersIfNecessary</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-forming the foreign key graph relies on the command being executed
	 * on the local table first. However, in order to decide whether the
	 * command leads to an invalidation, we need to check before the command
	 * is being executed since we read pg_constraint table. Thus, we maintain a
	 * local flag and do the invalidation after multi_ProcessUtility,
	 * before ExecuteDistributedDDLJob().
	 */</comment>
	<expr_stmt><expr><call><name>InvalidateForeignKeyGraphForDDL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DecrementUtilityHookCountersIfNecessary decrements activeAlterTables and
 * activeDropSchemaOrDBs counters if utility command being processed implies
 * to do so.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DecrementUtilityHookCountersIfNecessary</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>activeAlterTables</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsDropSchemaOrDB</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>activeDropSchemaOrDBs</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MarkInvalidateForeignKeyGraph marks whether the foreign key graph should be
 * invalidated due to a DDL.
 */</comment>
<function><type><name>void</name></type>
<name>MarkInvalidateForeignKeyGraph</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>shouldInvalidateForeignKeyGraph</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InvalidateForeignKeyGraphForDDL simply keeps track of whether
 * the foreign key graph should be invalidated due to a DDL.
 */</comment>
<function><type><name>void</name></type>
<name>InvalidateForeignKeyGraphForDDL</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>shouldInvalidateForeignKeyGraph</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvalidateForeignKeyGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>shouldInvalidateForeignKeyGraph</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DDLTaskList builds a list of tasks to execute a DDL command on a
 * given list of shards.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>DDLTaskList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>taskList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shardIntervalList</name> <init>= <expr><call><name>LoadShardIntervalList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedSchemaName</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escapedCommandString</name> <init>= <expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>jobId</name> <init>= <expr><name>INVALID_JOB_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>taskId</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* lock metadata before getting placement lists */</comment>
	<expr_stmt><expr><call><name>LockShardListMetadata</name><argument_list>(<argument><expr><name>shardIntervalList</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ShardInterval</name> <modifier>*</modifier></type><name>shardInterval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>shardInterval</argument>, <argument>shardIntervalList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><name><name>shardInterval</name><operator>-&gt;</operator><name>shardId</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>applyCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If rightRelationId is not InvalidOid, instead of worker_apply_shard_ddl_command
		 * we use worker_apply_inter_shard_ddl_command.
		 */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>applyCommand</name></expr></argument>, <argument><expr><name>WORKER_APPLY_SHARD_DDL_COMMAND</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>,
						 <argument><expr><name>escapedSchemaName</name></expr></argument>, <argument><expr><name>escapedCommandString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>jobId</name></name> <operator>=</operator> <name>jobId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskId</name></name> <operator>=</operator> <name>taskId</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>DDL_TASK</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetTaskQueryString</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name><name>applyCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>replicationModel</name></name> <operator>=</operator> <name>REPLICATION_MODEL_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>dependentTaskList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>anchorShardId</name></name> <operator>=</operator> <name>shardId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>ActiveShardPlacementList</name><argument_list>(<argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>taskList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>taskList</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>taskList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeDDLTaskList builds a list of tasks to execute a DDL command on a
 * given target set of nodes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>NodeDDLTaskList</name><parameter_list>(<parameter><decl><type><name>TargetWorkerSet</name></type> <name>targets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* don't allow concurrent node list changes that require an exclusive lock */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>workerNodes</name> <init>= <expr><call><name>TargetWorkerSetNodeList</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>workerNodes</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * if there are no nodes we don't have to plan any ddl tasks. Planning them would
		 * cause the executor to stop responding.
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Task</name> <modifier>*</modifier></type><name>task</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>Task</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskType</name></name> <operator>=</operator> <name>DDL_TASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetTaskQueryStringList</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>WorkerNode</name> <modifier>*</modifier></type><name>workerNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>workerNode</argument>, <argument>workerNodes</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShardPlacement</name> <modifier>*</modifier></type><name>targetPlacement</name> <init>= <expr><call><name>CitusMakeNode</name><argument_list>(<argument><expr><name>ShardPlacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>targetPlacement</name><operator>-&gt;</operator><name>nodeName</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerName</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetPlacement</name><operator>-&gt;</operator><name>nodePort</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>workerPort</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetPlacement</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name><name>workerNode</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>task</name><operator>-&gt;</operator><name>taskPlacementList</name></name></expr></argument>, <argument><expr><name>targetPlacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name> <operator>=</operator> <name>InvalidObjectAddress</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTableInProgress returns true if we're processing an ALTER TABLE command
 * right now.
 */</comment>
<function><type><name>bool</name></type>
<name>AlterTableInProgress</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>activeAlterTables</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropSchemaOrDBInProgress returns true if we're processing a DROP SCHEMA
 * or a DROP DATABASE command right now.
 */</comment>
<function><type><name>bool</name></type>
<name>DropSchemaOrDBInProgress</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>activeDropSchemaOrDBs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
