<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/commands/citus_add_local_table_to_metadata.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * citus_add_local_table_to_metadata.c
 *
 * This file contains functions to add local table to citus metadata.
 *
 * A local table added to metadata is composed of a shell relation to wrap the
 * the regular postgres relation as its coordinator local shard.
 *
 * As we want to hide "citus local table" concept from users, we renamed
 * udf and re-branded that concept as "local tables added to metadata".
 * Note that we might still call this local table concept as "citus local" in
 * many places of the code base.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/foreign_key_relationship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/namespace_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_shard_visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Global variable for the GUC citus.use_citus_managed_tables.
 * This is used after every CREATE TABLE statement in utility_hook.c
 * If this variable is set to true, we add all created tables to metadata.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>AddAllLocalTablesToMetadata</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>citus_add_local_table_to_metadata_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
													   <parameter><decl><type><name>bool</name></type> <name>cascadeViaForeignKeys</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfAddingPartitionTableToMetadata</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedCreateCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedCitusLocalTableKind</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedCitusLocalColumnDefinition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>NoticeIfAutoConvertingLocalTables</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>autoConverted</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CascadeOperationType</name></type> <name>GetCascadeTypeForCitusLocalTables</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>autoConverted</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetShellTableDDLEventsForCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>ConvertLocalTableToShard</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RenameRelationToShardRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shellRelationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RenameShardRelationConstraints</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetConstraintNameList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetRenameShardConstraintCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name></decl></parameter>,
											  <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RenameShardRelationIndexes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RenameShardRelationStatistics</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetDropTriggerCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetRenameShardIndexCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetRenameShardStatsCommand</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>statSchema</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>statsName</name></decl></parameter>,
										 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>statsNameWithShardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RenameShardRelationNonTruncateTriggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetRenameShardTriggerCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name></decl></parameter>,
										   <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropRelationTruncateTriggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetDropTriggerCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropViewsOnTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRenameStatsCommandList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>statsOidList</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ReversedOidList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>oidList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendExplicitIndexIdsToList</name><parameter_list>(<parameter><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>explicitIndexIdList</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropNextValExprsAndMoveOwnedSeqOwnerships</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>,
													  <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropDefaultColumnDefinition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TransferSequenceOwnership</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>ownedSequenceId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>,
									  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InsertMetadataForCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>citusLocalTableId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
											 <parameter><decl><type><name>bool</name></type> <name>autoConverted</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FinalizeCitusLocalTableCreation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>citus_add_local_table_to_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>create_citus_local_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>remove_local_tables_from_metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * citus_add_local_table_to_metadata creates a citus local table from the table with
 * relationId by executing the internal method CreateCitusLocalTable.
 * (See CreateCitusLocalTable function's comment.)
 */</comment>
<function><type><name>Datum</name></type>
<name>citus_add_local_table_to_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>cascadeViaForeignKeys</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>citus_add_local_table_to_metadata_internal</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>cascadeViaForeignKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * citus_add_local_table_to_metadata_internal is the internal method for
 * citus_add_local_table_to_metadata udf.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>citus_add_local_table_to_metadata_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>cascadeViaForeignKeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* enable citus_add_local_table_to_metadata on an empty node */</comment>
	<expr_stmt><expr><call><name>InsertCoordinatorIfClusterEmpty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>autoConverted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CreateCitusLocalTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>cascadeViaForeignKeys</name></expr></argument>, <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * create_citus_local_table is a wrapper function for old name of
 * of citus_add_local_table_to_metadata.
 *
 * The only reason for having this udf in citus binary is to make
 * multi_extension test happy as it uses this udf when testing the
 * downgrade scenario from 9.5 to 9.4.
 */</comment>
<function><type><name>Datum</name></type>
<name>create_citus_local_table</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"create_citus_local_table is deprecated in favour of "</literal>
							<literal type="string">"citus_add_local_table_to_metadata"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * create_citus_local_table doesn't have cascadeViaForeignKeys option,
	 * so we can't directly call citus_add_local_table_to_metadata udf itself
	 * since create_citus_local_table doesn't specify cascadeViaForeignKeys.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>cascadeViaForeignKeys</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>citus_add_local_table_to_metadata_internal</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>cascadeViaForeignKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * remove_local_tables_from_metadata undistributes citus local
 * tables that are not chained with any reference tables via foreign keys.
 */</comment>
<function><type><name>Datum</name></type>
<name>remove_local_tables_from_metadata</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UndistributeDisconnectedCitusLocalTables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateCitusLocalTable is the internal method that creates a citus table
 * from the table with relationId. The created table would have the following
 * properties:
 *  - it will have only one shard,
 *  - its distribution method will be DISTRIBUTE_BY_NONE,
 *  - its replication model will be REPLICATION_MODEL_STREAMING,
 *  - its replication factor will be set to 1.
 * Similar to reference tables, it has only 1 placement. In addition to that, that
 * single placement is only allowed to be on the coordinator.
 */</comment>
<function><type><name>void</name></type>
<name>CreateCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>cascadeViaForeignKeys</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>autoConverted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * These checks should be done before acquiring any locks on relation.
	 * This is because we don't allow creating citus local tables in worker
	 * nodes and we don't want to acquire any locks on a table if we are not
	 * the owner of it.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* enable citus_add_local_table_to_metadata on an empty node */</comment>
	<expr_stmt><expr><call><name>InsertCoordinatorIfClusterEmpty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Creating Citus local tables relies on functions that accesses
	 * shards locally (e.g., ExecuteAndLogUtilityCommand()). As long as
	 * we don't teach those functions to access shards remotely, we
	 * cannot relax this check.
	 */</comment>
	<expr_stmt><expr><call><name>SetLocalExecutionStatus</name><argument_list>(<argument><expr><name>LOCAL_EXECUTION_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>autoConverted</name> <operator>&amp;&amp;</operator> <call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We allow users to mark local tables already added to metadata
		 * as "autoConverted = false".
		 * If the user called citus_add_local_table_to_metadata for a table that is
		 * already added to metadata, we should mark this one and connected relations
		 * as auto-converted = false.
		 */</comment>
		<expr_stmt><expr><call><name>UpdateAutoConvertedForConnectedRelations</name><argument_list>(<argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Lock target relation with an AccessExclusiveLock as we don't want
	 * multiple backends manipulating this relation. We could actually simply
	 * lock the relation without opening it. However, we also want to check
	 * if the relation does not exist or dropped by another backend. Also,
	 * we open the relation with try_relation_open instead of relation_open
	 * to give a nice error in case the table is dropped by another backend.
	 */</comment>
	<decl_stmt><decl><type><name>LOCKMODE</name></type> <name>lockMode</name> <init>= <expr><name>AccessExclusiveLock</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfUnsupportedCreateCitusLocalTable</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ErrorIfAddingPartitionTableToMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We immediately close relation with NoLock right after opening it. This is
	 * because, in this function, we may execute ALTER TABLE commands modifying
	 * relation's column definitions and postgres does not allow us to do so when
	 * the table is still open. (See the postgres function CheckTableNotInUse for
	 * more information)
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>NoticeIfAutoConvertingLocalTables</name><argument_list>(<argument><expr><name>autoConverted</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TableHasExternalForeignKeys</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cascadeViaForeignKeys</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We do not allow creating citus local table if the table is involved in a
			 * foreign key relationship with "any other table", unless the option
			 * cascadeViaForeignKeys is given true.
			 * Note that we allow self references.
			 */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation %s is involved in a foreign key "</literal>
								   <literal type="string">"relationship with another table"</literal></expr></argument>,
								   <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use cascade_via_foreign_keys option to add "</literal>
									<literal type="string">"all the relations involved in a foreign key "</literal>
									<literal type="string">"relationship with %s to citus metadata by "</literal>
									<literal type="string">"executing SELECT citus_add_local_table_to_metadata($$%s$$, "</literal>
									<literal type="string">"cascade_via_foreign_keys=&gt;true)"</literal></expr></argument>,
									<argument><expr><name>qualifiedRelationName</name></expr></argument>, <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>CascadeOperationType</name></type> <name>cascadeType</name> <init>=
			<expr><call><name>GetCascadeTypeForCitusLocalTables</name><argument_list>(<argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * By acquiring AccessExclusiveLock, make sure that no modifications happen
		 * on the relations.
		 */</comment>
		<expr_stmt><expr><call><name>CascadeOperationForFkeyConnectedRelations</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>, <argument><expr><name>cascadeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We converted every foreign key connected table in our subgraph
		 * including itself to a citus local table, so return here.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relationList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>relationList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>relationList</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>CascadeOperationType</name></type> <name>cascadeType</name> <init>=
				<expr><call><name>GetCascadeTypeForCitusLocalTables</name><argument_list>(<argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CascadeOperationForRelationIdList</name><argument_list>(<argument><expr><name>relationList</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
											  <argument><expr><name>cascadeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>tableAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>tableAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure that the sequences used in column defaults of the table
	 * have proper types
	 */</comment>
	<expr_stmt><expr><call><name>EnsureRelationHasCompatibleSequenceTypes</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure dependencies exist as we will create shell table on the other nodes
	 * in the MX case.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>tableAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure that existing reference tables have been replicated to all
	 * the nodes such that we can create foreign keys and joins work
	 * immediately after creation.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureReferenceTablesExistOnAllNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shellTableDDLEvents</name> <init>= <expr><call><name>GetShellTableDDLEventsForCitusLocalTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableViewCreationCommands</name> <init>= <expr><call><name>GetViewCreationCommandsOfTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationSchemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* below we convert relation with relationId to the shard relation */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>ConvertLocalTableToShard</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * As we retrieved the DDL commands necessary to create the shell table
	 * from scratch, below we simply recreate the shell table executing them
	 * via process utility.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommandList</name><argument_list>(<argument><expr><name>shellTableDDLEvents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Execute the view creation commands with the shell table.
	 * Views will be distributed via FinalizeCitusLocalTableCreation below.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommandListInTableTypeConversionViaSPI</name><argument_list>(<argument><expr><name>tableViewCreationCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set shellRelationId as the relation with relationId now points
	 * to the shard relation.
	 */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>shardRelationId</name> <init>= <expr><name>relationId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>shellRelationId</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>relationSchemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* assert that we created the shell table properly in the same schema */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>shellRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Move sequence ownerships from shard table to shell table and also drop
	 * DEFAULT expressions based on sequences from shard relation as we should
	 * evaluate such columns in shell table when needed.
	 */</comment>
	<expr_stmt><expr><call><name>DropNextValExprsAndMoveOwnedSeqOwnerships</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>,
											  <argument><expr><name>shellRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>InsertMetadataForCitusLocalTable</name><argument_list>(<argument><expr><name>shellRelationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FinalizeCitusLocalTableCreation</name><argument_list>(<argument><expr><name>shellRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateCitusLocalTablePartitionOf generates and executes the necessary commands
 * to create a table as partition of a partitioned Citus Local Table.
 * The conversion is done by CreateCitusLocalTable.
 */</comment>
<function><type><name>void</name></type>
<name>CreateCitusLocalTablePartitionOf</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStatement</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>createStatement</name><operator>-&gt;</operator><name>partspec</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Since partspec represents "PARTITION BY" clause, being different than
		 * NULL means that given CreateStmt attempts to create a parent table
		 * at the same time. That means multi-level partitioning within this
		 * function's context. We don't support this currently.
		 */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distributing multi-level partitioned tables "</literal>
							   <literal type="string">"is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Relation \"%s\" is partitioned table itself "</literal>
								  <literal type="string">"and it is also partition of relation \"%s\"."</literal></expr></argument>,
								  <argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since the shell table for the partition is not created yet on MX workers,
	 * we should disable DDL propagation before the DETACH command, to avoid
	 * getting an error on the worker.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>detachCommands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
									  <argument><expr><call><name>GenerateDetachPartitionCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attachCommand</name> <init>= <expr><call><name>GenerateAlterTableAttachPartitionCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommandList</name><argument_list>(<argument><expr><name>detachCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fKeyFlags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_ALL_TABLE_TYPES</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When cascadeViaForeignKeys is false, CreateCitusLocalTable doesn't expect
	 * any foreign keys on given relation. Note that we don't want to pass
	 * cascadeViaForeignKeys to be true here since we don't already allow non-inherited
	 * foreign keys on child relations, and for the inherited ones, we should have already
	 * cascaded to the other relations when creating a citus local table from parent.
	 *
	 * For this reason, we drop inherited foreign keys here, they'll anyway get created
	 * again with the attach command
	 */</comment>
	<expr_stmt><expr><call><name>DropRelationForeignKeys</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>fKeyFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get the autoconverted field from the parent */</comment>
	<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>cascade</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>autoConverted</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>autoConverted</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CreateCitusLocalTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>cascade</name></expr></argument>, <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommand</name><argument_list>(<argument><expr><name>attachCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfAddingPartitionTableToMetadata errors out if we try to create the
 * citus local table from a partition table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfAddingPartitionTableToMetadata</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We do not allow converting only partitions into Citus Local Tables.
		 * Users should call the UDF citus_add_local_table_to_metadata with the
		 * parent table; then the whole partitioned table will be converted.
		 */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add local table %s to metadata since "</literal>
							   <literal type="string">"it is a partition of %s. Instead, add the parent "</literal>
							   <literal type="string">"table %s to metadata."</literal></expr></argument>,
							   <argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>parentRelationName</name></expr></argument>,
							   <argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedCreateCitusLocalTable errors out if we cannot create the
 * citus local table from the relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedCreateCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add local table to metadata, relation does "</literal>
							   <literal type="string">"not exist"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ErrorIfTableIsACatalogTable</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfCoordinatorNotAddedAsWorkerNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorIfUnsupportedCitusLocalTableKind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableNotDistributed</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorIfUnsupportedCitusLocalColumnDefinition</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ErrorIfRelationHasUnsupportedTrigger</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When creating other citus table types, we don't need to check that case as
	 * EnsureTableNotDistributed already errors out if the given relation implies
	 * a citus table. However, as we don't mark the relation as citus table, i.e we
	 * do not use the relation with relationId as the shell relation, parallel
	 * citus_add_local_table_to_metadata executions would not error out for that relation.
	 * Hence we need to error out for shard relations too.
	 */</comment>
	<expr_stmt><expr><call><name>ErrorIfRelationIsAKnownShard</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we do not support policies in citus community */</comment>
	<expr_stmt><expr><call><name>ErrorIfUnsupportedPolicy</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedCitusLocalTableKind errors out if the relation kind of
 * relation with relationId is not supported for citus local table creation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedCitusLocalTableKind</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsChildTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsParentTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add local table \"%s\" to metadata, local tables "</literal>
							   <literal type="string">"added to metadata cannot be involved in inheritance "</literal>
							   <literal type="string">"relationships"</literal></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>relationKind</name> <init>= <expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>relationKind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator> <name>relationKind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		  <name>relationKind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add local table \"%s\" to metadata, only regular "</literal>
							   <literal type="string">"tables, partitioned tables and foreign tables"</literal>
							   <literal type="string">" can be added to citus metadata "</literal></expr></argument>,
							   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_rel_persistence</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Currently, we use citus local tables only to support foreign keys
		 * between local tables and reference tables. Citus already doesn't
		 * support creating reference tables from temp tables.
		 * So now we are creating a citus local table from a temp table that
		 * has a foreign key from/to a reference table with persistent storage.
		 * In that case, we want to give the same error as postgres would do.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraints on temporary tables may reference only "</literal>
							   <literal type="string">"temporary tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedCitusLocalColumnDefinition errors out if given relation
 * has unsupported column definition for citus local table creation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedCitusLocalColumnDefinition</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>relationDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>RelationUsesIdentityColumns</name><argument_list>(<argument><expr><name>relationDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * pg_get_tableschemadef_string doesn't know how to deparse identity
		 * columns so we cannot reflect those columns when creating shell
		 * relation. For this reason, error out here.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add %s to citus metadata since table "</literal>
							   <literal type="string">"has identity column"</literal></expr></argument>,
							   <argument><expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Drop the identity columns and re-try the command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * NoticeIfAutoConvertingLocalTables logs a NOTICE message to inform the user that we are
 * automatically adding local tables to metadata. The user should know that this table
 * will be undistributed automatically, if it gets disconnected from reference table(s).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NoticeIfAutoConvertingLocalTables</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>autoConverted</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>autoConverted</name> <operator>&amp;&amp;</operator> <call><name>ShouldEnableLocalReferenceForeignKeys</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * When foreign keys between reference tables and postgres tables are
		 * enabled, we automatically undistribute citus local tables that are
		 * not chained with any reference tables back to postgres tables.
		 * So give a warning to user for that.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"local tables that are added to metadata automatically "</literal>
								<literal type="string">"by citus, but not chained with reference tables via "</literal>
								<literal type="string">"foreign keys might be automatically converted back to "</literal>
								<literal type="string">"postgres tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Executing citus_add_local_table_to_metadata($$%s$$) "</literal>
								 <literal type="string">"prevents this for the given relation, and all of the "</literal>
								 <literal type="string">"connected relations"</literal></expr></argument>, <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetCascadeTypeForCitusLocalTables returns CASCADE_AUTO_ADD_LOCAL_TABLE_TO_METADATA
 * if autoConverted is true. Returns CASCADE_USER_ADD_LOCAL_TABLE_TO_METADATA otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>CascadeOperationType</name></type>
<name>GetCascadeTypeForCitusLocalTables</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>autoConverted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>autoConverted</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>CASCADE_AUTO_ADD_LOCAL_TABLE_TO_METADATA</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>CASCADE_USER_ADD_LOCAL_TABLE_TO_METADATA</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateAutoConvertedForConnectedRelations updates the autoConverted field on
 * pg_dist_partition for the foreign key connected relations of the given relations.
 * Sets it to given autoConverted value for all of the connected relations.
 * We don't need to update partition relations separately, since the foreign key
 * graph already includes them, as they have the same (inherited) fkeys as their parents.
 */</comment>
<function><type><name>void</name></type>
<name>UpdateAutoConvertedForConnectedRelations</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>autoConverted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>InvalidateForeignKeyGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relid</argument>, <argument>relationIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>connectedRelations</name> <init>= <expr><call><name>GetForeignKeyConnectedRelationIdList</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>list_concat_unique_oid</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>connectedRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>CompareOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach_oid</name><argument_list>(<argument>relid</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UpdatePgDistPartitionAutoConverted</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetShellTableDDLEventsForCitusLocalTable returns a list of DDL commands
 * to create the shell table from scratch.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetShellTableDDLEventsForCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * As we don't allow foreign keys with other tables initially, below we
	 * only pick self-referencing foreign keys.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignConstraintCommands</name> <init>=
		<expr><call><name>GetReferencingForeignConstaintCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Include DEFAULT clauses for columns getting their default values from
	 * a sequence.
	 */</comment>
	<decl_stmt><decl><type><name>IncludeSequenceDefaults</name></type> <name>includeSequenceDefaults</name> <init>= <expr><name>NEXTVAL_SEQUENCE_DEFAULTS</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>creatingShellTableOnRemoteNode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableDDLCommands</name> <init>= <expr><call><name>GetFullTableCreationCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>,
														  <argument><expr><name>includeSequenceDefaults</name></expr></argument>,
														  <argument><expr><name>creatingShellTableOnRemoteNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>shellTableDDLEvents</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>tableDDLCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>tableDDLCommand</argument>, <argument>tableDDLCommands</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>tableDDLCommand</name></expr></argument>, <argument><expr><name>TableDDLCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>shellTableDDLEvents</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>shellTableDDLEvents</name></expr></argument>,
									  <argument><expr><call><name>GetTableDDLCommand</name><argument_list>(<argument><expr><name>tableDDLCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>shellTableDDLEvents</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>shellTableDDLEvents</name></expr></argument>, <argument><expr><name>foreignConstraintCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shellTableDDLEvents</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConvertLocalTableToShard first acquires a shardId and then converts the
 * given relation with relationId to the shard relation with shardId. That
 * means, this function suffixes shardId to:
 *  - relation name,
 *  - all the objects "defined on" the relation.
 * After converting the given relation, returns the acquired shardId.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>ConvertLocalTableToShard</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>shardId</name> <init>= <expr><call><name>GetNextShardId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>RenameRelationToShardRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RenameShardRelationConstraints</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RenameShardRelationIndexes</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RenameShardRelationStatistics</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We do not create truncate triggers on shard relation. This is
	 * because truncate triggers are fired by utility hook and we would
	 * need to disable them to prevent executing them twice if we don't
	 * drop the trigger on shard relation.
	 */</comment>
	<expr_stmt><expr><call><name>DropRelationTruncateTriggers</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* drop views that depend on the shard table */</comment>
	<expr_stmt><expr><call><name>DropViewsOnTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We create INSERT|DELETE|UPDATE triggers on shard relation too.
	 * This is because citus prevents postgres executor to fire those
	 * triggers. So, here we suffix such triggers on shard relation
	 * with shardId.
	 */</comment>
	<expr_stmt><expr><call><name>RenameShardRelationNonTruncateTriggers</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shardId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RenameRelationToShardRelation appends given shardId to the end of the name
 * of relation with shellRelationId.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RenameRelationToShardRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shellRelationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedShellRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>shellRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shellRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>shellRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardRelationName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>shellRelationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardRelationName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedShardRelationName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>shardRelationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>renameCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>renameCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s RENAME TO %s;"</literal></expr></argument>,
					 <argument><expr><name>qualifiedShellRelationName</name></expr></argument>, <argument><expr><name>quotedShardRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommand</name><argument_list>(<argument><expr><name><name>renameCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RenameShardRelationConstraints appends given shardId to the end of the name
 * of constraints "defined on" the relation with shardRelationId. This function
 * utilizes GetConstraintNameList to pick the constraints to be renamed,
 * see more details in function's comment.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RenameShardRelationConstraints</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>constraintNameList</name> <init>= <expr><call><name>GetConstraintNameList</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>constraintName</argument>, <argument>constraintNameList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name> <init>=
			<expr><call><name>GetRenameShardConstraintCommand</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>, <argument><expr><name>constraintName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommand</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetConstraintNameList returns a list of constraint names "defined on" the
 * relation with relationId. Those constraints can be:
 *  - "check" constraints or,
 *  - "primary key" constraints or,
 *  - "unique" constraints or,
 *  - "trigger" constraints or,
 *  - "exclusion" constraints or,
 *  - "foreign key" constraints in which the relation is the "referencing"
 *     relation (including the self-referencing foreign keys).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetConstraintNameList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>constraintNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgConstraint</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>useIndex</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>,
													<argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>,
													<argument><expr><name>useIndex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>,
													<argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>constraintForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>constraintNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>constraintNameList</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgConstraint</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>constraintNameList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRenameShardConstraintCommand returns DDL command to append given
 * shardId to the constrant with constraintName on the relation with
 * relationId.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetRenameShardConstraintCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardConstraintName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardConstraintName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedShardConstraintName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>shardConstraintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedConstraintName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>renameCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>renameCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s RENAME CONSTRAINT %s TO %s;"</literal></expr></argument>,
					 <argument><expr><name>qualifiedRelationName</name></expr></argument>, <argument><expr><name>quotedConstraintName</name></expr></argument>,
					 <argument><expr><name>quotedShardConstraintName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>renameCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RenameShardRelationIndexes appends given shardId to the end of the names
 * of shard relation indexes except the ones that are already renamed via
 * RenameShardRelationConstraints. This function utilizes
 * GetExplicitIndexOidList to pick the indexes to be renamed, see more
 * details in function's comment.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RenameShardRelationIndexes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexOidList</name> <init>= <expr><call><name>GetExplicitIndexOidList</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>indexOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>indexOid</argument>, <argument>indexOidList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name> <init>= <expr><call><name>GetRenameShardIndexCommand</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommand</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetRenameShardIndexCommand returns DDL command to append given shardId to
 * the index with indexName.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetRenameShardIndexCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>indexName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardIndexName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>indexName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardIndexName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedShardIndexName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>shardIndexName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedIndexName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>renameCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>renameCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER INDEX %s RENAME TO %s;"</literal></expr></argument>,
					 <argument><expr><name>quotedIndexName</name></expr></argument>, <argument><expr><name>quotedShardIndexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>renameCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RenameShardRelationStatistics appends given shardId to the end of the names
 * of shard relation statistics. This function utilizes GetExplicitStatsNameList
 * to pick the statistics to be renamed, see more details in function's comment.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RenameShardRelationStatistics</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>shardRelation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>shardRelation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>statsOidList</name> <init>= <expr><call><name>RelationGetStatExtList</name><argument_list>(<argument><expr><name>shardRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>shardRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>statsCommandList</name> <init>= <expr><call><name>GetRenameStatsCommandList</name><argument_list>(<argument><expr><name>statsOidList</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>statsCommandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommand</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetRenameShardStatsCommand returns DDL command to append given shardId to
 * the statistics with statName.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetRenameShardStatsCommand</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>statSchema</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>statsName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>statsNameWithShardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedStatsNameWithShardId</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>statsNameWithShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedStatsName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>statSchema</name></expr></argument>, <argument><expr><name>statsName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>renameCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>renameCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER STATISTICS %s RENAME TO %s;"</literal></expr></argument>,
					 <argument><expr><name>qualifiedStatsName</name></expr></argument>, <argument><expr><name>quotedStatsNameWithShardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>renameCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RenameShardRelationNonTruncateTriggers appends given shardId to the end of
 * the names of shard relation INSERT/DELETE/UPDATE triggers that are explicitly
 * created.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RenameShardRelationNonTruncateTriggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggerIdList</name> <init>= <expr><call><name>GetExplicitTriggerIdList</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>triggerId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>triggerId</argument>, <argument>triggerIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>triggerTuple</name> <init>= <expr><call><name>GetTriggerTupleById</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>triggerForm</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name><name>triggerForm</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>triggerForm</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>commandString</name> <init>=
				<expr><call><name>GetRenameShardTriggerCommand</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>, <argument><expr><name>triggerName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommand</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetRenameShardTriggerCommand returns DDL command to append given shardId to
 * the trigger with triggerName.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetRenameShardTriggerCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>shardRelationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedShardRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>shardRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shardTriggerName</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>triggerName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shardTriggerName</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedShardTriggerName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>shardTriggerName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedTriggerName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>triggerName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>renameCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>renameCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER TRIGGER %s ON %s RENAME TO %s;"</literal></expr></argument>,
					 <argument><expr><name>quotedTriggerName</name></expr></argument>, <argument><expr><name>qualifiedShardRelationName</name></expr></argument>,
					 <argument><expr><name>quotedShardTriggerName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>renameCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropRelationTruncateTriggers drops TRUNCATE triggers that are explicitly
 * created on relation with relationId.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropRelationTruncateTriggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>triggerIdList</name> <init>= <expr><call><name>GetExplicitTriggerIdList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>triggerId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>triggerId</argument>, <argument>triggerIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>triggerTuple</name> <init>= <expr><call><name>GetTriggerTupleById</name><argument_list>(<argument><expr><name>triggerId</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>triggerForm</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_TRUNCATE</name><argument_list>(<argument><expr><name><name>triggerForm</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>triggerForm</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>commandString</name> <init>= <expr><call><name>GetDropTriggerCommand</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>triggerName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommand</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>triggerTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetDropTriggerCommand returns DDL command to drop the trigger with triggerName
 * on relationId.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetDropTriggerCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>triggerName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedTriggerName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>triggerName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In postgres, the only possible object type that may depend on a trigger
	 * is the "constraint" object implied by the trigger itself if it is a
	 * constraint trigger, and it would be an internal dependency so it could
	 * be dropped without using CASCADE. Other than this, it is also possible
	 * to define dependencies on trigger via recordDependencyOn api by other
	 * extensions. We don't handle those kind of dependencies, we just drop
	 * them with CASCADE.
	 */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>dropCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dropCommand</name></expr></argument>, <argument><expr><literal type="string">"DROP TRIGGER %s ON %s CASCADE;"</literal></expr></argument>,
					 <argument><expr><name>quotedTriggerName</name></expr></argument>, <argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>dropCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropViewsOnTable drops the views that depend on the given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropViewsOnTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>views</name> <init>= <expr><call><name>GetDependingViews</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * GetDependingViews returns views in the dependency order. We should drop views
	 * in the reversed order since dropping views can cascade to other views below.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>reverseOrderedViews</name> <init>= <expr><call><name>ReversedOidList</name><argument_list>(<argument><expr><name>views</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>viewId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>viewId</argument>, <argument>reverseOrderedViews</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>viewId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>viewId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedViewName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>viewName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>dropCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dropCommand</name></expr></argument>, <argument><expr><literal type="string">"DROP %sVIEW IF EXISTS %s"</literal></expr></argument>,
						 <argument><expr><ternary><condition><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>viewId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr> ?</condition><then> <expr><literal type="string">"MATERIALIZED "</literal></expr> </then><else>:
						 <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><name>qualifiedViewName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommand</name><argument_list>(<argument><expr><name><name>dropCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ReversedOidList takes a list of oids and returns the reverse ordered version of it.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ReversedOidList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>oidList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>reversed</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>oid</argument>, <argument>oidList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>reversed</name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>reversed</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetExplicitIndexOidList returns a list of index oids defined "explicitly"
 * on the relation with relationId by the "CREATE INDEX" commands. That means,
 * all the constraints defined on the relation except:
 *  - primary indexes,
 *  - unique indexes and
 *  - exclusion indexes
 * that are actually applied by the related constraints.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetExplicitIndexOidList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* flags are not applicable for AppendExplicitIndexIdsToList */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>ExecuteFunctionOnEachTableIndex</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AppendExplicitIndexIdsToList</name></expr></argument>,
										   <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AppendExplicitIndexIdsToList adds the given index oid if it is
 * explicitly created on its relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendExplicitIndexIdsToList</name><parameter_list>(<parameter><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>explicitIndexIdList</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexImpliedByAConstraint</name><argument_list>(<argument><expr><name>indexForm</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>explicitIndexIdList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>explicitIndexIdList</name></expr></argument>, <argument><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indexrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetRenameStatsCommandList returns a list of "ALTER STATISTICS ...
 * RENAME TO ..._shardId" commands for given statistics oid list.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRenameStatsCommandList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>statsOidList</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>statsCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>statsOid</name></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>statsOid</argument>, <argument>statsOidList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>statsOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"No stats object found with id: %u"</literal></expr></argument>, <argument><expr><name>statsOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Form_pg_statistic_ext</name></type> <name>statisticsForm</name> <init>= <expr><operator>(</operator><name>Form_pg_statistic_ext</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>statsName</name> <init>= <expr><name><name>statisticsForm</name><operator>-&gt;</operator><name>stxname</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>statsSchemaOid</name> <init>= <expr><name><name>statisticsForm</name><operator>-&gt;</operator><name>stxnamespace</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>statsSchema</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>statsSchemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>statsNameWithShardId</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>statsName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>statsNameWithShardId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>renameShardStatsCommand</name> <init>= <expr><call><name>GetRenameShardStatsCommand</name><argument_list>(<argument><expr><name>statsSchema</name></expr></argument>, <argument><expr><name>statsName</name></expr></argument>,
																   <argument><expr><name>statsNameWithShardId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>statsCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>statsCommandList</name></expr></argument>, <argument><expr><name>renameShardStatsCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>statsCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropNextValExprsAndMoveOwnedSeqOwnerships drops default column definitions
 * that are based on sequences for relation with sourceRelationId.
 *
 * Also, for each such column that owns a sequence, it grants ownership to the
 * same named column of the relation with targetRelationId.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropNextValExprsAndMoveOwnedSeqOwnerships</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceRelationId</name></decl></parameter>,
										  <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ownedSequenceIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExtractDefaultColumnsAndOwnedSequences</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>columnNameList</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>ownedSequenceIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>ownedSequenceId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>forboth_ptr_oid</name><argument_list>(<argument>columnName</argument>, <argument>columnNameList</argument>, <argument>ownedSequenceId</argument>, <argument>ownedSequenceIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * We drop nextval() expressions because Citus currently evaluates
		 * nextval() on the shell table, not on the shards. Hence, there is
		 * no reason for keeping nextval(). Also, distributed/reference table
		 * shards do not have - so be consistent with those.
		 *
		 * Note that we keep other kind of DEFAULT expressions on shards
		 * because we still want to be able to evaluate DEFAULT expressions
		 * that are not based on sequences on shards, e.g., for foreign key
		 * - SET DEFAULT actions.
		 */</comment>
		<decl_stmt><decl><type><name>AttrNumber</name></type> <name>columnAttrNumber</name> <init>= <expr><call><name>get_attnum</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ColumnDefaultsToNextVal</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>columnAttrNumber</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DropDefaultColumnDefinition</name><argument_list>(<argument><expr><name>sourceRelationId</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Column might own a sequence without having a nextval() expr on it
		 * --e.g., due to ALTER SEQUENCE OWNED BY .. --, so check if that is
		 * the case even if the column doesn't have a DEFAULT.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ownedSequenceId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TransferSequenceOwnership</name><argument_list>(<argument><expr><name>ownedSequenceId</name></expr></argument>, <argument><expr><name>targetRelationId</name></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * DropDefaultColumnDefinition drops the DEFAULT definiton of the column with
 * columnName of the relation with relationId via process utility.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropDefaultColumnDefinition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>columnName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedColumnName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>sequenceDropCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sequenceDropCommand</name></expr></argument>,
					 <argument><expr><literal type="string">"ALTER TABLE %s ALTER COLUMN %s DROP DEFAULT"</literal></expr></argument>,
					 <argument><expr><name>qualifiedRelationName</name></expr></argument>, <argument><expr><name>quotedColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to disable/enable ddl propagation for this command, to prevent
	 * sending unnecessary ALTER COLUMN commands for partitions, to MX workers.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommandList</name><argument_list>(<argument><expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
											   <argument><expr><name><name>sequenceDropCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
											   <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TransferSequenceOwnership grants ownership of the sequence with sequenceId
 * to the column with targetColumnName of relation with targetRelationId via
 * process utility. Note that this function assumes that the target relation
 * has a column with targetColumnName which can default to the given sequence.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TransferSequenceOwnership</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sequenceId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetRelationId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetColumnName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedSequenceName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>sequenceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedTargetRelationName</name> <init>=
		<expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>targetRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedTargetColumnName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>targetColumnName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>sequenceOwnershipCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sequenceOwnershipCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER SEQUENCE %s OWNED BY %s.%s"</literal></expr></argument>,
					 <argument><expr><name>qualifiedSequenceName</name></expr></argument>, <argument><expr><name>qualifiedTargetRelationName</name></expr></argument>,
					 <argument><expr><name>quotedTargetColumnName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to disable/enable ddl propagation for this command, to prevent
	 * sending unnecessary ALTER SEQUENCE commands for partitions, to MX workers.
	 * Especially for partitioned tables, where the same sequence is used for
	 * all partitions, this might cause errors.
	 */</comment>
	<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommandList</name><argument_list>(<argument><expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
											   <argument><expr><name><name>sequenceOwnershipCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
											   <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InsertMetadataForCitusLocalTable inserts necessary metadata for the citus
 * local table to the following metadata tables:
 * pg_dist_partition, pg_dist_shard &amp; pg_dist_placement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InsertMetadataForCitusLocalTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>citusLocalTableId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>shardId</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>autoConverted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>shardId</name> <operator>!=</operator> <name>INVALID_SHARD_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>distributionMethod</name> <init>= <expr><name>DISTRIBUTE_BY_NONE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name>replicationModel</name> <init>= <expr><name>REPLICATION_MODEL_STREAMING</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>colocationId</name> <init>= <expr><name>INVALID_COLOCATION_ID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InsertIntoPgDistPartition</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>, <argument><expr><name>distributionMethod</name></expr></argument>,
							  <argument><expr><name>distributionColumn</name></expr></argument>, <argument><expr><name>colocationId</name></expr></argument>,
							  <argument><expr><name>replicationModel</name></expr></argument>, <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set shard storage type according to relation type */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>shardStorageType</name> <init>= <expr><call><name>ShardStorageType</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMinValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>shardMaxValue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InsertShardRow</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>shardStorageType</name></expr></argument>,
				   <argument><expr><name>shardMinValue</name></expr></argument>, <argument><expr><name>shardMaxValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>CoordinatorNodeIfAddedAsWorkerOrError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>replicationFactor</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>workerStartIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InsertShardPlacementRows</name><argument_list>(<argument><expr><name>citusLocalTableId</name></expr></argument>, <argument><expr><name>shardId</name></expr></argument>, <argument><expr><name>nodeList</name></expr></argument>,
							 <argument><expr><name>workerStartIndex</name></expr></argument>, <argument><expr><name>replicationFactor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FinalizeCitusLocalTableCreation completes creation of the citus local table
 * with relationId by performing operations that should be done after creating
 * the shard and inserting the metadata.
 * If the cluster has metadata workers, we ensure proper propagation of the
 * sequences dependent with the table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinalizeCitusLocalTableCreation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If it is a foreign table, then skip creating citus truncate trigger
	 * as foreign tables do not support truncate triggers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RegularTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CreateTruncateTrigger</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SyncCitusTableMetadata</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We've a custom way of foreign key graph invalidation,
	 * see InvalidateForeignKeyGraph().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TableReferenced</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TableReferencing</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InvalidateForeignKeyGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
