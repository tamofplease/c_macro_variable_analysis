<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/commands/type.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * type.c
 *    Commands for TYPE statements.
 *    The following types are supported in citus
 *     - Composite Types
 *     - Enum Types
 *     - Array Types
 *
 *    Types that are currently not supporter:
 *     - Range Types
 *     - Base Types
 *
 *    Range types have a dependency on functions. We can only support Range
 *    types after we have function distribution sorted.
 *
 *    Base types are more complex and often involve c code from extensions.
 *    These types should be created by creating the extension on all the
 *    workers as well. Therefore types created during the creation of an
 *    extension are not propagated to the worker nodes.
 *
 *    Types will be created on the workers during the following situations:
 *     - on type creation (except if called in a transaction)
 *       By not distributing types directly when in a transaction allows
 *       the type to be used in a newly created table that will be
 *       distributed in the same transaction. In that case the type will be
 *       created just-in-time to allow citus' parallelism to work.
 *     - just-in-time
 *       When the type is not already distributed but used in an object
 *       that will distribute now. This allows distributed tables to use
 *       types that have not yet been propagated, either due to the
 *       transaction case abvove, or due to a type predating the citus
 *       extension.
 *     - node activation
 *       Together with all objects that are marked as distributed in citus
 *       types will be created during the activation of a new node to allow
 *       reference tables to use this type.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/remote_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_create_or_replace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AlterEnumIsRename</name><parameter_list>(<parameter><type><name>stmt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(stmt-&gt;oldVal != NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AlterEnumIsAddValue</name><parameter_list>(<parameter><type><name>stmt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(stmt-&gt;oldVal == NULL)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALTER_TYPE_OWNER_COMMAND</name></cpp:macro> <cpp:value>"ALTER TYPE %s OWNER TO %s;"</cpp:value></cpp:define>


<comment type="block">/* guc to turn of the automatic type distribution */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableCreateTypePropagation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* forward declaration for helper functions*/</comment>
<function_decl><type><specifier>static</specifier> <name>TypeName</name> <modifier>*</modifier></type> <name>MakeTypeNameFromRangeVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>GetTypeOwner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>LookupNonAssociatedArrayTypeNameOid</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
											   <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* recreate functions */</comment>
<function_decl><type><specifier>static</specifier> <name>CompositeTypeStmt</name> <modifier>*</modifier></type> <name>RecreateCompositeTypeStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>CompositeTypeColumnDefList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CreateEnumStmt</name> <modifier>*</modifier></type> <name>RecreateEnumStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>EnumValsList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * PreprocessRenameTypeAttributeStmt is called for changes of attribute names for composite
 * types. Planning is called before the statement is applied locally.
 *
 * For distributed types we apply the attribute renames directly on all the workers to
 * keep the type in sync across the cluster.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessRenameTypeAttributeStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
								  <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_ATTRIBUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relationType</name></name> <operator>==</operator> <name>OBJECT_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>typeAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>typeAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateAnyObject</name><argument_list>(<argument><expr><name>typeAddresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>QualifyTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>EnsureSequentialMode</name><argument_list>(<argument><expr><name>OBJECT_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>sql</name></expr></argument>,
								<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateTypeStmtByObjectAddress returns a parsetree for the CREATE TYPE statement to
 * recreate the type by its object address.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>CreateTypeStmtByObjectAddress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name>TypeRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TYPTYPE_ENUM</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>RecreateEnumStmt</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>TYPTYPE_COMPOSITE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>RecreateCompositeTypeStmt</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<case>case <expr><name>TYPTYPE_DOMAIN</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>RecreateDomainStmt</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported type to generate create statement for"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"only enum and composite types can be recreated"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * RecreateCompositeTypeStmt is called for composite types to create its parsetree for the
 * CREATE TYPE statement that would recreate the composite type.
 */</comment>
<function><type><specifier>static</specifier> <name>CompositeTypeStmt</name> <modifier>*</modifier></type>
<name>RecreateCompositeTypeStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CompositeTypeStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CompositeTypeStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name> <init>= <expr><call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>typevar</name></name> <operator>=</operator> <call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>coldeflist</name></name> <operator>=</operator> <call><name>CompositeTypeColumnDefList</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * attributeFormToColumnDef returns a ColumnDef * describing the field and its property
 * for a pg_attribute entry.
 */</comment>
<function><type><specifier>static</specifier> <name>ColumnDef</name> <modifier>*</modifier></type>
<name>attributeFormToColumnDef</name><parameter_list>(<parameter><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>makeColumnDef</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
						 <argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
						 <argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompositeTypeColumnDefList returns a list of ColumnDef *'s that make up all the fields
 * of the composite type.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>CompositeTypeColumnDefList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnDefs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>typeidTypeRelid</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>attributeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>attributeIndex</name> <operator>&lt;</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition>
		 <incr><expr><name>attributeIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>attributeIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip logically hidden attributes */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>columnDefs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>columnDefs</name></expr></argument>, <argument><expr><call><name>attributeFormToColumnDef</name><argument_list>(<argument><expr><name>attributeForm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>columnDefs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecreateEnumStmt returns a parsetree for a CREATE TYPE ... AS ENUM statement that would
 * recreate the given enum type.
 */</comment>
<function><type><specifier>static</specifier> <name>CreateEnumStmt</name> <modifier>*</modifier></type>
<name>RecreateEnumStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_ENUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CreateEnumStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateEnumStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>vals</name></name> <operator>=</operator> <call><name>EnumValsList</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnumValsList returns a list of String values containing the enum values for the given
 * enum type.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>EnumValsList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>enum_tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Scan pg_enum for the members of the target enum type. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_pg_enum_enumtypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>enum_rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>EnumRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>enum_scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>enum_rel</name></expr></argument>,
											   <argument><expr><name>EnumTypIdSortOrderIndexId</name></expr></argument>,
											   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* collect all value names in CREATE TYPE ... AS ENUM stmt */</comment>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>enum_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>enum_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_enum</name></type> <name>en</name> <init>= <expr><operator>(</operator><name>Form_pg_enum</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>enum_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>vals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vals</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>en</name><operator>-&gt;</operator><name>enumlabel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>enum_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>enum_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>vals</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompositeTypeStmtObjectAddress finds the ObjectAddress for the composite type described
 * by the CompositeTypeStmt. If missing_ok is false this function throws an error if the
 * type does not exist.
 *
 * Never returns NULL, but the objid in the address could be invalid if missing_ok was set
 * to true.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CompositeTypeStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CompositeTypeStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CompositeTypeStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>MakeTypeNameFromRangeVar</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typevar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><call><name>LookupNonAssociatedArrayTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateEnumStmtObjectAddress finds the ObjectAddress for the enum type described by the
 * CreateEnumStmt. If missing_ok is false this function throws an error if the type does
 * not exist.
 *
 * Never returns NULL, but the objid in the address could be invalid if missing_ok was set
 * to true.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CreateEnumStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateEnumStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateEnumStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><call><name>LookupNonAssociatedArrayTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTypeStmtObjectAddress finds the ObjectAddress for the type described by the ALTER
 * TYPE statement. If missing_ok is false this function throws an error if the type does
 * not exist.
 *
 * Never returns NULL, but the objid in the address could be invalid if missing_ok was set
 * to true.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterTypeStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AlterTableStmtObjType_compat</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBJECT_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>MakeTypeNameFromRangeVar</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><call><name>LookupTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterEnumStmtObjectAddress return the ObjectAddress of the enum type that is the
 * object of the AlterEnumStmt. Errors is missing_ok is false.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterEnumStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterEnumStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterEnumStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><call><name>LookupTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RenameTypeStmtObjectAddress returns the ObjectAddress of the type that is the object
 * of the RenameStmt. Errors if missing_ok is false.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RenameTypeStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><call><name>LookupTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTypeSchemaStmtObjectAddress returns the ObjectAddress of the type that is the
 * object of the AlterObjectSchemaStmt. Errors if missing_ok is false.
 *
 * This could be called both before or after it has been applied locally. It will look in
 * the old schema first, if the type cannot be found in that schema it will look in the
 * new schema. Errors if missing_ok is false and the type cannot be found in either of the
 * schemas.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterTypeSchemaStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_TYPE</name> <operator>||</operator> <name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_DOMAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * we hardcode missing_ok here during LookupTypeNameOid because if we can't find it it
	 * might have already been moved in this transaction.
	 */</comment>
	<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><call><name>LookupTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typeOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * couldn't find the type, might have already been moved to the new schema, we
		 * construct a new typename that uses the new schema to search in.
		 */</comment>

		<comment type="block">/* typename is the last in the list of names */</comment>
		<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>typeNameStr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_tail</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * we don't error here either, as the error would be not a good user facing
		 * error if the type didn't exist in the first place.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newNames</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typeNameStr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>newTypeName</name> <init>= <expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>newNames</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <call><name>LookupTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newTypeName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if the type is still invalid we couldn't find the type, error with the same
		 * message postgres would error with it missing_ok is false (not ok to miss)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name> <operator>&amp;&amp;</operator> <name>typeOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" does not exist"</literal></expr></argument>,
								   <argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RenameTypeAttributeStmtObjectAddress returns the ObjectAddress of the type that is the
 * object of the RenameStmt. Errors if missing_ok is false.
 *
 * The ObjectAddress is that of the type, not that of the attributed for which the name is
 * changed as Attributes are not distributed on their own but as a side effect of the
 * whole type distribution.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RenameTypeAttributeStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_ATTRIBUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relationType</name></name> <operator>==</operator> <name>OBJECT_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>MakeTypeNameFromRangeVar</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><call><name>LookupTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTypeOwnerObjectAddress returns the ObjectAddress of the type that is the object
 * of the AlterOwnerStmt. Errors if missing_ok is false.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterTypeOwnerObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterOwnerStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>typeName</name> <init>= <expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><call><name>LookupTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>TypeRelationId</name></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateTypeDDLCommandsIdempotent returns a list of DDL statements (const char *) to be
 * executed on a node to recreate the type addressed by the typeAddress.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CreateTypeDDLCommandsIdempotent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>typeAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>typeAddress</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name>TypeRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>type_is_array</name><argument_list>(<argument><expr><name><name>typeAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * array types cannot be created on their own, but could be a direct dependency of
		 * a table. In that case they are on the dependency graph and tried to be created.
		 *
		 * By returning an empty list we will not send any commands to create this type.
		 */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name> <init>= <expr><call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>typeAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name><name>typeAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Don't send any command if the type is a table's row type */</comment>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name> <operator>&amp;&amp;</operator>
		<call><name>get_rel_relkind</name><argument_list>(<argument><expr><name><name>typTup</name><operator>-&gt;</operator><name>typrelid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>CreateTypeStmtByObjectAddress</name><argument_list>(<argument><expr><name>typeAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* capture ddl command for recreation and wrap in create if not exists construct */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ddlCommand</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>ddlCommand</name> <operator>=</operator> <call><name>WrapCreateOrReplace</name><argument_list>(<argument><expr><name>ddlCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ddlCommands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommands</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ddlCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add owner ship change so the creation command can be run as a different user */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name> <init>= <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><call><name>GetTypeOwner</name><argument_list>(<argument><expr><name><name>typeAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ALTER_TYPE_OWNER_COMMAND</name></expr></argument>,
					 <argument><expr><call><name>getObjectIdentity_compat</name><argument_list>(<argument><expr><name>typeAddress</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ddlCommands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>ddlCommands</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ddlCommands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateBackupNameForTypeCollision generates a new type name for an existing type. The
 * name is generated in such a way that the new name doesn't overlap with an existing type
 * by adding a suffix with incrementing number after the new name.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GenerateBackupNameForTypeCollision</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name> <init>= <expr><call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><call><name>format_type_be_qualified</name><argument_list>(<argument><expr><name><name>address</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newName</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>suffix</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>baseName</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>baseLength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>baseName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>suffixLength</name> <init>= <expr><call><name>SafeSnprintf</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"(citus_backup_%d)"</literal></expr></argument>,
										<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* trim the base name at the end to leave space for the suffix and trailing \0 */</comment>
		<expr_stmt><expr><name>baseLength</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>baseLength</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <name>suffixLength</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* clear newName before copying the potentially trimmed baseName and suffix */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>newName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy_s</name><argument_list>(<argument><expr><name>newName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><name>baseName</name></expr></argument>, <argument><expr><name>baseLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy_s</name><argument_list>(<argument><expr><name>newName</name> <operator>+</operator> <name>baseLength</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <name>baseLength</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>,
				  <argument><expr><name>suffixLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <name>newName</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>newTypeName</name> <init>= <expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><call><name>MakeNameListFromRangeVar</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><call><name>LookupTypeNameOid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newTypeName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>typeOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>newName</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * GetTypeOwner
 *
 *		Given the type OID, find its owner
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>GetTypeOwner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MakeTypeNameFromRangeVar creates a TypeName based on a RangeVar.
 */</comment>
<function><type><specifier>static</specifier> <name>TypeName</name> <modifier>*</modifier></type>
<name>MakeTypeNameFromRangeVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupNonAssociatedArrayTypeNameOid returns the oid of the type with the given type name
 * that is not an array type that is associated to another user defined type.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>LookupNonAssociatedArrayTypeNameOid</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Type</name></type> <name>tup</name> <init>= <expr><call><name>LookupTypeName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>tup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typelem</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name> <operator>&amp;&amp;</operator> <name>typeOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"type \"%s\" that is not an array type associated with "</literal>
					<literal type="string">"another type does not exist"</literal></expr></argument>, <argument><expr><call><name>TypeNameToString</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>typeOid</name></expr>;</return>
</block_content>}</block></function>
</unit>
