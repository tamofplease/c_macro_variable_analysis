<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/commands/cascade_table_operation_for_connected_relations.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cascade_table_operation_for_connected_relations.c
 *   Routines to execute citus table functions (e.g undistribute_table,
 *   create_citus_local_table) by cascading to foreign key connected
 *   relations.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/foreign_key_relationship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureSequentialModeForCitusTableCascadeFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetPartitionRelationIds</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LockRelationsWithLockMode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfConvertingMultiLevelPartitionedTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropRelationIdListForeignKeys</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fKeyFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetRelationDropFkeyCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fKeyFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetDropFkeyCascadeCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>foreignKeyId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteCascadeOperationForRelationIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>,
													 <parameter><decl><type><name>CascadeOperationType</name></type>
													 <name>cascadeOperationType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecuteForeignKeyCreateCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name></type> <name>skip_validation</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * CascadeOperationForFkeyConnectedRelations is a wrapper function which calls
 * CascadeOperationForRelationIdList for the foreign key connected relations, for
 * the given relationId.
 */</comment>
<function><type><name>void</name></type>
<name>CascadeOperationForFkeyConnectedRelations</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>,
										  <parameter><decl><type><name>CascadeOperationType</name></type>
										  <name>cascadeOperationType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * As we will operate on foreign key connected relations, here we
	 * invalidate foreign key graph to be on the safe side.
	 */</comment>
	<expr_stmt><expr><call><name>InvalidateForeignKeyGraph</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fKeyConnectedRelationIdList</name> <init>= <expr><call><name>GetForeignKeyConnectedRelationIdList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* early exit if there are no connected relations */</comment>
	<if_stmt><if>if <condition>(<expr><name>fKeyConnectedRelationIdList</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CascadeOperationForRelationIdList</name><argument_list>(<argument><expr><name>fKeyConnectedRelationIdList</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>,
									  <argument><expr><name>cascadeOperationType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CascadeOperationForRelationIdList executes citus table function specified
 * by CascadeOperationType argument on each relation in the relationIdList;
 * Also see CascadeOperationType enum definition for supported
 * citus table functions.
 */</comment>
<function><type><name>void</name></type>
<name>CascadeOperationForRelationIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>,
								  <parameter><decl><type><name>CascadeOperationType</name></type>
								  <name>cascadeOperationType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LockRelationsWithLockMode</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cascadeOperationType</name> <operator>==</operator> <name>CASCADE_USER_ADD_LOCAL_TABLE_TO_METADATA</name> <operator>||</operator>
		<name>cascadeOperationType</name> <operator>==</operator> <name>CASCADE_AUTO_ADD_LOCAL_TABLE_TO_METADATA</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In CreateCitusLocalTable function, this check would never error out,
		 * since CreateCitusLocalTable gets called with partition relations, *after*
		 * they are detached.
		 * Instead, here, it would error out if the user tries to convert a multi-level
		 * partitioned table, since partitioned table conversions always go through here.
		 * Also, there can be a multi-level partitioned table, to be cascaded via foreign
		 * keys, and they are hard to detect in CreateCitusLocalTable.
		 * Therefore, we put this check here.
		 */</comment>
		<expr_stmt><expr><call><name>ErrorIfConvertingMultiLevelPartitionedTable</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Before removing any partition relations, we should error out here if any
	 * of connected relations is a partition table involved in a foreign key that
	 * is not inherited from its parent table.
	 * We should handle this case here as we remove partition relations in this
	 * function	before ExecuteCascadeOperationForRelationIdList.
	 */</comment>
	<expr_stmt><expr><call><name>ErrorIfAnyPartitionRelationInvolvedInNonInheritedFKey</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitonRelationList</name> <init>= <expr><call><name>GetPartitionRelationIds</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Here we generate detach/attach commands, if there are any partition tables
	 * in our "relations-to-cascade" list.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>detachPartitionCommands</name> <init>=
		<expr><call><name>GenerateDetachPartitionCommandRelationIdList</name><argument_list>(<argument><expr><name>partitonRelationList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attachPartitionCommands</name> <init>=
		<expr><call><name>GenerateAttachPartitionCommandRelationIdList</name><argument_list>(<argument><expr><name>partitonRelationList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Our foreign key subgraph can have distributed tables which might already
	 * be modified in current transaction. So switch to sequential execution
	 * before executing any ddl's to prevent erroring out later in this function.
	 */</comment>
	<expr_stmt><expr><call><name>EnsureSequentialModeForCitusTableCascadeFunction</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* store foreign key creation commands before dropping them */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fKeyCreationCommands</name> <init>=
		<expr><call><name>GetFKeyCreationCommandsForRelationIdList</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note that here we only drop referencing foreign keys for each relation.
	 * This is because referenced foreign keys are already captured as other
	 * relations' referencing foreign keys.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>fKeyFlags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_ALL_TABLE_TYPES</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>DropRelationIdListForeignKeys</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>fKeyFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommandList</name><argument_list>(<argument><expr><name>detachPartitionCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteCascadeOperationForRelationIdList</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>,
											 <argument><expr><name>cascadeOperationType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommandList</name><argument_list>(<argument><expr><name>attachPartitionCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now recreate foreign keys on tables */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>skip_validation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecuteForeignKeyCreateCommandList</name><argument_list>(<argument><expr><name>fKeyCreationCommands</name></expr></argument>, <argument><expr><name>skip_validation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetPartitionRelationIds returns a list of relation id's by picking
 * partition relation id's from given relationIdList.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetPartitionRelationIds</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionRelationIdList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>partitionRelationIdList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>partitionRelationIdList</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>partitionRelationIdList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LockRelationsWithLockMode sorts given relationIdList and then acquires
 * specified lockMode on those relations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LockRelationsWithLockMode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>relationIdList</name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>, <argument><expr><name>CompareOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfConvertingMultiLevelPartitionedTable iterates given relationIdList and checks
 * if there's a multi-level partitioned table involved or not. As we currently don't
 * support converting multi-level partitioned tables into Citus Local Tables,
 * this function errors out for such a case. We detect the multi-level partitioned
 * table if one of the relations is both partition and partitioned table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfConvertingMultiLevelPartitionedTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelId</name> <init>= <expr><call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentRelId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Citus does not support multi-level "</literal>
								   <literal type="string">"partitioned tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Relation \"%s\" is partitioned table itself so "</literal>
									  <literal type="string">"cannot be partition of relation \"%s\"."</literal></expr></argument>,
									  <argument><expr><name>relationName</name></expr></argument>, <argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfAnyPartitionRelationInvolvedInNonInheritedFKey searches given
 * relationIdList for a partition relation involved in a foreign key relationship
 * that is not inherited from its parent and errors out if such a partition
 * relation exists.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfAnyPartitionRelationInvolvedInNonInheritedFKey</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationInvolvedInAnyNonInheritedForeignKeys</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>partitionRelationQualifiedName</name> <init>=
			<expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cascade operation via foreign keys as "</literal>
							   <literal type="string">"partition table %s involved in a foreign key "</literal>
							   <literal type="string">"relationship that is not inherited from its "</literal>
							   <literal type="string">"parent table"</literal></expr></argument>, <argument><expr><name>partitionRelationQualifiedName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Remove non-inherited foreign keys from %s and "</literal>
								<literal type="string">"try operation again"</literal></expr></argument>, <argument><expr><name>partitionRelationQualifiedName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureSequentialModeForCitusTableCascadeFunction switches to sequential
 * execution mode if needed. If it's not possible, then errors out.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureSequentialModeForCitusTableCascadeFunction</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIdListHasReferenceTable</name><argument_list>(<argument><expr><name>relationIdList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We don't need to switch to sequential execution if there is no
		 * reference table in our foreign key subgraph.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot execute command because there was a parallel "</literal>
							   <literal type="string">"operation on a distributed table in transaction"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
								<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
								<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"switching to sequential query execution mode because the "</literal>
							<literal type="string">"operation cascades into distributed tables with foreign "</literal>
							<literal type="string">"keys to reference tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RelationIdListHasReferenceTable returns true if relationIdList has a relation
 * id that belongs to a reference table.
 */</comment>
<function><type><name>bool</name></type>
<name>RelationIdListHasReferenceTable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetFKeyCreationCommandsForRelationIdList returns a list of DDL commands to
 * create foreign keys for each relation in relationIdList.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetFKeyCreationCommandsForRelationIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fKeyCreationCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationFKeyCreationCommands</name> <init>=
			<expr><call><name>GetReferencingForeignConstaintCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>fKeyCreationCommands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>fKeyCreationCommands</name></expr></argument>,
										   <argument><expr><name>relationFKeyCreationCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>fKeyCreationCommands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropRelationIdListForeignKeys drops foreign keys for each relation in given
 * relation id list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropRelationIdListForeignKeys</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fKeyFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DropRelationForeignKeys</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>fKeyFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * DropRelationForeignKeys drops foreign keys where the relation with
 * relationId is the referencing relation.
 */</comment>
<function><type><name>void</name></type>
<name>DropRelationForeignKeys</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fKeyFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We undistribute citus local tables that are not chained with any reference
	 * tables via foreign keys at the end of the utility hook.
	 * Here we temporarily set the related GUC to off to disable the logic for
	 * internally executed DDL's that might invoke this mechanism unnecessarily.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>oldEnableLocalReferenceForeignKeys</name> <init>= <expr><name>EnableLocalReferenceForeignKeys</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetLocalEnableLocalReferenceForeignKeys</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dropFkeyCascadeCommandList</name> <init>= <expr><call><name>GetRelationDropFkeyCommands</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>fKeyFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommandList</name><argument_list>(<argument><expr><name>dropFkeyCascadeCommandList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetLocalEnableLocalReferenceForeignKeys</name><argument_list>(<argument><expr><name>oldEnableLocalReferenceForeignKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SetLocalEnableLocalReferenceForeignKeys is simply a C interface for setting
 * the following:
 *      SET LOCAL citus.enable_local_reference_table_foreign_keys = 'on'|'off';
 */</comment>
<function><type><name>void</name></type>
<name>SetLocalEnableLocalReferenceForeignKeys</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>stateStr</name> <init>= <expr><ternary><condition><expr><name>state</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"citus.enable_local_reference_table_foreign_keys"</literal></expr></argument>, <argument><expr><name>stateStr</name></expr></argument>,
					  <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
					  <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetRelationDropFkeyCommands returns a list of DDL commands to drop foreign
 * keys where the relation with relationId is the referencing relation.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetRelationDropFkeyCommands</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fKeyFlags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dropFkeyCascadeCommandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>relationFKeyIdList</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>fKeyFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>foreignKeyId</name></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>foreignKeyId</argument>, <argument>relationFKeyIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dropFkeyCascadeCommand</name> <init>= <expr><call><name>GetDropFkeyCascadeCommand</name><argument_list>(<argument><expr><name>foreignKeyId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>dropFkeyCascadeCommandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dropFkeyCascadeCommandList</name></expr></argument>,
											 <argument><expr><name>dropFkeyCascadeCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>dropFkeyCascadeCommandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDropFkeyCascadeCommand returns DDL command to drop foreign key with
 * foreignKeyId.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetDropFkeyCascadeCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>foreignKeyId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * As we need to execute ALTER TABLE DROP CONSTRAINT command on
	 * referencing relation, resolve it here.
	 */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>foreignKeyId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constraintForm</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name><name>constraintForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><call><name>get_constraint_name</name><argument_list>(<argument><expr><name>foreignKeyId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedConstraintName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>dropFkeyCascadeCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dropFkeyCascadeCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s DROP CONSTRAINT %s CASCADE;"</literal></expr></argument>,
					 <argument><expr><name>qualifiedRelationName</name></expr></argument>, <argument><expr><name>quotedConstraintName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>dropFkeyCascadeCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteCascadeOperationForRelationIdList executes citus table function
 * specified by CascadeOperationType argument for given relation id
 * list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteCascadeOperationForRelationIdList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIdList</name></decl></parameter>,
										 <parameter><decl><type><name>CascadeOperationType</name></type>
										 <name>cascadeOperationType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>relationId</argument>, <argument>relationIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * The reason behind skipping certain table types in below loop is
		 * that we support some sort of foreign keys between postgres tables
		 * and citus tables when enable_local_reference_table_foreign_keys is
		 * false or when coordinator is not added to metadata.
		 *
		 * Also, as caller already passed the relations that we should operate
		 * on, we don't cascade via foreign keys here.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>cascadeViaForeignKeys</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name>cascadeOperationType</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CASCADE_FKEY_UNDISTRIBUTE_TABLE</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TableConversionParameters</name></type> <name>params</name> <init>= <expr><block>{
						<expr><operator>.</operator><name>relationId</name> <operator>=</operator> <name>relationId</name></expr>,
						<expr><operator>.</operator><name>cascadeViaForeignKeys</name> <operator>=</operator> <name>cascadeViaForeignKeys</name></expr>
					}</block></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>UndistributeTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>CASCADE_USER_ADD_LOCAL_TABLE_TO_METADATA</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type> <name>autoConverted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>CreateCitusLocalTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>cascadeViaForeignKeys</name></expr></argument>,
										  <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>CASCADE_AUTO_ADD_LOCAL_TABLE_TO_METADATA</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type> <name>autoConverted</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>CreateCitusLocalTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>cascadeViaForeignKeys</name></expr></argument>,
										  <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>

			<default>default:</default>
			<block>{<block_content>
				<comment type="block">/*
				 * This is not expected as other create table functions don't have
				 * cascade option yet. To be on the safe side, error out here.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus table function could not be found"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteAndLogUtilityCommandListInTableTypeConversionViaSPI is a wrapper function
 * around ExecuteAndLogQueryViaSPI, that executes view creation commands
 * with the flag InTableTypeConversionFunctionCall set to true.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteAndLogUtilityCommandListInTableTypeConversionViaSPI</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>utilityCommandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>oldValue</name> <init>= <expr><name>InTableTypeConversionFunctionCall</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>InTableTypeConversionFunctionCall</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>savedMemoryContext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>utilityCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>utilityCommand</argument>, <argument>utilityCommandList</argument>)</argument_list></macro>
		<block>{<block_content>
			<comment type="block">/*
			 * CREATE MATERIALIZED VIEW commands need to be parsed/transformed,
			 * which SPI does for us.
			 */</comment>
			<expr_stmt><expr><call><name>ExecuteAndLogQueryViaSPI</name><argument_list>(<argument><expr><name>utilityCommand</name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>InTableTypeConversionFunctionCall</name> <operator>=</operator> <name>oldValue</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savedMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>errorData</name> <init>= <expr><call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>errorData</name><operator>-&gt;</operator><name>elevel</name></name> <operator>!=</operator> <name>ERROR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ThrowErrorData</name><argument_list>(<argument><expr><name>errorData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>InTableTypeConversionFunctionCall</name> <operator>=</operator> <name>oldValue</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteAndLogUtilityCommandList takes a list of utility commands and calls
 * ExecuteAndLogUtilityCommand function for each of them.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteAndLogUtilityCommandList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>utilityCommandList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>utilityCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>utilityCommand</argument>, <argument>utilityCommandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteAndLogUtilityCommand</name><argument_list>(<argument><expr><name>utilityCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteAndLogUtilityCommand takes a utility command and logs it in DEBUG4 log level.
 * Then, parses and executes it via CitusProcessUtility.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteAndLogUtilityCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"executing \"%s\""</literal></expr></argument>, <argument><expr><name>commandString</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteUtilityCommand</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteForeignKeyCreateCommandList takes a list of foreign key creation ddl commands
 * and calls ExecuteAndLogForeignKeyCreateCommand function for each of them.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteForeignKeyCreateCommandList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommandList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_validation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ddlCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>ddlCommand</argument>, <argument>ddlCommandList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteForeignKeyCreateCommand</name><argument_list>(<argument><expr><name>ddlCommand</name></expr></argument>, <argument><expr><name>skip_validation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteForeignKeyCreateCommand takes a foreign key creation command
 * and logs it in DEBUG4 log level.
 *
 * Then, parses, sets skip_validation flag to considering the input and
 * executes the command via CitusProcessUtility.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecuteForeignKeyCreateCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>commandString</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_validation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"executing foreign key create command \"%s\""</literal></expr></argument>,
							<argument><expr><name>commandString</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name> <init>= <expr><call><name>ParseTreeNode</name><argument_list>(<argument><expr><name>commandString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We might have thrown an error if IsA(parseTree, AlterTableStmt),
	 * but that doesn't seem to provide any benefits, so assertion is
	 * fine for this case.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>oldSkipConstraintsValidationValue</name> <init>= <expr><name>SkipConstraintValidation</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>skip_validation</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnableSkippingConstraintValidation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"skipping validation for foreign key create "</literal>
								<literal type="string">"command \"%s\""</literal></expr></argument>, <argument><expr><name>commandString</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ProcessUtilityParseTree</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>commandString</name></expr></argument>, <argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>SkipConstraintValidation</name> <operator>=</operator> <name>oldSkipConstraintsValidationValue</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
