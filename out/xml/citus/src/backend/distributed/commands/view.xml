<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/commands/view.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * view.c
 *    Commands for distributing CREATE OR REPLACE VIEW statements.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaddress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/errormessage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/namespace_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * GUC controls some restrictions for local objects. For example,
 * if it is disabled, a local view with no distributed relation dependency
 * will be created even if it has circular dependency and will not
 * log error or warning. Citus will normally restrict that behaviour for the
 * local views. e.g CREATE TABLE local_t (a int);
 *                  CREATE VIEW vv1 as SELECT * FROM local_t;
 *					CREATE OR REPLACE VIEW vv2 as SELECT * FROM vv1;
 *
 * When the GUC is disabled, citus also wont distribute the local
 * view which has no citus relation dependency to workers. Otherwise, it distributes
 * them by default. e.g create view v as select 1;
 */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>EnforceLocalObjectRestrictions</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FilterNameListForDistributedViews</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>viewNamesList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendQualifiedViewNameToCreateViewCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendViewDefinitionToCreateViewCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendAliasesToCreateViewCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>createViewCommand</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendOptionsToCreateViewCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>createViewCommand</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ViewHasDistributedRelationDependency</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewObjectAddress</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * ViewHasDistributedRelationDependency returns true if given view at address has
 * any distributed relation dependency.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ViewHasDistributedRelationDependency</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewObjectAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencies</name> <init>= <expr><call><name>GetAllDependenciesForObject</name><argument_list>(<argument><expr><name>viewObjectAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>dependency</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_ptr</name><argument_list>(<argument>dependency</argument>, <argument>dependencies</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dependency</name><operator>-&gt;</operator><name>classId</name></name> <operator>==</operator> <name>RelationRelationId</name> <operator>&amp;&amp;</operator> <call><name>IsAnyObjectDistributed</name><argument_list>(
				<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>dependency</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessViewStmt is called during the planning phase for CREATE OR REPLACE VIEW
 * before it is created on the local node internally.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessViewStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
				   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check creation against multi-statement transaction policy */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateCreateInCoordinatedTransction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessViewStmt actually creates the commmands we need to run on workers to
 * propagate views.
 *
 * If view depends on any undistributable object, Citus can not distribute it. In order to
 * not to prevent users from creating local views on the coordinator WARNING message will
 * be sent to the customer about the case instead of erroring out. If no worker nodes exist
 * at all, view will be created locally without any WARNING message.
 *
 * Besides creating the plan we also make sure all (new) dependencies of the view are
 * created on all nodes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessViewStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ViewStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ViewStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check creation against multi-statement transaction policy */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateCreateInCoordinatedTransction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>viewAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If the view has any unsupported dependency, create it locally */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ErrorOrWarnIfAnyObjectHasUnsupportedDependency</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it is disabled, a local view with no distributed relation dependency
	 * will be created even if it has circular dependency and will not
	 * log error or warning. Citus will normally restrict that behaviour for the
	 * local views. e.g CREATE TABLE local_t (a int);
	 *                  CREATE VIEW vv1 as SELECT * FROM local_t;
	 *					CREATE OR REPLACE VIEW vv2 as SELECT * FROM vv1;
	 *
	 * When the GUC is disabled, citus also wont distribute the local
	 * view which has no citus relation dependency to workers. Otherwise, it distributes
	 * them by default. e.g create view v as select 1;
	 *
	 * We disable local object restrictions during pg vanilla tests to not diverge
	 * from Postgres in terms of error messages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnforceLocalObjectRestrictions</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we asserted that we have only one address. */</comment>
		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ViewHasDistributedRelationDependency</name><argument_list>(<argument><expr><name>viewAddress</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The local view has no distributed relation dependency, so we can allow
			 * it to be created even if it has circular dependency.
			 */</comment>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We have already asserted that we have exactly 1 address in the addresses. */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><call><name>CreateViewDDLCommand</name><argument_list>(<argument><expr><name><name>viewAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We'd typically use NodeDDLTaskList() for generating node-level DDL commands,
	 * such as when creating a type. However, views are different in a sense that
	 * views do not depend on citus tables. Instead, they are `depending` on citus tables.
	 *
	 * When NodeDDLTaskList() used, it should be accompanied with sequential execution.
	 * Here, we do something equivalent to NodeDDLTaskList(), but using metadataSyncCommand
	 * field. This hack allows us to use the metadata connection
	 * (see `REQUIRE_METADATA_CONNECTION` flag). Meaning that, view creation is treated as
	 * a metadata operation.
	 *
	 * We do this mostly for performance reasons, because we cannot	afford to switch to
	 * sequential execution, for instance when we are altering or creating distributed
	 * tables -- which may require significant resources.
	 *
	 * The downside of using this hack is that if a view is re-used in the same transaction
	 * that creates the view on the workers, we might get errors such as the below which
	 * we consider a decent trade-off currently:
	 *
	 * BEGIN;
	 *      CREATE VIEW dist_view ..
	 *      CRETAE TABLE t2(id int, val dist_view);
	 *
	 *      -- shard creation fails on one of the connections
	 *      SELECT create_distributed_table('t2', 'id');
	 * ERROR: type "public.dist_view" does not exist
	 *
	 */</comment>
	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name> <operator>=</operator> <operator>*</operator><name>viewAddress</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>command</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ViewStmtObjectAddress returns the ObjectAddress for the subject of the
 * CREATE [OR REPLACE] VIEW statement.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ViewStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ViewStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ViewStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>viewOid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>view</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>viewAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>viewAddress</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessDropViewStmt gets called during the planning phase of a DROP VIEW statement
 * and returns a list of DDLJob's that will drop any distributed view from the
 * workers.
 *
 * The DropStmt could have multiple objects to drop, the list of objects will be filtered
 * to only keep the distributed views for deletion on the workers. Non-distributed
 * views will still be dropped locally but not on the workers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessDropViewStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ProcessUtilityContext</name></type>
					   <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedViewNames</name> <init>= <expr><call><name>FilterNameListForDistributedViews</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></argument>,
																   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>distributedViewNames</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no distributed view to drop */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureSequentialMode</name><argument_list>(<argument><expr><name>OBJECT_VIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Swap the list of objects before deparsing and restore the old list after. This
	 * ensures we only have distributed views in the deparsed drop statement.
	 */</comment>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmtCopy</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stmtCopy</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>distributedViewNames</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>QualifyTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmtCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dropStmtSql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmtCopy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>dropStmtSql</name></expr></argument>,
								<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropViewStmtObjectAddress returns list of object addresses in the drop view
 * statement.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>DropViewStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>objectAddresses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>possiblyQualifiedViewName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>possiblyQualifiedViewName</argument>, <argument>dropStmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>viewRangeVar</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><name>possiblyQualifiedViewName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>viewOid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>viewRangeVar</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>,
									   <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>objectAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>objectAddresses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>objectAddresses</name></expr></argument>, <argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>objectAddresses</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FilterNameListForDistributedViews takes a list of view names and filters against the
 * views that are distributed.
 *
 * The original list will not be touched, a new list will be created with only the objects
 * in there.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FilterNameListForDistributedViews</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>viewNamesList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedViewNames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>possiblyQualifiedViewName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>possiblyQualifiedViewName</argument>, <argument>viewNamesList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>possiblyQualifiedViewName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>viewName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>schemaName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>objName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>schemaOid</name> <init>= <expr><call><name>QualifiedNameGetCreationNamespace</name><argument_list>(<argument><expr><name>possiblyQualifiedViewName</name></expr></argument>,
															  <argument><expr><operator>&amp;</operator><name>objName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>schemaName</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>viewOid</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>viewName</name></expr></argument>, <argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsViewDistributed</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>distributedViewNames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>distributedViewNames</name></expr></argument>,
										   <argument><expr><name>possiblyQualifiedViewName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>distributedViewNames</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateViewDDLCommand returns the DDL command to create the view addressed by
 * the viewAddress.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>CreateViewDDLCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>createViewCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>, <argument><expr><literal type="string">"CREATE OR REPLACE VIEW "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AppendQualifiedViewNameToCreateViewCommand</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendAliasesToCreateViewCommand</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendOptionsToCreateViewCommand</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendViewDefinitionToCreateViewCommand</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>createViewCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AppendQualifiedViewNameToCreateViewCommand adds the qualified view of the given view
 * oid to the given create view command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendQualifiedViewNameToCreateViewCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedViewName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>viewName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><name>qualifiedViewName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AppendAliasesToCreateViewCommand appends aliases to the create view
 * command for the existing view.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendAliasesToCreateViewCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>createViewCommand</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Get column name aliases from pg_attribute */</comment>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>maprel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>mapidx</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>pgAttributeScan</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>maprel</name></expr></argument>, <argument><expr><name>mapidx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
															 <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isInitialAlias</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasAlias</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>attributeTuple</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attributeTuple</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>pgAttributeScan</name></expr></argument>,
																	  <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aliasName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isInitialAlias</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>, <argument><expr><name>aliasName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>hasAlias</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>isInitialAlias</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>hasAlias</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>, <argument><expr><literal type="string">") "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>pgAttributeScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>mapidx</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>maprel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AppendOptionsToCreateViewCommand add relation options to create view command
 * for an existing view
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOptionsToCreateViewCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>createViewCommand</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Add rel options to create view command */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relOptions</name> <init>= <expr><call><name>flatten_reloptions</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relOptions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>createViewCommand</name></expr></argument>, <argument><expr><literal type="string">"WITH (%s) "</literal></expr></argument>, <argument><expr><name>relOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AppendViewDefinitionToCreateViewCommand adds the definition of the given view to the
 * given create view command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendViewDefinitionToCreateViewCommand</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Set search_path to NIL so that all objects outside of pg_catalog will be
	 * schema-prefixed.
	 */</comment>
	<decl_stmt><decl><type><name>OverrideSearchPath</name> <modifier>*</modifier></type><name>overridePath</name> <init>= <expr><call><name>GetOverrideSearchPath</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>overridePath</name><operator>-&gt;</operator><name>schemas</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>overridePath</name><operator>-&gt;</operator><name>addCatalog</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PushOverrideSearchPath</name><argument_list>(<argument><expr><name>overridePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Push the transaction snapshot to be able to get vief definition with pg_get_viewdef
	 */</comment>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>viewDefinitionDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_get_viewdef</name></expr></argument>,
													<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewDefinition</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>viewDefinitionDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"AS %s "</literal></expr></argument>, <argument><expr><name>viewDefinition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AlterViewOwnerCommand returns the command to alter view owner command for the
 * given view or materialized view oid.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>AlterViewOwnerCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Add alter owner commmand */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>alterOwnerCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaOid</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewOwnerName</name> <init>= <expr><call><name>TableOwner</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedViewName</name> <init>= <expr><call><name>NameListToQuotedString</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>)</argument_list></call></expr></argument>,
																<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>viewName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>alterOwnerCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER MATERIALIZED VIEW %s "</literal></expr></argument>,
						 <argument><expr><name>qualifiedViewName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>alterOwnerCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER VIEW %s "</literal></expr></argument>, <argument><expr><name>qualifiedViewName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>alterOwnerCommand</name></expr></argument>, <argument><expr><literal type="string">"OWNER TO %s"</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>viewOwnerName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>alterOwnerCommand</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsViewDistributed checks if a view is distributed
 */</comment>
<function><type><name>bool</name></type>
<name>IsViewDistributed</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
		   <call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>viewAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>viewAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterViewStmt is invoked for alter view statements.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterViewStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>ProcessUtilityContext</name></type>
						<name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>viewAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateAnyObject</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>QualifyTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reconstruct alter statement in a portable fashion */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alterViewStmtSql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We have already asserted that we have exactly 1 address in the addresses. */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * To avoid sequential mode, we are using metadata connection. For the
	 * detailed explanation, please check the comment on PostprocessViewStmt.
	 */</comment>
	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name> <operator>=</operator> <operator>*</operator><name>viewAddress</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>alterViewStmtSql</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessAlterViewStmt is invoked for alter view statements.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessAlterViewStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AlterTableStmtObjType_compat</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OBJECT_VIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>viewAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateAnyObject</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If the view has any unsupported dependency, create it locally */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ErrorOrWarnIfAnyObjectHasUnsupportedDependency</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterViewStmtObjectAddress returns the ObjectAddress for the subject of the
 * ALTER VIEW statement.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterViewStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>viewOid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>viewAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>viewAddress</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessRenameViewStmt is called when the user is renaming the view or the column of
 * the view.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessRenameViewStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						 <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>viewAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateAnyObject</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fully qualify */</comment>
	<expr_stmt><expr><call><name>QualifyTreeNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* deparse sql*/</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>renameStmtSql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We have already asserted that we have exactly 1 address in the addresses. */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * To avoid sequential mode, we are using metadata connection. For the
	 * detailed explanation, please check the comment on PostprocessViewStmt.
	 */</comment>
	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name> <operator>=</operator> <operator>*</operator><name>viewAddress</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>renameStmtSql</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RenameViewStmtObjectAddress returns the ObjectAddress of the view that is the object
 * of the RenameStmt. Errors if missing_ok is false.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>RenameViewStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>viewOid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>viewAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>viewAddress</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterViewSchemaStmt is executed before the statement is applied to the local
 * postgres instance.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterViewSchemaStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
							  <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>viewAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateAnyObject</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>QualifyTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We have already asserted that we have exactly 1 address in the addresses. */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * To avoid sequential mode, we are using metadata connection. For the
	 * detailed explanation, please check the comment on PostprocessViewStmt.
	 */</comment>
	<decl_stmt><decl><type><name>DDLJob</name> <modifier>*</modifier></type><name>ddlJob</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DDLJob</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>targetObjectAddress</name></name> <operator>=</operator> <operator>*</operator><name>viewAddress</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>metadataSyncCommand</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ddlJob</name><operator>-&gt;</operator><name>taskList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>ddlJob</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessAlterViewSchemaStmt is executed after the change has been applied locally, we
 * can now use the new dependencies of the view to ensure all its dependencies exist on
 * the workers before we apply the commands remotely.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessAlterViewSchemaStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>viewAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateAnyObject</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* dependencies have changed (schema) let's ensure they exist */</comment>
	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><name>viewAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterViewSchemaStmtObjectAddress returns the ObjectAddress of the view that is the object
 * of the alter schema statement.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterViewSchemaStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>viewOid</name> <init>= <expr><call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since it can be called both before and after executing the standardProcess utility,
	 * we need to check both old and new schemas
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>viewOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>newschema</name></name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>viewOid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * if the view is still invalid we couldn't find the view, error with the same
		 * message postgres would error with it missing_ok is false (not ok to miss)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name> <operator>&amp;&amp;</operator> <name>viewOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"view \"%s\" does not exist"</literal></expr></argument>,
								   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>viewAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>viewAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>viewAddress</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsViewRenameStmt returns whether the passed-in RenameStmt is the following
 * form:
 *
 *   - ALTER VIEW RENAME
 *   - ALTER VIEW RENAME COLUMN
 */</comment>
<function><type><name>bool</name></type>
<name>IsViewRenameStmt</name><parameter_list>(<parameter><decl><type><name>RenameStmt</name> <modifier>*</modifier></type><name>renameStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isViewRenameStmt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>renameStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_VIEW</name> <operator>||</operator>
		<operator>(</operator><name><name>renameStmt</name><operator>-&gt;</operator><name>renameType</name></name> <operator>==</operator> <name>OBJECT_COLUMN</name> <operator>&amp;&amp;</operator>
		 <name><name>renameStmt</name><operator>-&gt;</operator><name>relationType</name></name> <operator>==</operator> <name>OBJECT_VIEW</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isViewRenameStmt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>isViewRenameStmt</name></expr>;</return>
</block_content>}</block></function>
</unit>
