<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/distributed/commands/role.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * role.c
 *    Commands for ALTER ROLE statements.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_version_compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/pg_version_constants.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_auth_members.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_db_role_setting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaddress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>ExtractEncryptedPassword</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>CreateAlterRoleIfExistsCommand</name><parameter_list>(<parameter><decl><type><name>AlterRoleStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>CreateAlterRoleSetIfExistsCommand</name><parameter_list>(<parameter><decl><type><name>AlterRoleSetStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>CreateCreateOrAlterRoleCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>roleName</name></decl></parameter>,
											 <parameter><decl><type><name>CreateRoleStmt</name> <modifier>*</modifier></type><name>createRoleStmt</name></decl></parameter>,
											 <parameter><decl><type><name>AlterRoleStmt</name> <modifier>*</modifier></type><name>alterRoleStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DefElem</name> <modifier>*</modifier></type> <name>makeDefElemInt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DefElem</name> <modifier>*</modifier></type> <name>makeDefElemBool</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateRoleOptionsList</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateGrantRoleStmtsFromOptions</name><parameter_list>(<parameter><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>roleSpec</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateGrantRoleStmtsOfRole</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureSequentialModeForRoleDDL</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetRoleNameFromDbRoleSetting</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
										   <parameter><decl><type><name>TupleDesc</name></type> <name>DbRoleSettingDescription</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetDatabaseNameFromDbRoleSetting</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
											   <parameter><decl><type><name>TupleDesc</name></type> <name>DbRoleSettingDescription</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>makeStringConst</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>makeIntConst</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>makeFloatConst</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>WrapQueryInAlterRoleIfExistsCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>role</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VariableSetStmt</name> <modifier>*</modifier></type> <name>MakeVariableSetStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ConfigGenericNameCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>RoleSpecToObjectAddress</name><parameter_list>(<parameter><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>role</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* controlled via GUC */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableCreateRolePropagation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableAlterRolePropagation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>EnableAlterRoleSetPropagation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * AlterRoleStmtObjectAddress returns the ObjectAddress of the role in the
 * AlterRoleStmt. If missing_ok is set to false an error will be raised if postgres
 * was unable to find the role that was the target of the statement.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterRoleStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterRoleStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>RoleSpecToObjectAddress</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterRoleSetStmtObjectAddress returns the ObjectAddress of the role in the
 * AlterRoleSetStmt. If missing_ok is set to false an error will be raised if postgres
 * was unable to find the role that was the target of the statement.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterRoleSetStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterRoleSetStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterRoleSetStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>RoleSpecToObjectAddress</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RoleSpecToObjectAddress returns the ObjectAddress of a Role associated with a
 * RoleSpec. If missing_ok is set to false an error will be raised by postgres
 * explaining the Role could not be found.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>RoleSpecToObjectAddress</name><parameter_list>(<parameter><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>role</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>role</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* roles can be NULL for statements on ALL roles eg. ALTER ROLE ALL SET ... */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>roleOid</name> <init>= <expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name>role</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessAlterRoleStmt actually creates the plan we need to execute for alter
 * role statement. We need to do it this way because we need to use the encrypted
 * password, which is, in some cases, created at standardProcessUtility.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessAlterRoleStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>addresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateAnyObject</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableAlterRolePropagation</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>AlterRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterRoleStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>option</argument>, <argument>stmt-&gt;options</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"password"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>roleOid</name> <init>= <expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encryptedPassword</name> <init>= <expr><call><name>ExtractEncryptedPassword</name><argument_list>(<argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>encryptedPassword</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>encryptedPasswordValue</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>encryptedPassword</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>option</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>encryptedPasswordValue</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>option</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>CreateAlterRoleIfExistsCommand</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterRoleSetStmt actually creates the plan we need to execute for alter
 * role set statement.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterRoleSetStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableAlterRoleSetPropagation</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AlterRoleSetStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterRoleSetStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* don't propagate if the statement is scoped to another database */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>database</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>addresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * stmt-&gt;role could be NULL when the statement is on 'ALL' roles, we do propagate for
	 * ALL roles. If it is not NULL the role is for a specific role. If that role is not
	 * distributed we will not propagate the statement
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><name>addresses</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>QualifyTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>sql</name></expr></argument>,
								   <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commandList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateAlterRoleIfExistsCommand creates ALTER ROLE command, from the alter role node
 *  using the alter_role_if_exists() UDF.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateAlterRoleIfExistsCommand</name><parameter_list>(<parameter><decl><type><name>AlterRoleStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alterRoleQuery</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>WrapQueryInAlterRoleIfExistsCall</name><argument_list>(<argument><expr><name>alterRoleQuery</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateAlterRoleSetIfExistsCommand creates ALTER ROLE .. SET command, from the
 * AlterRoleSetStmt node.
 *
 * If the statement affects a single user, the query is wrapped in a
 * alter_role_if_exists() to make sure that it is run on workers that has a user
 * with the same name. If the query is a ALTER ROLE ALL .. SET query, the query
 * is sent to the workers as is.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateAlterRoleSetIfExistsCommand</name><parameter_list>(<parameter><decl><type><name>AlterRoleSetStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alterRoleSetQuery</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* ALTER ROLE ALL .. SET queries should not be wrapped in a alter_role_if_exists() call */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>alterRoleSetQuery</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>WrapQueryInAlterRoleIfExistsCall</name><argument_list>(<argument><expr><name>alterRoleSetQuery</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WrapQueryInAlterRoleIfExistsCall wraps a given query in a alter_role_if_exists()
 * UDF.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>WrapQueryInAlterRoleIfExistsCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>role</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>roleName</name> <init>= <expr><call><name>RoleSpecString</name><argument_list>(<argument><expr><name>role</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT alter_role_if_exists(%s, %s)"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>roleName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateCreateOrAlterRoleCommand creates ALTER ROLE command, from the alter role node
 *  using the alter_role_if_exists() UDF.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateCreateOrAlterRoleCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>roleName</name></decl></parameter>,
							   <parameter><decl><type><name>CreateRoleStmt</name> <modifier>*</modifier></type><name>createRoleStmt</name></decl></parameter>,
							   <parameter><decl><type><name>AlterRoleStmt</name> <modifier>*</modifier></type><name>alterRoleStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>createOrAlterRoleQueryBuffer</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>createRoleQuery</name> <init>= <expr><literal type="string">"null"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alterRoleQuery</name> <init>= <expr><literal type="string">"null"</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>createRoleStmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>createRoleQuery</name> <operator>=</operator> <call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>createRoleStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>alterRoleStmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>alterRoleQuery</name> <operator>=</operator> <call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>alterRoleStmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>createOrAlterRoleQueryBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>createOrAlterRoleQueryBuffer</name></expr></argument>,
					 <argument><expr><literal type="string">"SELECT worker_create_or_alter_role(%s, %s, %s)"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>roleName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>createRoleQuery</name></expr></argument>,
					 <argument><expr><name>alterRoleQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>createOrAlterRoleQueryBuffer</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractEncryptedPassword extracts the encrypted password of a role. The function
 * gets the password from the pg_authid table.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExtractEncryptedPassword</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgAuthId</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>pgAuthIdDescription</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pgAuthId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>passwordDatum</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_authid_rolpassword</name></expr></argument>,
									   <argument><expr><name>pgAuthIdDescription</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In PG, an empty password is treated the same as NULL.
	 * So we propagate NULL password to the other nodes, even if
	 * the user supplied an empty password
	 */</comment>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>passwordCstring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>passwordCstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>passwordDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgAuthId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>passwordCstring</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateAlterRoleSetIfExistsCommandList generate a list of ALTER ROLE .. SET commands that
 * copies a role session defaults from the pg_db_role_settings table.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GenerateAlterRoleSetIfExistsCommandList</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>,
										<parameter><decl><type><name>TupleDesc</name></type> <name>DbRoleSettingDescription</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterRoleSetStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterRoleSetStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commandList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name> <init>=
		<expr><call><name>GetDatabaseNameFromDbRoleSetting</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>DbRoleSettingDescription</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>databaseName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>database</name></name> <operator>=</operator> <name>databaseName</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>roleName</name> <init>= <expr><call><name>GetRoleNameFromDbRoleSetting</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>DbRoleSettingDescription</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>roleName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RoleSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name><operator>-&gt;</operator><name>roletype</name></name> <operator>=</operator> <name>ROLESPEC_CSTRING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name><operator>-&gt;</operator><name>rolename</name></name> <operator>=</operator> <name>roleName</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>setconfig</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_db_role_setting_setconfig</name></expr></argument>,
								   <argument><expr><name>DbRoleSettingDescription</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>configs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nconfigs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>setconfig</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>configs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nconfigs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * A tuple might contain one or more settings that apply to the user-database combination.
	 * ALTER ROLE ... SET ... only allows to set one at a time. We will create a statement for every
	 * configuration contained in the tuple.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nconfigs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>config</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>configs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>setstmt</name></name> <operator>=</operator> <call><name>MakeVariableSetStmt</name><argument_list>(<argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>commandList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commandList</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>CreateAlterRoleSetIfExistsCommand</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>commandList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MakeVariableSetStmt takes a "some-option=some value" string and creates a
 * VariableSetStmt Node.
 */</comment>
<function><type><specifier>static</specifier> <name>VariableSetStmt</name> <modifier>*</modifier></type>
<name>MakeVariableSetStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>config</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ParseLongOption</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>VariableSetStmt</name> <modifier>*</modifier></type><name>variableSetStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>VariableSetStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>variableSetStmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>VAR_SET_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>variableSetStmt</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>variableSetStmt</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>MakeSetStatementArguments</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>variableSetStmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateRoleOptionsList returns the list of options set on a user based on the record
 * in pg_authid. It requires the HeapTuple for a user entry to access both its fixed
 * length and variable length fields.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GenerateRoleOptionsList</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_authid</name></type> <name>role</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElemBool</name><argument_list>(<argument><expr><literal type="string">"superuser"</literal></expr></argument>, <argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolsuper</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElemBool</name><argument_list>(<argument><expr><literal type="string">"createdb"</literal></expr></argument>, <argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolcreatedb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElemBool</name><argument_list>(<argument><expr><literal type="string">"createrole"</literal></expr></argument>, <argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolcreaterole</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElemBool</name><argument_list>(<argument><expr><literal type="string">"inherit"</literal></expr></argument>, <argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolinherit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElemBool</name><argument_list>(<argument><expr><literal type="string">"canlogin"</literal></expr></argument>, <argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolcanlogin</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElemBool</name><argument_list>(<argument><expr><literal type="string">"isreplication"</literal></expr></argument>, <argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolreplication</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElemBool</name><argument_list>(<argument><expr><literal type="string">"bypassrls"</literal></expr></argument>, <argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolbypassrls</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElemInt</name><argument_list>(<argument><expr><literal type="string">"connectionlimit"</literal></expr></argument>, <argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolconnlimit</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* load password from heap tuple, use NULL if not set */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>rolPasswordDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>AUTHNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_authid_rolpassword</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rolPassword</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>rolPasswordDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>passwordStringNode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>rolPassword</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>passwordOption</name> <init>= <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"password"</literal></expr></argument>, <argument><expr><name>passwordStringNode</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>passwordOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"password"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* load valid unitl data from the heap tuple, use default of infinity if not set */</comment>
	<decl_stmt><decl><type><name>Datum</name></type> <name>rolValidUntilDatum</name> <init>= <expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>AUTHNAME</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
											   <argument><expr><name>Anum_pg_authid_rolvaliduntil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rolValidUntil</name> <init>= <expr><literal type="string">"infinity"</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rolValidUntil</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>timestamptz_to_str</name><argument_list>(<argument><expr><name>rolValidUntilDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>validUntilStringNode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>rolValidUntil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>validUntilOption</name> <init>= <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"validUntil"</literal></expr></argument>, <argument><expr><name>validUntilStringNode</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>validUntilOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateCreateOrAlterRoleCommand generates ALTER ROLE command that copies a role from
 * the pg_authid table.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GenerateCreateOrAlterRoleCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>roleTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_authid</name></type> <name>role</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>roleTuple</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CreateRoleStmt</name> <modifier>*</modifier></type><name>createRoleStmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>EnableCreateRolePropagation</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>createRoleStmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateRoleStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>createRoleStmt</name><operator>-&gt;</operator><name>stmt_type</name></name> <operator>=</operator> <name>ROLESTMT_ROLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>createRoleStmt</name><operator>-&gt;</operator><name>role</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>createRoleStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>GenerateRoleOptionsList</name><argument_list>(<argument><expr><name>roleTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AlterRoleStmt</name> <modifier>*</modifier></type><name>alterRoleStmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>EnableAlterRolePropagation</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>alterRoleStmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterRoleStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>role</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RoleSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>role</name><operator>-&gt;</operator><name>roletype</name></name> <operator>=</operator> <name>ROLESPEC_CSTRING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>role</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>role</name><operator>-&gt;</operator><name>rolename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>GenerateRoleOptionsList</name><argument_list>(<argument><expr><name>roleTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>roleTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>completeRoleList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>createRoleStmt</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>alterRoleStmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* add a worker_create_or_alter_role command if any of them are set */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>createOrAlterRoleQuery</name> <init>= <expr><call><name>CreateCreateOrAlterRoleCommand</name><argument_list>(
			<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>role</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>createRoleStmt</name></expr></argument>,
			<argument><expr><name>alterRoleStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>completeRoleList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>completeRoleList</name></expr></argument>, <argument><expr><name>createOrAlterRoleQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>EnableAlterRoleSetPropagation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* append ALTER ROLE ... SET commands fot this specific user */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>alterRoleSetCommands</name> <init>= <expr><call><name>GenerateAlterRoleSetCommandForRole</name><argument_list>(<argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>completeRoleList</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>completeRoleList</name></expr></argument>, <argument><expr><name>alterRoleSetCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>EnableCreateRolePropagation</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>grantRoleStmts</name> <init>= <expr><call><name>GenerateGrantRoleStmtsOfRole</name><argument_list>(<argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>stmt</argument>, <argument>grantRoleStmts</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>completeRoleList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>completeRoleList</name></expr></argument>, <argument><expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>completeRoleList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateAlterRoleSetCommandForRole returns the list of database wide settings for a
 * specifc role. If the roleid is InvalidOid it returns the commands that apply to all
 * users for the database or postgres wide.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GenerateAlterRoleSetCommandForRole</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>DbRoleSetting</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DbRoleSettingRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>DbRoleSettingDescription</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>DbRoleSetting</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>


	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>DbRoleSetting</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_db_role_setting</name></type> <name>roleSetting</name> <init>= <expr><operator>(</operator><name>Form_pg_db_role_setting</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>roleSetting</name><operator>-&gt;</operator><name>setrole</name></name> <operator>!=</operator> <name>roleid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* not the user we are looking for */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>roleSetting</name><operator>-&gt;</operator><name>setdatabase</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>roleSetting</name><operator>-&gt;</operator><name>setdatabase</name></name> <operator>!=</operator> <name>MyDatabaseId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* setting is database specific for a different database */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>alterRoleSetQueries</name> <init>= <expr><call><name>GenerateAlterRoleSetIfExistsCommandList</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
																			<argument><expr><name>DbRoleSettingDescription</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><name>alterRoleSetQueries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>DbRoleSetting</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>commands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * makeDefElemInt creates a DefElem with integer typed value with -1 as location.
 */</comment>
<function><type><specifier>static</specifier> <name>DefElem</name> <modifier>*</modifier></type>
<name>makeDefElemInt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * makeDefElemBool creates a DefElem with boolean typed value with -1 as location.
 */</comment>
<function><type><specifier>static</specifier> <name>DefElem</name> <modifier>*</modifier></type>
<name>makeDefElemBool</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolean</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDatabaseNameFromDbRoleSetting performs a lookup, and finds the database name
 * associated DbRoleSetting Tuple
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetDatabaseNameFromDbRoleSetting</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>DbRoleSettingDescription</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>setdatabase</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_db_role_setting_setdatabase</name></expr></argument>,
									 <argument><expr><name>DbRoleSettingDescription</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>databaseId</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>setdatabase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>databaseName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetRoleNameFromDbRoleSetting performs a lookup, and finds the role name
 * associated DbRoleSetting Tuple
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetRoleNameFromDbRoleSetting</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>DbRoleSettingDescription</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>setrole</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_db_role_setting_setrole</name></expr></argument>,
								 <argument><expr><name>DbRoleSettingDescription</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>roleId</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>setrole</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>roleName</name> <init>= <expr><call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name>roleId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>roleName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MakeSetStatementArgs parses a configuration value and creates an List of A_Const
 * Nodes with appropriate types.
 *
 * The allowed A_Const types are Integer, Float, and String.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>MakeSetStatementArguments</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>configurationName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>configurationValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>key</name> <init>= <expr><operator>&amp;</operator><name>configurationName</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Perform a lookup on GUC variables to find the config type and units.
	 * All user-defined GUCs have string values, but we need to perform a search
	 * on all the GUCs to understand if it is a user-defined one or not.
	 *
	 * Note: get_guc_variables() is intended for internal use only, but there
	 * is no other way to determine allowed units, and value types other than
	 * using this function
	 */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>gucVariables</name> <init>= <expr><call><name>get_guc_variables</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numOpts</name> <init>= <expr><call><name>GetNumConfigOptions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>matchingConfig</name> <init>=
		<expr><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>SafeBsearch</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>gucVariables</name></expr></argument>,
											   <argument><expr><name>numOpts</name></expr></argument>,
											   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
											   <argument><expr><name>ConfigGenericNameCompare</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If the config is not user-defined, lookup the variable type to contruct the arguments */</comment>
	<if_stmt><if>if <condition>(<expr><name>matchingConfig</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><operator>(</operator><operator>*</operator><name>matchingConfig</name><operator>)</operator><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We use postgresql parser so that we will parse the units only if
			 * the configuration paramater allows it.
			 *
			 * e.g. `SET statement_timeout = '1min'` will be parsed as 60000 since
			 * the value is stored in units of ms internally.
			 */</comment>
			<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>intValue</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>parse_int</name><argument_list>(<argument><expr><name>configurationValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intValue</name></expr></argument>,
						  <argument><expr><name><operator>(</operator><operator>*</operator><name>matchingConfig</name><operator>)</operator><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>makeIntConst</name><argument_list>(<argument><expr><name>intValue</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>makeFloatConst</name><argument_list>(<argument><expr><name>configurationValue</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

			<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>configurationList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>matchingConfig</name><operator>)</operator><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_LIST_INPUT</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>configurationValueCopy</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>configurationValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>configurationValueCopy</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>configurationList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>configurationList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>configurationValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>configuration</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<macro><name>foreach_ptr</name><argument_list>(<argument>configuration</argument>, <argument>configurationList</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>makeStringConst</name><argument_list>(<argument><expr><name>configuration</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			</block_content>}</block>

			<default>default:</default>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unrecognized run-time parameter type for %s"</literal></expr></argument>,
									   <argument><expr><name>configurationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>makeStringConst</name><argument_list>(<argument><expr><name>configurationValue</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>args</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateGrantRoleStmtsFromOptions gets a RoleSpec of a role that is being
 * created and a list of options of CreateRoleStmt to generate GrantRoleStmts
 * for the role's memberships.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GenerateGrantRoleStmtsFromOptions</name><parameter_list>(<parameter><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>roleSpec</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>option</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>option</argument>, <argument>options</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"adminmembers"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"rolemembers"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"addroleto"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>GrantRoleStmt</name> <modifier>*</modifier></type><name>grantRoleStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GrantRoleStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>is_grant</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"adminmembers"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>,
																   <argument><expr><literal type="string">"rolemembers"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>granted_roles</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>roleSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>grantee_roles</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>option</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>granted_roles</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>option</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>grantee_roles</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>roleSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>option</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"adminmembers"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>admin_opt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>grantRoleStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>stmts</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateGrantRoleStmtsOfRole generates the GrantRoleStmts for the memberships
 * of the role whose oid is roleid.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GenerateGrantRoleStmtsOfRole</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>pgAuthMembers</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>AuthMemRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_auth_members_member</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgAuthMembers</name></expr></argument>, <argument><expr><name>AuthMemMemRoleIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_auth_members</name></type> <name>membership</name> <init>= <expr><operator>(</operator><name>Form_pg_auth_members</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>GrantRoleStmt</name> <modifier>*</modifier></type><name>grantRoleStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GrantRoleStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>is_grant</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>grantedRole</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RoleSpec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>grantedRole</name><operator>-&gt;</operator><name>roletype</name></name> <operator>=</operator> <name>ROLESPEC_CSTRING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grantedRole</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grantedRole</name><operator>-&gt;</operator><name>rolename</name></name> <operator>=</operator> <call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name><name>membership</name><operator>-&gt;</operator><name>roleid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>granted_roles</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>grantedRole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>granteeRole</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RoleSpec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>granteeRole</name><operator>-&gt;</operator><name>roletype</name></name> <operator>=</operator> <name>ROLESPEC_CSTRING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>granteeRole</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>granteeRole</name><operator>-&gt;</operator><name>rolename</name></name> <operator>=</operator> <call><name>GetUserNameFromId</name><argument_list>(<argument><expr><name><name>membership</name><operator>-&gt;</operator><name>member</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>grantee_roles</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>granteeRole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>grantor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>grantRoleStmt</name><operator>-&gt;</operator><name>admin_opt</name></name> <operator>=</operator> <name><name>membership</name><operator>-&gt;</operator><name>admin_option</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>stmts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stmts</name></expr></argument>, <argument><expr><name>grantRoleStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgAuthMembers</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stmts</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessCreateRoleStmt creates a worker_create_or_alter_role query for the
 * role that is being created. With that query we can create the role in the
 * workers or if they exist we alter them to the way they are being created
 * right now.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessCreateRoleStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						 <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableCreateRolePropagation</name> <operator>||</operator> <operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureSequentialModeForRoleDDL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><call><name>DistNodeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CreateRoleStmt</name> <modifier>*</modifier></type><name>createRoleStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateRoleStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AlterRoleStmt</name> <modifier>*</modifier></type><name>alterRoleStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterRoleStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>role</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RoleSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>role</name><operator>-&gt;</operator><name>roletype</name></name> <operator>=</operator> <name>ROLESPEC_CSTRING</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>role</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>role</name><operator>-&gt;</operator><name>rolename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>createRoleStmt</name><operator>-&gt;</operator><name>role</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name><name>createRoleStmt</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>grantRoleStmts</name> <init>= <expr><call><name>GenerateGrantRoleStmtsFromOptions</name><argument_list>(<argument><expr><name><name>alterRoleStmt</name><operator>-&gt;</operator><name>role</name></name></expr></argument>,
															 <argument><expr><name><name>createRoleStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>createOrAlterRoleQuery</name> <init>= <expr><call><name>CreateCreateOrAlterRoleCommand</name><argument_list>(<argument><expr><name><name>createRoleStmt</name><operator>-&gt;</operator><name>role</name></name></expr></argument>,
																  <argument><expr><name>createRoleStmt</name></expr></argument>,
																  <argument><expr><name>alterRoleStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><name>createOrAlterRoleQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* deparse all grant statements and add them to the commands list */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>stmt</argument>, <argument>grantRoleStmts</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * makeStringConst creates a Const Node that stores a given string
 *
 * copied from backend/parser/gram.c
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeStringConst</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>sval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>sval</name><operator>.</operator><name>sval</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * makeIntConst creates a Const Node that stores a given integer
 *
 * copied from backend/parser/gram.c
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeIntConst</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>ival</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Integer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>ival</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Integer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * makeIntConst creates a Const Node that stores a given Float
 *
 * copied from backend/parser/gram.c
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>makeFloatConst</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>fval</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Float</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>fval</name><operator>.</operator><name>fval</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Float</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessDropRoleStmt finds the distributed role out of the ones
 * being dropped and unmarks them distributed and creates the drop statements
 * for the workers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessDropRoleStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
					   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropRoleStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allDropRoles</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedDropRoles</name> <init>= <expr><call><name>FilterDistributedRoles</name><argument_list>(<argument><expr><name>allDropRoles</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>distributedDropRoles</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableCreateRolePropagation</name> <operator>||</operator> <operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureSequentialModeForRoleDDL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name> <operator>=</operator> <name>distributedDropRoles</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>roles</name></name> <operator>=</operator> <name>allDropRoles</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								<argument><expr><name>sql</name></expr></argument>,
								<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UnmarkRolesDistributed unmarks the roles in the RoleSpec list distributed.
 */</comment>
<function><type><name>void</name></type>
<name>UnmarkRolesDistributed</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>roles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>roleNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>roleNode</argument>, <argument>roles</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>role</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RoleSpec</name></expr></argument>, <argument><expr><name>roleNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>roleAddress</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>roleOid</name> <init>= <expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name>role</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>roleOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the role is dropped (concurrently), we might get an inactive oid for the
			 * role. If it is invalid oid, skip.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>roleAddress</name></expr></argument>, <argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnmarkObjectDistributed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>roleAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * FilterDistributedRoles filters the list of RoleSpecs and returns the ones
 * that are distributed.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>FilterDistributedRoles</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>roles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedRoles</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>roleNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>roleNode</argument>, <argument>roles</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>role</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RoleSpec</name></expr></argument>, <argument><expr><name>roleNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>roleOid</name> <init>= <expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name>role</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>roleOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Non-existing roles are ignored silently here. Postgres will
			 * handle to give an error or not for these roles.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>roleAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>roleAddress</name></expr></argument>, <argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>roleAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>distributedRoles</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>distributedRoles</name></expr></argument>, <argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>distributedRoles</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessGrantRoleStmt finds the distributed grantee roles and creates the
 * query to run on the workers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessGrantRoleStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
						<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableCreateRolePropagation</name> <operator>||</operator> <operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GrantRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantRoleStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allGranteeRoles</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>grantee_roles</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>grantor</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>grantor</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedGranteeRoles</name> <init>= <expr><call><name>FilterDistributedRoles</name><argument_list>(<argument><expr><name>allGranteeRoles</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>distributedGranteeRoles</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Postgres don't seem to use the grantor. Even dropping the grantor doesn't
	 * seem to affect the membership. If this changes, we might need to add grantors
	 * to the dependency resolution too. For now we just don't propagate it.
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>grantor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>grantee_roles</name></name> <operator>=</operator> <name>distributedGranteeRoles</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>grantee_roles</name></name> <operator>=</operator> <name>allGranteeRoles</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>grantor</name></name> <operator>=</operator> <name>grantor</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								<argument><expr><name>sql</name></expr></argument>,
								<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessGrantRoleStmt actually creates the plan we need to execute for grant
 * role statement.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessGrantRoleStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableCreateRolePropagation</name> <operator>||</operator> <operator>!</operator><call><name>IsCoordinator</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ShouldPropagate</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>GrantRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>GrantRoleStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RoleSpec</name> <modifier>*</modifier></type><name>role</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>role</argument>, <argument>stmt-&gt;grantee_roles</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>roleOid</name> <init>= <expr><call><name>get_rolespec_oid</name><argument_list>(<argument><expr><name>role</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>roleAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>roleAddress</name></expr></argument>, <argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>roleAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>roleAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConfigGenericNameCompare compares two config_generic structs based on their
 * name fields. If the name fields contain the same strings two structs are
 * considered to be equal.
 *
 * copied from guc_var_compare in utils/misc/guc.c
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ConfigGenericNameCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>confa</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>confb</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * guc_var_compare used a custom comparison function here to allow stable
	 * ordering, but we do not need it here as we only perform a lookup, and do
	 * not use this function to order the guc list.
	 */</comment>
	<return>return <expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>confa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>confb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateRoleStmtObjectAddress finds the ObjectAddress for the role described
 * by the CreateRoleStmt. If missing_ok is false this function throws an error if the
 * role does not exist.
 *
 * Never returns NULL, but the objid in the address could be invalid if missing_ok was set
 * to true.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CreateRoleStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateRoleStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateRoleStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>roleOid</name> <init>= <expr><call><name>get_role_oid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>roleAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>roleAddress</name></expr></argument>, <argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>roleAddress</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureSequentialModeForRoleDDL makes sure that the current transaction is already in
 * sequential mode, or can still safely be put in sequential mode, it errors if that is
 * not possible. The error contains information for the user to retry the transaction with
 * sequential mode set from the begining.
 *
 * As roles are node scoped objects there exists only 1 instance of the role used by
 * potentially multiple shards. To make sure all shards in the transaction can interact
 * with the role the role needs to be visible on all connections used by the transaction,
 * meaning we can only use 1 connection per node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EnsureSequentialModeForRoleDDL</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we do not need to switch to sequential mode if we are not in a transaction */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create or modify role because there was a "</literal>
							   <literal type="string">"parallel operation on a distributed table in the "</literal>
							   <literal type="string">"transaction"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"When creating or altering a role, Citus needs to "</literal>
								  <literal type="string">"perform all operations over a single connection per "</literal>
								  <literal type="string">"node to ensure consistency."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
								<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
								<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"switching to sequential query execution mode"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Role is created or altered. To make sure subsequent "</literal>
							   <literal type="string">"commands see the role correctly we need to make sure to "</literal>
							   <literal type="string">"use only one connection for all future commands"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
