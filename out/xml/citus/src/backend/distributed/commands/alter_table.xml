<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/commands/alter_table.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * alter_table.c
 *	  Routines related to the altering of tables.
 *
 *		There are three UDFs defined in this file:
 *		undistribute_table:
 *			Turns a distributed table to a local table
 *		alter_distributed_table:
 *			Alters distribution_column, shard_count or colocate_with
 *			properties of a distributed table
 *		alter_table_set_access_method:
 *			Changes the access method of a table
 *
 *		All three methods work in similar steps:
 *			- Create a new table the required way (with a different
 *			  shard count, distribution column, colocate with value,
 *			  access method or local)
 *			- Move everything to the new table
 *			- Drop the old one
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_rewrite_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/colocation_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/distribution_column.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/hash_helpers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/local_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_logical_planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_partitioning_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/reference_table_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shared_library_init.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/shard_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/worker_transaction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/* Table Conversion Types */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDISTRIBUTE_TABLE</name></cpp:macro> <cpp:value>'u'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALTER_DISTRIBUTED_TABLE</name></cpp:macro> <cpp:value>'a'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALTER_TABLE_SET_ACCESS_METHOD</name></cpp:macro> <cpp:value>'m'</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDISTRIBUTE_TABLE_CASCADE_HINT</name></cpp:macro> \
	<cpp:value>"Use cascade option to undistribute all the relations involved in " \
	"a foreign key relationship with %s by executing SELECT " \
	"undistribute_table($$%s$$, cascade_via_foreign_keys=&gt;true)"</cpp:value></cpp:define>


<typedef>typedef <function_decl><type><name>TableConversionReturn</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>TableConversionFunction</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name>
														  <name>TableConversionParameters</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>


<comment type="block">/*
 * TableConversionState objects are used for table conversion functions:
 * UndistributeTable, AlterDistributedTable, AlterTableSetAccessMethod.
 *
 * They can be created using TableConversionParameters objects with
 * CreateTableConversion function.
 *
 * TableConversionState objects include everything TableConversionParameters
 * objects do and some extra to be used in the conversion process.
 */</comment>
<typedef>typedef <type><struct>struct <name>TableConversionState</name>
<block>{
	<comment type="block">/*
	 * Determines type of conversion: UNDISTRIBUTE_TABLE,
	 * ALTER_DISTRIBUTED_TABLE, ALTER_TABLE_SET_ACCESS_METHOD.
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name>conversionType</name></decl>;</decl_stmt>

	<comment type="block">/* Oid of the table to do conversion on */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Options to do conversions on the table
	 * distributionColumn is the name of the new distribution column,
	 * shardCountIsNull is if the shardCount variable is not given
	 * shardCount is the new shard count,
	 * colocateWith is the name of the table to colocate with, 'none', or
	 * 'default'
	 * accessMethod is the name of the new accessMethod for the table
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>shardCountIsNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWith</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>accessMethod</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * cascadeToColocated determines whether the shardCount and
	 * colocateWith will be cascaded to the currently colocated tables
	 */</comment>
	<decl_stmt><decl><type><name>CascadeToColocatedOption</name></type> <name>cascadeToColocated</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * cascadeViaForeignKeys determines if the conversion operation
	 * will be cascaded to the graph connected with foreign keys
	 * to the table
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>cascadeViaForeignKeys</name></decl>;</decl_stmt>


	<comment type="block">/* schema of the table */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name></decl>;</decl_stmt>

	<comment type="block">/* name of the table */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name></decl>;</decl_stmt>

	<comment type="block">/* new relation oid after the conversion */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>newRelationId</name></decl>;</decl_stmt>

	<comment type="block">/* temporary name for intermediate table */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tempName</name></decl>;</decl_stmt>

	<comment type="block">/*hash that is appended to the name to create tempName */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>hashOfName</name></decl>;</decl_stmt>

	<comment type="block">/* shard count of the table before conversion */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>originalShardCount</name></decl>;</decl_stmt>

	<comment type="block">/* list of the table oids of tables colocated with the table before conversion */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name></decl>;</decl_stmt>

	<comment type="block">/* new distribution key, if distributionColumn variable is given */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>distributionKey</name></decl>;</decl_stmt>

	<comment type="block">/* distribution key of the table before conversion */</comment>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>originalDistributionKey</name></decl>;</decl_stmt>

	<comment type="block">/* access method name of the table before conversion */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>originalAccessMethod</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The function that will be used for the conversion
	 * Must comply with conversionType
	 * UNDISTRIBUTE_TABLE -&gt; UndistributeTable
	 * ALTER_DISTRIBUTED_TABLE -&gt; AlterDistributedTable
	 * ALTER_TABLE_SET_ACCESS_METHOD -&gt; AlterTableSetAccessMethod
	 */</comment>
	<decl_stmt><decl><type><name>TableConversionFunction</name></type> <name>function</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * suppressNoticeMessages determines if we want to suppress NOTICE
	 * messages that we explicitly issue
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>suppressNoticeMessages</name></decl>;</decl_stmt>
}</block></struct></type> <name>TableConversionState</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>TableConversionReturn</name> <modifier>*</modifier></type> <name>AlterDistributedTable</name><parameter_list>(<parameter><decl><type><name>TableConversionParameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableConversionReturn</name> <modifier>*</modifier></type> <name>AlterTableSetAccessMethod</name><parameter_list>(
	<parameter><decl><type><name>TableConversionParameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableConversionReturn</name> <modifier>*</modifier></type> <name>ConvertTable</name><parameter_list>(<parameter><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SwitchToSequentialAndLocalExecutionIfShardNameTooLong</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>,
																  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>longestShardName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropIndexesNotSupportedByColumnar</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name></type> <name>suppressNoticeMessages</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetIndexAccessMethodName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropConstraintRestrict</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DropIndexRestrict</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureTableNotReferencing</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>conversionType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureTableNotReferenced</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>conversionType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureTableNotForeign</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnsureTableNotPartition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableConversionState</name> <modifier>*</modifier></type> <name>CreateTableConversion</name><parameter_list>(<parameter><decl><type><name>TableConversionParameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateDistributedTableLike</name><parameter_list>(<parameter><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CreateCitusTableLike</name><parameter_list>(<parameter><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReplaceTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>justBeforeDropCommands</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>suppressNoticeMessages</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasAnyGeneratedStoredColumns</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetNonGeneratedStoredColumnNameList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckAlterDistributedTableConversionParameters</name><parameter_list>(<parameter><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>CreateWorkerChangeSequenceDependencyCommand</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceSchemaName</name></decl></parameter>,
														  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceName</name></decl></parameter>,
														  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceSchemaName</name></decl></parameter>,
														  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceName</name></decl></parameter>,
														  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetSchemaName</name></decl></parameter>,
														  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfMatViewSizeExceedsTheLimit</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>matViewOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>CreateMaterializedViewDDLCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>matViewOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>GetAccessMethodForMatViewIfExists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>WillRecreateForeignKeyToReferenceTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
												   <parameter><decl><type><name>CascadeToColocatedOption</name></type> <name>cascadeOption</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WarningsForDroppingForeignKeysWithDistributedTables</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfUnsupportedCascadeObjects</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DoesCascadeDropUnsupportedObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>nodeMap</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>undistribute_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>alter_distributed_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>alter_table_set_access_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>worker_change_sequence_dependency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* global variable keeping track of whether we are in a table type conversion function */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>InTableTypeConversionFunctionCall</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* controlled by GUC, in MB */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>MaxMatViewSizeToAutoRecreate</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * undistribute_table gets a distributed table name and
 * udistributes it.
 */</comment>
<function><type><name>Datum</name></type>
<name>undistribute_table</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>cascadeViaForeignKeys</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TableConversionParameters</name></type> <name>params</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>relationId</name> <operator>=</operator> <name>relationId</name></expr>,
		<expr><operator>.</operator><name>cascadeViaForeignKeys</name> <operator>=</operator> <name>cascadeViaForeignKeys</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>UndistributeTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * alter_distributed_table gets a distributed table and some other
 * parameters and alters some properties of the table according to
 * the parameters.
 */</comment>
<function><type><name>Datum</name></type>
<name>alter_distributed_table</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>distributionColumnText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>distributionColumn</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>distributionColumnText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>shardCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>shardCountIsNull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>shardCount</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>shardCountIsNull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colocateWith</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>colocateWithText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>colocateWith</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>colocateWithText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>CascadeToColocatedOption</name></type> <name>cascadeToColocated</name> <init>= <expr><name>CASCADE_TO_COLOCATED_UNSPECIFIED</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>true</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cascadeToColocated</name> <operator>=</operator> <name>CASCADE_TO_COLOCATED_YES</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>cascadeToColocated</name> <operator>=</operator> <name>CASCADE_TO_COLOCATED_NO</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>TableConversionParameters</name></type> <name>params</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>relationId</name> <operator>=</operator> <name>relationId</name></expr>,
		<expr><operator>.</operator><name>distributionColumn</name> <operator>=</operator> <name>distributionColumn</name></expr>,
		<expr><operator>.</operator><name>shardCountIsNull</name> <operator>=</operator> <name>shardCountIsNull</name></expr>,
		<expr><operator>.</operator><name>shardCount</name> <operator>=</operator> <name>shardCount</name></expr>,
		<expr><operator>.</operator><name>colocateWith</name> <operator>=</operator> <name>colocateWith</name></expr>,
		<expr><operator>.</operator><name>cascadeToColocated</name> <operator>=</operator> <name>cascadeToColocated</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AlterDistributedTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * alter_table_set_access_method gets a distributed table and an access
 * method and changes table's access method into that.
 */</comment>
<function><type><name>Datum</name></type>
<name>alter_table_set_access_method</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>accessMethodText</name> <init>= <expr><call><name>PG_GETARG_TEXT_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>accessMethod</name> <init>= <expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>accessMethodText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TableConversionParameters</name></type> <name>params</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>relationId</name> <operator>=</operator> <name>relationId</name></expr>,
		<expr><operator>.</operator><name>accessMethod</name> <operator>=</operator> <name>accessMethod</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AlterTableSetAccessMethod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * worker_change_sequence_dependency is a wrapper UDF for
 * changeDependencyFor function
 */</comment>
<function><type><name>Datum</name></type>
<name>worker_change_sequence_dependency</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sourceRelationOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>targetRelationOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>sequenceOid</name></expr></argument>,
						<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>sourceRelationOid</name></expr></argument>, <argument><expr><name>targetRelationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * UndistributeTable undistributes the given table. It uses ConvertTable function to
 * create a new local table and move everything to that table.
 *
 * The local tables, tables with references, partition tables and foreign tables are
 * not supported. The function gives errors in these cases.
 */</comment>
<function><type><name>TableConversionReturn</name> <modifier>*</modifier></type>
<name>UndistributeTable</name><parameter_list>(<parameter><decl><type><name>TableConversionParameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureRelationExists</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot undistribute table "</literal>
							   <literal type="string">"because the table is not distributed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>cascadeViaForeignKeys</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureTableNotReferencing</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>UNDISTRIBUTE_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EnsureTableNotReferenced</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>UNDISTRIBUTE_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureTableNotPartition</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * This is a less common pattern where foreing key is directly from/to
		 * the partition relation as we already handled inherited foreign keys
		 * on partitions either by erroring out or cascading via foreign keys.
		 * It seems an acceptable limitation for now to ask users to drop such
		 * foreign keys manually.
		 */</comment>
		<expr_stmt><expr><call><name>ErrorIfAnyPartitionRelationInvolvedInNonInheritedFKey</name><argument_list>(<argument><expr><name>partitionList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ErrorIfUnsupportedCascadeObjects</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>=</operator> <name>UNDISTRIBUTE_TABLE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>CreateTableConversion</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>ConvertTable</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterDistributedTable changes some properties of the given table. It uses
 * ConvertTable function to create a new local table and move everything to that table.
 *
 * The local and reference tables, tables with references, partition tables and foreign
 * tables are not supported. The function gives errors in these cases.
 */</comment>
<function><type><name>TableConversionReturn</name> <modifier>*</modifier></type>
<name>AlterDistributedTable</name><parameter_list>(<parameter><decl><type><name>TableConversionParameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureRelationExists</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter table because the table "</literal>
							   <literal type="string">"is not distributed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureTableNotForeign</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableNotPartition</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureHashDistributedTable</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ErrorIfUnsupportedCascadeObjects</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>=</operator> <name>ALTER_DISTRIBUTED_TABLE</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>CreateTableConversion</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CheckAlterDistributedTableConversionParameters</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>WillRecreateForeignKeyToReferenceTable</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"setting multi shard modify mode to sequential"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>ConvertTable</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterTableSetAccessMethod changes the access method of the given table. It uses
 * ConvertTable function to create a new table with the access method and move everything
 * to that table.
 *
 * The local and references tables, tables with references, partition tables and foreign
 * tables are not supported. The function gives errors in these cases.
 */</comment>
<function><type><name>TableConversionReturn</name> <modifier>*</modifier></type>
<name>AlterTableSetAccessMethod</name><parameter_list>(<parameter><decl><type><name>TableConversionParameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>EnsureRelationExists</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableOwner</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EnsureTableNotReferencing</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>ALTER_TABLE_SET_ACCESS_METHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableNotReferenced</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>ALTER_TABLE_SET_ACCESS_METHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnsureTableNotForeign</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnsureHashDistributedTable</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"you cannot alter access method of a partitioned table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><call><name>PartitionParentOid</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HasForeignKeyToReferenceTable</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"setting multi shard modify mode to sequential"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ErrorIfUnsupportedCascadeObjects</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>=</operator> <name>ALTER_TABLE_SET_ACCESS_METHOD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>CreateTableConversion</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>originalAccessMethod</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the access method of %s is already %s"</literal></expr></argument>,
							   <argument><expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name><name>con</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>ConvertTable</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConvertTable is used for converting a table into a new table with different properties.
 * The conversion is done by creating a new table, moving everything to the new table and
 * dropping the old one. So the oid of the table is not preserved.
 *
 * The new table will have the same name, columns and rows. It will also have partitions,
 * views, sequences of the old table. Finally it will have everything created by
 * GetPostLoadTableCreationCommands function, which include indexes. These will be
 * re-created during conversion, so their oids are not preserved either (except for
 * sequences). However, their names are preserved.
 *
 * The dropping of old table is done with CASCADE. Anything not mentioned here will
 * be dropped.
 *
 * The function returns a TableConversionReturn object that can stores variables that
 * can be used at the caller operations.
 *
 * To be able to provide more meaningful messages while converting a table type,
 * Citus keeps InTableTypeConversionFunctionCall flag. Don't forget to set it properly
 * in case you add a new way to return from this function.
 */</comment>
<function><type><name>TableConversionReturn</name> <modifier>*</modifier></type>
<name>ConvertTable</name><parameter_list>(<parameter><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>InTableTypeConversionFunctionCall</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We undistribute citus local tables that are not chained with any reference
	 * tables via foreign keys at the end of the utility hook.
	 * Here we temporarily set the related GUC to off to disable the logic for
	 * internally executed DDL's that might invoke this mechanism unnecessarily.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>oldEnableLocalReferenceForeignKeys</name> <init>= <expr><name>EnableLocalReferenceForeignKeys</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetLocalEnableLocalReferenceForeignKeys</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* switch to sequential execution if shard names will be too long */</comment>
	<expr_stmt><expr><call><name>SwitchToSequentialAndLocalExecutionIfRelationNameTooLong</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
															 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>==</operator> <name>UNDISTRIBUTE_TABLE</name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>cascadeViaForeignKeys</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>TableReferencing</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>TableReferenced</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Acquire ExclusiveLock as UndistributeTable does in order to
		 * make sure that no modifications happen on the relations.
		 */</comment>
		<expr_stmt><expr><call><name>CascadeOperationForFkeyConnectedRelations</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>,
												  <argument><expr><name>CASCADE_FKEY_UNDISTRIBUTE_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Undistributed every foreign key connected relation in our foreign key
		 * subgraph including itself, so return here.
		 */</comment>
		<expr_stmt><expr><call><name>SetLocalEnableLocalReferenceForeignKeys</name><argument_list>(<argument><expr><name>oldEnableLocalReferenceForeignKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>InTableTypeConversionFunctionCall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newAccessMethod</name> <init>= <expr><ternary><condition><expr><name><name>con</name><operator>-&gt;</operator><name>accessMethod</name></name></expr> ?</condition><then> <expr><name><name>con</name><operator>-&gt;</operator><name>accessMethod</name></name></expr> </then><else>:
							<expr><name><name>con</name><operator>-&gt;</operator><name>originalAccessMethod</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IncludeSequenceDefaults</name></type> <name>includeSequenceDefaults</name> <init>= <expr><name>NEXTVAL_SEQUENCE_DEFAULTS</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>preLoadCommands</name> <init>= <expr><call><name>GetPreLoadTableCreationCommands</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
															<argument><expr><name>includeSequenceDefaults</name></expr></argument>,
															<argument><expr><name>newAccessMethod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>, <argument><expr><literal type="string">"columnar"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DropIndexesNotSupportedByColumnar</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
										  <argument><expr><name><name>con</name><operator>-&gt;</operator><name>suppressNoticeMessages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since we already dropped unsupported indexes, we can safely pass
	 * includeIndexes to be true.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>includeIndexes</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>includeReplicaIdentity</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>postLoadCommands</name> <init>= <expr><call><name>GetPostLoadTableCreationCommands</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>,
															  <argument><expr><name>includeIndexes</name></expr></argument>,
															  <argument><expr><name>includeReplicaIdentity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>justBeforeDropCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>attachPartitionCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>postLoadCommands</name> <operator>=</operator>
		<call><name>list_concat</name><argument_list>(<argument><expr><name>postLoadCommands</name></expr></argument>,
					<argument><expr><call><name>GetViewCreationTableDDLCommandsOfTable</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>==</operator> <name>ALTER_DISTRIBUTED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>foreignKeyCommands</name> <operator>=</operator> <call><name>GetForeignConstraintToReferenceTablesCommands</name><argument_list>(
			<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_YES</name> <operator>||</operator>
			<name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_NO_ALREADY_CASCADED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyToDistributedTableCommands</name> <init>=
				<expr><call><name>GetForeignConstraintToDistributedTablesCommands</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>foreignKeyCommands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>foreignKeyCommands</name></expr></argument>,
											 <argument><expr><name>foreignKeyToDistributedTableCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeyFromDistributedTableCommands</name> <init>=
				<expr><call><name>GetForeignConstraintFromDistributedTablesCommands</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>foreignKeyCommands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>foreignKeyCommands</name></expr></argument>,
											 <argument><expr><name>foreignKeyFromDistributedTableCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>WarningsForDroppingForeignKeysWithDistributedTables</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>isPartitionTable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attachToParentCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>isPartitionTable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>detachFromParentCommand</name> <init>= <expr><call><name>GenerateDetachPartitionCommand</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>attachToParentCommand</name> <operator>=</operator> <call><name>GenerateAlterTableAttachPartitionCommand</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>justBeforeDropCommands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>justBeforeDropCommands</name></expr></argument>, <argument><expr><name>detachFromParentCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>suppressNoticeMessages</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"converting the partitions of %s"</literal></expr></argument>,
									<argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>schemaName</name></name></expr></argument>,
															   <argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>partitionList</name> <init>= <expr><call><name>PartitionList</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>partitionRelationId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_oid</name><argument_list>(<argument>partitionRelationId</argument>, <argument>partitionList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableQualifiedName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(
				<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>detachPartitionCommand</name> <init>= <expr><call><name>GenerateDetachPartitionCommand</name><argument_list>(
				<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attachPartitionCommand</name> <init>= <expr><call><name>GenerateAlterTableAttachPartitionCommand</name><argument_list>(
				<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We first detach the partitions to be able to convert them separately.
			 * After this they are no longer partitions, so they will not be caught by
			 * the checks.
			 */</comment>
			<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name>detachPartitionCommand</name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attachPartitionCommands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>attachPartitionCommands</name></expr></argument>,
											  <argument><expr><name>attachPartitionCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>CascadeToColocatedOption</name></type> <name>cascadeOption</name> <init>= <expr><name>CASCADE_TO_COLOCATED_NO</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_YES</name> <operator>||</operator>
				<name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_NO_ALREADY_CASCADED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cascadeOption</name> <operator>=</operator> <name>CASCADE_TO_COLOCATED_NO_ALREADY_CASCADED</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>TableConversionParameters</name></type> <name>partitionParam</name> <init>= <expr><block>{
				<expr><operator>.</operator><name>relationId</name> <operator>=</operator> <name>partitionRelationId</name></expr>,
				<expr><operator>.</operator><name>distributionColumn</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name></expr>,
				<expr><operator>.</operator><name>shardCountIsNull</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name></expr>,
				<expr><operator>.</operator><name>shardCount</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>shardCount</name></name></expr>,
				<expr><operator>.</operator><name>cascadeToColocated</name> <operator>=</operator> <name>cascadeOption</name></expr>,
				<expr><operator>.</operator><name>colocateWith</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr>,
				<expr><operator>.</operator><name>suppressNoticeMessages</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>suppressNoticeMessages</name></name></expr>,

				<comment type="block">/*
				 * Even if we called UndistributeTable with cascade option, we
				 * shouldn't cascade via foreign keys on partitions. Otherwise,
				 * we might try to undistribute partitions of other tables in
				 * our foreign key subgraph more than once.
				 */</comment>
				<expr><operator>.</operator><name>cascadeViaForeignKeys</name> <operator>=</operator> <name>false</name></expr>
			}</block></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>TableConversionReturn</name> <modifier>*</modifier></type><name>partitionReturn</name> <init>= <expr><call><name><name>con</name><operator>-&gt;</operator><name>function</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>partitionParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>cascadeOption</name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_NO_ALREADY_CASCADED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>foreignKeyCommands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>foreignKeyCommands</name></expr></argument>,
												 <argument><expr><name><name>partitionReturn</name><operator>-&gt;</operator><name>foreignKeyCommands</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>


			<comment type="block">/*
			 * If we are altering a partitioned distributed table by
			 * colocateWith:none, we override con-&gt;colocationWith parameter
			 * with the first newly created partition table to share the
			 * same colocation group for rest of partitions and partitioned
			 * table.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsColocateWithNone</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>=</operator> <name>tableQualifiedName</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>suppressNoticeMessages</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"creating a new table for %s"</literal></expr></argument>,
								<argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>schemaName</name></name></expr></argument>,
														   <argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>tableCreationCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>tableCreationCommand</argument>, <argument>preLoadCommands</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>tableCreationCommand</name></expr></argument>, <argument><expr><name>TableDDLCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableCreationSql</name> <init>= <expr><call><name>GetTableDDLCommand</name><argument_list>(<argument><expr><name>tableCreationCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name> <init>= <expr><call><name>ParseTreeNode</name><argument_list>(<argument><expr><name>tableCreationSql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RelayEventExtendNames</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>schemaName</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>hashOfName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ProcessUtilityParseTree</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>tableCreationSql</name></expr></argument>, <argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* set columnar options */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>originalAccessMethod</name></name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>originalAccessMethod</name></name></expr></argument>, <argument><expr><literal type="string">"columnar"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnarOptions</name></type> <name>options</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>extern_ReadColumnarOptions</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ColumnarTableDDLContext</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><operator>(</operator><name>ColumnarTableDDLContext</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnarTableDDLContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* build the context */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>schemaName</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>schemaName</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>relationName</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>relationName</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columnarOptionsSql</name> <init>= <expr><call><name>GetShardedTableDDLCommandColumnar</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>hashOfName</name></name></expr></argument>,
																	 <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name>columnarOptionsSql</name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>newRelationId</name></name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>tempName</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>schemaId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>==</operator> <name>ALTER_DISTRIBUTED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CreateDistributedTableLike</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>==</operator> <name>ALTER_TABLE_SET_ACCESS_METHOD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CreateCitusTableLike</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* preserve colocation with procedures/functions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>==</operator> <name>ALTER_DISTRIBUTED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Updating the colocationId of functions is always desirable for
		 * the following scenario:
		 *    we have shardCount or colocateWith change
		 *    AND  entire co-location group is altered
		 * The reason for the second condition is because we currently don't
		 * remember the original table specified in the colocateWith when
		 * distributing the function. We only remember the colocationId in
		 * pg_dist_object table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>||</operator> <name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_YES</name> <operator>||</operator> <call><name>list_length</name><argument_list>(
				 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocatedTableList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Update the colocationId from the one of the old relation to the one
			 * of the new relation for all tuples in citus.pg_dist_object
			 */</comment>
			<expr_stmt><expr><call><name>UpdateDistributedObjectColocationId</name><argument_list>(<argument><expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>TableColocationId</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>newRelationId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReplaceTable</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>newRelationId</name></name></expr></argument>, <argument><expr><name>justBeforeDropCommands</name></expr></argument>,
				 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>suppressNoticeMessages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TableDDLCommand</name> <modifier>*</modifier></type><name>tableConstructionCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>tableConstructionCommand</argument>, <argument>postLoadCommands</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusIsA</name><argument_list>(<argument><expr><name>tableConstructionCommand</name></expr></argument>, <argument><expr><name>TableDDLCommand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tableConstructionSQL</name> <init>= <expr><call><name>GetTableDDLCommand</name><argument_list>(<argument><expr><name>tableConstructionCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name>tableConstructionSQL</name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attachPartitionCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>attachPartitionCommand</argument>, <argument>attachPartitionCommands</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name> <init>= <expr><call><name>ParseTreeNode</name><argument_list>(<argument><expr><name>attachPartitionCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ProcessUtilityParseTree</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>attachPartitionCommand</name></expr></argument>,
								<argument><expr><name>PROCESS_UTILITY_QUERY</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>None_Receiver</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>isPartitionTable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name>attachToParentCommand</name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_YES</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* For now we only support cascade to colocation for alter_distributed_table UDF */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>==</operator> <name>ALTER_DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach_oid</name><argument_list>(<argument>colocatedTableId</argument>, <argument>con-&gt;colocatedTableList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>colocatedTableId</name> <operator>==</operator> <name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>schemaName</name></name></expr></argument>,
																	 <argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>TableConversionParameters</name></type> <name>cascadeParam</name> <init>= <expr><block>{
				<expr><operator>.</operator><name>relationId</name> <operator>=</operator> <name>colocatedTableId</name></expr>,
				<expr><operator>.</operator><name>shardCountIsNull</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name></expr>,
				<expr><operator>.</operator><name>shardCount</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>shardCount</name></name></expr>,
				<expr><operator>.</operator><name>colocateWith</name> <operator>=</operator> <name>qualifiedRelationName</name></expr>,
				<expr><operator>.</operator><name>cascadeToColocated</name> <operator>=</operator> <name>CASCADE_TO_COLOCATED_NO_ALREADY_CASCADED</name></expr>,
				<expr><operator>.</operator><name>suppressNoticeMessages</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>suppressNoticeMessages</name></name></expr>
			}</block></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TableConversionReturn</name> <modifier>*</modifier></type><name>colocatedReturn</name> <init>= <expr><call><name><name>con</name><operator>-&gt;</operator><name>function</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>cascadeParam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>foreignKeyCommands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>foreignKeyCommands</name></expr></argument>,
											 <argument><expr><name><name>colocatedReturn</name><operator>-&gt;</operator><name>foreignKeyCommands</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* recreate foreign keys */</comment>
	<decl_stmt><decl><type><name>TableConversionReturn</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>==</operator> <name>ALTER_DISTRIBUTED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>!=</operator> <name>CASCADE_TO_COLOCATED_NO_ALREADY_CASCADED</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>foreignKeyCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<macro><name>foreach_ptr</name><argument_list>(<argument>foreignKeyCommand</argument>, <argument>foreignKeyCommands</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name>foreignKeyCommand</name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableConversionReturn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>foreignKeyCommands</name></name> <operator>=</operator> <name>foreignKeyCommands</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* increment command counter so that next command can see the new table */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetLocalEnableLocalReferenceForeignKeys</name><argument_list>(<argument><expr><name>oldEnableLocalReferenceForeignKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>InTableTypeConversionFunctionCall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropIndexesNotSupportedByColumnar is a helper function used during accces
 * method conversion to drop the indexes that are not supported by columnarAM.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropIndexesNotSupportedByColumnar</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>suppressNoticeMessages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarRelation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexIdList</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Immediately close the relation since we might execute ALTER TABLE
	 * for that relation.
	 */</comment>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>indexId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>indexId</argument>, <argument>indexIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>indexAmName</name> <init>= <expr><call><name>GetIndexAccessMethodName</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>extern_ColumnarSupportsIndexAM</name><argument_list>(<argument><expr><name>indexAmName</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>suppressNoticeMessages</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported access method for index %s "</literal>
									<literal type="string">"on columnar table %s, given index and "</literal>
									<literal type="string">"the constraint depending on the index "</literal>
									<literal type="string">"(if any) will be dropped"</literal></expr></argument>,
									<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>constraintId</name> <init>= <expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* index is implied by a constraint, so drop the constraint itself */</comment>
			<expr_stmt><expr><call><name>DropConstraintRestrict</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>DropIndexRestrict</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * GetIndexAccessMethodName returns access method name of index with indexId.
 * If there is no such index, then errors out.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetIndexAccessMethodName</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* fetch pg_class tuple of the index relation */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>indexTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index with oid %u does not exist"</literal></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>indexForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>indexAMId</name> <init>= <expr><name><name>indexForm</name><operator>-&gt;</operator><name>relam</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>indexAmName</name> <init>= <expr><call><name>get_am_name</name><argument_list>(<argument><expr><name>indexAMId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>indexAmName</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"access method with oid %u does not exist"</literal></expr></argument>, <argument><expr><name>indexAMId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>indexAmName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DropConstraintRestrict drops the constraint with constraintId by using spi.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropConstraintRestrict</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>constraintId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>constraintName</name> <init>= <expr><call><name>get_constraint_name</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedConstraintName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>dropConstraintCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dropConstraintCommand</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s DROP CONSTRAINT %s RESTRICT;"</literal></expr></argument>,
					 <argument><expr><name>qualifiedRelationName</name></expr></argument>, <argument><expr><name>quotedConstraintName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name><name>dropConstraintCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DropIndexRestrict drops the index with indexId by using spi.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DropIndexRestrict</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedIndexName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>dropIndexCommand</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>dropIndexCommand</name></expr></argument>, <argument><expr><literal type="string">"DROP INDEX %s RESTRICT;"</literal></expr></argument>, <argument><expr><name>qualifiedIndexName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name><name>dropIndexCommand</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureTableNotReferencing checks if the table has a reference to another
 * table and errors if it is.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureTableNotReferencing</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>conversionType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TableReferencing</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>conversionType</name> <operator>==</operator> <name>UNDISTRIBUTE_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot complete operation "</literal>
								   <literal type="string">"because table %s has a foreign key"</literal></expr></argument>,
								   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><name>UNDISTRIBUTE_TABLE_CASCADE_HINT</name></expr></argument>,
									<argument><expr><name>qualifiedRelationName</name></expr></argument>,
									<argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot complete operation "</literal>
								   <literal type="string">"because table %s has a foreign key"</literal></expr></argument>,
								   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureTableNotReferenced checks if the table is referenced by another
 * table and errors if it is.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureTableNotReferenced</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>conversionType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>TableReferenced</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>conversionType</name> <operator>==</operator> <name>UNDISTRIBUTE_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedRelationName</name> <init>= <expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot complete operation "</literal>
								   <literal type="string">"because table %s is referenced by a foreign key"</literal></expr></argument>,
								   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><name>UNDISTRIBUTE_TABLE_CASCADE_HINT</name></expr></argument>,
									<argument><expr><name>qualifiedRelationName</name></expr></argument>,
									<argument><expr><name>qualifiedRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot complete operation "</literal>
								   <literal type="string">"because table %s is referenced by a foreign key"</literal></expr></argument>,
								   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureTableNotForeign checks if the table is a foreign table and errors
 * if it is.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureTableNotForeign</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot complete operation "</literal>
							   <literal type="string">"because it is a foreign table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * EnsureTableNotPartition checks if the table is a partition of another
 * table and errors if it is.
 */</comment>
<function><type><name>void</name></type>
<name>EnsureTableNotPartition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parentRelationName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot complete operation "</literal>
							   <literal type="string">"because table is a partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"the parent table is \"%s\""</literal></expr></argument>,
								<argument><expr><name>parentRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>TableConversionState</name> <modifier>*</modifier></type>
<name>CreateTableConversion</name><parameter_list>(<parameter><decl><type><name>TableConversionParameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TableConversionState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>conversionType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>relationId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>distributionColumn</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>shardCountIsNull</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>shardCount</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>shardCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>colocateWith</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>accessMethod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>cascadeToColocated</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>cascadeViaForeignKeys</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>cascadeViaForeignKeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>suppressNoticeMessages</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>suppressNoticeMessages</name></name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot complete operation "</literal>
							   <literal type="string">"because no such table exists"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>relationDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>RelationUsesIdentityColumns</name><argument_list>(<argument><expr><name>relationDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * pg_get_tableschemadef_string doesn't know how to deparse identity
		 * columns so we cannot reflect those columns when creating table
		 * from scratch. For this reason, error out here.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot complete command because relation "</literal>
							   <literal type="string">"%s has identity column"</literal></expr></argument>,
							   <argument><expr><call><name>generate_qualified_relation_name</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Drop the identity columns and re-try the command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator>
		<call><name>BuildDistributionKeyFromColumnName</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name></expr></argument>,
										   <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>originalAccessMethod</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsForeignTable</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>amTuple</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(
												<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>amTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cache lookup failed for access method %d"</literal></expr></argument>,
								   <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>Form_pg_am</name></type> <name>amForm</name> <init>= <expr><operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>amTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>originalAccessMethod</name></name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>amForm</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>amTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>colocatedTableList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>originalDistributionKey</name></name> <operator>=</operator> <call><name>DistPartitionKey</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>cacheEntry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>originalShardCount</name></name> <operator>=</operator> <name><name>cacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><call><name>ColocatedTableList</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * we will not add partition tables to the colocatedTableList
		 * since they will be handled separately.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_oid</name><argument_list>(<argument>colocatedTableId</argument>, <argument>colocatedTableList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>PartitionTable</name><argument_list>(<argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>colocatedTableList</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocatedTableList</name></name></expr></argument>,
												  <argument><expr><name>colocatedTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* sort the oids to avoid deadlock */</comment>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>colocatedTableList</name></name> <operator>=</operator> <call><name>SortList</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocatedTableList</name></name></expr></argument>, <argument><expr><name>CompareOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* find relation and schema names */</comment>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>relationName</name></name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>schemaId</name></name> <operator>=</operator> <call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>schemaName</name></name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>schemaId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* calculate a temp name for the new table */</comment>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>tempName</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>hashOfName</name></name> <operator>=</operator> <call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>tempName</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>tempName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AppendShardIdToName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>tempName</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>hashOfName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>==</operator> <name>UNDISTRIBUTE_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>function</name></name> <operator>=</operator> <operator>&amp;</operator><name>UndistributeTable</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>==</operator> <name>ALTER_DISTRIBUTED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>function</name></name> <operator>=</operator> <operator>&amp;</operator><name>AlterDistributedTable</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>conversionType</name></name> <operator>==</operator> <name>ALTER_TABLE_SET_ACCESS_METHOD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>function</name></name> <operator>=</operator> <operator>&amp;</operator><name>AlterTableSetAccessMethod</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>con</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateDistributedTableLike distributes the new table in con parameter
 * like the old one. It checks the distribution column, colocation and
 * shard count and if they are not changed sets them to the old table's values.
 */</comment>
<function><type><name>void</name></type>
<name>CreateDistributedTableLike</name><parameter_list>(<parameter><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>newDistributionKey</name> <init>=
		<expr><ternary><condition><expr><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name></expr> ?</condition><then> <expr><name><name>con</name><operator>-&gt;</operator><name>distributionKey</name></name></expr> </then><else>: <expr><name><name>con</name><operator>-&gt;</operator><name>originalDistributionKey</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newColocateWith</name> <init>= <expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the new distribution column and the old one have the same data type
		 * and the shard_count parameter is null (which means shard count will not
		 * change) we can create the new table in the same colocation as the old one.
		 * In this case we set the new table's colocate_with value as the old table
		 * so we don't even change the colocation id of the table during conversion.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>originalDistributionKey</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>newDistributionKey</name><operator>-&gt;</operator><name>vartype</name></name> <operator>&amp;&amp;</operator>
			<name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newColocateWith</name> <operator>=</operator>
				<call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>schemaName</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newColocateWith</name> <operator>=</operator> <literal type="string">"default"</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>newShardCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newShardCount</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>originalShardCount</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>newShardCount</name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>shardCount</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * To get the correct column name, we use the original relation id, not the
	 * new relation id. The reason is that the cached attributes of the original
	 * and newly created tables are not the same if the original table has
	 * dropped columns (dropped columns are still present in the attribute cache)
	 * Detailed example in https://github.com/citusdata/citus/pull/6387
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>distributionColumnName</name> <init>=
		<expr><call><name>ColumnToColumnName</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newDistributionKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>originalRelationId</name> <init>= <expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>originalDistributionKey</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>PartitionTable</name><argument_list>(<argument><expr><name>originalRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Due to dropped columns, the partition tables might have different
		 * distribution keys than their parents, see issue #5123 for details.
		 *
		 * At this point, we get the partitioning information from the
		 * originalRelationId, but we get the distribution key for newRelationId.
		 *
		 * We have to do this, because the newRelationId is just a placeholder
		 * at this moment, but that's going to be the table in pg_dist_partition.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>parentRelationId</name> <init>= <expr><call><name>PartitionParentOid</name><argument_list>(<argument><expr><name>originalRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>parentDistKey</name> <init>= <expr><call><name>DistPartitionKeyOrError</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>distributionColumnName</name> <operator>=</operator>
			<call><name>ColumnToColumnName</name><argument_list>(<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parentDistKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>partitionMethod</name> <init>= <expr><call><name>PartitionMethod</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CreateDistributedTable</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>newRelationId</name></name></expr></argument>, <argument><expr><name>distributionColumnName</name></expr></argument>, <argument><expr><name>partitionMethod</name></expr></argument>,
						   <argument><expr><name>newShardCount</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>newColocateWith</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateCitusTableLike converts the new table to the Citus table type
 * of the old table.
 */</comment>
<function><type><name>void</name></type>
<name>CreateCitusTableLike</name><parameter_list>(<parameter><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CreateDistributedTableLike</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>REFERENCE_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CreateDistributedTable</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>newRelationId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DISTRIBUTE_BY_NONE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>, <argument><expr><name>CITUS_LOCAL_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>autoConverted</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>autoConverted</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>cascade</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>CreateCitusLocalTable</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>newRelationId</name></name></expr></argument>, <argument><expr><name>cascade</name></expr></argument>, <argument><expr><name>autoConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * creating Citus local table adds a shell table on top
		 * so we need its oid now
		 */</comment>
		<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>newRelationId</name></name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>tempName</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>schemaId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfUnsupportedCascadeObjects gets oid of a relation, finds the objects
 * that dropping this relation cascades into and errors if there are any extensions
 * that would be dropped.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfUnsupportedCascadeObjects</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>nodeMap</name> <init>= <expr><call><name>CreateSimpleHashSetWithName</name><argument_list>(<argument><expr><name>Oid</name></expr></argument>, <argument><expr><literal type="string">"object dependency map (oid)"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>unsupportedObjectInDepGraph</name> <init>=
		<expr><call><name>DoesCascadeDropUnsupportedObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>nodeMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>unsupportedObjectInDepGraph</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot alter table because an extension depends on it"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DoesCascadeDropUnsupportedObject walks through the objects that depend on the
 * object with object id and returns true if it finds any unsupported objects.
 *
 * This function only checks extensions as unsupported objects.
 *
 * Extension dependency is different than the rest. If an object depends on an extension
 * dropping the object would drop the extension too.
 * So we check with IsAnyObjectAddressOwnedByExtension function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DoesCascadeDropUnsupportedObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>nodeMap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>nodeMap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>objectId</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>objectAddress</name></expr></argument>, <argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsAnyObjectAddressOwnedByExtension</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>targetObjectClassId</name> <init>= <expr><name>classId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>targetObjectId</name> <init>= <expr><name>objectId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dependencyTupleList</name> <init>= <expr><call><name>GetPgDependTuplesForDependingObjects</name><argument_list>(<argument><expr><name>targetObjectClassId</name></expr></argument>,
																	 <argument><expr><name>targetObjectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>depTup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>depTup</argument>, <argument>dependencyTupleList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pg_depend</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>depTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>dependingOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>dependingClassId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name> <operator>==</operator> <name>RewriteRelationId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dependingOid</name> <operator>=</operator> <call><name>GetDependingView</name><argument_list>(<argument><expr><name>pg_depend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dependingClassId</name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>dependingOid</name> <operator>=</operator> <name><name>pg_depend</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dependingClassId</name> <operator>=</operator> <name><name>pg_depend</name><operator>-&gt;</operator><name>classid</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>DoesCascadeDropUnsupportedObject</name><argument_list>(<argument><expr><name>dependingClassId</name></expr></argument>, <argument><expr><name>dependingOid</name></expr></argument>, <argument><expr><name>nodeMap</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetViewCreationCommandsOfTable takes a table oid generates the CREATE VIEW
 * commands for views that depend to the given table. This includes the views
 * that recursively depend on the table too.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetViewCreationCommandsOfTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>views</name> <init>= <expr><call><name>GetDependingViews</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>viewOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>viewOid</argument>, <argument>views</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>query</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* See comments on CreateMaterializedViewDDLCommand for its limitations */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ErrorIfMatViewSizeExceedsTheLimit</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>matViewCreateCommands</name> <init>= <expr><call><name>CreateMaterializedViewDDLCommand</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>matViewCreateCommands</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewCreateCommand</name> <init>= <expr><call><name>CreateViewDDLCommand</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>viewCreateCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alterViewCommmand</name> <init>= <expr><call><name>AlterViewOwnerCommand</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>alterViewCommmand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>commands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetViewCreationTableDDLCommandsOfTable is the same as GetViewCreationCommandsOfTable,
 * but the returned list includes objects of TableDDLCommand's, not strings.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetViewCreationTableDDLCommandsOfTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>GetViewCreationCommandsOfTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tableDDLCommands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>command</argument>, <argument>commands</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>tableDDLCommands</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tableDDLCommands</name></expr></argument>, <argument><expr><call><name>makeTableDDLCommandString</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>tableDDLCommands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfMatViewSizeExceedsTheLimit takes the oid of a materialized view and errors
 * out if the size of the matview exceeds the limit set by the GUC
 * citus.max_matview_size_to_auto_recreate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfMatViewSizeExceedsTheLimit</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>matViewOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MaxMatViewSizeToAutoRecreate</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if it's below 0, it means the user has removed the limit */</comment>
		<decl_stmt><decl><type><name>Datum</name></type> <name>relSizeDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_total_relation_size</name></expr></argument>,
												 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>matViewOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>matViewSize</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>relSizeDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* convert from MB to bytes */</comment>
		<decl_stmt><decl><type><name>uint64</name></type> <name>limitSizeInBytes</name> <init>= <expr><name>MaxMatViewSizeToAutoRecreate</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>matViewSize</name> <operator>&gt;</operator> <name>limitSizeInBytes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"size of the materialized view %s exceeds "</literal>
								   <literal type="string">"citus.max_matview_size_to_auto_recreate "</literal>
								   <literal type="string">"(currently %d MB)"</literal></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>matViewOid</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>MaxMatViewSizeToAutoRecreate</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Citus restricts automatically recreating "</literal>
									  <literal type="string">"materialized views that are larger than the "</literal>
									  <literal type="string">"limit, because it could take too long."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(
								<argument><expr><literal type="string">"Consider increasing the size limit by setting "</literal>
								<literal type="string">"citus.max_matview_size_to_auto_recreate; "</literal>
								<literal type="string">"or you can remove the limit by setting it to -1"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateMaterializedViewDDLCommand creates the command to create materialized view.
 * Note that this function doesn't support
 * - Aliases
 * - Storage parameters
 * - Tablespace
 * - WITH [NO] DATA
 * options for the given materialized view. Parser functions for materialized views
 * should be added to handle them.
 *
 * Related issue: https://github.com/citusdata/citus/issues/5968
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateMaterializedViewDDLCommand</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>matViewOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>query</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>matViewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>matViewOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedViewName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>viewName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* here we need to get the access method of the view to recreate it */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>accessMethodName</name> <init>= <expr><call><name>GetAccessMethodForMatViewIfExists</name><argument_list>(<argument><expr><name>matViewOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"CREATE MATERIALIZED VIEW %s "</literal></expr></argument>, <argument><expr><name>qualifiedViewName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>accessMethodName</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"USING %s "</literal></expr></argument>, <argument><expr><name>accessMethodName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set search_path to NIL so that all objects outside of pg_catalog will be
	 * schema-prefixed.
	 */</comment>
	<decl_stmt><decl><type><name>OverrideSearchPath</name> <modifier>*</modifier></type><name>overridePath</name> <init>= <expr><call><name>GetOverrideSearchPath</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>overridePath</name><operator>-&gt;</operator><name>schemas</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>overridePath</name><operator>-&gt;</operator><name>addCatalog</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PushOverrideSearchPath</name><argument_list>(<argument><expr><name>overridePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Push the transaction snapshot to be able to get vief definition with pg_get_viewdef
	 */</comment>
	<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>viewDefinitionDatum</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>pg_get_viewdef</name></expr></argument>,
													<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>matViewOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>viewDefinition</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>viewDefinitionDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PopOverrideSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"AS %s"</literal></expr></argument>, <argument><expr><name>viewDefinition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReplaceTable replaces the source table with the target table.
 * It moves all the rows of the source table to target table with INSERT SELECT.
 * Changes the dependencies of the sequences owned by source table to target table.
 * Then drops the source table and renames the target table to source tables name.
 *
 * Source and target tables need to be in the same schema and have the same columns.
 */</comment>
<function><type><name>void</name></type>
<name>ReplaceTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>sourceId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>targetId</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>justBeforeDropCommands</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>suppressNoticeMessages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sourceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>targetName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>targetId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>schemaId</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>sourceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>schemaId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>query</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>sourceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>sourceId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>suppressNoticeMessages</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"moving the data of %s"</literal></expr></argument>,
									<argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HasAnyGeneratedStoredColumns</name><argument_list>(<argument><expr><name>sourceId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Relation has no GENERATED STORED columns, copy the table via plain
			 * "INSERT INTO .. SELECT *"".
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s SELECT * FROM %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Skip columns having GENERATED ALWAYS AS (...) STORED expressions
			 * since Postgres doesn't allow inserting into such columns.
			 * This is not bad since Postgres would already generate such columns.
			 * Note that here we intentionally don't skip columns having DEFAULT
			 * expressions since user might have inserted non-default values.
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nonStoredColumnNameList</name> <init>= <expr><call><name>GetNonGeneratedStoredColumnNameList</name><argument_list>(<argument><expr><name>sourceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>insertColumnString</name> <init>= <expr><call><name>StringJoin</name><argument_list>(<argument><expr><name>nonStoredColumnNameList</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO %s (%s) SELECT %s FROM %s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>insertColumnString</name></expr></argument>, <argument><expr><name>insertColumnString</name></expr></argument>,
							 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>SPI_OK_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ownedSequences</name> <init>= <expr><call><name>getOwnedSequences</name><argument_list>(<argument><expr><name>sourceId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>sequenceOid</argument>, <argument>ownedSequences</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>changeDependencyFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>sequenceOid</name></expr></argument>,
							<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>sourceId</name></expr></argument>, <argument><expr><name>targetId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Skip if we cannot sync metadata for target table.
		 * Checking only for the target table is sufficient since we will
		 * anyway drop the source table even if it was a Citus table that
		 * has metadata on MX workers.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>targetId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>sequenceSchemaOid</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>sequenceSchemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>sequenceOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>workerChangeSequenceDependencyCommand</name> <init>=
				<expr><call><name>CreateWorkerChangeSequenceDependencyCommand</name><argument_list>(<argument><expr><name>sequenceSchemaName</name></expr></argument>,
															<argument><expr><name>sequenceName</name></expr></argument>,
															<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>,
															<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name>workerChangeSequenceDependencyCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>ShouldSyncTableMetadata</name><argument_list>(<argument><expr><name>sourceId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedTableName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We are converting a citus local table to a distributed/reference table,
			 * so we should prevent dropping the sequence on the table. Otherwise, we'd
			 * lose track of the previous changes in the sequence.
			 */</comment>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>command</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>,
							 <argument><expr><literal type="string">"SELECT pg_catalog.worker_drop_sequence_dependency(%s);"</literal></expr></argument>,
							 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedTableName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SendCommandToWorkersWithMetadata</name><argument_list>(<argument><expr><name><name>command</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>justBeforeDropCommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>justBeforeDropCommand</argument>, <argument>justBeforeDropCommands</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name>justBeforeDropCommand</name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>suppressNoticeMessages</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dropping the old %s"</literal></expr></argument>,
								<argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"DROP %sTABLE %s CASCADE"</literal></expr></argument>,
					 <argument><expr><ternary><condition><expr><call><name>IsForeignTable</name><argument_list>(<argument><expr><name>sourceId</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"FOREIGN "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>suppressNoticeMessages</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"renaming the new table to %s"</literal></expr></argument>,
								<argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"ALTER TABLE %s RENAME TO %s"</literal></expr></argument>,
					 <argument><expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>schemaName</name></expr></argument>, <argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>sourceName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>SPI_OK_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * HasAnyGeneratedStoredColumns decides if relation has any columns that we
 * might need to copy the data of when replacing table.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasAnyGeneratedStoredColumns</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>GetNonGeneratedStoredColumnNameList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetNonGeneratedStoredColumnNameList returns a list of column names for
 * columns not having GENERATED ALWAYS AS (...) STORED expressions.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetNonGeneratedStoredColumnNameList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nonStoredColumnNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>currentColumn</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip dropped columns */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>==</operator> <name>ATTRIBUTE_GENERATED_STORED</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quotedColumnName</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>currentColumn</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>nonStoredColumnNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nonStoredColumnNameList</name></expr></argument>,
										  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>quotedColumnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nonStoredColumnNameList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckAlterDistributedTableConversionParameters errors for the cases where
 * alter_distributed_table UDF wouldn't work.
 */</comment>
<function><type><name>void</name></type>
<name>CheckAlterDistributedTableConversionParameters</name><parameter_list>(<parameter><decl><type><name>TableConversionState</name> <modifier>*</modifier></type><name>con</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Changing nothing is not allowed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>&amp;&amp;</operator>
		<name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>!=</operator> <name>CASCADE_TO_COLOCATED_YES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"you have to specify at least one of the "</literal>
							   <literal type="string">"distribution_column, shard_count or "</literal>
							   <literal type="string">"colocate_with parameters"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check if the parameters in this conversion are given and same with table's properties */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>sameDistColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>equal</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>distributionKey</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>originalDistributionKey</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sameDistColumn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>sameShardCount</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>originalShardCount</name></name> <operator>==</operator> <name><name>con</name><operator>-&gt;</operator><name>shardCount</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sameShardCount</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>sameColocateWith</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check if already colocated with colocate_with */</comment>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>colocateWithText</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocateWithTableOid</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>colocateWithText</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_oid</name><argument_list>(<argument>colocatedTableOid</argument>, <argument>con-&gt;colocatedTableList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>colocateWithTableOid</name> <operator>==</operator> <name>colocatedTableOid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>sameColocateWith</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * already found colocateWithTableOid so let's check if
		 * colocate_with table is a distributed table
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTableType</name><argument_list>(<argument><expr><name>colocateWithTableOid</name></expr></argument>, <argument><expr><name>DISTRIBUTED_TABLE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate with %s because "</literal>
								   <literal type="string">"it is not a distributed table"</literal></expr></argument>,
								   <argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* shard_count:=0 is not allowed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>shardCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard_count cannot be 0"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"if you no longer want this to be a "</literal>
								<literal type="string">"distributed table you can try "</literal>
								<literal type="string">"undistribute_table() function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_YES</name> <operator>&amp;&amp;</operator>
		<name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution_column cannot be "</literal>
							   <literal type="string">"cascaded to colocated tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_YES</name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>&amp;&amp;</operator>
		<name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard_count or colocate_with is necessary "</literal>
							   <literal type="string">"for cascading to colocated tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if every parameter is either not given or already the
	 * same then give error
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sameDistColumn</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>||</operator> <name>sameShardCount</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sameColocateWith</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"this call doesn't change any properties of the table"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"check citus_tables view to see current "</literal>
								<literal type="string">"properties of the table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_YES</name> <operator>&amp;&amp;</operator>
		<name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"colocate_with := 'none' cannot be "</literal>
							   <literal type="string">"cascaded to colocated tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>colocatedTableCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocatedTableList</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>colocatedTableCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>sameShardCount</name> <operator>&amp;&amp;</operator>
		<name><name>con</name><operator>-&gt;</operator><name>cascadeToColocated</name></name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_UNSPECIFIED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cascade_to_colocated parameter is necessary"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"this table is colocated with some other tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"cascade_to_colocated := false will break the "</literal>
								<literal type="string">"current colocation, cascade_to_colocated := true "</literal>
								<literal type="string">"will change the shard count of colocated tables "</literal>
								<literal type="string">"too."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>, <argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>colocateWithText</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocateWithTableOid</name> <init>= <expr><call><name>ResolveRelationId</name><argument_list>(<argument><expr><name>colocateWithText</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CitusTableCacheEntry</name> <modifier>*</modifier></type><name>colocateWithTableCacheEntry</name> <init>=
			<expr><call><name>GetCitusTableCacheEntry</name><argument_list>(<argument><expr><name>colocateWithTableOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>colocateWithTableShardCount</name> <init>=
			<expr><name><name>colocateWithTableCacheEntry</name><operator>-&gt;</operator><name>shardIntervalArrayLength</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>&amp;&amp;</operator> <name><name>con</name><operator>-&gt;</operator><name>shardCount</name></name> <operator>!=</operator> <name>colocateWithTableShardCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard_count cannot be different than the shard "</literal>
								   <literal type="string">"count of the table in colocate_with"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"if no shard_count is specified shard count "</literal>
									<literal type="string">"will be same with colocate_with table's"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>colocateWithTableShardCount</name> <operator>!=</operator> <name><name>con</name><operator>-&gt;</operator><name>originalShardCount</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * shardCount is either 0 or already same with colocateWith table's
			 * It's ok to set shardCountIsNull to false because we assume giving a table
			 * to colocate with and no shard count is the same with giving colocate_with
			 * table's shard count if it is different than the original.
			 * So it is almost like the shard_count parameter was given by the user.
			 */</comment>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>shardCount</name></name> <operator>=</operator> <name>colocateWithTableShardCount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>shardCountIsNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>colocateWithPartKey</name> <init>= <expr><call><name>DistPartitionKey</name><argument_list>(<argument><expr><name>colocateWithTableOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>colocateWithPartKey</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* this should never happen */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate %s with %s because %s doesn't have a "</literal>
								   <literal type="string">"distribution column"</literal></expr></argument>,
								   <argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>,
								   <argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name> <operator>&amp;&amp;</operator>
				 <name><name>colocateWithPartKey</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name><name>con</name><operator>-&gt;</operator><name>distributionKey</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate with %s and change distribution "</literal>
								   <literal type="string">"column to %s because data type of column %s is "</literal>
								   <literal type="string">"different then the distribution column of the %s"</literal></expr></argument>,
								   <argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name></expr></argument>,
								   <argument><expr><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name> <operator>&amp;&amp;</operator>
				 <name><name>colocateWithPartKey</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name><name>con</name><operator>-&gt;</operator><name>originalDistributionKey</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot colocate with %s because data type of its "</literal>
								   <literal type="string">"distribution column is different than %s"</literal></expr></argument>,
								   <argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>suppressNoticeMessages</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Notices for no operation UDF calls */</comment>
		<if_stmt><if>if <condition>(<expr><name>sameDistColumn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table is already distributed by %s"</literal></expr></argument>,
									<argument><expr><name><name>con</name><operator>-&gt;</operator><name>distributionColumn</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>sameShardCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard count of the table is already %d"</literal></expr></argument>,
									<argument><expr><name><name>con</name><operator>-&gt;</operator><name>shardCount</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>sameColocateWith</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table is already colocated with %s"</literal></expr></argument>,
									<argument><expr><name><name>con</name><operator>-&gt;</operator><name>colocateWith</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateWorkerChangeSequenceDependencyCommand creates and returns a
 * worker_change_sequence_dependency query with the parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>CreateWorkerChangeSequenceDependencyCommand</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceSchemaName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sequenceName</name></decl></parameter>,
											<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceSchemaName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourceName</name></decl></parameter>,
											<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetSchemaName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedSchemaName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>sequenceSchemaName</name></expr></argument>,
														   <argument><expr><name>sequenceName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedSourceName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>sourceSchemaName</name></expr></argument>, <argument><expr><name>sourceName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qualifiedTargetName</name> <init>= <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>targetSchemaName</name></expr></argument>, <argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>query</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="string">"SELECT worker_change_sequence_dependency(%s, %s, %s)"</literal></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedSchemaName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedSourceName</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>qualifiedTargetName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>query</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetAccessMethodForMatViewIfExists returns if there's an access method
 * set to the view with the given oid. Returns NULL otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetAccessMethodForMatViewIfExists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>viewOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>accessMethodName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>relation</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot complete operation "</literal>
							   <literal type="string">"because no such view exists"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>accessMethodOid</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>accessMethodOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>accessMethodName</name> <operator>=</operator> <call><name>get_am_name</name><argument_list>(<argument><expr><name>accessMethodOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>accessMethodName</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WillRecreateForeignKeyToReferenceTable checks if the table of relationId has any foreign
 * key to a reference table, if conversion will be cascaded to colocated table this function
 * also checks if any of the colocated tables have a foreign key to a reference table too
 */</comment>
<function><type><name>bool</name></type>
<name>WillRecreateForeignKeyToReferenceTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
									   <parameter><decl><type><name>CascadeToColocatedOption</name></type> <name>cascadeOption</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>cascadeOption</name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_NO</name> <operator>||</operator>
		<name>cascadeOption</name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_UNSPECIFIED</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>HasForeignKeyToReferenceTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>cascadeOption</name> <operator>==</operator> <name>CASCADE_TO_COLOCATED_YES</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colocatedTableList</name> <init>= <expr><call><name>ColocatedTableList</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>colocatedTableOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_oid</name><argument_list>(<argument>colocatedTableOid</argument>, <argument>colocatedTableList</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>HasForeignKeyToReferenceTable</name><argument_list>(<argument><expr><name>colocatedTableOid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WarningsForDroppingForeignKeysWithDistributedTables gives warnings for the
 * foreign keys that will be dropped because formerly colocated distributed tables
 * are not colocated.
 */</comment>
<function><type><name>void</name></type>
<name>WarningsForDroppingForeignKeysWithDistributedTables</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>INCLUDE_REFERENCING_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_DISTRIBUTED_TABLES</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencingForeingKeys</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>INCLUDE_REFERENCED_CONSTRAINTS</name> <operator>|</operator> <name>INCLUDE_DISTRIBUTED_TABLES</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>referencedForeignKeys</name> <init>= <expr><call><name>GetForeignKeyOids</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>foreignKeys</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>referencingForeingKeys</name></expr></argument>, <argument><expr><name>referencedForeignKeys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>foreignKeyOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>foreignKeyOid</argument>, <argument>foreignKeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key %s will be dropped"</literal></expr></argument>,
								 <argument><expr><call><name>get_constraint_name</name><argument_list>(<argument><expr><name>foreignKeyOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteQueryViaSPI connects to SPI, executes the query and checks if it
 * returned the OK value and finishes the SPI connection
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteQueryViaSPI</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>SPIOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>spiResult</name> <init>= <expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>spiResult</name> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to SPI manager"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>spiResult</name> <operator>=</operator> <call><name>SPI_execute</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>spiResult</name> <operator>!=</operator> <name>SPIOK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not run SPI query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>spiResult</name> <operator>=</operator> <call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>spiResult</name> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not finish SPI connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExecuteAndLogQueryViaSPI is a wrapper around ExecuteQueryViaSPI, that logs
 * the query to be executed, with the given log level.
 */</comment>
<function><type><name>void</name></type>
<name>ExecuteAndLogQueryViaSPI</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>SPIOK</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>logLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>logLevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"executing \"%s\""</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecuteQueryViaSPI</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>SPIOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SwitchToSequentialAndLocalExecutionIfRelationNameTooLong generates the longest shard name
 * on the shards of a distributed table, and if exceeds the limit switches to sequential and
 * local execution to prevent self-deadlocks.
 *
 * In case of a RENAME, the relation name parameter should store the new table name, so
 * that the function can generate shard names of the renamed relations
 */</comment>
<function><type><name>void</name></type>
<name>SwitchToSequentialAndLocalExecutionIfRelationNameTooLong</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
														 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>finalRelationName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ShardIntervalCount</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Relation has no shards, so we cannot run into "long shard relation
		 * name" issue.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>longestShardName</name> <init>= <expr><call><name>GetLongestShardName</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>finalRelationName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>switchedToSequentialAndLocalExecution</name> <init>=
		<expr><call><name>SwitchToSequentialAndLocalExecutionIfShardNameTooLong</name><argument_list>(<argument><expr><name>finalRelationName</name></expr></argument>,
															  <argument><expr><name>longestShardName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>switchedToSequentialAndLocalExecution</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PartitionedTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>longestNamePartitionId</name> <init>= <expr><call><name>PartitionWithLongestNameRelationId</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no partitions have been created yet */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>longestPartitionName</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>longestPartitionShardName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Use the shardId values of the partition if it is distributed, otherwise use
		 * hypothetical values
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsCitusTable</name><argument_list>(<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>ShardIntervalCount</name><argument_list>(<argument><expr><name>longestNamePartitionId</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>longestPartitionShardName</name> <operator>=</operator>
				<call><name>GetLongestShardName</name><argument_list>(<argument><expr><name>longestNamePartitionId</name></expr></argument>, <argument><expr><name>longestPartitionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>longestPartitionShardName</name> <operator>=</operator>
				<call><name>GetLongestShardNameForLocalPartition</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>longestPartitionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>SwitchToSequentialAndLocalExecutionIfShardNameTooLong</name><argument_list>(<argument><expr><name>longestPartitionName</name></expr></argument>,
															  <argument><expr><name>longestPartitionShardName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SwitchToSequentialAndLocalExecutionIfShardNameTooLong switches to sequential and local
 * execution if the shard name is too long.
 *
 * returns true if switched to sequential and local execution.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SwitchToSequentialAndLocalExecutionIfShardNameTooLong</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>,
													  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>longestShardName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>longestShardName</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ParallelQueryExecutedInTransaction</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there has already been a parallel query executed, the sequential mode
			 * would still use the already opened parallel connections to the workers,
			 * thus contradicting our purpose of using sequential mode.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"Shard name (%s) for table (%s) is too long and could "</literal>
								<literal type="string">"lead to deadlocks when executed in a transaction "</literal>
								<literal type="string">"block after a parallel query"</literal></expr></argument>, <argument><expr><name>longestShardName</name></expr></argument>,
								<argument><expr><name>relationName</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try re-running the transaction with "</literal>
									<literal type="string">"\"SET LOCAL citus.multi_shard_modify_mode TO "</literal>
									<literal type="string">"\'sequential\';\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"the name of the shard (%s) for relation (%s) is too long, "</literal>
						 <literal type="string">"switching to sequential and local execution mode to prevent "</literal>
						 <literal type="string">"self deadlocks"</literal></expr></argument>,
				 <argument><expr><name>longestShardName</name></expr></argument>, <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SetLocalMultiShardModifyModeToSequential</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetLocalExecutionStatus</name><argument_list>(<argument><expr><name>LOCAL_EXECUTION_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SwitchToSequentialAndLocalExecutionIfPartitionNameTooLong is a wrapper for new
 * partitions that will be distributed after attaching to a distributed partitioned table
 */</comment>
<function><type><name>void</name></type>
<name>SwitchToSequentialAndLocalExecutionIfPartitionNameTooLong</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>parentRelationId</name></decl></parameter>,
														  <parameter><decl><type><name>Oid</name></type> <name>partitionRelationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SwitchToSequentialAndLocalExecutionIfRelationNameTooLong</name><argument_list>(
		<argument><expr><name>parentRelationId</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>partitionRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
