<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/distributed/commands/extension.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * extension.c
 *    Commands for creating and altering extensions.
 *
 * Copyright (c) Citus Data, Inc.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"citus_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_data_wrapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/citus_ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/commands/utility_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/deparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/coordinator_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata_sync.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/metadata/distobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/multi_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/relation_access_tracking.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/transaction_management.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/* Local functions forward declarations for helper functions */</comment>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>ExtractNewExtensionVersion</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddSchemaFieldIfMissing</name><parameter_list>(<parameter><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>FilterDistributedExtensions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>extensionObjectList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ExtensionNameListToObjectAddressList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>extensionObjectList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MarkExistingObjectDependenciesDistributedIfSupported</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetAllViews</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldPropagateExtensionCommand</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsAlterExtensionSetSchemaCitus</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>RecreateExtensionStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extensionOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GenerateGrantCommandsOnExtesionDependentFDWs</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extensionId</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ErrorIfUnstableCreateOrAlterExtensionStmt compares CITUS_EXTENSIONVERSION
 * and version given CREATE/ALTER EXTENSION statement will create/update to. If
 * they are not same in major or minor version numbers, this function errors
 * out. It ignores the schema version.
 */</comment>
<function><type><name>void</name></type>
<name>ErrorIfUnstableCreateOrAlterExtensionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newExtensionVersion</name> <init>= <expr><call><name>ExtractNewExtensionVersion</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>newExtensionVersion</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*  explicit version provided in CREATE or ALTER EXTENSION UPDATE; verify */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MajorVersionsCompatible</name><argument_list>(<argument><expr><name>newExtensionVersion</name></expr></argument>, <argument><expr><name>CITUS_EXTENSIONVERSION</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specified version incompatible with loaded "</literal>
								   <literal type="string">"Citus library"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Loaded library requires %s, but %s was specified."</literal></expr></argument>,
									  <argument><expr><name>CITUS_MAJORVERSION</name></expr></argument>, <argument><expr><name>newExtensionVersion</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If a newer library is present, restart the database "</literal>
									<literal type="string">"and try the command again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * No version was specified, so PostgreSQL will use the default_version
		 * from the citus.control file.
		 */</comment>
		<expr_stmt><expr><call><name>CheckAvailableVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractNewExtensionVersion returns the palloc'd new extension version specified
 * by a CREATE or ALTER EXTENSION statement. Other inputs are not permitted.
 * This function returns NULL for statements with no explicit version specified.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ExtractNewExtensionVersion</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>optionsList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>CreateExtensionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>optionsList</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CreateExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name><operator>)</operator><operator>-&gt;</operator><name>options</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>AlterExtensionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>optionsList</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name><operator>)</operator><operator>-&gt;</operator><name>options</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* input must be one of the two above types */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>newVersionValue</name> <init>= <expr><call><name>GetExtensionOption</name><argument_list>(<argument><expr><name>optionsList</name></expr></argument>, <argument><expr><literal type="string">"new_version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* return target string safely */</comment>
	<if_stmt><if>if <condition>(<expr><name>newVersionValue</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newVersion</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>newVersionValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>newVersion</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessCreateExtensionStmt is called after the creation of an extension.
 * We decide if the extension needs to be replicated to the worker, and
 * if that is the case return a list of DDLJob's that describe how and
 * where the extension needs to be created.
 *
 * As we now have access to ObjectAddress of the extension that is just
 * created, we can mark it as distributed to make sure that its
 * dependencies exist on all nodes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessCreateExtensionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateExtensionStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateExtensionCommand</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check creation against multi-statement transaction policy */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateCreateInCoordinatedTransction</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extension management can only be done via coordinator node */</comment>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure that the current transaction is already in sequential mode,
	 * or can still safely be put in sequential mode
	 */</comment>
	<expr_stmt><expr><call><name>EnsureSequentialMode</name><argument_list>(<argument><expr><name>OBJECT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Here we append "schema" field to the "options" list (if not specified)
	 * to satisfy the schema consistency between worker nodes and the coordinator.
	 */</comment>
	<expr_stmt><expr><call><name>AddSchemaFieldIfMissing</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* always send commands with IF NOT EXISTS */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>createExtensionStmtSql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * To prevent recursive propagation in mx architecture, we disable ddl
	 * propagation before sending the command to workers.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>createExtensionStmtSql</name></expr></argument>,
								<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>extensionAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>extensionAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><name>extensionAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddSchemaFieldIfMissing adds DefElem item for "schema" (if not specified
 * in statement) to "options" list before deparsing the statement to satisfy
 * the schema consistency between worker nodes and the coordinator.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddSchemaFieldIfMissing</name><parameter_list>(<parameter><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>createExtensionStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>optionsList</name> <init>= <expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>schemaNameValue</name> <init>= <expr><call><name>GetExtensionOption</name><argument_list>(<argument><expr><name>optionsList</name></expr></argument>, <argument><expr><literal type="string">"schema"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>schemaNameValue</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * As we already created the extension by standard_ProcessUtility,
		 * we actually know the schema it belongs to
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>extensionOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>extensionSchemaOid</name> <init>= <expr><call><name>get_extension_schema</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>extensionSchemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>schemaNameArg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>extensionSchemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* set location to -1 as it is unknown */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>location</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>newDefElement</name> <init>= <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"schema"</literal></expr></argument>, <argument><expr><name>schemaNameArg</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
											   <argument><expr><name>newDefElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessDropExtensionStmt is called to drop extension(s) in coordinator and
 * in worker nodes if distributed before.
 * We first ensure that we keep only the distributed ones before propagating
 * the statement to worker nodes.
 * If no extensions in the drop list are distributed, then no calls will
 * be made to the workers.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessDropExtensionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
							<parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateExtensionCommand</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get distributed extensions to be dropped in worker nodes as well */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allDroppedExtensions</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedExtensions</name> <init>= <expr><call><name>FilterDistributedExtensions</name><argument_list>(<argument><expr><name>allDroppedExtensions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>distributedExtensions</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no distributed extensions to drop */</comment>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extension management can only be done via coordinator node */</comment>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure that the current transaction is already in sequential mode,
	 * or can still safely be put in sequential mode
	 */</comment>
	<expr_stmt><expr><call><name>EnsureSequentialMode</name><argument_list>(<argument><expr><name>OBJECT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedExtensionAddresses</name> <init>= <expr><call><name>ExtensionNameListToObjectAddressList</name><argument_list>(
		<argument><expr><name>distributedExtensions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* unmark each distributed extension */</comment>
	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>address</argument>, <argument>distributedExtensionAddresses</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnmarkObjectDistributed</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Temporary swap the lists of objects to delete with the distributed
	 * objects and deparse to an sql statement for the workers.
	 * Then switch back to allDroppedExtensions to drop all specified
	 * extensions in coordinator after PreprocessDropExtensionStmt completes
	 * its execution.
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>distributedExtensions</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>deparsedStmt</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objects</name></name> <operator>=</operator> <name>allDroppedExtensions</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * To prevent recursive propagation in mx architecture, we disable ddl
	 * propagation before sending the command to workers.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>deparsedStmt</name></expr></argument>,
								<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FilterDistributedExtensions returns the distributed objects in an "objects"
 * list of a DropStmt, a list having the format of a "DropStmt.objects" list.
 * That is, in turn, a list of string "Value"s.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FilterDistributedExtensions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>extensionObjectList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>extensionNameList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>objectName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>objectName</argument>, <argument>extensionObjectList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><name>objectName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>missingOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>extensionOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsAnyObjectDistributed</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>extensionNameList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>extensionNameList</name></expr></argument>, <argument><expr><name>objectName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>extensionNameList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtensionNameListToObjectAddressList returns the object addresses in
 * an ObjectAddress list for an "objects" list of a DropStmt.
 * Callers of this function should ensure that all the objects in the list
 * are valid and distributed.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ExtensionNameListToObjectAddressList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>extensionObjectList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>extensionObjectAddressList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>objectName</name></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>objectName</argument>, <argument>extensionObjectList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * We set missingOk to false as we assume all the objects in
		 * extensionObjectList list are valid and distributed.
		 */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><name>objectName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>missingOk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>extensionOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>, <argument><expr><name>missingOk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>extensionObjectAddressList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>extensionObjectAddressList</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>extensionObjectAddressList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterExtensionSchemaStmt is invoked for alter extension set schema statements.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterExtensionSchemaStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
								   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateExtensionCommand</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extension management can only be done via coordinator node */</comment>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure that the current transaction is already in sequential mode,
	 * or can still safely be put in sequential mode
	 */</comment>
	<expr_stmt><expr><call><name>EnsureSequentialMode</name><argument_list>(<argument><expr><name>OBJECT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alterExtensionStmtSql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * To prevent recursive propagation in mx architecture, we disable ddl
	 * propagation before sending the command to workers.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>alterExtensionStmtSql</name></expr></argument>,
								<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessAlterExtensionSchemaStmt is executed after the change has been applied
 * locally, we can now use the new dependencies (schema) of the extension to ensure
 * all its dependencies exist on the workers before we apply the commands remotely.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PostprocessAlterExtensionSchemaStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>extensionAddresses</name> <init>= <expr><call><name>GetObjectAddressListFromParseTree</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*  the code-path only supports a single object */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>extensionAddresses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateExtensionCommand</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* dependencies (schema) have changed let's ensure they exist */</comment>
	<expr_stmt><expr><call><name>EnsureAllObjectDependenciesExistOnAllNodes</name><argument_list>(<argument><expr><name>extensionAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterExtensionUpdateStmt is invoked for alter extension update statements.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterExtensionUpdateStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
								   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterExtensionStmt</name> <modifier>*</modifier></type><name>alterExtensionStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterExtensionStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldPropagateExtensionCommand</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>alterExtensionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* extension management can only be done via coordinator node */</comment>
	<expr_stmt><expr><call><name>EnsureCoordinator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure that the current transaction is already in sequential mode,
	 * or can still safely be put in sequential mode
	 */</comment>
	<expr_stmt><expr><call><name>EnsureSequentialMode</name><argument_list>(<argument><expr><name>OBJECT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alterExtensionStmtSql</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>alterExtensionStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * To prevent recursive propagation in mx architecture, we disable ddl
	 * propagation before sending the command to workers.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><call><name>list_make3</name><argument_list>(<argument><expr><name>DISABLE_DDL_PROPAGATION</name></expr></argument>,
								<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>alterExtensionStmtSql</name></expr></argument>,
								<argument><expr><name>ENABLE_DDL_PROPAGATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>NodeDDLTaskList</name><argument_list>(<argument><expr><name>NON_COORDINATOR_NODES</name></expr></argument>, <argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessAlterExtensionCitusUpdateStmt is called after ALTER EXTENSION
 * citus UPDATE command is executed by standard utility hook.
 *
 * Actually, we do not need such a post process function for ALTER EXTENSION
 * UPDATE commands unless the extension is Citus itself. This is because we
 * need to mark existing objects that are not included in distributed object
 * infrastructure in older versions of Citus (but now should be) as distributed
 * if we really updated Citus to the available version successfully via standard
 * utility hook.
 */</comment>
<function><type><name>void</name></type>
<name>PostprocessAlterExtensionCitusUpdateStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>citusIsUpdatedToLatestVersion</name> <init>= <expr><call><name>InstalledAndAvailableVersionsSame</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Knowing that Citus version was different than the available version before
	 * standard process utility runs ALTER EXTENSION command, we perform post
	 * process operations if Citus is updated to that available version
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>citusIsUpdatedToLatestVersion</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Finally, mark existing objects that are not included in distributed object
	 * infrastructure in older versions of Citus (but now should be) as distributed
	 */</comment>
	<expr_stmt><expr><call><name>MarkExistingObjectDependenciesDistributedIfSupported</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * MarkExistingObjectDependenciesDistributedIfSupported marks all objects that could
 * be distributed by resolving dependencies of "existing distributed tables" and
 * "already distributed objects" to introduce the objects created in older versions
 * of Citus to distributed object infrastructure as well.
 *
 * Note that this function is not responsible for ensuring if dependencies exist on
 * nodes and satisfying these dependendencies if not exists, which is already done by
 * EnsureAllObjectDependenciesExistOnAllNodes on demand. Hence, this function is just designed
 * to be used when "ALTER EXTENSION citus UPDATE" is executed.
 * This is because we want to add existing objects that would have already been in
 * pg_dist_object if we had created them in new version of Citus to pg_dist_object.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MarkExistingObjectDependenciesDistributedIfSupported</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/* resulting object addresses to be marked as distributed */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>resultingObjectAddresses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* resolve dependencies of citus tables */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>citusTableIdList</name> <init>= <expr><call><name>CitusTableTypeIdList</name><argument_list>(<argument><expr><name>ANY_CITUS_TABLE_TYPE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>citusTableId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>citusTableId</argument>, <argument>citusTableIdList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldMarkRelationDistributed</name><argument_list>(<argument><expr><name>citusTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* refrain reading the metadata cache for all tables */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ShouldSyncTableMetadataViaCatalog</name><argument_list>(<argument><expr><name>citusTableId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>tableAddress</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>tableAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>citusTableId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We mark tables distributed immediately because we also need to mark
			 * views as distributed. We check whether the views that depend on
			 * the table has any auto-distirbutable dependencies below. Citus
			 * currently cannot "auto" distribute tables as dependencies, so we
			 * mark them distributed immediately.
			 */</comment>
			<expr_stmt><expr><call><name>MarkObjectDistributedLocally</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tableAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * All the distributable dependencies of a table should be marked as
			 * distributed.
			 */</comment>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributableDependencyObjectAddresses</name> <init>=
				<expr><call><name>GetDistributableDependenciesForObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tableAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>resultingObjectAddresses</name> <operator>=</operator>
				<call><name>list_concat</name><argument_list>(<argument><expr><name>resultingObjectAddresses</name></expr></argument>,
							<argument><expr><name>distributableDependencyObjectAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * As of Citus 11, views on Citus tables that do not have any unsupported
	 * dependency should also be distributed.
	 *
	 * In general, we mark views distributed as long as it does not have
	 * any unsupported dependencies.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>viewList</name> <init>= <expr><call><name>GetAllViews</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>viewOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>viewOid</argument>, <argument>viewList</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldMarkRelationDistributed</name><argument_list>(<argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>viewAddress</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>viewAddress</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>viewOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If a view depends on multiple views, that view will be marked
		 * as distributed while it is processed for the last view
		 * table.
		 */</comment>
		<expr_stmt><expr><call><name>MarkObjectDistributedLocally</name><argument_list>(<argument><expr><operator>&amp;</operator><name>viewAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we need to pass pointer allocated in the heap */</comment>
		<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>addressPointer</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>addressPointer</name> <operator>=</operator> <name>viewAddress</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributableDependencyObjectAddresses</name> <init>=
			<expr><call><name>GetDistributableDependenciesForObject</name><argument_list>(<argument><expr><operator>&amp;</operator><name>viewAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>resultingObjectAddresses</name> <operator>=</operator>
			<call><name>list_concat</name><argument_list>(<argument><expr><name>resultingObjectAddresses</name></expr></argument>,
						<argument><expr><name>distributableDependencyObjectAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>


	<comment type="block">/* resolve dependencies of the objects in pg_dist_object*/</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributedObjectAddressList</name> <init>= <expr><call><name>GetDistributedObjectAddressList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>distributedObjectAddress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>distributedObjectAddress</argument>, <argument>distributedObjectAddressList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distributableDependencyObjectAddresses</name> <init>=
			<expr><call><name>GetDistributableDependenciesForObject</name><argument_list>(<argument><expr><name>distributedObjectAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>resultingObjectAddresses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>resultingObjectAddresses</name></expr></argument>,
											   <argument><expr><name>distributableDependencyObjectAddresses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* remove duplicates from object addresses list for efficiency */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>uniqueObjectAddresses</name> <init>= <expr><call><name>GetUniqueDependenciesList</name><argument_list>(<argument><expr><name>resultingObjectAddresses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should sync the new dependencies during ALTER EXTENSION because
	 * we cannot know whether the nodes has already been upgraded or not. If
	 * the nodes are not upgraded at this point, we cannot sync the object. Also,
	 * when the workers upgraded, they'd get the same objects anyway.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>prevMetadataSyncValue</name> <init>= <expr><name>EnableMetadataSync</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SetLocalEnableMetadataSync</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>objectAddress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>objectAddress</argument>, <argument>uniqueObjectAddresses</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkObjectDistributed</name><argument_list>(<argument><expr><name>objectAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>SetLocalEnableMetadataSync</name><argument_list>(<argument><expr><name>prevMetadataSyncValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetAllViews returns list of view oids that exists on this server.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetAllViews</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>viewOidList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgClass</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgClass</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
													<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relationForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* we're only interested in views */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relationForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>viewOidList</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>viewOidList</name></expr></argument>, <argument><expr><name><name>relationForm</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgClass</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>viewOidList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterExtensionContentsStmt issues a notice. It does not propagate.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>PreprocessAlterExtensionContentsStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
									 <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>processUtilityContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
						 <argument><expr><literal type="string">"Citus does not propagate adding/dropping member objects"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(
						 <argument><expr><literal type="string">"You can add/drop the member objects on the workers as well."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ShouldPropagateExtensionCommand determines whether to propagate an extension
 * command to the worker nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldPropagateExtensionCommand</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if we disabled object propagation, then we should not propagate anything. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableMetadataSync</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If extension command is run for/on citus, leave the rest to standard utility hook
	 * by returning false.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsCreateAlterExtensionUpdateCitusStmt</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsDropCitusExtensionStmt</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsAlterExtensionSetSchemaCitus</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsCreateAlterExtensionUpdateCitusStmt returns whether a given utility is a
 * CREATE or ALTER EXTENSION UPDATE statement which references the citus extension.
 * This function returns false for all other inputs.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCreateAlterExtensionUpdateCitusStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>CreateExtensionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>extensionName</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CreateExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name><operator>)</operator><operator>-&gt;</operator><name>extname</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>AlterExtensionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>extensionName</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AlterExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name><operator>)</operator><operator>-&gt;</operator><name>extname</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is not a Create Extension or a Alter Extension stmt,
		 * it does not matter if the it is about citus
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Now that we have CreateExtensionStmt or AlterExtensionStmt,
	 * check if it is run for/on citus
	 */</comment>
	<return>return <expr><operator>(</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>, <argument><expr><literal type="string">"citus"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreProcessCreateExtensionCitusStmtForColumnar determines whether need to
 * install citus_columnar first or citus_columnar is supported on current
 * citus version, when a given utility is a CREATE statement
 */</comment>
<function><type><name>void</name></type>
<name>PreprocessCreateExtensionStmtForCitusColumnar</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*CREATE EXTENSION CITUS (version Z) */</comment>
	<decl_stmt><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>createExtensionStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateExtensionStmt</name></expr></argument>,
														<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><literal type="string">"citus"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>versionNumber</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><literal type="number">100</literal> <operator>*</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>CITUS_MAJORVERSION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>newVersionValue</name> <init>= <expr><call><name>GetExtensionOption</name><argument_list>(<argument><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
													  <argument><expr><literal type="string">"new_version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*create extension citus version xxx*/</comment>
		<if_stmt><if>if <condition>(<expr><name>newVersionValue</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newVersion</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>newVersionValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>versionNumber</name> <operator>=</operator> <call><name>GetExtensionVersionNumber</name><argument_list>(<argument><expr><name>newVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*citus version &gt;= 11.1 requires install citus_columnar first*/</comment>
		<if_stmt><if>if <condition>(<expr><name>versionNumber</name> <operator>&gt;=</operator> <literal type="number">1110</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CitusHasBeenLoaded</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CreateExtensionWithVersion</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*Edge case check: citus_columnar are supported on citus version &gt;= 11.1*/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>citusOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>citusOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>curCitusVersion</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><call><name>get_extension_version</name><argument_list>(<argument><expr><name>citusOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>curCitusVersionNum</name> <init>= <expr><call><name>GetExtensionVersionNumber</name><argument_list>(<argument><expr><name>curCitusVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>curCitusVersionNum</name> <operator>&lt;</operator> <literal type="number">1110</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(
									<argument><expr><literal type="string">"must upgrade citus to version 11.1-1 first before install citus_columnar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsDropCitusExtensionStmt iterates the objects to be dropped in a drop statement
 * and try to find citus extension there.
 */</comment>
<function><type><name>bool</name></type>
<name>IsDropCitusExtensionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if it is not a DropStmt, it is needless to search for citus */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>DropStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>DropStmt</name> <modifier>*</modifier></type><name>dropStmt</name> <init>= <expr><operator>(</operator><name>DropStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check if the drop command is a DROP EXTENSION command */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dropStmt</name><operator>-&gt;</operator><name>removeType</name></name> <operator>!=</operator> <name>OBJECT_EXTENSION</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* now that we have a DropStmt, check if citus extension is among the objects to dropped */</comment>
	<decl_stmt><decl><type><name>String</name> <modifier>*</modifier></type><name>objectName</name></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>objectName</argument>, <argument>dropStmt-&gt;objects</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><name>objectName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>, <argument><expr><literal type="string">"citus"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsAlterExtensionSetSchemaCitus returns whether a given utility is an
 * ALTER EXTENSION SET SCHEMA statement which references the citus extension.
 * This function returns false for all other inputs.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsAlterExtensionSetSchemaCitus</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parseTree</name></expr></argument>, <argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>alterExtensionSetSchemaStmt</name> <init>=
			<expr><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>alterExtensionSetSchemaStmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_EXTENSION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>extensionName</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>AlterObjectSchemaStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name><operator>)</operator><operator>-&gt;</operator><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now that we have AlterObjectSchemaStmt for an extension,
			 * check if it is run for/on citus
			 */</comment>
			<return>return <expr><operator>(</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>, <argument><expr><literal type="string">"citus"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PreprocessAlterExtensionCitusStmtForCitusColumnar pre-process the case when upgrade citus
 * to version that support citus_columnar, or downgrade citus to lower version that
 * include columnar inside citus extension
 */</comment>
<function><type><name>void</name></type>
<name>PreprocessAlterExtensionCitusStmtForCitusColumnar</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*upgrade citus: alter extension citus update to 'xxx' */</comment>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>newVersionValue</name> <init>= <expr><call><name>GetExtensionOption</name><argument_list>(
		<argument><expr><operator>(</operator><operator>(</operator><name>AlterExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name><operator>)</operator><operator>-&gt;</operator><name>options</name></expr></argument>, <argument><expr><literal type="string">"new_version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusColumnarOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>newVersionValue</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newVersion</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>newVersionValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>newVersionNumber</name> <init>= <expr><call><name>GetExtensionVersionNumber</name><argument_list>(<argument><expr><call><name>strdup</name><argument_list>(<argument><expr><name>newVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*alter extension citus update to version &gt;= 11.1-1, and no citus_columnar installed */</comment>
		<if_stmt><if>if <condition>(<expr><name>newVersionNumber</name> <operator>&gt;=</operator> <literal type="number">1110</literal> <operator>&amp;&amp;</operator> <name>citusColumnarOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*it's upgrade citus to 11.1-1 or further version */</comment>
			<expr_stmt><expr><call><name>CreateExtensionWithVersion</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>, <argument><expr><name>CITUS_COLUMNAR_INTERNAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>newVersionNumber</name> <operator>&lt;</operator> <literal type="number">1110</literal> <operator>&amp;&amp;</operator> <name>citusColumnarOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*downgrade citus, need downgrade citus_columnar to Y */</comment>
			<expr_stmt><expr><call><name>AlterExtensionUpdateStmt</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>, <argument><expr><name>CITUS_COLUMNAR_INTERNAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*alter extension citus update without specifying the version*/</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>versionNumber</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><literal type="number">100</literal> <operator>*</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>CITUS_MAJORVERSION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>versionNumber</name> <operator>&gt;=</operator> <literal type="number">1110</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>citusColumnarOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CreateExtensionWithVersion</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>,
										   <argument><expr><name>CITUS_COLUMNAR_INTERNAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PostprocessAlterExtensionCitusStmtForCitusColumnar process the case when upgrade citus
 * to version that support citus_columnar, or downgrade citus to lower version that
 * include columnar inside citus extension
 */</comment>
<function><type><name>void</name></type>
<name>PostprocessAlterExtensionCitusStmtForCitusColumnar</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>newVersionValue</name> <init>= <expr><call><name>GetExtensionOption</name><argument_list>(
		<argument><expr><operator>(</operator><operator>(</operator><name>AlterExtensionStmt</name> <operator>*</operator><operator>)</operator> <name>parseTree</name><operator>)</operator><operator>-&gt;</operator><name>options</name></expr></argument>, <argument><expr><literal type="string">"new_version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>citusColumnarOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>newVersionValue</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newVersion</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>newVersionValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type> <name>newVersionNumber</name> <init>= <expr><call><name>GetExtensionVersionNumber</name><argument_list>(<argument><expr><call><name>strdup</name><argument_list>(<argument><expr><name>newVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>newVersionNumber</name> <operator>&gt;=</operator> <literal type="number">1110</literal> <operator>&amp;&amp;</operator> <name>citusColumnarOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*upgrade citus, after "ALTER EXTENSION citus update to xxx" updates citus_columnar Y to version Z. */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>curColumnarVersion</name> <init>= <expr><call><name>get_extension_version</name><argument_list>(<argument><expr><name>citusColumnarOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>curColumnarVersion</name></expr></argument>, <argument><expr><name>CITUS_COLUMNAR_INTERNAL_VERSION</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>AlterExtensionUpdateStmt</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>, <argument><expr><literal type="string">"11.1-1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>newVersionNumber</name> <operator>&lt;</operator> <literal type="number">1110</literal> <operator>&amp;&amp;</operator> <name>citusColumnarOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*downgrade citus, after "ALTER EXTENSION citus update to xxx" drops citus_columnar extension */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>curColumnarVersion</name> <init>= <expr><call><name>get_extension_version</name><argument_list>(<argument><expr><name>citusColumnarOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>curColumnarVersion</name></expr></argument>, <argument><expr><name>CITUS_COLUMNAR_INTERNAL_VERSION</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RemoveExtensionById</name><argument_list>(<argument><expr><name>citusColumnarOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*alter extension citus update, need upgrade citus_columnar from Y to Z*/</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>versionNumber</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><literal type="number">100</literal> <operator>*</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>CITUS_MAJORVERSION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>versionNumber</name> <operator>&gt;=</operator> <literal type="number">1110</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>curColumnarVersion</name> <init>= <expr><call><name>get_extension_version</name><argument_list>(<argument><expr><name>citusColumnarOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>curColumnarVersion</name></expr></argument>, <argument><expr><name>CITUS_COLUMNAR_INTERNAL_VERSION</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>AlterExtensionUpdateStmt</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>, <argument><expr><literal type="string">"11.1-1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateExtensionDDLCommand returns a list of DDL statements (const char *) to be
 * executed on a node to recreate the extension addressed by the extensionAddress.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>CreateExtensionDDLCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectAddress</name> <modifier>*</modifier></type><name>extensionAddress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* generate a statement for creation of the extension in "if not exists" construct */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>RecreateExtensionStmt</name><argument_list>(<argument><expr><name><name>extensionAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* capture ddl command for the create statement */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ddlCommand</name> <init>= <expr><call><name>DeparseTreeNode</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ddlCommands</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>ddlCommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* any privilege granted on FDWs that belong to the extension should be included */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>FDWGrants</name> <init>=
		<expr><call><name>GenerateGrantCommandsOnExtesionDependentFDWs</name><argument_list>(<argument><expr><name><name>extensionAddress</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ddlCommands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>ddlCommands</name></expr></argument>, <argument><expr><name>FDWGrants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ddlCommands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RecreateExtensionStmt returns a parsetree for a CREATE EXTENSION statement that would
 * recreate the given extension on a new node.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>RecreateExtensionStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extensionOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>createExtensionStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateExtensionStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><call><name>get_extension_name</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extensionName</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension with oid %u does not exist"</literal></expr></argument>,
							   <argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* schema DefElement related variables */</comment>

	<comment type="block">/* set location to -1 as it is unknown */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>location</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set extension name and if_not_exists fields */</comment>
	<expr_stmt><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>extname</name></name> <operator>=</operator> <name>extensionName</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* get schema name that extension was created on */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>extensionSchemaOid</name> <init>= <expr><call><name>get_extension_schema</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionSchemaName</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>extensionSchemaOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* make DefEleme for extensionSchemaName */</comment>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>schemaNameArg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>extensionSchemaName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>schemaDefElement</name> <init>= <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"schema"</literal></expr></argument>, <argument><expr><name>schemaNameArg</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* append the schema name DefElem finally */</comment>
	<expr_stmt><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
										   <argument><expr><name>schemaDefElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionVersion</name> <init>= <expr><call><name>get_extension_version</name><argument_list>(<argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>extensionVersion</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>extensionVersionArg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>extensionVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>extensionVersionElement</name> <init>=
			<expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"new_version"</literal></expr></argument>, <argument><expr><name>extensionVersionArg</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
											   <argument><expr><name>extensionVersionElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>createExtensionStmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GenerateGrantCommandsOnExtesionDependentFDWs returns a list of commands that GRANTs
 * the privileges on FDWs that are depending on the given extension.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GenerateGrantCommandsOnExtesionDependentFDWs</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extensionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>commands</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>FDWOids</name> <init>= <expr><call><name>GetDependentFDWsToExtension</name><argument_list>(<argument><expr><name>extensionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>FDWOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_oid</name><argument_list>(<argument>FDWOid</argument>, <argument>FDWOids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Acl</name> <modifier>*</modifier></type><name>aclEntry</name> <init>= <expr><call><name>GetPrivilegesForFDW</name><argument_list>(<argument><expr><name>FDWOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>aclEntry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>AclItem</name> <modifier>*</modifier></type><name>privileges</name> <init>= <expr><call><name>ACL_DAT</name><argument_list>(<argument><expr><name>aclEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>numberOfPrivsGranted</name> <init>= <expr><call><name>ACL_NUM</name><argument_list>(<argument><expr><name>aclEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numberOfPrivsGranted</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>commands</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>commands</name></expr></argument>,
								   <argument><expr><call><name>GenerateGrantOnFDWQueriesFromAclItem</name><argument_list>(<argument><expr><name>FDWOid</name></expr></argument>,
																		<argument><expr><operator>&amp;</operator><name><name>privileges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<return>return <expr><name>commands</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetDependentFDWsToExtension gets an extension oid and returns the list of oids of FDWs
 * that are depending on the given extension.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetDependentFDWsToExtension</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>extensionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>extensionFDWs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>scanKeyCount</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>pgDepend</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>DependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>extensionId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_depend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>ForeignDataWrapperRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgDepend</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>scanKeyCount</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_depend</name></type> <name>pgDependEntry</name> <init>= <expr><operator>(</operator><name>Form_pg_depend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pgDependEntry</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>DEPENDENCY_EXTENSION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>extensionFDWs</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>extensionFDWs</name></expr></argument>, <argument><expr><name><name>pgDependEntry</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgDepend</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>extensionFDWs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterExtensionSchemaStmtObjectAddress returns the ObjectAddress of the extension that is
 * the subject of the AlterObjectSchemaStmt. Errors if missing_ok is false.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterExtensionSchemaStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>objectType</name></name> <operator>==</operator> <name>OBJECT_EXTENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>extensionOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>extensionOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" does not exist"</literal></expr></argument>,
							   <argument><expr><name>extensionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterExtensionUpdateStmtObjectAddress returns the ObjectAddress of the extension that is
 * the subject of the AlterExtensionStmt. Errors if missing_ok is false.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AlterExtensionUpdateStmtObjectAddress</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPostprocess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterExtensionStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterExtensionStmt</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>extname</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>extensionOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>extensionOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"extension \"%s\" does not exist"</literal></expr></argument>,
							   <argument><expr><name>extensionName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><operator>*</operator><name>address</name></expr></argument>, <argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>extensionOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateExtensionWithVersion builds and execute create extension statements
 * per given extension name and extension verision
 */</comment>
<function><type><name>void</name></type>
<name>CreateExtensionWithVersion</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>createExtensionStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CreateExtensionStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set location to -1 as it is unknown */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>location</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set extension name and if_not_exists fields */</comment>
	<expr_stmt><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>extname</name></name> <operator>=</operator> <name>extname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>extVersion</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>extensionVersionArg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>extVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>extensionVersionElement</name> <init>= <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"new_version"</literal></expr></argument>, <argument><expr><name>extensionVersionArg</name></expr></argument>,
													   <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
											   <argument><expr><name>extensionVersionElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>CreateExtension</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>createExtensionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetExtensionVersionNumber convert extension version to real value
 */</comment>
<function><type><name>int</name></type>
<name>GetExtensionVersionNumber</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strtokPosition</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>versionVal</name> <init>= <expr><call><name>strtok_r</name><argument_list>(<argument><expr><name>extVersion</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>strtokPosition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>versionNumber</name> <init>= <expr><call><name>strtod</name><argument_list>(<argument><expr><name>versionVal</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>versionNumber</name> <operator>*</operator> <literal type="number">100</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AlterExtensionUpdateStmt builds and execute Alter extension statements
 * per given extension name and updates extension verision
 */</comment>
<function><type><name>void</name></type>
<name>AlterExtensionUpdateStmt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>extVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterExtensionStmt</name> <modifier>*</modifier></type><name>alterExtensionStmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterExtensionStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* set location to -1 as it is unknown */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>location</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>alterExtensionStmt</name><operator>-&gt;</operator><name>extname</name></name> <operator>=</operator> <name>extname</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>extVersion</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"alter extension \"%s\" should not be empty"</literal></expr></argument>,
							   <argument><expr><name>extVersion</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>extensionVersionArg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>extVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>extensionVersionElement</name> <init>= <expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"new_version"</literal></expr></argument>, <argument><expr><name>extensionVersionArg</name></expr></argument>,
												   <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>alterExtensionStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>alterExtensionStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
										  <argument><expr><name>extensionVersionElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecAlterExtensionStmt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>alterExtensionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
