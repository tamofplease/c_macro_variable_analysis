<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/columnar/columnar_writer.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * columnar_writer.c
 *
 * This file contains function definitions for writing columnar tables. This
 * includes the logic for writing file level metadata, writing row stripes,
 * and calculating chunk skip nodes.
 *
 * Copyright (c) 2016, Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_lib.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relfilenodemap.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_version_compat.h"</cpp:file></cpp:include>

<struct>struct <name>ColumnarWriteState</name>
<block>{
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>comparisonFunctionArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>relfilenode</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stripeWriteContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>perTupleContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EmptyStripeReservation</name> <modifier>*</modifier></type><name>emptyStripeReservation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnarOptions</name></type> <name>options</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkData</name> <modifier>*</modifier></type><name>chunkData</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunkGroupRowCounts</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * compressionBuffer buffer is used as temporary storage during
	 * data value compression operation. It is kept here to minimize
	 * memory allocations. It lives in stripeWriteContext and gets
	 * deallocated when memory context is reset.
	 */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>compressionBuffer</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>StripeBuffers</name> <modifier>*</modifier></type> <name>CreateEmptyStripeBuffers</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>stripeMaxRowCount</name></decl></parameter>,
												<parameter><decl><type><name>uint32</name></type> <name>chunkRowCount</name></decl></parameter>,
												<parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StripeSkipList</name> <modifier>*</modifier></type> <name>CreateEmptyStripeSkipList</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>stripeMaxRowCount</name></decl></parameter>,
												  <parameter><decl><type><name>uint32</name></type> <name>chunkRowCount</name></decl></parameter>,
												  <parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FlushStripe</name><parameter_list>(<parameter><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>SerializeBoolArray</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>boolArray</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>boolArrayLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SerializeSingleDatum</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>datumBuffer</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>,
								 <parameter><decl><type><name>bool</name></type> <name>datumTypeByValue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datumTypeLength</name></decl></parameter>,
								 <parameter><decl><type><name>char</name></type> <name>datumTypeAlign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SerializeChunkData</name><parameter_list>(<parameter><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>chunkIndex</name></decl></parameter>,
							   <parameter><decl><type><name>uint32</name></type> <name>rowCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateChunkSkipNodeMinMax</name><parameter_list>(<parameter><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNode</name></decl></parameter>,
									  <parameter><decl><type><name>Datum</name></type> <name>columnValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>columnTypeByValue</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>columnTypeLength</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>columnCollation</name></decl></parameter>,
									  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>comparisonFunction</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>DatumCopy</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>datumTypeByValue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datumTypeLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StringInfo</name></type> <name>CopyStringInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>sourceString</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * ColumnarBeginWrite initializes a columnar data load operation and returns a table
 * handle. This handle should be used for adding the row values and finishing the
 * data load operation.
 */</comment>
<function><type><name>ColumnarWriteState</name> <modifier>*</modifier></type>
<name>ColumnarBeginWrite</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>relfilenode</name></decl></parameter>,
				   <parameter><decl><type><name>ColumnarOptions</name></type> <name>options</name></decl></parameter>,
				   <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* get comparison function pointers for each of the columns */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>comparisonFunctionArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>comparisonFunction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>attributeForm</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>,
															 <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attributeForm</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>typeId</name> <init>= <expr><name><name>attributeForm</name><operator>-&gt;</operator><name>atttypid</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>comparisonFunction</name> <operator>=</operator> <call><name>GetFunctionInfoOrNull</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>BTREE_AM_OID</name></expr></argument>,
													   <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>comparisonFunctionArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>comparisonFunction</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We allocate all stripe specific data in the stripeWriteContext, and
	 * reset this memory context once we have flushed the stripe to the file.
	 * This is to avoid memory leaks.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stripeWriteContext</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
															 <argument><expr><literal type="string">"Stripe Write Memory Context"</literal></expr></argument>,
															 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnMaskArray</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>columnMaskArray</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ChunkData</name> <modifier>*</modifier></type><name>chunkData</name> <init>= <expr><call><name>CreateEmptyChunkData</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>columnMaskArray</name></expr></argument>,
												<argument><expr><name><name>options</name><operator>.</operator><name>chunkRowCount</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnarWriteState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>relfilenode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>tupleDescriptor</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>comparisonFunctionArray</name></name> <operator>=</operator> <name>comparisonFunctionArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeBuffers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeSkipList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>emptyStripeReservation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeWriteContext</name></name> <operator>=</operator> <name>stripeWriteContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>chunkData</name></name> <operator>=</operator> <name>chunkData</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>compressionBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>perTupleContext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
														<argument><expr><literal type="string">"Columnar per tuple context"</literal></expr></argument>,
														<argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>writeState</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarWriteRow adds a row to the columnar table. If the stripe is not initialized,
 * we create structures to hold stripe data and skip list. Then, we serialize and
 * append data to serialized value buffer for each of the columns and update
 * corresponding skip nodes. Then, whole chunk data is compressed at every
 * rowChunkCount insertion. Then, if row count exceeds stripeMaxRowCount, we flush
 * the stripe, and add its metadata to the table footer.
 *
 * Returns the "row number" assigned to written row.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarWriteRow</name><parameter_list>(<parameter><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeBuffers</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeSkipList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnarOptions</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><operator>&amp;</operator><name><name>writeState</name><operator>-&gt;</operator><name>options</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint32</name></type> <name>chunkRowCount</name> <init>= <expr><name><name>options</name><operator>-&gt;</operator><name>chunkRowCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkData</name> <modifier>*</modifier></type><name>chunkData</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>chunkData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeWriteContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>stripeBuffers</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stripeBuffers</name> <operator>=</operator> <call><name>CreateEmptyStripeBuffers</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name></expr></argument>,
												 <argument><expr><name>chunkRowCount</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stripeSkipList</name> <operator>=</operator> <call><name>CreateEmptyStripeSkipList</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name></expr></argument>,
												   <argument><expr><name>chunkRowCount</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeBuffers</name></name> <operator>=</operator> <name>stripeBuffers</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeSkipList</name></name> <operator>=</operator> <name>stripeSkipList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>compressionBuffer</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelidByRelfilenode</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
											<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>emptyStripeReservation</name></name> <operator>=</operator>
			<call><name>ReserveEmptyStripe</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>chunkRowCount</name></expr></argument>,
							   <argument><expr><name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * serializedValueBuffer lives in stripe write memory context so it needs to be
		 * initialized when the stripe is created.
		 */</comment>
		<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueBufferArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkIndex</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>/</operator> <name>chunkRowCount</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkRowIndex</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>%</operator> <name>chunkRowCount</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunkSkipNodeArray</name> <init>= <expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNode</name> <init>=
			<expr><operator>&amp;</operator><name><name>chunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>columnNulls</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>chunkRowIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>comparisonFunction</name> <init>=
				<expr><name><name>writeState</name><operator>-&gt;</operator><name>comparisonFunctionArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name> <init>=
				<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>tupleDescriptor</name></name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>columnTypeByValue</name> <init>= <expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attbyval</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>columnTypeLength</name> <init>= <expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attlen</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>columnCollation</name> <init>= <expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attcollation</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type> <name>columnTypeAlign</name> <init>= <expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attalign</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>chunkRowIndex</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SerializeSingleDatum</name><argument_list>(<argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueBufferArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>columnValues</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>columnTypeByValue</name></expr></argument>,
								 <argument><expr><name>columnTypeLength</name></expr></argument>, <argument><expr><name>columnTypeAlign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>UpdateChunkSkipNodeMinMax</name><argument_list>(<argument><expr><name>chunkSkipNode</name></expr></argument>, <argument><expr><name><name>columnValues</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name>columnTypeByValue</name></expr></argument>, <argument><expr><name>columnTypeLength</name></expr></argument>,
									  <argument><expr><name>columnCollation</name></expr></argument>, <argument><expr><name>comparisonFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>rowCount</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name> <operator>=</operator> <name>chunkIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* last row of the chunk is inserted serialize the chunk */</comment>
	<if_stmt><if>if <condition>(<expr><name>chunkRowIndex</name> <operator>==</operator> <name>chunkRowCount</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SerializeChunkData</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>, <argument><expr><name>chunkIndex</name></expr></argument>, <argument><expr><name>chunkRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>writtenRowNumber</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>emptyStripeReservation</name><operator>-&gt;</operator><name>stripeFirstRowNumber</name></name> <operator>+</operator>
							  <name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>&gt;=</operator> <name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ColumnarFlushPendingWrites</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>writtenRowNumber</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarEndWrite finishes a columnar data load operation. If we have an unflushed
 * stripe, we flush it.
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarEndWrite</name><parameter_list>(<parameter><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ColumnarFlushPendingWrites</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeWriteContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>comparisonFunctionArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeChunkData</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>chunkData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ColumnarFlushPendingWrites</name><parameter_list>(<parameter><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeBuffers</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>stripeBuffers</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeWriteContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FlushStripe</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeWriteContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set stripe data and skip list to NULL so they are recreated next time */</comment>
		<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeBuffers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeSkipList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarWritePerTupleContext
 *
 * Return per-tuple context for columnar write operation.
 */</comment>
<function><type><name>MemoryContext</name></type>
<name>ColumnarWritePerTupleContext</name><parameter_list>(<parameter><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>perTupleContext</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateEmptyStripeBuffers allocates an empty StripeBuffers structure with the given
 * column count.
 */</comment>
<function><type><specifier>static</specifier> <name>StripeBuffers</name> <modifier>*</modifier></type>
<name>CreateEmptyStripeBuffers</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>stripeMaxRowCount</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>chunkRowCount</name></decl></parameter>,
						 <parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>maxChunkCount</name> <init>= <expr><operator>(</operator><name>stripeMaxRowCount</name> <operator>/</operator> <name>chunkRowCount</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnBuffers</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnBuffersArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnBuffers</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>chunkIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnChunkBuffers</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunkBuffersArray</name> <init>=
			<expr><call><name>palloc0</name><argument_list>(<argument><expr><name>maxChunkCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnChunkBuffers</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name>maxChunkCount</name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnChunkBuffers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name><operator>-&gt;</operator><name>existsBuffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name><operator>-&gt;</operator><name>valueBuffer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name><operator>-&gt;</operator><name>valueCompressionType</name> <operator>=</operator> <name>COMPRESSION_NONE</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>columnBuffersArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnBuffers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>columnBuffersArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name><operator>-&gt;</operator><name>chunkBuffersArray</name> <operator>=</operator> <name>chunkBuffersArray</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StripeBuffers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnBuffersArray</name></name> <operator>=</operator> <name>columnBuffersArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnCount</name></name> <operator>=</operator> <name>columnCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>stripeBuffers</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateEmptyStripeSkipList allocates an empty StripeSkipList structure with
 * the given column count. This structure has enough chunks to hold statistics
 * for stripeMaxRowCount rows.
 */</comment>
<function><type><specifier>static</specifier> <name>StripeSkipList</name> <modifier>*</modifier></type>
<name>CreateEmptyStripeSkipList</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>stripeMaxRowCount</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>chunkRowCount</name></decl></parameter>,
						  <parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>maxChunkCount</name> <init>= <expr><operator>(</operator><name>stripeMaxRowCount</name> <operator>/</operator> <name>chunkRowCount</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunkSkipNodeArray</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnChunkSkipNode</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>chunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>maxChunkCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnChunkSkipNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StripeSkipList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>columnCount</name></name> <operator>=</operator> <name>columnCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name></name> <operator>=</operator> <name>chunkSkipNodeArray</name></expr>;</expr_stmt>

	<return>return <expr><name>stripeSkipList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FlushStripe flushes current stripe data into the file. The function first ensures
 * the last data chunk for each column is properly serialized and compressed. Then,
 * the function creates the skip list and footer buffers. Finally, the function
 * flushes the skip list, data, and footer buffers to the file.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FlushStripe</name><parameter_list>(<parameter><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeBuffers</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeSkipList</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnSkipNodeArray</name> <init>= <expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkCount</name> <init>= <expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkRowCount</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>chunkRowCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>lastChunkIndex</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>/</operator> <name>chunkRowCount</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>lastChunkRowCount</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>%</operator> <name>chunkRowCount</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>stripeSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>stripeRowCount</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Flushing Stripe of size %d"</literal></expr></argument>, <argument><expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelidByRelfilenode</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>relfilenode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * check if the last chunk needs serialization , the last chunk was not serialized
	 * if it was not full yet, e.g.  (rowCount &gt; 0)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lastChunkRowCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SerializeChunkData</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>, <argument><expr><name>lastChunkIndex</name></expr></argument>, <argument><expr><name>lastChunkRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* update buffer sizes in stripe skip list */</comment>
	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNodeArray</name> <init>= <expr><name><name>columnSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnBuffers</name> <modifier>*</modifier></type><name>columnBuffers</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnBuffersArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name>chunkCount</name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnChunkBuffers</name> <modifier>*</modifier></type><name>chunkBuffers</name> <init>=
				<expr><name><name>columnBuffers</name><operator>-&gt;</operator><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>existsBufferSize</name> <init>= <expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>existsBuffer</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNode</name> <init>= <expr><operator>&amp;</operator><name><name>chunkSkipNodeArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>existsChunkOffset</name></name> <operator>=</operator> <name>stripeSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>existsLength</name></name> <operator>=</operator> <name>existsBufferSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>stripeSize</name> <operator>+=</operator> <name>existsBufferSize</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name>chunkCount</name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnChunkBuffers</name> <modifier>*</modifier></type><name>chunkBuffers</name> <init>=
				<expr><name><name>columnBuffers</name><operator>-&gt;</operator><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type> <name>valueBufferSize</name> <init>= <expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>valueBuffer</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CompressionType</name></type> <name>valueCompressionType</name> <init>= <expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>valueCompressionType</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNode</name> <init>= <expr><operator>&amp;</operator><name><name>chunkSkipNodeArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>valueChunkOffset</name></name> <operator>=</operator> <name>stripeSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>valueLength</name></name> <operator>=</operator> <name>valueBufferSize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>valueCompressionType</name></name> <operator>=</operator> <name>valueCompressionType</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>valueCompressionLevel</name></name> <operator>=</operator> <name><name>writeState</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>compressionLevel</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>decompressedValueSize</name></name> <operator>=</operator> <name><name>chunkBuffers</name><operator>-&gt;</operator><name>decompressedValueSize</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>stripeSize</name> <operator>+=</operator> <name>valueBufferSize</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>=
		<expr><call><name>CompleteStripeReservation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>emptyStripeReservation</name><operator>-&gt;</operator><name>stripeId</name></name></expr></argument>,
								  <argument><expr><name>stripeSize</name></expr></argument>, <argument><expr><name>stripeRowCount</name></expr></argument>, <argument><expr><name>chunkCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>currentFileOffset</name> <init>= <expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>fileOffset</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Each stripe has only one section:
	 * Data section, in which we store data for each column continuously.
	 * We store data for each for each column in chunks. For each chunk, we
	 * store two buffers: "exists" buffer, and "value" buffer. "exists" buffer
	 * tells which values are not NULL. "value" buffer contains values for
	 * present values. For each column, we first store all "exists" buffers,
	 * and then all "value" buffers.
	 */</comment>

	<comment type="block">/* flush the data buffers */</comment>
	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnBuffers</name> <modifier>*</modifier></type><name>columnBuffers</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnBuffersArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnChunkBuffers</name> <modifier>*</modifier></type><name>chunkBuffers</name> <init>=
				<expr><name><name>columnBuffers</name><operator>-&gt;</operator><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>existsBuffer</name> <init>= <expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>existsBuffer</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ColumnarStorageWrite</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>currentFileOffset</name></expr></argument>,
								 <argument><expr><name><name>existsBuffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>existsBuffer</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>currentFileOffset</name> <operator>+=</operator> <name><name>existsBuffer</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnChunkBuffers</name> <modifier>*</modifier></type><name>chunkBuffers</name> <init>=
				<expr><name><name>columnBuffers</name><operator>-&gt;</operator><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>valueBuffer</name> <init>= <expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>valueBuffer</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ColumnarStorageWrite</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>currentFileOffset</name></expr></argument>,
								 <argument><expr><name><name>valueBuffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>valueBuffer</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>currentFileOffset</name> <operator>+=</operator> <name><name>valueBuffer</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>SaveChunkGroups</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>relfilenode</name></name></expr></argument>,
					<argument><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
					<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>chunkGroupRowCounts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SaveStripeSkipList</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>relfilenode</name></name></expr></argument>,
					   <argument><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
					   <argument><expr><name>stripeSkipList</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>chunkGroupRowCounts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SerializeBoolArray serializes the given boolean array and returns the result
 * as a StringInfo. This function packs every 8 boolean values into one byte.
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>SerializeBoolArray</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>boolArray</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>boolArrayLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>boolArrayIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>byteCount</name> <init>= <expr><operator>(</operator><operator>(</operator><name>boolArrayLength</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>+</operator> <operator>(</operator><literal type="number">8</literal> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StringInfo</name></type> <name>boolArrayBuffer</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>boolArrayBuffer</name></expr></argument>, <argument><expr><name>byteCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>boolArrayBuffer</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>byteCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>boolArrayBuffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>byteCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>boolArrayIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>boolArrayIndex</name> <operator>&lt;</operator> <name>boolArrayLength</name></expr>;</condition> <incr><expr><name>boolArrayIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>boolArray</name><index>[<expr><name>boolArrayIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type> <name>byteIndex</name> <init>= <expr><name>boolArrayIndex</name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type> <name>bitIndex</name> <init>= <expr><name>boolArrayIndex</name> <operator>%</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>boolArrayBuffer</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>byteIndex</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitIndex</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>boolArrayBuffer</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SerializeSingleDatum serializes the given datum value and appends it to the
 * provided string info buffer.
 *
 * Since we don't want to limit datum buffer size to RSIZE_MAX unnecessarily,
 * we use memcpy instead of memcpy_s several places in this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SerializeSingleDatum</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>datumBuffer</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>datumTypeByValue</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>datumTypeLength</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>datumTypeAlign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>datumLength</name> <init>= <expr><call><name>att_addlength_datum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>datumTypeLength</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>datumLengthAligned</name> <init>= <expr><call><name>att_align_nominal</name><argument_list>(<argument><expr><name>datumLength</name></expr></argument>, <argument><expr><name>datumTypeAlign</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>datumBuffer</name></expr></argument>, <argument><expr><name>datumLengthAligned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>currentDatumDataPointer</name> <init>= <expr><name><name>datumBuffer</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>datumBuffer</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>currentDatumDataPointer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>datumLengthAligned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>datumTypeLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>datumTypeByValue</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>store_att_byval</name><argument_list>(<argument><expr><name>currentDatumDataPointer</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>, <argument><expr><name>datumTypeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>currentDatumDataPointer</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>datumTypeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IGNORE-BANNED */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>datumTypeByValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>currentDatumDataPointer</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>datumLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IGNORE-BANNED */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>datumBuffer</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>datumLengthAligned</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SerializeChunkData serializes and compresses chunk data at given chunk index with given
 * compression type for every column.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SerializeChunkData</name><parameter_list>(<parameter><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>chunkIndex</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>rowCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>stripeBuffers</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkData</name> <modifier>*</modifier></type><name>chunkData</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>chunkData</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CompressionType</name></type> <name>requestedCompressionType</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>compressionType</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>compressionLevel</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>compressionLevel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint32</name></type> <name>columnCount</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>compressionBuffer</name> <init>= <expr><name><name>writeState</name><operator>-&gt;</operator><name>compressionBuffer</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>writeState</name><operator>-&gt;</operator><name>chunkGroupRowCounts</name></name> <operator>=</operator>
		<call><name>lappend_int</name><argument_list>(<argument><expr><name><name>writeState</name><operator>-&gt;</operator><name>chunkGroupRowCounts</name></name></expr></argument>, <argument><expr><name>rowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* serialize exist values, data values are already serialized */</comment>
	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnBuffers</name> <modifier>*</modifier></type><name>columnBuffers</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnBuffersArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnChunkBuffers</name> <modifier>*</modifier></type><name>chunkBuffers</name> <init>= <expr><name><name>columnBuffers</name><operator>-&gt;</operator><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>existsBuffer</name></name> <operator>=</operator>
			<call><name>SerializeBoolArray</name><argument_list>(<argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>rowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * check and compress value buffers, if a value buffer is not compressable
	 * then keep it as uncompressed, store compression information.
	 */</comment>
	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnBuffers</name> <modifier>*</modifier></type><name>columnBuffers</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnBuffersArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnChunkBuffers</name> <modifier>*</modifier></type><name>chunkBuffers</name> <init>= <expr><name><name>columnBuffers</name><operator>-&gt;</operator><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CompressionType</name></type> <name>actualCompressionType</name> <init>= <expr><name>COMPRESSION_NONE</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>StringInfo</name></type> <name>serializedValueBuffer</name> <init>= <expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueBufferArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>requestedCompressionType</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			   <name>requestedCompressionType</name> <operator>&lt;</operator> <name>COMPRESSION_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>decompressedValueSize</name></name> <operator>=</operator>
			<name><name>chunkData</name><operator>-&gt;</operator><name>valueBufferArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name><operator>-&gt;</operator><name>len</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * if serializedValueBuffer is be compressed, update serializedValueBuffer
		 * with compressed data and store compression type.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>compressed</name> <init>= <expr><call><name>CompressBuffer</name><argument_list>(<argument><expr><name>serializedValueBuffer</name></expr></argument>, <argument><expr><name>compressionBuffer</name></expr></argument>,
										 <argument><expr><name>requestedCompressionType</name></expr></argument>,
										 <argument><expr><name>compressionLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>compressed</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>serializedValueBuffer</name> <operator>=</operator> <name>compressionBuffer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>actualCompressionType</name> <operator>=</operator> <name>requestedCompressionType</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* store (compressed) value buffer */</comment>
		<expr_stmt><expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>valueCompressionType</name></name> <operator>=</operator> <name>actualCompressionType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>valueBuffer</name></name> <operator>=</operator> <call><name>CopyStringInfo</name><argument_list>(<argument><expr><name>serializedValueBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* valueBuffer needs to be reset for next chunk's data */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueBufferArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateChunkSkipNodeMinMax takes the given column value, and checks if this
 * value falls outside the range of minimum/maximum values of the given column
 * chunk skip node. If it does, the function updates the column chunk skip node
 * accordingly.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateChunkSkipNodeMinMax</name><parameter_list>(<parameter><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNode</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>columnValue</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>columnTypeByValue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>columnTypeLength</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>columnCollation</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>comparisonFunction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasMinMax</name> <init>= <expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>hasMinMax</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>previousMinimum</name> <init>= <expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>minimumValue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>previousMaximum</name> <init>= <expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>maximumValue</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>currentMinimum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>currentMaximum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if type doesn't have a comparison function, skip min/max values */</comment>
	<if_stmt><if>if <condition>(<expr><name>comparisonFunction</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasMinMax</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>currentMinimum</name> <operator>=</operator> <call><name>DatumCopy</name><argument_list>(<argument><expr><name>columnValue</name></expr></argument>, <argument><expr><name>columnTypeByValue</name></expr></argument>, <argument><expr><name>columnTypeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>currentMaximum</name> <operator>=</operator> <call><name>DatumCopy</name><argument_list>(<argument><expr><name>columnValue</name></expr></argument>, <argument><expr><name>columnTypeByValue</name></expr></argument>, <argument><expr><name>columnTypeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name>minimumComparisonDatum</name> <init>= <expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>comparisonFunction</name></expr></argument>,
														 <argument><expr><name>columnCollation</name></expr></argument>, <argument><expr><name>columnValue</name></expr></argument>,
														 <argument><expr><name>previousMinimum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>maximumComparisonDatum</name> <init>= <expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>comparisonFunction</name></expr></argument>,
														 <argument><expr><name>columnCollation</name></expr></argument>, <argument><expr><name>columnValue</name></expr></argument>,
														 <argument><expr><name>previousMaximum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>minimumComparison</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>minimumComparisonDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>maximumComparison</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>maximumComparisonDatum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>minimumComparison</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>currentMinimum</name> <operator>=</operator> <call><name>DatumCopy</name><argument_list>(<argument><expr><name>columnValue</name></expr></argument>, <argument><expr><name>columnTypeByValue</name></expr></argument>, <argument><expr><name>columnTypeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>currentMinimum</name> <operator>=</operator> <name>previousMinimum</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>maximumComparison</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>currentMaximum</name> <operator>=</operator> <call><name>DatumCopy</name><argument_list>(<argument><expr><name>columnValue</name></expr></argument>, <argument><expr><name>columnTypeByValue</name></expr></argument>, <argument><expr><name>columnTypeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>currentMaximum</name> <operator>=</operator> <name>previousMaximum</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>hasMinMax</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>minimumValue</name></name> <operator>=</operator> <name>currentMinimum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>maximumValue</name></name> <operator>=</operator> <name>currentMaximum</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Creates a copy of the given datum. */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>DatumCopy</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>datumTypeByValue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datumTypeLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type> <name>datumCopy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>datumTypeByValue</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>datumCopy</name> <operator>=</operator> <name>datum</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>datumLength</name> <init>= <expr><call><name>att_addlength_datum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>datumTypeLength</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>datumData</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>datumLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We use IGNORE-BANNED here since we don't want to limit datum size to
		 * RSIZE_MAX unnecessarily.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>datumData</name></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>datumLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IGNORE-BANNED */</comment>

		<expr_stmt><expr><name>datumCopy</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>datumData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>datumCopy</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CopyStringInfo creates a deep copy of given source string allocating only needed
 * amount of memory.
 */</comment>
<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>CopyStringInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>sourceString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>targetString</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StringInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sourceString</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>targetString</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>sourceString</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetString</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>sourceString</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetString</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>=</operator> <name><name>sourceString</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We use IGNORE-BANNED here since we don't want to limit string
		 * buffer size to RSIZE_MAX unnecessarily.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>targetString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>sourceString</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>sourceString</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IGNORE-BANNED */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>targetString</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>ContainsPendingWrites</name><parameter_list>(<parameter><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>stripeBuffers</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
