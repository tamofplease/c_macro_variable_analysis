<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/columnar/columnar_customscan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * columnar_customscan.c
 *
 * This file contains the implementation of a postgres custom scan that
 * we use to push down the projections into the table access methods.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"citus_version.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/spccache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_customscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_metadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * ColumnarScanState represents the state for a columnar scan. It's a
 * CustomScanState with additional fields specific to columnar scans.
 */</comment>
<typedef>typedef <type><struct>struct <name>ColumnarScanState</name>
<block>{
	<decl_stmt><decl><type><name>CustomScanState</name></type> <name>custom_scanstate</name></decl>;</decl_stmt> <comment type="block">/* must be first field */</comment>

	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>css_RuntimeContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
}</block></struct></type> <name>ColumnarScanState</name>;</typedef>


<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>PathPredicate</name>)<parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl></typedef>


<comment type="block">/* functions to cost paths in-place */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CostColumnarPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CostColumnarIndexPath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
								  <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>indexPath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CostColumnarSeqPath</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CostColumnarScan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
							 <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numberOfColumnsRead</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>nClauses</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* functions to add new paths */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddColumnarScanPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								 <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddColumnarScanPath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_relids</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* helper functions to be used when costing paths or altering them */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemovePathsByPredicate</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>PathPredicate</name></type> <name>removePathPredicate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsNotIndexPath</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Cost</name></type> <name>ColumnarIndexScanAdditionalCost</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
											<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>indexPath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>RelationIdGetNumberOfAttributes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Cost</name></type> <name>ColumnarPerStripeScanCost</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>numberOfColumnsRead</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>ColumnarTableStripeCount</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type> <name>CreateColumnarSeqScanPath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddColumnarScanPathsRec</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
									<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>paramRelids</name></decl></parameter>,
									<parameter><decl><type><name>Relids</name></type> <name>candidateRelids</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>depthLimit</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* hooks and callbacks */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarSetRelPathlistHook</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>,
									   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarGetRelationInfoHook</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationObjectId</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>inhparent</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type> <name>ColumnarScanPath_PlanCustomPath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
											  <parameter><decl><type><name><name>struct</name> <name>CustomPath</name></name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
											  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ColumnarScanPath_ReparameterizeCustomPathByChild</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
															   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_private</name></decl></parameter>,
															   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>ColumnarScan_CreateCustomScanState</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarScan_BeginCustomScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
										 <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type> <name>ColumnarScan_ExecCustomScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarScan_EndCustomScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarScan_ReScanCustomScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarScan_ExplainCustomScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
										   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* helper functions to build strings for EXPLAIN */</comment>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>ColumnarPushdownClausesStr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>ColumnarProjectedColumnsStr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
												<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>set_deparse_context_planstate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dpcontext</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* other helpers */</comment>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ColumnarVarNeeded</name><parameter_list>(<parameter><decl><type><name>ColumnarScanState</name> <modifier>*</modifier></type><name>columnarScanState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type> <name>ColumnarAttrNeeded</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* saved hook value in case of unload */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>set_rel_pathlist_hook_type</name></type> <name>PreviousSetRelPathlistHook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>get_relation_info_hook_type</name></type> <name>PreviousGetRelationInfoHook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>EnableColumnarCustomScan</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>EnableColumnarQualPushdown</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>ColumnarQualPushdownCorrelationThreshold</name> <init>= <expr><literal type="number">0.9</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ColumnarMaxCustomScanPaths</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ColumnarPlannerDebugLevel</name> <init>= <expr><name>DEBUG3</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>CustomPathMethods</name></name></type> <name>ColumnarScanPathMethods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"ColumnarScan"</literal></expr>,
	<expr><operator>.</operator><name>PlanCustomPath</name> <operator>=</operator> <name>ColumnarScanPath_PlanCustomPath</name></expr>,
	<expr><operator>.</operator><name>ReparameterizeCustomPathByChild</name> <operator>=</operator> <name>ColumnarScanPath_ReparameterizeCustomPathByChild</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>CustomScanMethods</name></name></type> <name>ColumnarScanScanMethods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"ColumnarScan"</literal></expr>,
	<expr><operator>.</operator><name>CreateCustomScanState</name> <operator>=</operator> <name>ColumnarScan_CreateCustomScanState</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>CustomExecMethods</name></name></type> <name>ColumnarScanExecuteMethods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>CustomName</name> <operator>=</operator> <literal type="string">"ColumnarScan"</literal></expr>,

	<expr><operator>.</operator><name>BeginCustomScan</name> <operator>=</operator> <name>ColumnarScan_BeginCustomScan</name></expr>,
	<expr><operator>.</operator><name>ExecCustomScan</name> <operator>=</operator> <name>ColumnarScan_ExecCustomScan</name></expr>,
	<expr><operator>.</operator><name>EndCustomScan</name> <operator>=</operator> <name>ColumnarScan_EndCustomScan</name></expr>,
	<expr><operator>.</operator><name>ReScanCustomScan</name> <operator>=</operator> <name>ColumnarScan_ReScanCustomScan</name></expr>,

	<expr><operator>.</operator><name>ExplainCustomScan</name> <operator>=</operator> <name>ColumnarScan_ExplainCustomScan</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>debug_level_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{ <expr><literal type="string">"debug5"</literal></expr>, <expr><name>DEBUG5</name></expr>, <expr><name>false</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"debug4"</literal></expr>, <expr><name>DEBUG4</name></expr>, <expr><name>false</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"debug3"</literal></expr>, <expr><name>DEBUG3</name></expr>, <expr><name>false</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"debug2"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>false</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"debug1"</literal></expr>, <expr><name>DEBUG1</name></expr>, <expr><name>false</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"debug"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>true</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"info"</literal></expr>, <expr><name>INFO</name></expr>, <expr><name>false</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"notice"</literal></expr>, <expr><name>NOTICE</name></expr>, <expr><name>false</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"warning"</literal></expr>, <expr><name>WARNING</name></expr>, <expr><name>false</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="string">"log"</literal></expr>, <expr><name>LOG</name></expr>, <expr><name>false</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * columnar_customscan_init installs the hook required to intercept the postgres planner and
 * provide extra paths for columnar tables
 */</comment>
<function><type><name>void</name></type>
<name>columnar_customscan_init</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>PreviousSetRelPathlistHook</name> <operator>=</operator> <name>set_rel_pathlist_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>set_rel_pathlist_hook</name> <operator>=</operator> <name>ColumnarSetRelPathlistHook</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>PreviousGetRelationInfoHook</name> <operator>=</operator> <name>get_relation_info_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>get_relation_info_hook</name> <operator>=</operator> <name>ColumnarGetRelationInfoHook</name></expr>;</expr_stmt>

	<comment type="block">/* register customscan specific GUC's */</comment>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
		<argument><expr><literal type="string">"columnar.enable_custom_scan"</literal></expr></argument>,
		<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the use of a custom scan to push projections and quals "</literal>
					 <literal type="string">"into the storage layer."</literal></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>EnableColumnarCustomScan</name></expr></argument>,
		<argument><expr><name>true</name></expr></argument>,
		<argument><expr><name>PGC_USERSET</name></expr></argument>,
		<argument><expr><name>GUC_NO_SHOW_ALL</name></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
		<argument><expr><literal type="string">"columnar.enable_qual_pushdown"</literal></expr></argument>,
		<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables qual pushdown into columnar. This has no effect unless "</literal>
					 <literal type="string">"columnar.enable_custom_scan is true."</literal></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>EnableColumnarQualPushdown</name></expr></argument>,
		<argument><expr><name>true</name></expr></argument>,
		<argument><expr><name>PGC_USERSET</name></expr></argument>,
		<argument><expr><name>GUC_NO_SHOW_ALL</name></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DefineCustomRealVariable</name><argument_list>(
		<argument><expr><literal type="string">"columnar.qual_pushdown_correlation_threshold"</literal></expr></argument>,
		<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Correlation threshold to attempt to push a qual "</literal>
					 <literal type="string">"referencing the given column. A value of 0 means "</literal>
					 <literal type="string">"attempt to push down all quals, even if the column "</literal>
					 <literal type="string">"is uncorrelated."</literal></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>ColumnarQualPushdownCorrelationThreshold</name></expr></argument>,
		<argument><expr><literal type="number">0.9</literal></expr></argument>,
		<argument><expr><literal type="number">0.0</literal></expr></argument>,
		<argument><expr><literal type="number">1.0</literal></expr></argument>,
		<argument><expr><name>PGC_USERSET</name></expr></argument>,
		<argument><expr><name>GUC_NO_SHOW_ALL</name></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DefineCustomIntVariable</name><argument_list>(
		<argument><expr><literal type="string">"columnar.max_custom_scan_paths"</literal></expr></argument>,
		<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of custom scan paths to generate "</literal>
					 <literal type="string">"for a columnar table when planning."</literal></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>ColumnarMaxCustomScanPaths</name></expr></argument>,
		<argument><expr><literal type="number">64</literal></expr></argument>,
		<argument><expr><literal type="number">1</literal></expr></argument>,
		<argument><expr><literal type="number">1024</literal></expr></argument>,
		<argument><expr><name>PGC_USERSET</name></expr></argument>,
		<argument><expr><name>GUC_NO_SHOW_ALL</name></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DefineCustomEnumVariable</name><argument_list>(
		<argument><expr><literal type="string">"columnar.planner_debug_level"</literal></expr></argument>,
		<argument><expr><literal type="string">"Message level for columnar planning information."</literal></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>ColumnarPlannerDebugLevel</name></expr></argument>,
		<argument><expr><name>DEBUG3</name></expr></argument>,
		<argument><expr><name>debug_level_options</name></expr></argument>,
		<argument><expr><name>PGC_USERSET</name></expr></argument>,
		<argument><expr><literal type="number">0</literal></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RegisterCustomScanMethods</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ColumnarScanScanMethods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarSetRelPathlistHook</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>,
						   <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* call into previous hook if assigned */</comment>
	<if_stmt><if>if <condition>(<expr><name>PreviousSetRelPathlistHook</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PreviousSetRelPathlistHook</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>||</operator> <name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* some calls to the pathlist hook don't have a valid relation set. Do nothing */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Here we want to inspect if this relation pathlist hook is accessing a columnar table.
	 * If that is the case we want to insert an extra path that pushes down the projection
	 * into the scan of the table to minimize the data read.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_tableam</name></name> <operator>==</operator> <call><name>GetColumnarTableAmRoutine</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sample scans not supported on columnar tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Parallel scans on columnar tables are already discardad by
			 * ColumnarGetRelationInfoHook but be on the safe side.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel scans on columnar are not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * There are cases where IndexPath is normally more preferrable over
		 * SeqPath for heapAM but not for columnarAM. In such cases, an
		 * IndexPath could wrongly dominate a SeqPath based on the costs
		 * estimated by postgres earlier. For this reason, here we manually
		 * create a SeqPath, estimate the cost based on columnarAM and append
		 * to pathlist.
		 *
		 * Before doing that, we first re-cost all the existing paths so that
		 * add_path makes correct cost comparisons when appending our SeqPath.
		 */</comment>
		<expr_stmt><expr><call><name>CostColumnarPaths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>seqPath</name> <init>= <expr><call><name>CreateColumnarSeqScanPath</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>seqPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>EnableColumnarCustomScan</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pathlist hook for columnar table am"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * When columnar custom scan is enabled (columnar.enable_custom_scan),
			 * we only consider ColumnarScanPath's &amp; IndexPath's. For this reason,
			 * we remove other paths and re-estimate IndexPath costs to make accurate
			 * comparisons between them.
			 *
			 * Even more, we might calculate an equal cost for a
			 * ColumnarCustomScan and a SeqPath if we are reading all columns
			 * of given table since we don't consider chunk group filtering
			 * when costing ColumnarCustomScan.
			 * In that case, if we don't remove SeqPath's, we might wrongly choose
			 * SeqPath thinking that its cost would be equal to ColumnarCustomScan.
			 */</comment>
			<expr_stmt><expr><call><name>RemovePathsByPredicate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>IsNotIndexPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AddColumnarScanPaths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarGetRelationInfoHook</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationObjectId</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>inhparent</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>PreviousGetRelationInfoHook</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PreviousGetRelationInfoHook</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relationObjectId</name></expr></argument>, <argument><expr><name>inhparent</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsColumnarTableAmTable</name><argument_list>(<argument><expr><name>relationObjectId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* disable parallel query */</comment>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rel_parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* disable index-only scan */</comment>
		<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>indexOptInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>indexOptInfo</argument>, <argument>rel-&gt;indexlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>indexOptInfo</name><operator>-&gt;</operator><name>canreturn</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>indexOptInfo</name><operator>-&gt;</operator><name>ncolumns</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RemovePathsByPredicate removes the paths that removePathPredicate
 * evaluates to true from pathlist of given rel.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemovePathsByPredicate</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>PathPredicate</name></type> <name>removePathPredicate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>filteredPathList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>path</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>removePathPredicate</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>filteredPathList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>filteredPathList</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <name>filteredPathList</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IsNotIndexPath returns true if given path is not an IndexPath.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsNotIndexPath</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateColumnarSeqScanPath returns Path for sequential scan on columnar
 * table with relationId.
 */</comment>
<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>CreateColumnarSeqScanPath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* columnar doesn't support parallel scan */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>parallelWorkers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relids</name></type> <name>requiredOuter</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>create_seqscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>requiredOuter</name></expr></argument>, <argument><expr><name>parallelWorkers</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CostColumnarSeqPath</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CostColumnarPaths re-costs paths of given RelOptInfo for
 * columnar table with relationId.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CostColumnarPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>path</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Since we don't provide implementations for scan_bitmap_next_block
			 * &amp; scan_bitmap_next_tuple, postgres doesn't generate bitmap index
			 * scan paths for columnar tables already (see related comments in
			 * TableAmRoutine). For this reason, we only consider IndexPath's
			 * here.
			 */</comment>
			<expr_stmt><expr><call><name>CostColumnarIndexPath</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_SeqScan</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CostColumnarSeqPath</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * CostColumnarIndexPath re-costs given index path for columnar table with
 * relationId.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CostColumnarIndexPath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
					  <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>indexPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_indexscan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* costs are already set to disable_cost, don't adjust them */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar table index scan costs estimated by "</literal>
							<literal type="string">"indexAM: startup cost = %.10f, total cost = "</literal>
							<literal type="string">"%.10f"</literal></expr></argument>, <argument><expr><name><name>indexPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr></argument>,
							<argument><expr><name><name>indexPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We estimate the cost for columnar table read during index scan. Also,
	 * instead of overwriting total cost, we "add" ours to the cost estimated
	 * by indexAM since we should consider index traversal related costs too.
	 */</comment>
	<decl_stmt><decl><type><name>Cost</name></type> <name>columnarIndexScanCost</name> <init>= <expr><call><name>ColumnarIndexScanAdditionalCost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>,
																 <argument><expr><name>indexPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>indexPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name>columnarIndexScanCost</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar table index scan costs re-estimated "</literal>
							<literal type="string">"by columnarAM (including indexAM costs): "</literal>
							<literal type="string">"startup cost = %.10f, total cost = %.10f"</literal></expr></argument>,
							<argument><expr><name><name>indexPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr></argument>,
							<argument><expr><name><name>indexPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarIndexScanAdditionalCost returns additional cost estimated for
 * index scan described by IndexPath for columnar table with relationId.
 */</comment>
<function><type><specifier>static</specifier> <name>Cost</name></type>
<name>ColumnarIndexScanAdditionalCost</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>indexPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>numberOfColumnsRead</name> <init>= <expr><call><name>RelationIdGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>perStripeCost</name> <init>= <expr><call><name>ColumnarPerStripeScanCost</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>numberOfColumnsRead</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't need to pass correct loop count to amcostestimate since we
	 * will only use index correlation &amp; index selectivity, and loop count
	 * doesn't have any effect on those two.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>fakeLoopCount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>fakeIndexStartupCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>fakeIndexTotalCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>fakeIndexPages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>indexSelectivity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>indexCorrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>amcostestimate_function</name></type> <name>amcostestimate</name> <init>= <expr><name><name>indexPath</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>amcostestimate</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>amcostestimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>indexPath</name></expr></argument>, <argument><expr><name>fakeLoopCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fakeIndexStartupCost</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>fakeIndexTotalCost</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexSelectivity</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>indexCorrelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fakeIndexPages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>rowCount</name> <init>= <expr><call><name>ColumnarTableRowCount</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>estimatedRows</name> <init>= <expr><name>rowCount</name> <operator>*</operator> <name>indexSelectivity</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In the worst case (i.e no correlation between the column &amp; the index),
	 * we need to read a different stripe for each row.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>maxStripeReadCount</name> <init>= <expr><name>estimatedRows</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * In the best case (i.e the column is fully correlated with the index),
	 * we wouldn't read the same stripe again and again thanks
	 * to locality.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>avgStripeRowCount</name> <init>=
		<expr><name>rowCount</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>ColumnarTableStripeCount</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>minStripeReadCount</name> <init>= <expr><name>estimatedRows</name> <operator>/</operator> <name>avgStripeRowCount</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * While being close to 0 means low correlation, being close to -1 or +1
	 * means high correlation. For index scans on columnar tables, it doesn't
	 * matter if the column and the index are "correlated" (+1) or
	 * "anti-correlated" (-1) since both help us avoiding from reading the
	 * same stripe again and again.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>absIndexCorrelation</name> <init>= <expr><call><name>Abs</name><argument_list>(<argument><expr><name>indexCorrelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * To estimate the number of stripes that we need to read, we do linear
	 * interpolation between minStripeReadCount &amp; maxStripeReadCount. To do
	 * that, we use complement to 1 of absolute correlation, where being
	 * close to 0 means high correlation and being close to 1 means low
	 * correlation.
	 * In practice, we only want to do an index scan when absIndexCorrelation
	 * is 1 (or extremely close to it), or when the absolute number of tuples
	 * returned is very small. Other cases will have a prohibitive cost.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>complementIndexCorrelation</name> <init>= <expr><literal type="number">1</literal> <operator>-</operator> <name>absIndexCorrelation</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>estimatedStripeReadCount</name> <init>=
		<expr><name>minStripeReadCount</name> <operator>+</operator> <name>complementIndexCorrelation</name> <operator>*</operator> <operator>(</operator><name>maxStripeReadCount</name> <operator>-</operator>
														   <name>minStripeReadCount</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* even in the best case, we will read a single stripe */</comment>
	<expr_stmt><expr><name>estimatedStripeReadCount</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>estimatedStripeReadCount</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Cost</name></type> <name>scanCost</name> <init>= <expr><name>perStripeCost</name> <operator>*</operator> <name>estimatedStripeReadCount</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"re-costing index scan for columnar table: "</literal>
							<literal type="string">"selectivity = %.10f, complement abs "</literal>
							<literal type="string">"correlation = %.10f, per stripe cost = %.10f, "</literal>
							<literal type="string">"estimated stripe read count = %.10f, "</literal>
							<literal type="string">"total additional cost = %.10f"</literal></expr></argument>,
							<argument><expr><name>indexSelectivity</name></expr></argument>, <argument><expr><name>complementIndexCorrelation</name></expr></argument>,
							<argument><expr><name>perStripeCost</name></expr></argument>, <argument><expr><name>estimatedStripeReadCount</name></expr></argument>,
							<argument><expr><name>scanCost</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scanCost</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CostColumnarSeqPath sets costs given seq path for columnar table with
 * relationId.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CostColumnarSeqPath</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_seqscan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* costs are already set to disable_cost, don't adjust them */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Seq scan doesn't support projection or qual pushdown, so we will read
	 * all the stripes and all the columns.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>stripesToRead</name> <init>= <expr><call><name>ColumnarTableStripeCount</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numberOfColumnsRead</name> <init>= <expr><call><name>RelationIdGetNumberOfAttributes</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>stripesToRead</name> <operator>*</operator>
					   <call><name>ColumnarPerStripeScanCost</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>numberOfColumnsRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RelationIdGetNumberOfAttributes returns number of attributes that relation
 * with relationId has.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>RelationIdGetNumberOfAttributes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>nattrs</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nattrs</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckVarStats() checks whether a qual involving this Var is likely to be
 * useful based on the correlation stats. If so, or if stats are unavailable,
 * return true; otherwise return false and sets absVarCorrelation in case
 * caller wants to use for logging purposes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckVarStats</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sortop</name></decl></parameter>, <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>absVarCorrelation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Collect isunique, ndistinct, and varCorrelation.
	 */</comment>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>varStatData</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varStatData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>varStatData</name><operator>.</operator><name>rel</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>varStatData</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>varStatData</name><operator>.</operator><name>statsTuple</name></name></expr></argument>,
						  <argument><expr><name>STATISTIC_KIND_CORRELATION</name></expr></argument>, <argument><expr><name>sortop</name></expr></argument>,
						  <argument><expr><name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>varStatData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>float4</name></type> <name>varCorrelation</name> <init>= <expr><name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>varStatData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the Var is not highly correlated, then the chunk's min/max bounds
	 * will be nearly useless.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><name>varCorrelation</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>ColumnarQualPushdownCorrelationThreshold</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>absVarCorrelation</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Report absVarCorrelation if caller wants to know why given
			 * var is rejected.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>absVarCorrelation</name> <operator>=</operator> <call><name>Abs</name><argument_list>(<argument><expr><name>varCorrelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExprReferencesRelid returns true if any of the Expr's Vars refer to the
 * given relid; false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExprReferencesRelid</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>exprVars</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(
		<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
		<name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator> <name>PVC_RECURSE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprVars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>relid</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractPushdownClause extracts an Expr node from given clause for pushing down
 * into the given rel (including join clauses). This test may not be exact in
 * all cases; it's used to reduce the search space for parameterization.
 *
 * Note that we don't try to handle cases like "Var + ExtParam = 3". That
 * would require going through eval_const_expression after parameter binding,
 * and that doesn't seem worth the effort. Here we just look for "Var op Expr"
 * or "Expr op Var", where Var references rel and Expr references other rels
 * (or no rels at all).
 *
 * Moreover, this function also looks into BoolExpr's to recursively extract
 * pushdownable OpExpr's of them:
 * i)   AND_EXPR:
 *      Take pushdownable args of AND expressions by ignoring the other args.
 * ii)  OR_EXPR:
 *      Ignore the whole OR expression if we cannot exract a pushdownable Expr
 *      from one of its args.
 * iii) NOT_EXPR:
 *      Simply ignore NOT expressions since we don't expect to see them before
 *      an expression that we can pushdown, see the comment in function.
 *
 * The reasoning for those three rules could also be summarized as such;
 * for any expression that we cannot push-down, we must assume that it
 * evaluates to true.
 *
 * For example, given following WHERE clause:
 * (
 *     (a &gt; random() OR a &lt; 30)
 *     AND
 *     a &lt; 200
 * ) OR
 * (
 *     a = 300
 *     OR
 *     a &gt; 400
 * );
 * Even if we can pushdown (a &lt; 30), we cannot pushdown (a &gt; random() OR a &lt; 30)
 * due to (a &gt; random()). However, we can pushdown (a &lt; 200), so we extract
 * (a &lt; 200) from the lhs of the top level OR expression.
 *
 * For the rhs of the top level OR expression, since we can pushdown both (a = 300)
 * and (a &gt; 400), we take this part as is.
 *
 * Finally, since both sides of the top level OR expression yielded pushdownable
 * expressions, we will pushdown the following:
 *  (a &lt; 200) OR ((a = 300) OR (a &gt; 400))
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>ExtractPushdownClause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>boolExpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>boolExpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>NOT_EXPR</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Standard planner should have already applied de-morgan rule to
			 * simple NOT expressions. If we encounter with such an expression
			 * here, then it can't be a pushdownable one, such as:
			 *   WHERE id NOT IN (SELECT id FROM something).
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: cannot push down clause: "</literal>
							<literal type="string">"must not contain a subplan"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pushdownableArgs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>boolExprArg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach_ptr</name><argument_list>(<argument>boolExprArg</argument>, <argument>boolExpr-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pushdownableArg</name> <init>= <expr><call><name>ExtractPushdownClause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>boolExprArg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>pushdownableArg</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>pushdownableArgs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>pushdownableArgs</name></expr></argument>, <argument><expr><name>pushdownableArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>boolExpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>OR_EXPR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: cannot push down clause: "</literal>
								<literal type="string">"all arguments of an OR expression must be "</literal>
								<literal type="string">"pushdownable but one of them was not, due "</literal>
								<literal type="string">"to the reason given above"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* simply skip AND args that we cannot pushdown */</comment>
		</block_content>}</block>

		<decl_stmt><decl><type><name>int</name></type> <name>npushdownableArgs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>pushdownableArgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>npushdownableArgs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: cannot push down clause: "</literal>
							<literal type="string">"none of the arguments were pushdownable, "</literal>
							<literal type="string">"due to the reason(s) given above "</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>npushdownableArgs</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pushdownableArgs</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>boolExpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>AND_EXPR</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>make_andclause</name><argument_list>(<argument><expr><name>pushdownableArgs</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>boolExpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>OR_EXPR</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>pushdownableArgs</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* already discarded NOT expr, so should not be reachable */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: cannot push down clause: "</literal>
						<literal type="string">"must be binary operator expression"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>opExpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>lhs</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>opExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>rhs</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>opExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>varSide</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>exprSide</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>lhs</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>ExprReferencesRelid</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rhs</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>varSide</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exprSide</name> <operator>=</operator> <name>rhs</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>rhs</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>ExprReferencesRelid</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lhs</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>varSide</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exprSide</name> <operator>=</operator> <name>lhs</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: cannot push down clause: "</literal>
						<literal type="string">"must match 'Var &lt;op&gt; Expr' or 'Expr &lt;op&gt; Var'"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Var must only reference this rel, "</literal>
						 <literal type="string">"and Expr must not reference this rel"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>varSide</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: cannot push down clause: "</literal>
						<literal type="string">"var is whole-row reference or system column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>exprSide</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: cannot push down clause: "</literal>
						<literal type="string">"expr contains volatile functions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* only the default opclass is used for qual pushdown. */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>varOpClass</name> <init>= <expr><call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name><name>varSide</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>, <argument><expr><name>BTREE_AM_OID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>varOpFamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>varOpcInType</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>varOpClass</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>get_opclass_opfamily_and_input_type</name><argument_list>(<argument><expr><name>varOpClass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varOpFamily</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>varOpcInType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: cannot push down clause: "</literal>
						<literal type="string">"cannot find default btree opclass and opfamily for type: %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>varSide</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_in_opfamily</name><argument_list>(<argument><expr><name><name>opExpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name>varOpFamily</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: cannot push down clause: "</literal>
						<literal type="string">"operator %d not a member of opfamily %d"</literal></expr></argument>,
						<argument><expr><name><name>opExpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name>varOpFamily</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name> <init>= <expr><call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>varOpFamily</name></expr></argument>, <argument><expr><name>varOpcInType</name></expr></argument>,
									 <argument><expr><name>varOpcInType</name></expr></argument>, <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that statistics on the Var support the utility of this
	 * clause.
	 */</comment>
	<decl_stmt><decl><type><name>float4</name></type> <name>absVarCorrelation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckVarStats</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varSide</name></expr></argument>, <argument><expr><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>absVarCorrelation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: cannot push down clause: "</literal>
						<literal type="string">"absolute correlation (%.3f) of var attribute %d is "</literal>
						<literal type="string">"smaller than the value configured in "</literal>
						<literal type="string">"\"columnar.qual_pushdown_correlation_threshold\" "</literal>
						<literal type="string">"(%.3f)"</literal></expr></argument>, <argument><expr><name>absVarCorrelation</name></expr></argument>, <argument><expr><name><name>varSide</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>,
						<argument><expr><name>ColumnarQualPushdownCorrelationThreshold</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FilterPushdownClauses filters for clauses that are candidates for pushing
 * down into rel.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FilterPushdownClauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>inputClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>filteredClauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>inputClauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore clauses that don't refer to this rel, and pseudoconstants.
		 *
		 * XXX: A pseudoconstant may be of use, but it doesn't make sense to
		 * push it down because it doesn't contain any Vars. Look into if
		 * there's something we should do with pseudoconstants here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name> <operator>||</operator>
			<operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pushdownableExpr</name> <init>= <expr><call><name>ExtractPushdownClause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pushdownableExpr</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rinfo</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <name>pushdownableExpr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>filteredClauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>filteredClauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>filteredClauses</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * PushdownJoinClauseMatches is a callback that returns true, indicating that
 * we want all of the clauses from generate_implied_equalities_for_column().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PushdownJoinClauseMatches</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl></parameter>,
						  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindPushdownJoinClauses finds join clauses, including those implied by ECs,
 * that may be pushed down.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>FindPushdownJoinClauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauses</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>joininfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Here we are generating the clauses just so we can later extract the
	 * interesting relids. This is somewhat wasteful, but it allows us to
	 * filter out joinclauses, reducing the number of relids we need to
	 * consider.
	 *
	 * XXX: also find additional clauses for joininfo that are implied by ECs?
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ecClauses</name> <init>= <expr><call><name>generate_implied_equalities_for_column</name><argument_list>(
		<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>PushdownJoinClauseMatches</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
		<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_referencers</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allClauses</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>joinClauses</name></expr></argument>, <argument><expr><name>ecClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>FilterPushdownClauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>allClauses</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindCandidateRelids identifies candidate rels for parameterization from the
 * list of join clauses.
 *
 * Some rels cannot be considered for parameterization, such as a partitioned
 * parent of the given rel. Other rels are just not useful because they don't
 * appear in a join clause that could be pushed down.
 */</comment>
<function><type><specifier>static</specifier> <name>Relids</name></type>
<name>FindCandidateRelids</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relids</name></type> <name>candidateRelids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>joinClauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>candidateRelids</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>candidateRelids</name></expr></argument>,
										  <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>candidateRelids</name> <operator>=</operator> <call><name>bms_del_members</name><argument_list>(<argument><expr><name>candidateRelids</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>candidateRelids</name> <operator>=</operator> <call><name>bms_del_members</name><argument_list>(<argument><expr><name>candidateRelids</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>candidateRelids</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Combinations() calculates the number of combinations of n things taken k at
 * a time. When the correct result is large, the calculation may produce a
 * non-integer result, or overflow to inf, which caller should handle
 * appropriately.
 *
 * Use the following two formulae from Knuth TAoCP, 1.2.6:
 *    (2) Combinations(n, k) = (n*(n-1)..(n-k+1)) / (k*(k-1)..1)
 *    (5) Combinations(n, k) = Combinations(n, n-k)
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>Combinations</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>v</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If k is close to n, then both the numerator and the denominator are
	 * close to n!, and we may overflow even if the input is reasonable
	 * (e.g. Combinations(500, 500)). Use formula (5) to choose the smaller,
	 * but equivalent, k.
	 */</comment>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* calculate numerator of formula (2) first */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>n</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name>n</name> <operator>-</operator> <name>k</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>v</name> <operator>*=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Divide by each factor in the denominator of formula (2), skipping
	 * division by 1.
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>k</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>v</name> <operator>/=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ChooseDepthLimit() calculates the depth limit for the parameterization
 * search, given the number of candidate relations.
 *
 * The maximum number of paths generated for a given depthLimit is:
 *
 *    Combinations(nCandidates, 0) + Combinations(nCandidates, 1) + ... +
 *    Combinations(nCandidates, depthLimit)
 *
 * There's no closed formula for a partial sum of combinations, so just keep
 * increasing the depth until the number of combinations exceeds the limit.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ChooseDepthLimit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nCandidates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableColumnarQualPushdown</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>numPaths</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>depth</name> <operator>&lt;</operator> <name>nCandidates</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numPaths</name> <operator>+=</operator> <call><name>Combinations</name><argument_list>(<argument><expr><name>nCandidates</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>numPaths</name> <operator>&gt;</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>ColumnarMaxCustomScanPaths</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>depth</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AddColumnarScanPaths is the entry point for recursively generating
 * parameterized paths. See AddColumnarScanPathsRec() for discussion.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddColumnarScanPaths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClauses</name> <init>= <expr><call><name>FindPushdownJoinClauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type> <name>candidateRelids</name> <init>= <expr><call><name>FindCandidateRelids</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>joinClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>depthLimit</name> <init>= <expr><call><name>ChooseDepthLimit</name><argument_list>(<argument><expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>candidateRelids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* must always parameterize by lateral refs */</comment>
	<decl_stmt><decl><type><name>Relids</name></type> <name>paramRelids</name> <init>= <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AddColumnarScanPathsRec</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>paramRelids</name></expr></argument>, <argument><expr><name>candidateRelids</name></expr></argument>,
							<argument><expr><name>depthLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AddColumnarScanPathsRec is a recursive function to search the
 * parameterization space and add CustomPaths for columnar scans.
 *
 * The set paramRelids is the parameterization at the current level, and
 * candidateRelids is the set from which we draw to generate paths with
 * greater parameterization.
 *
 * Columnar tables resemble indexes because of the ability to push down
 * quals. Ordinary quals, such as x = 7, can be pushed down easily. But join
 * quals of the form "x = y" (where "y" comes from another rel) require the
 * proper parameterization.
 *
 * Paths that require more outer rels can push down more join clauses that
 * depend on those outer rels. But requiring more outer rels gives the planner
 * fewer options for the shape of the plan. That means there is a trade-off,
 * and we should generate plans of various parameterizations, then let the
 * planner choose. We always need to generate one minimally-parameterized path
 * (parameterized only by lateral refs, if present) to make sure that at least
 * one path can be chosen. Then, we generate as many parameterized paths as we
 * reasonably can.
 *
 * The set of all possible parameterizations is the power set of
 * candidateRelids. The power set has cardinality 2^N, where N is the
 * cardinality of candidateRelids. To avoid creating a huge number of paths,
 * limit the depth of the search; the depthLimit is equivalent to the maximum
 * number of required outer rels (beyond the minimal parameterization) for the
 * path. A depthLimit of zero means that only the minimally-parameterized path
 * will be generated.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddColumnarScanPathsRec</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>paramRelids</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>candidateRelids</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>depthLimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>paramRelids</name></expr></argument>, <argument><expr><name>candidateRelids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AddColumnarScanPath</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>paramRelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* recurse for all candidateRelids, unless we hit the depth limit */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>depthLimit</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>depthLimit</name><operator>--</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Iterate through parameter combinations depth-first. Deeper levels
	 * generate paths of greater parameterization (and hopefully lower
	 * cost).
	 */</comment>
	<decl_stmt><decl><type><name>Relids</name></type> <name>tmpCandidateRelids</name> <init>= <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>candidateRelids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>relid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>relid</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>candidateRelids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type> <name>tmpParamRelids</name> <init>= <expr><call><name>bms_add_member</name><argument_list>(
			<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>paramRelids</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Because we are generating combinations (not permutations), remove
		 * the relid from the set of candidates at this level as we descend to
		 * the next.
		 */</comment>
		<expr_stmt><expr><name>tmpCandidateRelids</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>tmpCandidateRelids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AddColumnarScanPathsRec</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>tmpParamRelids</name></expr></argument>,
								<argument><expr><name>tmpCandidateRelids</name></expr></argument>, <argument><expr><name>depthLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>tmpCandidateRelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ParameterizationAsString returns the string representation of the set of
 * rels given in paramRelids.
 *
 * Takes a StringInfo so that it doesn't return palloc'd memory. This makes it
 * easy to call this function as an argument to ereport(), such that it won't
 * be evaluated unless the message is going to be output somewhere.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ParameterizationAsString</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>paramRelids</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>firstTime</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>relid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>paramRelids</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="string">"unparameterized"</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"parameterized by rels {"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>relid</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>paramRelids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>relid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>firstTime</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>relname</name> <operator>!=</operator> <name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>firstTime</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ContainsExecParams tests whether the node contains any exec params. The
 * signature accepts an extra argument for use with expression_tree_walker.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ContainsExecParams</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>notUsed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ContainsExecParams</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Create and add a path with the given parameterization paramRelids.
 *
 * XXX: Consider refactoring to be more like postgresGetForeignPaths(). The
 * only differences are param_info and custom_private.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddColumnarScanPath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					<parameter><decl><type><name>Relids</name></type> <name>paramRelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Must return a CustomPath, not a larger structure containing a
	 * CustomPath as the first field. Otherwise, nodeToString() will fail to
	 * output the additional fields.
	 */</comment>
	<decl_stmt><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>cpath</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cpath</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>ColumnarScanPathMethods</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name><operator>)</operator></expr></cpp:if>

	<comment type="block">/* necessary to avoid extra Result node in PG15 */</comment>
	<expr_stmt><expr><name><name>cpath</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>CUSTOMPATH_SUPPORT_PROJECTION</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * populate generic path information
	 */</comment>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>&amp;</operator><name><name>cpath</name><operator>-&gt;</operator><name>path</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CustomScan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>

	<comment type="block">/* columnar scans are not parallel-aware, but they are parallel-safe */</comment>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>paramRelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Usable clauses for this parameterization exist in baserestrictinfo and
	 * ppi_clauses.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allClauses</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>allClauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>allClauses</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>allClauses</name> <operator>=</operator> <call><name>FilterPushdownClauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>allClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Plain clauses may contain extern params, but not exec params, and can
	 * be evaluated at init time or rescan time. Track them in another list
	 * that is a subset of allClauses.
	 *
	 * Note: although typically baserestrictinfo contains plain clauses,
	 * that's not always true. It can also contain a qual referencing a Var at
	 * a higher query level, which can be turned into an exec param, and
	 * therefore it won't be a plain clause.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>plainClauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>allClauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>required_relids</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>ContainsExecParams</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>plainClauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>plainClauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We can't make our own CustomPath structure, so we need to put
	 * everything in the custom_private list. To keep the two lists separate,
	 * we make them sublists in a 2-element list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>EnableColumnarQualPushdown</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cpath</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>plainClauses</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>allClauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cpath</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>numberOfColumnsRead</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numberOfClausesPushed</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>allClauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CostColumnarScan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>cpath</name></expr></argument>, <argument><expr><name>numberOfColumnsRead</name></expr></argument>,
					 <argument><expr><name>numberOfClausesPushed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ColumnarPlannerDebugLevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar planner: adding CustomScan path for %s"</literal></expr></argument>,
					<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s; %d clauses pushed down"</literal></expr></argument>,
					   <argument><expr><call><name>ParameterizationAsString</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>paramRelids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>numberOfClausesPushed</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CostColumnarScan calculates the cost of scanning the columnar table. The
 * cost is estimated by using all stripe metadata to estimate based on the
 * columns to read how many pages need to be read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CostColumnarScan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
				 <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>cpath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numberOfColumnsRead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nClauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>&amp;</operator><name><name>cpath</name><operator>-&gt;</operator><name>path</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allClauses</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>clauseSel</name> <init>= <expr><call><name>clauselist_selectivity</name><argument_list>(
		<argument><expr><name>root</name></expr></argument>, <argument><expr><name>allClauses</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We already filtered out clauses where the overall selectivity would be
	 * misleading, such as inequalities involving an uncorrelated column. So
	 * we can apply the selectivity directly to the number of stripes.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>stripesToRead</name> <init>= <expr><name>clauseSel</name> <operator>*</operator> <call><name>ColumnarTableStripeCount</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>stripesToRead</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>stripesToRead</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name>stripesToRead</name> <operator>*</operator>
					   <call><name>ColumnarPerStripeScanCost</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>numberOfColumnsRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarPerStripeScanCost calculates the cost to scan a single stripe
 * of given columnar table based on number of columns that needs to be
 * read during scan operation.
 */</comment>
<function><type><specifier>static</specifier> <name>Cost</name></type>
<name>ColumnarPerStripeScanCost</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numberOfColumnsRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stripeList</name> <init>= <expr><call><name>StripesForRelfilenode</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>maxColumnCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>totalStripeSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>stripeMetadata</argument>, <argument>stripeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>totalStripeSize</name> <operator>+=</operator> <name><name>stripeMetadata</name><operator>-&gt;</operator><name>dataLength</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxColumnCount</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxColumnCount</name></expr></argument>, <argument><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>columnCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * When no stripes are in the table we don't have a count in maxColumnCount. To
	 * prevent a division by zero turning into a NaN we keep the ratio on zero.
	 * This will result in a cost of 0 for scanning the table which is a reasonable
	 * cost on an empty table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>maxColumnCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>columnSelectionRatio</name> <init>= <expr><name>numberOfColumnsRead</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>maxColumnCount</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>tableScanCost</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name>totalStripeSize</name> <operator>/</operator> <name>BLCKSZ</name> <operator>*</operator> <name>columnSelectionRatio</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> <name>perStripeScanCost</name> <init>= <expr><name>tableScanCost</name> <operator>/</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>stripeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Finally, multiply the cost of reading a single stripe by seq page read
	 * cost to make our estimation scale compatible with postgres.
	 * Since we are calculating the cost for a single stripe here, we use seq
	 * page cost instead of random page cost. This is because, random page
	 * access only happens when switching between columns, which is pretty
	 * much neglactable.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type> <name>relSpaceSeqPageCost</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>get_tablespace_page_costs</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relSpaceSeqPageCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>perStripeScanCost</name> <operator>=</operator> <name>perStripeScanCost</name> <operator>*</operator> <name>relSpaceSeqPageCost</name></expr>;</expr_stmt>

	<return>return <expr><name>perStripeScanCost</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarTableStripeCount returns the number of stripes that columnar
 * table with relationId has by using stripe metadata.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>ColumnarTableStripeCount</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open relation with OID %u"</literal></expr></argument>, <argument><expr><name>relationId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stripeList</name> <init>= <expr><call><name>StripesForRelfilenode</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>stripeCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>stripeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stripeCount</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>ColumnarScanPath_PlanCustomPath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								<parameter><decl><type><name><name>struct</name> <name>CustomPath</name></name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_plans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Must return a CustomScan, not a larger structure containing a
	 * CustomScan as the first field. Otherwise, copyObject() will fail to
	 * copy the additional fields.
	 */</comment>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>ColumnarScanScanMethods</name></expr>;</expr_stmt>

	<comment type="block">/* XXX: also need to store projected column list for EXPLAIN */</comment>

	<if_stmt><if>if <condition>(<expr><name>EnableColumnarQualPushdown</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Lists of pushed-down clauses. The Vars in custom_exprs referencing
		 * other relations will be changed into exec Params by
		 * create_customscan_plan().
		 *
		 * Like CustomPath-&gt;custom_private, keep a list of plain clauses
		 * separate from the list of all clauses by making them sublists of a
		 * 2-element list.
		 *
		 * XXX: custom_exprs are the quals that will be pushed into the
		 * columnar reader code; some of these may not be usable. We should
		 * fix this by processing the quals more completely and using
		 * ScanKeys.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>plainClauses</name> <init>= <expr><call><name>extract_actual_clauses</name><argument_list>(
			<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* no pseudoconstants */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allClauses</name> <init>= <expr><call><name>extract_actual_clauses</name><argument_list>(
			<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* no pseudoconstants */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>plainClauses</name></expr></argument>, <argument><expr><name>allClauses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(
		<argument><expr><name>clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* no pseudoconstants */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">150000</literal><operator>)</operator></expr></cpp:if>

	<comment type="block">/* necessary to avoid extra Result node in PG15 */</comment>
	<expr_stmt><expr><name><name>cscan</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>CUSTOMPATH_SUPPORT_PROJECTION</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>cscan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReparameterizeMutator changes all varnos referencing the topmost parent of
 * child_rel to instead reference child_rel directly.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>ReparameterizeMutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name><name>child_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>rinfo</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(
			<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>ReparameterizeMutator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rinfo</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ReparameterizeMutator</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>child_rel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarScanPath_ReparameterizeCustomPathByChild is a method called when a
 * path is reparameterized directly to a child relation, rather than the
 * top-level parent.
 *
 * For instance, let there be a join of two partitioned columnar relations PX
 * and PY. A path for a ColumnarScan of PY3 might be parameterized by PX so
 * that the join qual "PY3.a = PX.a" (referencing the parent PX) can be pushed
 * down. But if the planner decides on a partition-wise join, then the path
 * will be reparameterized on the child table PX3 directly.
 *
 * When that happens, we need to update all Vars in the pushed-down quals to
 * reference PX3, not PX, to match the new parameterization. This method
 * notifies us that it needs to be done, and allows us to update the
 * information in custom_private.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ColumnarScanPath_ReparameterizeCustomPathByChild</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>custom_private</name></decl></parameter>,
												 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>ReparameterizeMutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>custom_private</name></expr></argument>, <argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>ColumnarScan_CreateCustomScanState</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarScanState</name> <modifier>*</modifier></type><name>columnarScanState</name> <init>= <expr><operator>(</operator><name>ColumnarScanState</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(
		<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnarScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>T_CustomScanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>cscanstate</name> <init>= <expr><operator>&amp;</operator><name><name>columnarScanState</name><operator>-&gt;</operator><name>custom_scanstate</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>cscanstate</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>ColumnarScanExecuteMethods</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cscanstate</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EvalParamsMutator evaluates Params in the expression and replaces them with
 * Consts.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>EvalParamsMutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type> <name>typLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>typByVal</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* XXX: should save ExprState for efficiency */</comment>
		<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>exprState</name> <init>= <expr><call><name>ExecInitExprWithParams</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
													  <argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_param_list_info</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>pval</name> <init>= <expr><call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>exprState</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>,
								  <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name></expr></argument>,
								  <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name></expr></argument>,
								  <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>typLen</name></expr></argument>,
								  <argument><expr><name>pval</name></expr></argument>,
								  <argument><expr><name>isnull</name></expr></argument>,
								  <argument><expr><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>EvalParamsMutator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>econtext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarScan_BeginCustomScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>cscanstate</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name><name>cscanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnarScanState</name> <modifier>*</modifier></type><name>columnarScanState</name> <init>= <expr><operator>(</operator><name>ColumnarScanState</name> <operator>*</operator><operator>)</operator> <name>cscanstate</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>stdecontext</name> <init>= <expr><name><name>cscanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make a new ExprContext just like the existing one, except that we don't
	 * reset it every tuple.
	 */</comment>
	<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cscanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>columnarScanState</name><operator>-&gt;</operator><name>css_RuntimeContext</name></name> <operator>=</operator> <name><name>cscanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cscanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name> <operator>=</operator> <name>stdecontext</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>columnarScanState</name><operator>-&gt;</operator><name>css_RuntimeContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>plainClauses</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>columnarScanState</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>EvalParamsMutator</name><argument_list>(
		<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plainClauses</name></expr></argument>, <argument><expr><name><name>columnarScanState</name><operator>-&gt;</operator><name>css_RuntimeContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* scan slot is already initialized */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarAttrNeeded returns a list of AttrNumber's for the ones that are
 * needed during columnar custom scan.
 * Throws an error if finds a Var referencing to an attribute not supported
 * by ColumnarScan.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>ColumnarAttrNeeded</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>ss</name><operator>-&gt;</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attr_needed</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>ss</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
				<name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator> <name>PVC_RECURSE_PLACEHOLDERS</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>list_concat</name><argument_list>(<argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(
								<argument><expr><literal type="string">"UPDATE and CTID scans not supported for ColumnarScan"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Need attribute: all"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* all attributes are required, we don't need to add more so break*/</comment>
			<expr_stmt><expr><name>attr_needed</name> <operator>=</operator> <call><name>bms_add_range</name><argument_list>(<argument><expr><name>attr_needed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>natts</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Need attribute: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attr_needed</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>attr_needed</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>attr_needed</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ColumnarScanNext</name><parameter_list>(<parameter><decl><type><name>ColumnarScanState</name> <modifier>*</modifier></type><name>columnarScanState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>columnarScanState</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * get information from the estate and scan state
	 */</comment>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scandesc</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>direction</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>scandesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* the columnar access method does not use the flags, they are specific to heap */</comment>
		<decl_stmt><decl><type><name>uint32</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attr_needed</name> <init>= <expr><call><name>ColumnarAttrNeeded</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We reach here if the scan is not parallel, or if we're serially
		 * executing a scan that was planned to be parallel.
		 */</comment>
		<expr_stmt><expr><name>scandesc</name> <operator>=</operator> <call><name>columnar_beginscan_extended</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentRelation</name></name></expr></argument>,
											   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>,
											   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>attr_needed</name></expr></argument>,
											   <argument><expr><name><name>columnarScanState</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>attr_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name> <operator>=</operator> <name>scandesc</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * get the next tuple from the table
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>table_scan_getnextslot</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>slot</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SeqRecheck -- access method routine to recheck a tuple in EvalPlanQual
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ColumnarScanRecheck</name><parameter_list>(<parameter><decl><type><name>ColumnarScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ColumnarScan_ExecCustomScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ExecScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
					<argument><expr><operator>(</operator><name>ExecScanAccessMtd</name><operator>)</operator> <name>ColumnarScanNext</name></expr></argument>,
					<argument><expr><operator>(</operator><name>ExecScanRecheckMtd</name><operator>)</operator> <name>ColumnarScanRecheck</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarScan_EndCustomScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * get information from node
	 */</comment>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scanDesc</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Free the exprcontext
	 */</comment>
	<expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * clean out the tuple table
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * close heap scan
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>scanDesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scanDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarScan_ReScanCustomScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnarScanState</name> <modifier>*</modifier></type><name>columnarScanState</name> <init>= <expr><operator>(</operator><name>ColumnarScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name><name>columnarScanState</name><operator>-&gt;</operator><name>css_RuntimeContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>allClauses</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>columnarScanState</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>EvalParamsMutator</name><argument_list>(
		<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>allClauses</name></expr></argument>, <argument><expr><name><name>columnarScanState</name><operator>-&gt;</operator><name>css_RuntimeContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scanDesc</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>scanDesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* XXX: hack to pass quals as scan keys */</comment>
		<decl_stmt><decl><type><name>ScanKey</name></type> <name>scanKeys</name> <init>= <expr><operator>(</operator><name>ScanKey</name><operator>)</operator> <name><name>columnarScanState</name><operator>-&gt;</operator><name>qual</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>table_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name></expr></argument>,
					 <argument><expr><name>scanKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarScan_ExplainCustomScan</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>,
							   <parameter><decl><type><name>ExplainState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarScanState</name> <modifier>*</modifier></type><name>columnarScanState</name> <init>= <expr><operator>(</operator><name>ColumnarScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>context</name> <init>= <expr><call><name>set_deparse_context_planstate</name><argument_list>(
		<argument><expr><name><name>es</name><operator>-&gt;</operator><name>deparse_cxt</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumns</name> <init>= <expr><call><name>ColumnarVarNeeded</name><argument_list>(<argument><expr><name>columnarScanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>projectedColumnsStr</name> <init>= <expr><call><name>ColumnarProjectedColumnsStr</name><argument_list>(
		<argument><expr><name>context</name></expr></argument>, <argument><expr><name>projectedColumns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Columnar Projected Columns"</literal></expr></argument>,
						<argument><expr><name>projectedColumnsStr</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>chunkGroupFilter</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>chunkGroupFilter</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pushdownClausesStr</name> <init>= <expr><call><name>ColumnarPushdownClausesStr</name><argument_list>(
			<argument><expr><name>context</name></expr></argument>, <argument><expr><name>chunkGroupFilter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ExplainPropertyText</name><argument_list>(<argument><expr><literal type="string">"Columnar Chunk Group Filters"</literal></expr></argument>,
							<argument><expr><name>pushdownClausesStr</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ColumnarScanDesc</name></type> <name>columnarScanDesc</name> <init>=
			<expr><operator>(</operator><name>ColumnarScanDesc</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_currentScanDesc</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>columnarScanDesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ExplainPropertyInteger</name><argument_list>(
				<argument><expr><literal type="string">"Columnar Chunk Groups Removed by Filter"</literal></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>ColumnarScanChunkGroupsFiltered</name><argument_list>(<argument><expr><name>columnarScanDesc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarPushdownClausesStr represents the clauses to push down as a string.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ColumnarPushdownClausesStr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>conjunction</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>conjunction</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>conjunction</name> <operator>=</operator> <call><name>make_andclause</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>useTableNamePrefix</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>showImplicitCast</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>conjunction</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
							  <argument><expr><name>useTableNamePrefix</name></expr></argument>, <argument><expr><name>showImplicitCast</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarProjectedColumnsStr generates projected column string for
 * explain output.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ColumnarProjectedColumnsStr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>projectedColumns</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="string">"&lt;columnar optimized out all columns&gt;"</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>useTableNamePrefix</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>showImplicitCast</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>projectedColumns</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
							  <argument><expr><name>useTableNamePrefix</name></expr></argument>, <argument><expr><name>showImplicitCast</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarVarNeeded returns a list of Var objects for the ones that are
 * needed during columnar custom scan.
 * Throws an error if finds a Var referencing to an attribute not supported
 * by ColumnarScan.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ColumnarVarNeeded</name><parameter_list>(<parameter><decl><type><name>ColumnarScanState</name> <modifier>*</modifier></type><name>columnarScanState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>scanState</name> <init>= <expr><operator>&amp;</operator><name><name>columnarScanState</name><operator>-&gt;</operator><name>custom_scanstate</name><operator>.</operator><name>ss</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>varList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>neededAttrSet</name> <init>= <expr><call><name>ColumnarAttrNeeded</name><argument_list>(<argument><expr><name>scanState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>bmsMember</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>bmsMember</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>neededAttrSet</name></expr></argument>, <argument><expr><name>bmsMember</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>columnarRelation</name> <init>= <expr><name><name>scanState</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* neededAttrSet already represents 0-indexed attribute numbers */</comment>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>columnForm</name> <init>=
			<expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bmsMember</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>columnForm</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot explain column with attrNum=%d "</literal>
								   <literal type="string">"of columnar table %s since it is dropped"</literal></expr></argument>,
								   <argument><expr><name>bmsMember</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>columnForm</name><operator>-&gt;</operator><name>attnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ColumnarAttrNeeded should have already thrown an error for
			 * system columns. Similarly, it should have already expanded
			 * whole-row references to individual attributes.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot explain column with attrNum=%d "</literal>
								   <literal type="string">"of columnar table %s since it is either "</literal>
								   <literal type="string">"a system column or a whole-row "</literal>
								   <literal type="string">"reference"</literal></expr></argument>, <argument><expr><name><name>columnForm</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>


		<comment type="block">/*
		 * varlevelsup is used to figure out the (query) level of the Var
		 * that we are investigating. Since we are dealing with a particular
		 * relation, it is useless here.
		 */</comment>
		<decl_stmt><decl><type><name>Index</name></type> <name>varlevelsup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>customScanState</name> <init>= <expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>columnarScanState</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>customScan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name><name>customScanState</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type> <name>scanrelid</name> <init>= <expr><name><name>customScan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>makeVar</name><argument_list>(<argument><expr><name>scanrelid</name></expr></argument>, <argument><expr><name><name>columnForm</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name><name>columnForm</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
						   <argument><expr><name><name>columnForm</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>, <argument><expr><name><name>columnForm</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
						   <argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>varList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>varList</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>varList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * set_deparse_context_planstate is a compatibility wrapper for versions 13+.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>set_deparse_context_planstate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dpcontext</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ancestors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>set_deparse_context_plan</name><argument_list>(<argument><expr><name>dpcontext</name></expr></argument>, <argument><expr><name><name>ps</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>ancestors</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
