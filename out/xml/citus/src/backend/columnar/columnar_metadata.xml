<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/columnar/columnar_metadata.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * columnar_metadata.c
 *
 * Copyright (c) Citus Data, Inc.
 *
 * Manages metadata for columnar relations in separate, shared metadata tables
 * in the "columnar" schema.
 *
 *   * holds basic stripe information including data size and row counts
 *   * holds basic chunk and chunk group information like data offsets and
 *     min/max values (used for Chunk Group Filtering)
 *   * useful for fast VACUUM operations (e.g. reporting with VACUUM VERBOSE)
 *   * useful for stats/costing
 *   * maps logical row numbers to stripe IDs
 *   * TODO: visibility information
 *
 *-------------------------------------------------------------------------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_lib.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"citus_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relfilenodemap.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLUMNAR_RELOPTION_NAMESPACE</name></cpp:macro> <cpp:value>"columnar"</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
}</block></struct></type> <name>ModifyState</name>;</typedef>

<comment type="block">/* RowNumberLookupMode to be used in StripeMetadataLookupRowNumber */</comment>
<typedef>typedef <type><enum>enum <name>RowNumberLookupMode</name>
<block>{
	<comment type="block">/*
	 * Find the stripe whose firstRowNumber is less than or equal to given
	 * input rowNumber.
	 */</comment>
	<decl><name>FIND_LESS_OR_EQUAL</name></decl>,

	<comment type="block">/*
	 * Find the stripe whose firstRowNumber is greater than input rowNumber.
	 */</comment>
	<decl><name>FIND_GREATER</name></decl>
}</block></enum></type> <name>RowNumberLookupMode</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParseColumnarRelOptions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>, <parameter><decl><type><name>ColumnarOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InsertEmptyStripeMetadataRow</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripeId</name></decl></parameter>,
										 <parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>chunkGroupRowCount</name></decl></parameter>,
										 <parameter><decl><type><name>uint64</name></type> <name>firstRowNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetHighestUsedAddressAndId</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>,
									   <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>highestUsedAddress</name></decl></parameter>,
									   <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>highestUsedId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StripeMetadata</name> <modifier>*</modifier></type> <name>UpdateStripeMetadataRow</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripeId</name></decl></parameter>,
												<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>update</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>newValues</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>ReadDataFileStripeList</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StripeMetadata</name> <modifier>*</modifier></type> <name>BuildStripeMetadata</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>columnarStripes</name></decl></parameter>,
											<parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name> <modifier>*</modifier></type> <name>ReadChunkGroupRowCounts</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripe</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type>
										<name>chunkGroupCount</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarStorageIdSequenceRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarStripeRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarStripePKeyIndexRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarStripeFirstRowNumberIndexRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarOptionsRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarOptionsIndexRegclass</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarChunkRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarChunkGroupRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarChunkIndexRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarChunkGroupIndexRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>ColumnarNamespaceId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>LookupStorageId</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>relfilenode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>GetHighestUsedRowNumber</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DeleteStorageFromColumnarMetadataTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>metadataTableId</name></decl></parameter>,
												   <parameter><decl><type><name>AttrNumber</name></type> <name>storageIdAtrrNumber</name></decl></parameter>,
												   <parameter><decl><type><name>Oid</name></type> <name>storageIdIndexId</name></decl></parameter>,
												   <parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ModifyState</name> <modifier>*</modifier></type> <name>StartModifyRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InsertTupleAndEnforceConstraints</name><parameter_list>(<parameter><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
											 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DeleteTupleAndEnforceConstraints</name><parameter_list>(<parameter><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FinishModifyRelation</name><parameter_list>(<parameter><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>EState</name> <modifier>*</modifier></type> <name>create_estate_for_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bytea</name> <modifier>*</modifier></type> <name>DatumToBytea</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attrForm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ByteaToDatum</name><parameter_list>(<parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>bytes</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attrForm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>WriteColumnarOptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>regclass</name></decl></parameter>, <parameter><decl><type><name>ColumnarOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>overwrite</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StripeMetadata</name> <modifier>*</modifier></type> <name>StripeMetadataLookupRowNumber</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>,
													  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
													  <parameter><decl><type><name>RowNumberLookupMode</name></type> <name>lookupMode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckStripeMetadataConsistency</name><parameter_list>(<parameter><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>columnar_relation_storageid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* constants for columnar.options */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Natts_columnar_options</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_options_regclass</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_options_chunk_group_row_limit</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_options_stripe_row_limit</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_options_compression_level</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_options_compression</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/* ----------------
 *		columnar.options definition.
 * ----------------
 */</comment>
<typedef>typedef <type><struct>struct <name>FormData_columnar_options</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type> <name>regclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>chunk_group_row_limit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>stripe_row_limit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>compressionLevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type> <name>compression</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CATALOG_VARLEN</name></cpp:ifdef>           <comment type="block">/* variable-length fields start here */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>FormData_columnar_options</name>;</typedef>
<typedef>typedef <type><name>FormData_columnar_options</name> <modifier>*</modifier></type><name>Form_columnar_options</name>;</typedef>


<comment type="block">/* constants for columnar.stripe */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Natts_columnar_stripe</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_stripe_storageid</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_stripe_stripe</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_stripe_file_offset</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_stripe_data_length</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_stripe_column_count</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_stripe_chunk_row_count</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_stripe_row_count</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_stripe_chunk_count</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_stripe_first_row_number</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>

<comment type="block">/* constants for columnar.chunk_group */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Natts_columnar_chunkgroup</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunkgroup_storageid</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunkgroup_stripe</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunkgroup_chunk</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunkgroup_row_count</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/* constants for columnar.chunk */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Natts_columnar_chunk</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_storageid</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_stripe</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_attr</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_chunk</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_minimum_value</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_maximum_value</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_value_stream_offset</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_value_stream_length</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_exists_stream_offset</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_exists_stream_length</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_value_compression_type</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_value_compression_level</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_value_decompressed_size</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Anum_columnar_chunk_value_count</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>


<comment type="block">/*
 * InitColumnarOptions initialized the columnar table options. Meaning it writes the
 * default options to the options table if not already existing.
 */</comment>
<function><type><name>void</name></type>
<name>InitColumnarOptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>regclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * When upgrading we retain options for all columnar tables by upgrading
	 * "columnar.options" catalog table, so we shouldn't do anything here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ColumnarOptions</name></type> <name>defaultOptions</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>chunkRowCount</name> <operator>=</operator> <name>columnar_chunk_group_row_limit</name></expr>,
		<expr><operator>.</operator><name>stripeRowCount</name> <operator>=</operator> <name>columnar_stripe_row_limit</name></expr>,
		<expr><operator>.</operator><name>compressionType</name> <operator>=</operator> <name>columnar_compression</name></expr>,
		<expr><operator>.</operator><name>compressionLevel</name> <operator>=</operator> <name>columnar_compression_level</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WriteColumnarOptions</name><argument_list>(<argument><expr><name>regclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defaultOptions</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ParseColumnarRelOptions - update the given 'options' using the given list
 * of DefElem.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseColumnarRelOptions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>, <parameter><decl><type><name>ColumnarOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>reloptions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>defnamespace</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defnamespace</name></name></expr></argument>, <argument><expr><name>COLUMNAR_RELOPTION_NAMESPACE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar options must have the prefix \"%s\""</literal></expr></argument>,
								   <argument><expr><name>COLUMNAR_RELOPTION_NAMESPACE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"chunk_group_row_limit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>chunkRowCount</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
									 <expr><name>columnar_chunk_group_row_limit</name></expr> </then><else>: <expr><call><name>defGetInt64</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>chunkRowCount</name></name> <operator>&lt;</operator> <name>CHUNK_ROW_COUNT_MINIMUM</name> <operator>||</operator>
				<name><name>options</name><operator>-&gt;</operator><name>chunkRowCount</name></name> <operator>&gt;</operator> <name>CHUNK_ROW_COUNT_MAXIMUM</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"chunk group row count limit out of range"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"chunk group row count limit must be between "</literal>
										<name>UINT64_FORMAT</name> <literal type="string">" and "</literal> <name>UINT64_FORMAT</name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>CHUNK_ROW_COUNT_MINIMUM</name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>CHUNK_ROW_COUNT_MAXIMUM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"stripe_row_limit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
									  <expr><name>columnar_stripe_row_limit</name></expr> </then><else>: <expr><call><name>defGetInt64</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name> <operator>&lt;</operator> <name>STRIPE_ROW_COUNT_MINIMUM</name> <operator>||</operator>
				<name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name> <operator>&gt;</operator> <name>STRIPE_ROW_COUNT_MAXIMUM</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"stripe row count limit out of range"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"stripe row count limit must be between "</literal>
										<name>UINT64_FORMAT</name> <literal type="string">" and "</literal> <name>UINT64_FORMAT</name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>STRIPE_ROW_COUNT_MINIMUM</name></expr></argument>,
										<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>STRIPE_ROW_COUNT_MAXIMUM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"compression"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>compressionType</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
									   <expr><name>columnar_compression</name></expr> </then><else>: <expr><call><name>ParseCompressionType</name><argument_list>(
				<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>compressionType</name></name> <operator>==</operator> <name>COMPRESSION_TYPE_INVALID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown compression type for columnar table: %s"</literal></expr></argument>,
									   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>defGetString</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"compression_level"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>elem</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
										<expr><name>columnar_compression_level</name></expr> </then><else>: <expr><call><name>defGetInt64</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>&lt;</operator> <name>COMPRESSION_LEVEL_MIN</name> <operator>||</operator>
				<name><name>options</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>&gt;</operator> <name>COMPRESSION_LEVEL_MAX</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compression level out of range"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"compression level must be between %d and %d"</literal></expr></argument>,
										<argument><expr><name>COMPRESSION_LEVEL_MIN</name></expr></argument>,
										<argument><expr><name>COMPRESSION_LEVEL_MAX</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized columnar storage parameter \"%s\""</literal></expr></argument>,
								   <argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ExtractColumnarOptions - extract columnar options from inOptions, appending
 * to inoutColumnarOptions. Return the remaining (non-columnar) options.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ExtractColumnarRelOptions</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>inOptions</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>inoutColumnarOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>otherOptions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>inOptions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>elem</name><operator>-&gt;</operator><name>defnamespace</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>elem</name><operator>-&gt;</operator><name>defnamespace</name></name></expr></argument>, <argument><expr><name>COLUMNAR_RELOPTION_NAMESPACE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>inoutColumnarOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>inoutColumnarOptions</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>otherOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>otherOptions</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/* validate options */</comment>
	<decl_stmt><decl><type><name>ColumnarOptions</name></type> <name>dummy</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ParseColumnarRelOptions</name><argument_list>(<argument><expr><operator>*</operator><name>inoutColumnarOptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>otherOptions</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SetColumnarRelOptions - apply the list of DefElem options to the
 * relation. If there are duplicates, the last one in the list takes effect.
 */</comment>
<function><type><name>void</name></type>
<name>SetColumnarRelOptions</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>reloptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarOptions</name></type> <name>options</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>reloptions</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_openrv</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get existing or default options */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadColumnarOptions</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if extension doesn't exist, just return */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ParseColumnarRelOptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetColumnarOptions</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SetColumnarOptions writes the passed table options as the authoritive options to the
 * table irregardless of the optiones already existing or not. This can be used to put a
 * table in a certain state.
 */</comment>
<function><type><name>void</name></type>
<name>SetColumnarOptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>regclass</name></decl></parameter>, <parameter><decl><type><name>ColumnarOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WriteColumnarOptions</name><argument_list>(<argument><expr><name>regclass</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WriteColumnarOptions writes the options to the catalog table for a given regclass.
 *  - If overwrite is false it will only write the values if there is not already a record
 *    found.
 *  - If overwrite is true it will always write the settings
 *
 * The return value indicates if the record has been written.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>WriteColumnarOptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>regclass</name></decl></parameter>, <parameter><decl><type><name>ColumnarOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>overwrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * When upgrading we should retain the options from the previous
	 * cluster and don't write new options.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsBinaryUpgrade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>written</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_columnar_options</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_columnar_options</name></expr>]</index></name> <init>= <expr><block>{
		<expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>regclass</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>chunkRowCount</name></name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr></argument>)</argument_list></call></expr>,
		<expr><literal type="number">0</literal></expr>, <comment type="block">/* to be filled below */</comment>
	}</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>NameData</name></type> <name>compressionName</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>compressionName</name></expr></argument>, <argument><expr><call><name>CompressionTypeStr</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>compressionType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_options_compression</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>compressionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create heap tuple and insert into catalog table */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarOptions</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><call><name>ColumnarOptionsRelationId</name><argument_list>()</argument_list></call></expr></argument>,
											 <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* find existing item to perform update if exist */</comment>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_options_regclass</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>regclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>ColumnarOptionsIndexRegclass</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
															<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>overwrite</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* TODO check if the options are actually different, skip if not changed */</comment>
			<comment type="block">/* update existing record */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name><name>update</name><index>[<expr><name>Natts_columnar_options</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>update</name><index>[<expr><name>Anum_columnar_options_chunk_group_row_limit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>update</name><index>[<expr><name>Anum_columnar_options_stripe_row_limit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>update</name><index>[<expr><name>Anum_columnar_options_compression_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>update</name><index>[<expr><name>Anum_columnar_options_compression</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>,
												<argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>update</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>written</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* inserting new record */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>newTuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>, <argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>written</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>written</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>written</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeleteColumnarTableOptions removes the columnar table options for a regclass. When
 * missingOk is false it will throw an error when no table options can be found.
 *
 * Returns whether a record has been removed.
 */</comment>
<function><type><name>bool</name></type>
<name>DeleteColumnarTableOptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>regclass</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missingOk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When upgrading we shouldn't delete or modify table options and
	 * retain options from the previous cluster.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsBinaryUpgrade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarOptions</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><call><name>ColumnarOptionsRelationId</name><argument_list>()</argument_list></call></expr></argument>,
												 <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>columnarOptions</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* extension has been dropped */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* find existing item to remove */</comment>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_options_regclass</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>regclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>ColumnarOptionsIndexRegclass</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
															<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>missingOk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing options for regclass: %d"</literal></expr></argument>, <argument><expr><name>regclass</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>ReadColumnarOptions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>regclass</name></decl></parameter>, <parameter><decl><type><name>ColumnarOptions</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_options_regclass</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>regclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>columnarOptionsOid</name> <init>= <expr><call><name>ColumnarOptionsRelationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarOptions</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>columnarOptionsOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>columnarOptions</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Extension has been dropped. This can be called while
		 * dropping extension or database via ObjectAccess().
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><call><name>ColumnarOptionsIndexRegclass</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* extension has been dropped */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
															<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_columnar_options</name></type> <name>tupOptions</name> <init>= <expr><operator>(</operator><name>Form_columnar_options</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>chunkRowCount</name></name> <operator>=</operator> <name><name>tupOptions</name><operator>-&gt;</operator><name>chunk_group_row_limit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name> <operator>=</operator> <name><name>tupOptions</name><operator>-&gt;</operator><name>stripe_row_limit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <name><name>tupOptions</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>compressionType</name></name> <operator>=</operator> <call><name>ParseCompressionType</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>tupOptions</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* populate options with system defaults */</comment>
		<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>compressionType</name></name> <operator>=</operator> <name>columnar_compression</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>stripeRowCount</name></name> <operator>=</operator> <name>columnar_stripe_row_limit</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>chunkRowCount</name></name> <operator>=</operator> <name>columnar_chunk_group_row_limit</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <name>columnar_compression_level</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>columnarOptions</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SaveStripeSkipList saves chunkList for a given stripe as rows
 * of columnar.chunk.
 */</comment>
<function><type><name>void</name></type>
<name>SaveStripeSkipList</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>relfilenode</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripe</name></decl></parameter>, <parameter><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>chunkList</name></decl></parameter>,
				   <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><name><name>chunkList</name><operator>-&gt;</operator><name>columnCount</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>LookupStorageId</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>columnarChunkOid</name> <init>= <expr><call><name>ColumnarChunkRelationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarChunk</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>columnarChunkOid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>modifyState</name> <init>= <expr><call><name>StartModifyRelation</name><argument_list>(<argument><expr><name>columnarChunk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name><name>chunkList</name><operator>-&gt;</operator><name>chunkCount</name></name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunk</name> <init>=
				<expr><operator>&amp;</operator><name><name>chunkList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_columnar_chunk</name></expr>]</index></name> <init>= <expr><block>{
				<expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr>,
				<expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>stripe</name></expr></argument>)</argument_list></call></expr>,
				<expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>columnIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
				<expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunkIndex</name></expr></argument>)</argument_list></call></expr>,
				<expr><literal type="number">0</literal></expr>, <comment type="block">/* to be filled below */</comment>
				<expr><literal type="number">0</literal></expr>, <comment type="block">/* to be filled below */</comment>
				<expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>valueChunkOffset</name></name></expr></argument>)</argument_list></call></expr>,
				<expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>valueLength</name></name></expr></argument>)</argument_list></call></expr>,
				<expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>existsChunkOffset</name></name></expr></argument>)</argument_list></call></expr>,
				<expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>existsLength</name></name></expr></argument>)</argument_list></call></expr>,
				<expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>valueCompressionType</name></name></expr></argument>)</argument_list></call></expr>,
				<expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>valueCompressionLevel</name></name></expr></argument>)</argument_list></call></expr>,
				<expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>decompressedValueSize</name></name></expr></argument>)</argument_list></call></expr>,
				<macro><name>Int64GetDatum</name><argument_list>(<argument>chunk-&gt;rowCount</argument>)</argument_list></macro>
			}</block></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_columnar_chunk</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>hasMinMax</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_chunk_minimum_value</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
					<call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>DatumToBytea</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>minimumValue</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_chunk_maximum_value</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
					<call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>DatumToBytea</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>maximumValue</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_columnar_chunk_minimum_value</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_columnar_chunk_maximum_value</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>InsertTupleAndEnforceConstraints</name><argument_list>(<argument><expr><name>modifyState</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>FinishModifyRelation</name><argument_list>(<argument><expr><name>modifyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>columnarChunk</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SaveChunkGroups saves the metadata for given chunk groups in columnar.chunk_group.
 */</comment>
<function><type><name>void</name></type>
<name>SaveChunkGroups</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>relfilenode</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripe</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>chunkGroupRowCounts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>LookupStorageId</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>columnarChunkGroupOid</name> <init>= <expr><call><name>ColumnarChunkGroupRelationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarChunkGroup</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>columnarChunkGroupOid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>modifyState</name> <init>= <expr><call><name>StartModifyRelation</name><argument_list>(<argument><expr><name>columnarChunkGroup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>chunkId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>chunkGroupRowCounts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>rowCount</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_columnar_chunkgroup</name></expr>]</index></name> <init>= <expr><block>{
			<expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>stripe</name></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunkId</name></expr></argument>)</argument_list></call></expr>,
			<macro><name>Int64GetDatum</name><argument_list>(<argument>rowCount</argument>)</argument_list></macro>
		}</block></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_columnar_chunkgroup</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>InsertTupleAndEnforceConstraints</name><argument_list>(<argument><expr><name>modifyState</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunkId</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>FinishModifyRelation</name><argument_list>(<argument><expr><name>modifyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>columnarChunkGroup</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReadStripeSkipList fetches chunk metadata for a given stripe.
 */</comment>
<function><type><name>StripeSkipList</name> <modifier>*</modifier></type>
<name>ReadStripeSkipList</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>relfilenode</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripe</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
				   <parameter><decl><type><name>uint32</name></type> <name>chunkCount</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>LookupStorageId</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>columnarChunkOid</name> <init>= <expr><call><name>ColumnarChunkRelationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarChunk</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>columnarChunkOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>ColumnarChunkIndexRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_chunk_storageid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_chunk_stripe</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>stripe</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>columnarChunk</name></expr></argument>, <argument><expr><name>index</name></expr></argument>,
															<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>chunkList</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StripeSkipList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>chunkList</name><operator>-&gt;</operator><name>chunkCount</name></name> <operator>=</operator> <name>chunkCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkList</name><operator>-&gt;</operator><name>columnCount</name></name> <operator>=</operator> <name>columnCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnChunkSkipNode</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>chunkList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator>
			<call><name>palloc0</name><argument_list>(<argument><expr><name>chunkCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnChunkSkipNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>,
																 <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_columnar_chunk</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_columnar_chunk</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>columnarChunk</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>datumArray</name></expr></argument>,
						  <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int32</name></type> <name>attr</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_attr</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type> <name>chunkIndex</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_chunk</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>attr</name> <operator>&gt;</operator> <name>columnCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid columnar chunk entry"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Attribute number out of range: %d"</literal></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>chunkIndex</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>chunkIndex</name> <operator>&gt;=</operator> <name>chunkCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid columnar chunk entry"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Chunk number out of range: %d"</literal></expr></argument>, <argument><expr><name>chunkIndex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>columnIndex</name> <operator>=</operator> <name>attr</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunk</name> <init>=
			<expr><operator>&amp;</operator><name><name>chunkList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_value_count</name> <operator>-</operator>
												   <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>valueChunkOffset</name></name> <operator>=</operator>
			<call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_value_stream_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>valueLength</name></name> <operator>=</operator>
			<call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_value_stream_length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>existsChunkOffset</name></name> <operator>=</operator>
			<call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_exists_stream_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>existsLength</name></name> <operator>=</operator>
			<call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_exists_stream_length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>valueCompressionType</name></name> <operator>=</operator>
			<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_value_compression_type</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>valueCompressionLevel</name></name> <operator>=</operator>
			<call><name>DatumGetInt32</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_value_compression_level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>decompressedValueSize</name></name> <operator>=</operator>
			<call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_value_decompressed_size</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>isNullArray</name><index>[<expr><name>Anum_columnar_chunk_minimum_value</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>||</operator>
			<name><name>isNullArray</name><index>[<expr><name>Anum_columnar_chunk_maximum_value</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hasMinMax</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bytea</name> <modifier>*</modifier></type><name>minValue</name> <init>= <expr><call><name>DatumGetByteaP</name><argument_list>(
				<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_minimum_value</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bytea</name> <modifier>*</modifier></type><name>maxValue</name> <init>= <expr><call><name>DatumGetByteaP</name><argument_list>(
				<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunk_maximum_value</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>minimumValue</name></name> <operator>=</operator>
				<call><name>ByteaToDatum</name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>maximumValue</name></name> <operator>=</operator>
				<call><name>ByteaToDatum</name><argument_list>(<argument><expr><name>maxValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hasMinMax</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>columnarChunk</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>chunkList</name><operator>-&gt;</operator><name>chunkGroupRowCounts</name></name> <operator>=</operator>
		<call><name>ReadChunkGroupRowCounts</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>, <argument><expr><name>stripe</name></expr></argument>, <argument><expr><name>chunkCount</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunkList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindStripeByRowNumber returns StripeMetadata for the stripe whose
 * firstRowNumber is greater than given rowNumber. If no such stripe
 * exists, then returns NULL.
 */</comment>
<function><type><name>StripeMetadata</name> <modifier>*</modifier></type>
<name>FindNextStripeByRowNumber</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>StripeMetadataLookupRowNumber</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>rowNumber</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>FIND_GREATER</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindStripeByRowNumber returns StripeMetadata for the stripe that contains
 * the row with rowNumber. If no such stripe exists, then returns NULL.
 */</comment>
<function><type><name>StripeMetadata</name> <modifier>*</modifier></type>
<name>FindStripeByRowNumber</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>=
		<expr><call><name>FindStripeWithMatchingFirstRowNumber</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>rowNumber</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stripeMetadata</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rowNumber</name> <operator>&gt;</operator> <call><name>StripeGetHighestRowNumber</name><argument_list>(<argument><expr><name>stripeMetadata</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>stripeMetadata</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FindStripeWithMatchingFirstRowNumber returns a StripeMetadata object for
 * the stripe that has the greatest firstRowNumber among the stripes whose
 * firstRowNumber is smaller than or equal to given rowNumber. If no such
 * stripe exists, then returns NULL.
 *
 * Note that this doesn't mean that found stripe certainly contains the tuple
 * with given rowNumber. This is because, it also needs to be verified if
 * highest row number that found stripe contains is greater than or equal to
 * given rowNumber. For this reason, unless that additional check is done,
 * this function is mostly useful for checking against "possible" constraint
 * violations due to concurrent writes that are not flushed by other backends
 * yet.
 */</comment>
<function><type><name>StripeMetadata</name> <modifier>*</modifier></type>
<name>FindStripeWithMatchingFirstRowNumber</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>,
									 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>StripeMetadataLookupRowNumber</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>rowNumber</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
										 <argument><expr><name>FIND_LESS_OR_EQUAL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StripeWriteState returns write state of given stripe.
 */</comment>
<function><type><name>StripeWriteStateEnum</name></type>
<name>StripeWriteState</name><parameter_list>(<parameter><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>aborted</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>STRIPE_WRITE_ABORTED</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>STRIPE_WRITE_FLUSHED</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>STRIPE_WRITE_IN_PROGRESS</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StripeGetHighestRowNumber returns rowNumber of the row with highest
 * rowNumber in given stripe.
 */</comment>
<function><type><name>uint64</name></type>
<name>StripeGetHighestRowNumber</name><parameter_list>(<parameter><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>firstRowNumber</name></name> <operator>+</operator> <name><name>stripeMetadata</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StripeMetadataLookupRowNumber returns StripeMetadata for the stripe whose
 * firstRowNumber is less than or equal to (FIND_LESS_OR_EQUAL), or is
 * greater than (FIND_GREATER) given rowNumber by doing backward index
 * scan on stripe_first_row_number_idx.
 * If no such stripe exists, then returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>StripeMetadata</name> <modifier>*</modifier></type>
<name>StripeMetadataLookupRowNumber</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
							  <parameter><decl><type><name>RowNumberLookupMode</name></type> <name>lookupMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lookupMode</name> <operator>==</operator> <name>FIND_LESS_OR_EQUAL</name> <operator>||</operator> <name>lookupMode</name> <operator>==</operator> <name>FIND_GREATER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>foundStripeMetadata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>ColumnarStorageGetStorageId</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_stripe_storageid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategyNumber</name> <init>= <expr><name>InvalidStrategy</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>procedure</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>lookupMode</name> <operator>==</operator> <name>FIND_LESS_OR_EQUAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>strategyNumber</name> <operator>=</operator> <name>BTLessEqualStrategyNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>procedure</name> <operator>=</operator> <name>F_INT8LE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>lookupMode</name> <operator>==</operator> <name>FIND_GREATER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>strategyNumber</name> <operator>=</operator> <name>BTGreaterStrategyNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>procedure</name> <operator>=</operator> <name>F_INT8GT</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_stripe_first_row_number</name></expr></argument>,
				<argument><expr><name>strategyNumber</name></expr></argument>, <argument><expr><name>procedure</name></expr></argument>, <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>rowNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarStripes</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>ColumnarStripeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>ColumnarStripeFirstRowNumberIndexRelationId</name><argument_list>()</argument_list></call></expr></argument>,
								<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>index</name></expr></argument>,
															<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
															<argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanDirection</name></type> <name>scanDirection</name> <init>= <expr><name>NoMovementScanDirection</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>lookupMode</name> <operator>==</operator> <name>FIND_LESS_OR_EQUAL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scanDirection</name> <operator>=</operator> <name>BackwardScanDirection</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>lookupMode</name> <operator>==</operator> <name>FIND_GREATER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>scanDirection</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>, <argument><expr><name>scanDirection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>foundStripeMetadata</name> <operator>=</operator> <call><name>BuildStripeMetadata</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>foundStripeMetadata</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckStripeMetadataConsistency first decides if stripe write operation for
 * given stripe is "flushed", "aborted" or "in-progress", then errors out if
 * its metadata entry contradicts with this fact.
 *
 * Checks performed here are just to catch bugs, so it is encouraged to call
 * this function whenever a StripeMetadata object is built from an heap tuple
 * of columnar.stripe. Currently, BuildStripeMetadata is the only function
 * that does this.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckStripeMetadataConsistency</name><parameter_list>(<parameter><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>stripeLooksInProgress</name> <init>=
		<expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stripeMetadata</name><operator>-&gt;</operator><name>chunkCount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>stripeMetadata</name><operator>-&gt;</operator><name>fileOffset</name></name> <operator>==</operator> <name>ColumnarInvalidLogicalOffset</name> <operator>&amp;&amp;</operator>
		<name><name>stripeMetadata</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Even if stripe is flushed, fileOffset and dataLength might be equal
	 * to 0 for zero column tables, but those two should still be consistent
	 * with respect to each other.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>stripeLooksFlushed</name> <init>=
		<expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stripeMetadata</name><operator>-&gt;</operator><name>chunkCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name><name>stripeMetadata</name><operator>-&gt;</operator><name>fileOffset</name></name> <operator>!=</operator> <name>ColumnarInvalidLogicalOffset</name> <operator>&amp;&amp;</operator>
		  <name><name>stripeMetadata</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		 <operator>(</operator><name><name>stripeMetadata</name><operator>-&gt;</operator><name>fileOffset</name></name> <operator>==</operator> <name>ColumnarInvalidLogicalOffset</name> <operator>&amp;&amp;</operator>
		  <name><name>stripeMetadata</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StripeWriteStateEnum</name></type> <name>stripeWriteState</name> <init>= <expr><call><name>StripeWriteState</name><argument_list>(<argument><expr><name>stripeMetadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>stripeWriteState</name> <operator>==</operator> <name>STRIPE_WRITE_FLUSHED</name> <operator>&amp;&amp;</operator> <name>stripeLooksFlushed</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If stripe was flushed to disk, then we expect stripe to store
		 * at least one tuple.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>stripeWriteState</name> <operator>==</operator> <name>STRIPE_WRITE_IN_PROGRESS</name> <operator>&amp;&amp;</operator> <name>stripeLooksInProgress</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If stripe was not flushed to disk, then values of given four
		 * fields should match the columns inserted by
		 * InsertEmptyStripeMetadataRow.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>stripeWriteState</name> <operator>==</operator> <name>STRIPE_WRITE_ABORTED</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>stripeLooksInProgress</name> <operator>||</operator>
														  <name>stripeLooksFlushed</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Stripe metadata entry for an aborted write can be complete or
		 * incomplete. We might have aborted the transaction before or after
		 * inserting into stripe metadata.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected stripe state, stripe metadata "</literal>
						   <literal type="string">"entry for stripe with id="</literal> <name>UINT64_FORMAT</name>
						   <literal type="string">" is not consistent"</literal></expr></argument>, <argument><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FindStripeWithHighestRowNumber returns StripeMetadata for the stripe that
 * has the row with highest rowNumber by doing backward index scan on
 * stripe_first_row_number_idx. If given relation is empty, then returns NULL.
 */</comment>
<function><type><name>StripeMetadata</name> <modifier>*</modifier></type>
<name>FindStripeWithHighestRowNumber</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeWithHighestRowNumber</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>ColumnarStorageGetStorageId</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_stripe_storageid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarStripes</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><call><name>ColumnarStripeRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>ColumnarStripeFirstRowNumberIndexRelationId</name><argument_list>()</argument_list></call></expr></argument>,
								<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>index</name></expr></argument>,
															<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>, <argument><expr><name>BackwardScanDirection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stripeWithHighestRowNumber</name> <operator>=</operator> <call><name>BuildStripeMetadata</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stripeWithHighestRowNumber</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReadChunkGroupRowCounts returns an array of row counts of chunk groups for the
 * given stripe.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name> <modifier>*</modifier></type>
<name>ReadChunkGroupRowCounts</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripe</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>chunkGroupCount</name></decl></parameter>,
						<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>columnarChunkGroupOid</name> <init>= <expr><call><name>ColumnarChunkGroupRelationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarChunkGroup</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>columnarChunkGroupOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>ColumnarChunkGroupIndexRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_chunkgroup_storageid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_chunkgroup_stripe</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>stripe</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>=
		<expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>columnarChunkGroup</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkGroupIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name> <modifier>*</modifier></type><name>chunkGroupRowCounts</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>chunkGroupCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>,
																 <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_columnar_chunkgroup</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_columnar_chunkgroup</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>,
						  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>columnarChunkGroup</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>uint32</name></type> <name>tupleChunkGroupIndex</name> <init>=
			<expr><call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunkgroup_chunk</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>chunkGroupIndex</name> <operator>&gt;=</operator> <name>chunkGroupCount</name> <operator>||</operator>
			<name>tupleChunkGroupIndex</name> <operator>!=</operator> <name>chunkGroupIndex</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected chunk group"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>chunkGroupRowCounts</name><index>[<expr><name>chunkGroupIndex</name></expr>]</index></name> <operator>=</operator>
			<operator>(</operator><name>uint32</name><operator>)</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_chunkgroup_row_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunkGroupIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>chunkGroupIndex</name> <operator>!=</operator> <name>chunkGroupCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected chunk group count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>columnarChunkGroup</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunkGroupRowCounts</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InsertEmptyStripeMetadataRow adds a row to columnar.stripe for the empty
 * stripe reservation made for stripeId.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InsertEmptyStripeMetadataRow</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripeId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>,
							 <parameter><decl><type><name>uint32</name></type> <name>chunkGroupRowCount</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>firstRowNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>Natts_columnar_stripe</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>Natts_columnar_stripe</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_stripe_storageid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_stripe_stripe</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>stripeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_stripe_column_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_stripe_chunk_row_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>chunkGroupRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_stripe_first_row_number</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>firstRowNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* stripe has no rows yet, so initialize rest of the columns accordingly */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_stripe_row_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>UInt64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_stripe_file_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>ColumnarInvalidLogicalOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_stripe_data_length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>UInt64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_columnar_stripe_chunk_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
		<call><name>UInt32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>columnarStripesOid</name> <init>= <expr><call><name>ColumnarStripeRelationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarStripes</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>columnarStripesOid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>modifyState</name> <init>= <expr><call><name>StartModifyRelation</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InsertTupleAndEnforceConstraints</name><argument_list>(<argument><expr><name>modifyState</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FinishModifyRelation</name><argument_list>(<argument><expr><name>modifyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StripesForRelfilenode returns a list of StripeMetadata for stripes
 * of the given relfilenode.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>StripesForRelfilenode</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>relfilenode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>LookupStorageId</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>ReadDataFileStripeList</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>, <argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetHighestUsedAddress returns the highest used address for the given
 * relfilenode across all active and inactive transactions.
 *
 * This is used by truncate stage of VACUUM, and VACUUM can be called
 * for empty tables. So this doesn't throw errors for empty tables and
 * returns 0.
 */</comment>
<function><type><name>uint64</name></type>
<name>GetHighestUsedAddress</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>relfilenode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>LookupStorageId</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>highestUsedAddress</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>highestUsedId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>GetHighestUsedAddressAndId</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>highestUsedAddress</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>highestUsedId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>highestUsedAddress</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetHighestUsedAddressAndId returns the highest used address and id for
 * the given relfilenode across all active and inactive transactions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetHighestUsedAddressAndId</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>,
						   <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>highestUsedAddress</name></decl></parameter>,
						   <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>highestUsedId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>stripeMetadataCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotDirty</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitDirtySnapshot</name><argument_list>(<argument><expr><name>SnapshotDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stripeMetadataList</name> <init>= <expr><call><name>ReadDataFileStripeList</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SnapshotDirty</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>highestUsedId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* file starts with metapage */</comment>
	<expr_stmt><expr><operator>*</operator><name>highestUsedAddress</name> <operator>=</operator> <name>COLUMNAR_BYTES_PER_PAGE</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>stripeMetadataCell</argument>, <argument>stripeMetadataList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripe</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>stripeMetadataCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>lastByte</name> <init>= <expr><name><name>stripe</name><operator>-&gt;</operator><name>fileOffset</name></name> <operator>+</operator> <name><name>stripe</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>highestUsedAddress</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><operator>*</operator><name>highestUsedAddress</name></expr></argument>, <argument><expr><name>lastByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>highestUsedId</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><operator>*</operator><name>highestUsedId</name></expr></argument>, <argument><expr><name><name>stripe</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * ReserveEmptyStripe reserves an empty stripe for given relation
 * and inserts it into columnar.stripe. It is guaranteed that concurrent
 * writes won't overwrite the returned stripe.
 */</comment>
<function><type><name>EmptyStripeReservation</name> <modifier>*</modifier></type>
<name>ReserveEmptyStripe</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>chunkGroupRowCount</name></decl></parameter>,
				   <parameter><decl><type><name>uint64</name></type> <name>stripeRowCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EmptyStripeReservation</name> <modifier>*</modifier></type><name>stripeReservation</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EmptyStripeReservation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>ColumnarStorageGetStorageId</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stripeReservation</name><operator>-&gt;</operator><name>stripeId</name></name> <operator>=</operator> <call><name>ColumnarStorageReserveStripeId</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeReservation</name><operator>-&gt;</operator><name>stripeFirstRowNumber</name></name> <operator>=</operator>
		<call><name>ColumnarStorageReserveRowNumber</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>stripeRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX: Instead of inserting a dummy entry to columnar.stripe and
	 * updating it when flushing the stripe, we could have a hash table
	 * in shared memory for the bookkeeping of ongoing writes.
	 */</comment>
	<expr_stmt><expr><call><name>InsertEmptyStripeMetadataRow</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>, <argument><expr><name><name>stripeReservation</name><operator>-&gt;</operator><name>stripeId</name></name></expr></argument>,
								 <argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>chunkGroupRowCount</name></expr></argument>,
								 <argument><expr><name><name>stripeReservation</name><operator>-&gt;</operator><name>stripeFirstRowNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stripeReservation</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CompleteStripeReservation completes reservation of the stripe with
 * stripeId for given size and in-place updates related stripe metadata tuple
 * to complete reservation.
 */</comment>
<function><type><name>StripeMetadata</name> <modifier>*</modifier></type>
<name>CompleteStripeReservation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripeId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>sizeBytes</name></decl></parameter>,
						  <parameter><decl><type><name>uint64</name></type> <name>rowCount</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>chunkCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>resLogicalStart</name> <init>= <expr><call><name>ColumnarStorageReserveData</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>sizeBytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>ColumnarStorageGetStorageId</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name><name>update</name><index>[<expr><name>Natts_columnar_stripe</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>update</name><index>[<expr><name>Anum_columnar_stripe_file_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>update</name><index>[<expr><name>Anum_columnar_stripe_data_length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>update</name><index>[<expr><name>Anum_columnar_stripe_row_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>update</name><index>[<expr><name>Anum_columnar_stripe_chunk_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name><name>newValues</name><index>[<expr><name>Natts_columnar_stripe</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_columnar_stripe_file_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>resLogicalStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_columnar_stripe_data_length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>sizeBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_columnar_stripe_row_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>rowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_columnar_stripe_chunk_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>chunkCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>UpdateStripeMetadataRow</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>, <argument><expr><name>stripeId</name></expr></argument>, <argument><expr><name>update</name></expr></argument>, <argument><expr><name>newValues</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateStripeMetadataRow updates stripe metadata tuple for the stripe with
 * stripeId according to given newValues and update arrays.
 * Note that this function shouldn't be used for the cases where any indexes
 * of stripe metadata should be updated according to modifications done.
 */</comment>
<function><type><specifier>static</specifier> <name>StripeMetadata</name> <modifier>*</modifier></type>
<name>UpdateStripeMetadataRow</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripeId</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>update</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>newValues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SnapshotData</name></type> <name>dirtySnapshot</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitDirtySnapshot</name><argument_list>(<argument><expr><name>dirtySnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_stripe_storageid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_stripe_stripe</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>stripeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>columnarStripesOid</name> <init>= <expr><call><name>ColumnarStripeRelationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarStripes</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>columnarStripesOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarStripePkeyIndex</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>ColumnarStripePKeyIndexRelationId</name><argument_list>()</argument_list></call></expr></argument>,
												  <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>,
															<argument><expr><name>columnarStripePkeyIndex</name></expr></argument>,
															<argument><expr><operator>&amp;</operator><name>dirtySnapshot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>oldTuple</name> <init>= <expr><call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attempted to modify an unexpected stripe, "</literal>
							   <literal type="string">"columnar storage with id="</literal> <name>UINT64_FORMAT</name>
							   <literal type="string">" does not have stripe with id="</literal> <name>UINT64_FORMAT</name></expr></argument>,
							   <argument><expr><name>storageId</name></expr></argument>, <argument><expr><name>stripeId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * heap_inplace_update already doesn't allow changing size of the original
	 * tuple, so we don't allow setting any Datum's to NULL values.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>newNulls</name><index>[<expr><name>Natts_columnar_stripe</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>modifiedTuple</name> <init>= <expr><call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldTuple</name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>,
												<argument><expr><name>newValues</name></expr></argument>, <argument><expr><name>newNulls</name></expr></argument>, <argument><expr><name>update</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>heap_inplace_update</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>modifiedTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Existing tuple now contains modifications, because we used
	 * heap_inplace_update().
	 */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>newTuple</name> <init>= <expr><name>oldTuple</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must not pass modifiedTuple, because BuildStripeMetadata expects a real
	 * heap tuple with MVCC fields.
	 */</comment>
	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>modifiedStripeMetadata</name> <init>= <expr><call><name>BuildStripeMetadata</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>,
																 <argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>columnarStripePkeyIndex</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* return StripeMetadata object built from modified tuple */</comment>
	<return>return <expr><name>modifiedStripeMetadata</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReadDataFileStripeList reads the stripe list for a given storageId
 * in the given snapshot.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>ReadDataFileStripeList</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stripeMetadataList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_columnar_stripe_storageid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>columnarStripesOid</name> <init>= <expr><call><name>ColumnarStripeRelationId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarStripes</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>columnarStripesOid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><call><name>ColumnarStripeFirstRowNumberIndexRelationId</name><argument_list>()</argument_list></call></expr></argument>,
								<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>index</name></expr></argument>,
															<argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
															<argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>,
																 <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>= <expr><call><name>BuildStripeMetadata</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>stripeMetadataList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stripeMetadataList</name></expr></argument>, <argument><expr><name>stripeMetadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stripeMetadataList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildStripeMetadata builds a StripeMetadata object from given heap tuple.
 *
 * NB: heapTuple must be a proper heap tuple with MVCC fields.
 */</comment>
<function><type><specifier>static</specifier> <name>StripeMetadata</name> <modifier>*</modifier></type>
<name>BuildStripeMetadata</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>columnarStripes</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ColumnarStripeRelationId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name><name>datumArray</name><index>[<expr><name>Natts_columnar_stripe</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name><name>isNullArray</name><index>[<expr><name>Natts_columnar_stripe</name></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>columnarStripes</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>datumArray</name></expr></argument>, <argument><expr><name>isNullArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StripeMetadata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_stripe_stripe</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>fileOffset</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(
		<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_stripe_file_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>dataLength</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(
		<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_stripe_data_length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>columnCount</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(
		<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_stripe_column_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>chunkCount</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(
		<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_stripe_chunk_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>chunkGroupRowCount</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(
		<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_stripe_chunk_row_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(
		<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_stripe_row_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>firstRowNumber</name></name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(
		<argument><expr><name><name>datumArray</name><index>[<expr><name>Anum_columnar_stripe_first_row_number</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is unflushed data in a parent transaction, then we would
	 * have already thrown an error before starting to scan the table.. If
	 * the data is from an earlier subxact that committed, then it would
	 * have been flushed already. For this reason, we don't care about
	 * subtransaction id here.
	 */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>entryXmin</name> <init>= <expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>aborted</name></name> <operator>=</operator> <operator>!</operator><call><name>TransactionIdIsInProgress</name><argument_list>(<argument><expr><name>entryXmin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							  <call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><name>entryXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>insertedByCurrentXact</name></name> <operator>=</operator>
		<call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>entryXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CheckStripeMetadataConsistency</name><argument_list>(<argument><expr><name>stripeMetadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stripeMetadata</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeleteMetadataRows removes the rows with given relfilenode from columnar
 * metadata tables.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteMetadataRows</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>relfilenode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * During a restore for binary upgrade, metadata tables and indexes may or
	 * may not exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>LookupStorageId</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DeleteStorageFromColumnarMetadataTable</name><argument_list>(<argument><expr><call><name>ColumnarStripeRelationId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>Anum_columnar_stripe_storageid</name></expr></argument>,
										   <argument><expr><call><name>ColumnarStripePKeyIndexRelationId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DeleteStorageFromColumnarMetadataTable</name><argument_list>(<argument><expr><call><name>ColumnarChunkGroupRelationId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>Anum_columnar_chunkgroup_storageid</name></expr></argument>,
										   <argument><expr><call><name>ColumnarChunkGroupIndexRelationId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DeleteStorageFromColumnarMetadataTable</name><argument_list>(<argument><expr><call><name>ColumnarChunkRelationId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>Anum_columnar_chunk_storageid</name></expr></argument>,
										   <argument><expr><call><name>ColumnarChunkIndexRelationId</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DeleteStorageFromColumnarMetadataTable removes the rows with given
 * storageId from given columnar metadata table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DeleteStorageFromColumnarMetadataTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>metadataTableId</name></decl></parameter>,
									   <parameter><decl><type><name>AttrNumber</name></type> <name>storageIdAtrrNumber</name></decl></parameter>,
									   <parameter><decl><type><name>Oid</name></type> <name>storageIdIndexId</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scanKey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanKey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>storageIdAtrrNumber</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
				<argument><expr><name>F_INT8EQ</name></expr></argument>, <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>metadataTable</name> <init>= <expr><call><name>try_relation_open</name><argument_list>(<argument><expr><name>metadataTableId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>metadataTable</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* extension has been dropped */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>index</name> <init>= <expr><call><name>index_open</name><argument_list>(<argument><expr><name>storageIdIndexId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scanDescriptor</name> <init>= <expr><call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>metadataTable</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
															<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>modifyState</name> <init>= <expr><call><name>StartModifyRelation</name><argument_list>(<argument><expr><name>metadataTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heapTuple</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>,
																 <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>DeleteTupleAndEnforceConstraints</name><argument_list>(<argument><expr><name>modifyState</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>scanDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FinishModifyRelation</name><argument_list>(<argument><expr><name>modifyState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>metadataTable</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StartModifyRelation allocates resources for modifications.
 */</comment>
<function><type><specifier>static</specifier> <name>ModifyState</name> <modifier>*</modifier></type>
<name>StartModifyRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>create_estate_for_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* ExecSimpleRelationInsert, ... require caller to open indexes */</comment>
	<expr_stmt><expr><call><name>ExecOpenIndices</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>modifyState</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ModifyState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>modifyState</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>modifyState</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>modifyState</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

	<return>return <expr><name>modifyState</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InsertTupleAndEnforceConstraints inserts a tuple into a relation and makes
 * sure constraints are enforced and indexes are updated.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InsertTupleAndEnforceConstraints</name><parameter_list>(<parameter><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>, <argument><expr><name>tupleDescriptor</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>TTSOpsHeapTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* use ExecSimpleRelationInsert to enforce constraints */</comment>
	<expr_stmt><expr><call><name>ExecSimpleRelationInsert_compat</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * DeleteTupleAndEnforceConstraints deletes a tuple from a relation and
 * makes sure constraints (e.g. FK constraints) are enforced.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DeleteTupleAndEnforceConstraints</name><parameter_list>(<parameter><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>heapTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>tid</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* execute AFTER ROW DELETE Triggers to enforce constraints */</comment>
	<expr_stmt><expr><call><name>ExecARDeleteTriggers_compat</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FinishModifyRelation cleans up resources after modifications are done.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishModifyRelation</name><parameter_list>(<parameter><decl><type><name>ModifyState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ExecCloseIndices</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>resultRelInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AfterTriggerEndQuery</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<expr_stmt><expr><call><name>ExecCloseResultRelations</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecCloseRangeTableRelations</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>ExecCleanUpTriggerState</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>ExecResetTupleTable</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>es_tupleTable</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Based on a similar function from
 * postgres/src/backend/replication/logical/worker.c.
 *
 * Executor state preparation for evaluation of constraint expressions,
 * indexes and triggers.
 *
 * This is based on similar code in copy.c
 */</comment>
<function><type><specifier>static</specifier> <name>EState</name> <modifier>*</modifier></type>
<name>create_estate_for_relation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecInitRangeTable</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ResultRelInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>InitResultRelInfo</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prepare to catch AFTER triggers. */</comment>
	<expr_stmt><expr><call><name>AfterTriggerBeginQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>estate</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DatumToBytea serializes a datum into a bytea value.
 *
 * Since we don't want to limit datum size to RSIZE_MAX unnecessarily,
 * we use memcpy instead of memcpy_s several places in this function.
 */</comment>
<function><type><specifier>static</specifier> <name>bytea</name> <modifier>*</modifier></type>
<name>DatumToBytea</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attrForm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>datumLength</name> <init>= <expr><call><name>att_addlength_datum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>attrForm</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>datumLength</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>datumLength</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attrForm</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>attrForm</name><operator>-&gt;</operator><name>attbyval</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>tmp</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>store_att_byval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>attrForm</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name><name>attrForm</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IGNORE-BANNED */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attrForm</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IGNORE-BANNED */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>datumLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IGNORE-BANNED */</comment>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ByteaToDatum deserializes a value which was previously serialized using
 * DatumToBytea.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ByteaToDatum</name><parameter_list>(<parameter><decl><type><name>bytea</name> <modifier>*</modifier></type><name>bytes</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attrForm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We copy the data so the result of this function lives even
	 * after the byteaDatum is freed.
	 */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>binaryDataCopy</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use IGNORE-BANNED here since we don't want to limit datum size to
	 * RSIZE_MAX unnecessarily.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>binaryDataCopy</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IGNORE-BANNED */</comment>

	<return>return <expr><call><name>fetch_att</name><argument_list>(<argument><expr><name>binaryDataCopy</name></expr></argument>, <argument><expr><name><name>attrForm</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>attrForm</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageIdSequenceRelationId returns relation id of columnar.stripe.
 * TODO: should we cache this similar to citus?
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarStorageIdSequenceRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"storageid_seq"</literal></expr></argument>, <argument><expr><call><name>ColumnarNamespaceId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStripeRelationId returns relation id of columnar.stripe.
 * TODO: should we cache this similar to citus?
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarStripeRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"stripe"</literal></expr></argument>, <argument><expr><call><name>ColumnarNamespaceId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStripePKeyIndexRelationId returns relation id of columnar.stripe_pkey.
 * TODO: should we cache this similar to citus?
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarStripePKeyIndexRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"stripe_pkey"</literal></expr></argument>, <argument><expr><call><name>ColumnarNamespaceId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStripeFirstRowNumberIndexRelationId returns relation id of
 * columnar.stripe_first_row_number_idx.
 * TODO: should we cache this similar to citus?
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarStripeFirstRowNumberIndexRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"stripe_first_row_number_idx"</literal></expr></argument>, <argument><expr><call><name>ColumnarNamespaceId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarOptionsRelationId returns relation id of columnar.options.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarOptionsRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"options"</literal></expr></argument>, <argument><expr><call><name>ColumnarNamespaceId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarOptionsIndexRegclass returns relation id of columnar.options_pkey.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarOptionsIndexRegclass</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"options_pkey"</literal></expr></argument>, <argument><expr><call><name>ColumnarNamespaceId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarChunkRelationId returns relation id of columnar.chunk.
 * TODO: should we cache this similar to citus?
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarChunkRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"chunk"</literal></expr></argument>, <argument><expr><call><name>ColumnarNamespaceId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarChunkGroupRelationId returns relation id of columnar.chunk_group.
 * TODO: should we cache this similar to citus?
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarChunkGroupRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"chunk_group"</literal></expr></argument>, <argument><expr><call><name>ColumnarNamespaceId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarChunkIndexRelationId returns relation id of columnar.chunk_pkey.
 * TODO: should we cache this similar to citus?
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarChunkIndexRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"chunk_pkey"</literal></expr></argument>, <argument><expr><call><name>ColumnarNamespaceId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarChunkGroupIndexRelationId returns relation id of columnar.chunk_group_pkey.
 * TODO: should we cache this similar to citus?
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarChunkGroupIndexRelationId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><literal type="string">"chunk_group_pkey"</literal></expr></argument>, <argument><expr><call><name>ColumnarNamespaceId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarNamespaceId returns namespace id of the schema we store columnar
 * related tables.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>ColumnarNamespaceId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>namespace</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><literal type="string">"columnar_internal"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if schema is earlier than 11.1-1 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>namespace</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><literal type="string">"columnar"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>namespace</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LookupStorageId reads storage metapage to find the storage ID for the given relfilenode. It returns
 * false if the relation doesn't have a meta page yet.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>LookupStorageId</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>relfilenode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>RelidByRelfilenode</name><argument_list>(<argument><expr><name><name>relfilenode</name><operator>.</operator><name>spcNode</name></name></expr></argument>,
										<argument><expr><name><name>relfilenode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>ColumnarStorageGetStorageId</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>storageId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarMetadataNewStorageId - create a new, unique storage id and return
 * it.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarMetadataNewStorageId</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>nextval_internal</name><argument_list>(<argument><expr><call><name>ColumnarStorageIdSequenceRelationId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * columnar_relation_storageid returns storage id associated with the
 * given relation id, or -1 if there is no associated storage id yet.
 */</comment>
<function><type><name>Datum</name></type>
<name>columnar_relation_storageid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>OBJECT_TABLE</name></expr></argument>,
					   <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsColumnarTableAmTable</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"relation \"%s\" is not a columnar table"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>ColumnarStorageGetStorageId</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageUpdateIfNeeded - upgrade columnar storage to the current version by
 * using information from the metadata tables.
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarStorageUpdateIfNeeded</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isUpgrade</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ColumnarStorageIsCurrent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name> <init>= <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ColumnarStorageInit</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ColumnarMetadataNewStorageId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>ColumnarStorageGetStorageId</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>highestId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>highestOffset</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>GetHighestUsedAddressAndId</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>highestOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>highestId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>reservedStripeId</name> <init>= <expr><name>highestId</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>reservedOffset</name> <init>= <expr><name>highestOffset</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>reservedRowNumber</name> <init>= <expr><call><name>GetHighestUsedRowNumber</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ColumnarStorageUpdateCurrent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>isUpgrade</name></expr></argument>, <argument><expr><name>reservedStripeId</name></expr></argument>,
								 <argument><expr><name>reservedRowNumber</name></expr></argument>, <argument><expr><name>reservedOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetHighestUsedRowNumber returns the highest used rowNumber for given
 * storageId. Returns COLUMNAR_INVALID_ROW_NUMBER if storage with
 * storageId has no stripes.
 * Note that normally we would use ColumnarStorageGetReservedRowNumber
 * to decide that. However, this function is designed to be used when
 * building the metapage itself during upgrades.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>GetHighestUsedRowNumber</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>highestRowNumber</name> <init>= <expr><name>COLUMNAR_INVALID_ROW_NUMBER</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stripeMetadataList</name> <init>= <expr><call><name>ReadDataFileStripeList</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>,
													  <argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>stripeMetadata</argument>, <argument>stripeMetadataList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>highestRowNumber</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>highestRowNumber</name></expr></argument>,
							   <argument><expr><call><name>StripeGetHighestRowNumber</name><argument_list>(<argument><expr><name>stripeMetadata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>highestRowNumber</name></expr>;</return>
</block_content>}</block></function>
</unit>
