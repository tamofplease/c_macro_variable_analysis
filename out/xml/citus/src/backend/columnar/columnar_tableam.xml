<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/columnar/columnar_tableam.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"citus_version.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/rewriteheap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tsmapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/detoast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_publication.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufpage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_customscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_version_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Timing parameters for truncate locking heuristics.
 *
 * These are the same values from src/backend/access/heap/vacuumlazy.c
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VACUUM_TRUNCATE_LOCK_WAIT_INTERVAL</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>       <comment type="block">/* ms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VACUUM_TRUNCATE_LOCK_TIMEOUT</name></cpp:macro> <cpp:value>4500</cpp:value></cpp:define>               <comment type="block">/* ms */</comment>

<comment type="block">/*
 * ColumnarScanDescData is the scan state passed between beginscan(),
 * getnextslot(), rescan(), and endscan() calls.
 */</comment>
<typedef>typedef <type><struct>struct <name>ColumnarScanDescData</name>
<block>{
	<decl_stmt><decl><type><name>TableScanDescData</name></type> <name>cs_base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>cs_readState</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We initialize cs_readState lazily in the first getnextslot() call. We
	 * need the following for initialization. We save them in beginscan().
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>scanContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attr_needed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>scanQual</name></decl>;</decl_stmt>
}</block></struct></type> <name>ColumnarScanDescData</name>;</typedef>


<comment type="block">/*
 * IndexFetchColumnarData is the scan state passed between index_fetch_begin,
 * index_fetch_reset, index_fetch_end, index_fetch_tuple calls.
 */</comment>
<typedef>typedef <type><struct>struct <name>IndexFetchColumnarData</name>
<block>{
	<decl_stmt><decl><type><name>IndexFetchTableData</name></type> <name>cs_base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>cs_readState</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We initialize cs_readState lazily in the first columnar_index_fetch_tuple
	 * call. However, we want to do memory allocations in a sub MemoryContext of
	 * columnar_index_fetch_begin. For this reason, we store scanContext in
	 * columnar_index_fetch_begin.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>scanContext</name></decl>;</decl_stmt>
}</block></struct></type> <name>IndexFetchColumnarData</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>object_access_hook_type</name></type> <name>PrevObjectAccessHook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ProcessUtility_hook_type</name></type> <name>PrevProcessUtilityHook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* forward declaration for static functions */</comment>
<function_decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>CreateColumnarScanMemoryContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarTableDropHook</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tgid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarTriggerCreateHook</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tgid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarTableAMObjectAccessHook</name><parameter_list>(<parameter><decl><type><name>ObjectAccessType</name></type> <name>access</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>,
											<parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subId</name></decl></parameter>,
											<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeVar</name> <modifier>*</modifier></type> <name>ColumnarProcessAlterTable</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStmt</name></decl></parameter>,
											<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnarOptions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
								   <parameter><decl><type><name>bool</name></type> <name>readOnlyTree</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
								   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
								   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
								   <parameter><decl><type><name><name>struct</name> <name>QueryEnvironment</name></name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
								   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
								   <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ConditionalLockRelationWithTimeout</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>retryInterval</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>NeededColumnsList</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attr_needed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LogRelationStats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TruncateColumnar</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>ColumnarSlotCopyHeapTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarCheckLogicalReplication</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type> <name>detoast_values</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>orig_values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ItemPointerData</name></type> <name>row_number_to_tid</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>tid_to_row_number</name><parameter_list>(<parameter><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ErrorIfInvalidRowNumber</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarReportTotalVirtualBlocks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
											 <parameter><decl><type><name>int</name></type> <name>progressArrIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BlockNumber</name></type> <name>ColumnarGetNumberOfVirtualBlocks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ItemPointerData</name></type> <name>ColumnarGetHighestItemPointer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
													 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>ColumnarReadRowsIntoIndex</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>,
										<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
										<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>,
										<parameter><decl><type><name>IndexBuildCallback</name></type> <name>indexCallback</name></decl></parameter>,
										<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>indexCallbackState</name></decl></parameter>,
										<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarReadMissingRowsIntoIndex</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
											 <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
											 <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>,
											 <parameter><decl><type><name>ValidateIndexState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ItemPointerData</name></type> <name>TupleSortSkipSmallerItemPointers</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>tupleSort</name></decl></parameter>,
														<parameter><decl><type><name>ItemPointer</name></type> <name>targetItemPointer</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* functions for CheckCitusColumnarVersion */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckAvailableVersionColumnar</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckInstalledVersionColumnar</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>AvailableExtensionVersionColumnar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>InstalledExtensionVersionColumnar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CitusColumnarHasBeenLoadedInternal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CitusColumnarHasBeenLoaded</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CheckCitusColumnarVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MajorVersionsCompatibleColumnar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>leftVersion</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rightVersion</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* global variables for CheckCitusColumnarVersion */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>extensionLoadedColumnar</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>EnableVersionChecksColumnar</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>citusVersionKnownCompatibleColumnar</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Custom tuple slot ops used for columnar. Initialized in columnar_tableam_init(). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TupleTableSlotOps</name></type> <name>TTSOpsColumnar</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TupleTableSlotOps</name> <modifier>*</modifier></type>
<name>columnar_slot_callbacks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>TTSOpsColumnar</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TableScanDesc</name></type>
<name>columnar_beginscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
				   <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>parallel_scan</name></decl></parameter>,
				   <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* attr_needed represents 0-indexed attribute numbers */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attr_needed</name> <init>= <expr><call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>natts</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scandesc</name> <init>= <expr><call><name>columnar_beginscan_extended</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
														 <argument><expr><name>parallel_scan</name></expr></argument>,
														 <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>attr_needed</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>attr_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>scandesc</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>TableScanDesc</name></type>
<name>columnar_beginscan_extended</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>nkeys</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>,
							<parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>parallel_scan</name></decl></parameter>,
							<parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attr_needed</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scanQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relfilenode</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * A memory context to use for scan-wide data, including the lazily
	 * initialized read state. We assume that beginscan is called in a
	 * context that will last until end of scan.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>scanContext</name> <init>= <expr><call><name>CreateColumnarScanMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>scanContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ColumnarScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnarScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rs_rd</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rs_snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rs_nkeys</name></name> <operator>=</operator> <name>nkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rs_key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rs_parallel</name></name> <operator>=</operator> <name>parallel_scan</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We will initialize this lazily in first tuple, where we have the actual
	 * tuple descriptor to use for reading. In some cases like ALTER TABLE ...
	 * ALTER COLUMN ... TYPE, the tuple descriptor of relation doesn't match
	 * the storage which we are reading, so we need to use the tuple descriptor
	 * of "slot" in first read.
	 */</comment>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>attr_needed</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>attr_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>scanQual</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>scanQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>scanContext</name></name> <operator>=</operator> <name>scanContext</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PendingWritesInUpperTransactions</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>, <argument><expr><call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"cannot read from table when there is unflushed data in upper transactions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><operator>(</operator><name>TableScanDesc</name><operator>)</operator> <name>scan</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateColumnarScanMemoryContext creates a memory context to store
 * ColumnarReadStare in it.
 */</comment>
<function><type><specifier>static</specifier> <name>MemoryContext</name></type>
<name>CreateColumnarScanMemoryContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"Columnar Scan Context"</literal></expr></argument>,
								 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * init_columnar_read_state initializes a column store table read and returns the
 * state.
 */</comment>
<function><type><specifier>static</specifier> <name>ColumnarReadState</name> <modifier>*</modifier></type>
<name>init_columnar_read_state</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attr_needed</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scanQual</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>scanContext</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>scanContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>neededColumnList</name> <init>= <expr><call><name>NeededColumnsList</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>attr_needed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name> <init>= <expr><call><name>ColumnarBeginRead</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>neededColumnList</name></expr></argument>,
													 <argument><expr><name>scanQual</name></expr></argument>, <argument><expr><name>scanContext</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
													 <argument><expr><name>randomAccess</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>readState</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_endscan</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>ColumnarScanDesc</name><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ColumnarEndRead</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rs_flags</name></name> <operator>&amp;</operator> <name>SO_TEMP_SNAPSHOT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_rescan</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>, <parameter><decl><type><name>ScanKey</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>set_params</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>allow_strat</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_sync</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_pagemode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>ColumnarScanDesc</name><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* XXX: hack to pass in new quals that aren't actually scan keys */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>scanQual</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ColumnarRescan</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name></expr></argument>, <argument><expr><name>scanQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>columnar_getnextslot</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>, <parameter><decl><type><name>ScanDirection</name></type> <name>direction</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarScanDesc</name></type> <name>scan</name> <init>= <expr><operator>(</operator><name>ColumnarScanDesc</name><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * if this is the first row, initialize read state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>randomAccess</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name> <operator>=</operator>
			<call><name>init_columnar_read_state</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rs_rd</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
									 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>attr_needed</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scanQual</name></name></expr></argument>,
									 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scanContext</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rs_snapshot</name></name></expr></argument>,
									 <argument><expr><name>randomAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>rowNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>nextRowFound</name> <init>= <expr><call><name>ColumnarReadNextRow</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
											<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nextRowFound</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <call><name>row_number_to_tid</name><argument_list>(<argument><expr><name>rowNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * row_number_to_tid maps given rowNumber to ItemPointerData.
 */</comment>
<function><type><specifier>static</specifier> <name>ItemPointerData</name></type>
<name>row_number_to_tid</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ErrorIfInvalidRowNumber</name><argument_list>(<argument><expr><name>rowNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tid</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>, <argument><expr><name>rowNumber</name> <operator>/</operator> <name>VALID_ITEMPOINTER_OFFSETS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>, <argument><expr><name>rowNumber</name> <operator>%</operator> <name>VALID_ITEMPOINTER_OFFSETS</name> <operator>+</operator>
							   <name>FirstOffsetNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * tid_to_row_number maps given ItemPointerData to rowNumber.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>tid_to_row_number</name><parameter_list>(<parameter><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type> <name>rowNumber</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>VALID_ITEMPOINTER_OFFSETS</name> <operator>+</operator>
					   <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>FirstOffsetNumber</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ErrorIfInvalidRowNumber</name><argument_list>(<argument><expr><name>rowNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rowNumber</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ErrorIfInvalidRowNumber errors out if given rowNumber is invalid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ErrorIfInvalidRowNumber</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>rowNumber</name> <operator>==</operator> <name>COLUMNAR_INVALID_ROW_NUMBER</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not expected but be on the safe side */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected row number for columnar table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rowNumber</name> <operator>&gt;</operator> <name>COLUMNAR_MAX_ROW_NUMBER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar tables can't have row numbers "</literal>
							   <literal type="string">"greater than "</literal> <name>UINT64_FORMAT</name></expr></argument>,
							   <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>COLUMNAR_MAX_ROW_NUMBER</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider using VACUUM FULL for your table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Size</name></type>
<name>columnar_parallelscan_estimate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_parallelscan_estimate not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Size</name></type>
<name>columnar_parallelscan_initialize</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>pscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_parallelscan_initialize not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_parallelscan_reinitialize</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ParallelTableScanDesc</name></type> <name>pscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_parallelscan_reinitialize not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>IndexFetchTableData</name> <modifier>*</modifier></type>
<name>columnar_index_fetch_begin</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relfilenode</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PendingWritesInUpperTransactions</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>, <argument><expr><call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* XXX: maybe we can just flush the data and continue */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot read from index when there is unflushed data in "</literal>
					<literal type="string">"upper transactions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>scanContext</name> <init>= <expr><call><name>CreateColumnarScanMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>scanContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>IndexFetchColumnarData</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexFetchColumnarData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>scanContext</name></name> <operator>=</operator> <name>scanContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_index_fetch_reset</name><parameter_list>(<parameter><decl><type><name>IndexFetchTableData</name> <modifier>*</modifier></type><name>sscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* no-op */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_index_fetch_end</name><parameter_list>(<parameter><decl><type><name>IndexFetchTableData</name> <modifier>*</modifier></type><name>sscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>columnar_index_fetch_reset</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>IndexFetchColumnarData</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><operator>(</operator><name>IndexFetchColumnarData</name> <operator>*</operator><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ColumnarEndRead</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>columnar_index_fetch_tuple</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>IndexFetchTableData</name></name> <modifier>*</modifier></type><name>sscan</name></decl></parameter>,
						   <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
						   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>call_again</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>all_dead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* no HOT chains are possible in columnar, directly set it to false */</comment>
	<expr_stmt><expr><operator>*</operator><name>call_again</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize all_dead to false if passed to be non-NULL.
	 *
	 * XXX: For aborted writes, we should set all_dead to true but this would
	 * require implementing columnar_index_delete_tuples for simple deletion
	 * of dead tuples (TM_IndexDeleteOp.bottomup = false).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>all_dead</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>all_dead</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>IndexFetchColumnarData</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><operator>(</operator><name>IndexFetchColumnarData</name> <operator>*</operator><operator>)</operator> <name>sscan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>columnarRelation</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>cs_base</name><operator>.</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* initialize read state for the first row */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we need all columns */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>columnarRelation</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attr_needed</name> <init>= <expr><call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>natts</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* no quals for index scan */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>scanQual</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>randomAccess</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name> <operator>=</operator> <call><name>init_columnar_read_state</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>,
													  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
													  <argument><expr><name>attr_needed</name></expr></argument>, <argument><expr><name>scanQual</name></expr></argument>,
													  <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scanContext</name></name></expr></argument>,
													  <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>randomAccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>rowNumber</name> <init>= <expr><call><name>tid_to_row_number</name><argument_list>(<argument><expr><operator>*</operator><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>=
		<expr><call><name>FindStripeWithMatchingFirstRowNumber</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>, <argument><expr><name>rowNumber</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stripeMetadata</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* it is certain that tuple with rowNumber doesn't exist */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StripeWriteStateEnum</name></type> <name>stripeWriteState</name> <init>= <expr><call><name>StripeWriteState</name><argument_list>(<argument><expr><name>stripeMetadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>stripeWriteState</name> <operator>==</operator> <name>STRIPE_WRITE_FLUSHED</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>ColumnarReadRowByRowNumber</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name></expr></argument>, <argument><expr><name>rowNumber</name></expr></argument>,
									<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * FindStripeWithMatchingFirstRowNumber doesn't verify upper row
		 * number boundary of found stripe. For this reason, we didn't
		 * certainly know if given row number belongs to one of the stripes.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>stripeWriteState</name> <operator>==</operator> <name>STRIPE_WRITE_ABORTED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We only expect to see un-flushed stripes when checking against
		 * constraint violation. In that case, indexAM provides dirty
		 * snapshot to index_fetch_tuple callback.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>stripeWriteState</name> <operator>==</operator> <name>STRIPE_WRITE_IN_PROGRESS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>insertedByCurrentXact</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Stripe write is in progress and its entry is inserted by current
			 * transaction, so obviously it must be written by me. Since caller
			 * might want to use tupleslot datums for some reason, do another
			 * look-up, but this time by first flushing our writes.
			 *
			 * XXX: For index scan, this is the only case that we flush pending
			 * writes of the current backend. If we have taught reader how to
			 * read from WriteStateMap. then we could guarantee that
			 * index_fetch_tuple would never flush pending writes, but this seem
			 * to be too much work for now, but should be doable.
			 */</comment>
			<expr_stmt><expr><call><name>ColumnarReadFlushPendingWrites</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Fill the tupleslot and fall through to return true, it
			 * certainly exists.
			 */</comment>
			<expr_stmt><expr><call><name>ColumnarReadRowByRowNumberOrError</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>cs_readState</name></name></expr></argument>, <argument><expr><name>rowNumber</name></expr></argument>,
											  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* similar to aborted writes, it should be dirty snapshot */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name> <operator>==</operator> <name>SNAPSHOT_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Stripe that "might" contain the tuple with rowNumber is not
			 * flushed yet. Here we set all attributes of given tupleslot to NULL
			 * before returning true and expect the indexAM callback that called
			 * us --possibly to check against constraint violation-- blocks until
			 * writer transaction commits or aborts, without requiring us to fill
			 * the tupleslot properly.
			 *
			 * XXX: Note that the assumption we made above for the tupleslot
			 * holds for "unique" constraints defined on "btree" indexes.
			 *
			 * For the other constraints that we support, namely:
			 * * exclusion on btree,
			 * * exclusion on hash,
			 * * unique on btree;
			 * we still need to fill tts_values.
			 *
			 * However, for the same reason, we should have already flushed
			 * single tuple stripes when inserting into table for those three
			 * classes of constraints.
			 *
			 * This is annoying, but this also explains why this hack works for
			 * unique constraints on btree indexes, and also explains how we
			 * would never end up with "else" condition otherwise.
			 */</comment>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_nvalid</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * At this point, we certainly know that stripe is flushed and
		 * ColumnarReadRowByRowNumber successfully filled the tupleslot.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stripeWriteState</name> <operator>==</operator> <name>STRIPE_WRITE_FLUSHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <operator>*</operator><name>tid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>columnar_fetch_row_version</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
						   <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>,
						   <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_fetch_row_version not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_get_latest_tid</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>sscan</name></decl></parameter>,
						<parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_get_latest_tid not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>columnar_tuple_tid_valid</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_tuple_tid_valid not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>columnar_tuple_satisfies_snapshot</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>rowNumber</name> <init>= <expr><call><name>tid_to_row_number</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>= <expr><call><name>FindStripeByRowNumber</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rowNumber</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>stripeMetadata</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>columnar_index_delete_tuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
							 <parameter><decl><type><name>TM_IndexDeleteOp</name> <modifier>*</modifier></type><name>delstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX: We didn't bother implementing index_delete_tuple for neither of
	 * simple deletion and bottom-up deletion cases. There is no particular
	 * reason for that, just to keep things simple.
	 *
	 * See the rest of this function to see how we deal with
	 * index_delete_tuples requests made to columnarAM.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>delstate</name><operator>-&gt;</operator><name>bottomup</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ignore any bottom-up deletion requests.
		 *
		 * Currently only caller in postgres that does bottom-up deletion is
		 * _bt_bottomupdel_pass, which in turn calls _bt_delitems_delete_check.
		 * And this function is okay with ndeltids being set to 0 by tableAM
		 * for bottom-up deletion.
		 */</comment>
		<expr_stmt><expr><name><name>delstate</name><operator>-&gt;</operator><name>ndeltids</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>InvalidTransactionId</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * TableAM is not expected to set ndeltids to 0 for simple deletion
		 * case, so here we cannot do the same trick that we do for
		 * bottom-up deletion.
		 * See the assertion around table_index_delete_tuples call in pg
		 * function index_compute_xid_horizon_for_tuples.
		 *
		 * For this reason, to avoid receiving simple deletion requests for
		 * columnar tables (bottomup = false), columnar_index_fetch_tuple
		 * doesn't ever set all_dead to true in order to prevent triggering
		 * simple deletion of index tuples. But let's throw an error to be on
		 * the safe side.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_index_delete_tuples not implemented for simple deletion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>TransactionId</name></type>
<name>columnar_compute_xid_horizon_for_tuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
										<parameter><decl><type><name>ItemPointerData</name> <modifier>*</modifier></type><name>tids</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>nitems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_compute_xid_horizon_for_tuples not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_tuple_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * columnar_init_write_state allocates the write state in a longer
	 * lasting context, so no need to worry about it.
	 */</comment>
	<decl_stmt><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name> <init>= <expr><call><name>columnar_init_write_state</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
															   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
															   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tableOid</name></name></expr></argument>,
															   <argument><expr><call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>ColumnarWritePerTupleContext</name><argument_list>(
														 <argument><expr><name>writeState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ColumnarCheckLogicalReplication</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><call><name>detoast_values</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
								   <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>writtenRowNumber</name> <init>= <expr><call><name>ColumnarWriteRow</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <call><name>row_number_to_tid</name><argument_list>(<argument><expr><name>writtenRowNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><call><name>ColumnarWritePerTupleContext</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_tuple_insert_speculative</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
								  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,
								  <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>specToken</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_tuple_insert_speculative not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_tuple_complete_speculative</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
									<parameter><decl><type><name>uint32</name></type> <name>specToken</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>succeeded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_tuple_complete_speculative not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_multi_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>slots</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntuples</name></decl></parameter>,
					  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BulkInsertState</name></type> <name>bistate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The callback to .multi_insert is table_multi_insert() and this is only used for the COPY
	 * command, so slot[i]-&gt;tts_tableoid will always be equal to relation-&gt;id. Thus, we can send
	 * RelationGetRelid(relation) as the tupSlotTableOid
	 */</comment>
	<decl_stmt><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name> <init>= <expr><call><name>columnar_init_write_state</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
															   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
															   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
															   <argument><expr><call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ColumnarCheckLogicalReplication</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>ColumnarWritePerTupleContext</name><argument_list>(
														 <argument><expr><name>writeState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleSlot</name> <init>= <expr><name><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>tupleSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><call><name>detoast_values</name><argument_list>(<argument><expr><name><name>tupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
									   <argument><expr><name><name>tupleSlot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>tupleSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>uint64</name></type> <name>writtenRowNumber</name> <init>= <expr><call><name>ColumnarWriteRow</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>, <argument><expr><name>values</name></expr></argument>,
												   <argument><expr><name><name>tupleSlot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>tupleSlot</name><operator>-&gt;</operator><name>tts_tid</name></name> <operator>=</operator> <call><name>row_number_to_tid</name><argument_list>(<argument><expr><name>writtenRowNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><call><name>ColumnarWritePerTupleContext</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>columnar_tuple_delete</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>,
					  <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>,
					  <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changingPart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_tuple_delete not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>columnar_tuple_update</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>otid</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
					  <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>crosscheck</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>, <parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>,
					  <parameter><decl><type><name>LockTupleMode</name> <modifier>*</modifier></type><name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>update_indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_tuple_update not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TM_Result</name></type>
<name>columnar_tuple_lock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
					<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>LockTupleMode</name></type> <name>mode</name></decl></parameter>,
					<parameter><decl><type><name>LockWaitPolicy</name></type> <name>wait_policy</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>flags</name></decl></parameter>,
					<parameter><decl><type><name>TM_FailureData</name> <modifier>*</modifier></type><name>tmfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_tuple_lock not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_finish_bulk_insert</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Nothing to do here. We keep write states live until transaction end.
	 */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_relation_set_new_filenode</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>RelFileNode</name> <modifier>*</modifier></type><name>newrnode</name></decl></parameter>,
								   <parameter><decl><type><name>char</name></type> <name>persistence</name></decl></parameter>,
								   <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>freezeXid</name></decl></parameter>,
								   <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>minmulti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>persistence</name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unlogged columnar tables are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If existing and new relfilenode are different, that means the existing
	 * storage was dropped and we also need to clean up the metadata and
	 * state. If they are equal, this is a new relation object and we don't
	 * need to clean anything.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name> <operator>!=</operator> <name><name>newrnode</name><operator>-&gt;</operator><name>relNode</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MarkRelfilenodeDropped</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>, <argument><expr><call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DeleteMetadataRows</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>freezeXid</name> <operator>=</operator> <name>RecentXmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>minmulti</name> <operator>=</operator> <call><name>GetOldestMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SMgrRelation</name></type> <name>srel</name> <init>= <expr><call><name>RelationCreateStorage_compat</name><argument_list>(<argument><expr><operator>*</operator><name>newrnode</name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ColumnarStorageInit</name><argument_list>(<argument><expr><name>srel</name></expr></argument>, <argument><expr><call><name>ColumnarMetadataNewStorageId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitColumnarOptions</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>smgrclose</name><argument_list>(<argument><expr><name>srel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we will lazily initialize metadata in first stripe reservation */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_relation_nontransactional_truncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>relfilenode</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>NonTransactionDropWriteState</name><argument_list>(<argument><expr><name><name>relfilenode</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete old relfilenode metadata */</comment>
	<expr_stmt><expr><call><name>DeleteMetadataRows</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No need to set new relfilenode, since the table was created in this
	 * transaction and no other transaction can see this relation yet. We
	 * can just truncate the relation.
	 *
	 * This is similar to what is done in heapam_relation_nontransactional_truncate.
	 */</comment>
	<expr_stmt><expr><call><name>RelationTruncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name> <init>= <expr><call><name>ColumnarMetadataNewStorageId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ColumnarStorageInit</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_relation_copy_data</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelFileNode</name> <modifier>*</modifier></type><name>newrnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_relation_copy_data not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * columnar_relation_copy_for_cluster is called on VACUUM FULL, at which
 * we should copy data from OldHeap to NewHeap.
 *
 * In general TableAM case this can also be called for the CLUSTER command
 * which is not applicable for columnar since it doesn't support indexes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_relation_copy_for_cluster</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>OldHeap</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>NewHeap</name></decl></parameter>,
								   <parameter><decl><type><name>Relation</name></type> <name>OldIndex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_sort</name></decl></parameter>,
								   <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
								   <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xid_cutoff</name></decl></parameter>,
								   <parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>multi_cutoff</name></decl></parameter>,
								   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>num_tuples</name></decl></parameter>,
								   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tups_vacuumed</name></decl></parameter>,
								   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tups_recently_dead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>sourceDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>targetDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>NewHeap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>OldIndex</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>use_sort</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"clustering columnar tables using indexes is "</literal>
							   <literal type="string">"not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * copy_table_data in cluster.c assumes tuple descriptors are exactly
	 * the same. Even dropped columns exist and are marked as attisdropped
	 * in the target relation.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sourceDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>==</operator> <name><name>targetDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* read settings from old heap, relfilenode will be swapped at the end */</comment>
	<decl_stmt><decl><type><name>ColumnarOptions</name></type> <name>columnarOptions</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReadColumnarOptions</name><argument_list>(<argument><expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>columnarOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ColumnarWriteState</name> <modifier>*</modifier></type><name>writeState</name> <init>= <expr><call><name>ColumnarBeginWrite</name><argument_list>(<argument><expr><name><name>NewHeap</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>,
														<argument><expr><name>columnarOptions</name></expr></argument>,
														<argument><expr><name>targetDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we need all columns */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>OldHeap</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attr_needed</name> <init>= <expr><call><name>bms_add_range</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>natts</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* no quals for table rewrite */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>scanQual</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* use SnapshotAny when re-writing table as heapAM does */</comment>
	<decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name> <init>= <expr><name>SnapshotAny</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>scanContext</name> <init>= <expr><call><name>CreateColumnarScanMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>randomAccess</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name> <init>= <expr><call><name>init_columnar_read_state</name><argument_list>(<argument><expr><name>OldHeap</name></expr></argument>, <argument><expr><name>sourceDesc</name></expr></argument>,
															<argument><expr><name>attr_needed</name></expr></argument>, <argument><expr><name>scanQual</name></expr></argument>,
															<argument><expr><name>scanContext</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
															<argument><expr><name>randomAccess</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name><name>sourceDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name><name>sourceDesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_tuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* we don't need to know rowNumber here */</comment>
	<while>while <condition>(<expr><call><name>ColumnarReadNextRow</name><argument_list>(<argument><expr><name>readState</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ColumnarWriteRow</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>num_tuples</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>tups_vacuumed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ColumnarEndWrite</name><argument_list>(<argument><expr><name>writeState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ColumnarEndRead</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * NeededColumnsList returns a list of AttrNumber's for the columns that
 * are not dropped and specified by attr_needed.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>NeededColumnsList</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>attr_needed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attisdropped</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* attr_needed is 0-indexed but columnList is 1-indexed */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>attr_needed</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttrNumber</name></type> <name>varattno</name> <init>= <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>columnList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>columnList</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>columnList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarTableTupleCount returns the number of tuples that columnar
 * table with relationId has by using stripe metadata.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>ColumnarTableTupleCount</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stripeList</name> <init>= <expr><call><name>StripesForRelfilenode</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>tupleCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>stripeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripe</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>tupleCount</name> <operator>+=</operator> <name><name>stripe</name><operator>-&gt;</operator><name>rowCount</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>tupleCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * columnar_vacuum_rel implements VACUUM without FULL option.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_vacuum_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>VacuumParams</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
					<parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Skip if the extension catalogs are not up-to-date, but avoid
		 * erroring during auto-vacuum.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_progress_start_command</name><argument_list>(<argument><expr><name>PROGRESS_COMMAND_VACUUM</name></expr></argument>,
								  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If metapage version of relation is older, then we hint users to VACUUM
	 * the relation in ColumnarMetapageCheckVersion. So if needed, upgrade
	 * the metapage before doing anything.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>isUpgrade</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ColumnarStorageUpdateIfNeeded</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>isUpgrade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>elevel</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>params</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VERBOSE</name><operator>)</operator></expr> ?</condition><then> <expr><name>INFO</name></expr> </then><else>: <expr><name>DEBUG2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this should have been resolved by vacuum.c until now */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>truncate</name></name> <operator>!=</operator> <name>VACOPTVALUE_UNSPECIFIED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LogRelationStats</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't have updates, deletes, or concurrent updates, so all we
	 * care for now is truncating the unused space at the end of storage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>truncate</name></name> <operator>==</operator> <name>VACOPTVALUE_ENABLED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TruncateColumnar</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>new_rel_pages</name> <init>= <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get the number of indexes */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>indexList</name> <init>= <expr><call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nindexes</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>indexList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TransactionId</name></type> <name>oldestXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>freezeLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiXactCutoff</name></decl>;</decl_stmt>

	<comment type="block">/* initialize xids */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>oldestMxact</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>vacuum_set_xid_limits</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>freeze_min_age</name></name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>freeze_table_age</name></name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>multixact_freeze_min_age</name></name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>multixact_freeze_table_age</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>oldestXmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldestMxact</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>freezeLimit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>multiXactCutoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>MultiXactIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>multiXactCutoff</name></expr></argument>, <argument><expr><name>oldestMxact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidFullScanLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>mxactFullScanLimit</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>vacuum_set_xid_limits</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>freeze_min_age</name></name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>freeze_table_age</name></name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>multixact_freeze_min_age</name></name></expr></argument>,
						  <argument><expr><name><name>params</name><operator>-&gt;</operator><name>multixact_freeze_table_age</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>oldestXmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>freezeLimit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xidFullScanLimit</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>multiXactCutoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mxactFullScanLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdPrecedesOrEquals</name><argument_list>(<argument><expr><name>freezeLimit</name></expr></argument>, <argument><expr><name>oldestXmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Columnar storage doesn't hold any transaction IDs, so we can always
	 * just advance to the most aggressive value.
	 */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>newRelFrozenXid</name> <init>= <expr><name>oldestXmin</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>newRelminMxid</name> <init>= <expr><name>oldestMxact</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>newRelminMxid</name> <init>= <expr><name>multiXactCutoff</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>double</name></type> <name>new_live_tuples</name> <init>= <expr><call><name>ColumnarTableTupleCount</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* all visible pages are always 0 */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>new_rel_allvisible</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<decl_stmt><decl><type><name>bool</name></type> <name>frozenxid_updated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>minmulti_updated</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>new_rel_pages</name></expr></argument>, <argument><expr><name>new_live_tuples</name></expr></argument>,
						<argument><expr><name>new_rel_allvisible</name></expr></argument>, <argument><expr><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>,
						<argument><expr><name>newRelFrozenXid</name></expr></argument>, <argument><expr><name>newRelminMxid</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>frozenxid_updated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minmulti_updated</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>vac_update_relstats</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>new_rel_pages</name></expr></argument>, <argument><expr><name>new_live_tuples</name></expr></argument>,
						<argument><expr><name>new_rel_allvisible</name></expr></argument>, <argument><expr><name>nindexes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>,
						<argument><expr><name>newRelFrozenXid</name></expr></argument>, <argument><expr><name>newRelminMxid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>pgstat_report_vacuum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>,
						 <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>new_live_tuples</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_progress_end_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * LogRelationStats logs statistics as the output of the VACUUM VERBOSE.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogRelationStats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>stripeMetadataCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelFileNode</name></type> <name>relfilenode</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>infoBuf</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name><name>compressionStats</name><index>[<expr><name>COMPRESSION_COUNT</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>totalStripeLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>tupleCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>chunkCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>droppedChunksWithData</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>totalDecompressedLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stripeList</name> <init>= <expr><call><name>StripesForRelfilenode</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>stripeCount</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>stripeList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>stripeMetadataCell</argument>, <argument>stripeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripe</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>stripeMetadataCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>skiplist</name> <init>= <expr><call><name>ReadStripeSkipList</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>, <argument><expr><name><name>stripe</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
													  <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name><name>stripe</name><operator>-&gt;</operator><name>chunkCount</name></name></expr></argument>,
													  <argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>uint32</name></type> <name>column</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>column</name> <operator>&lt;</operator> <name><name>skiplist</name><operator>-&gt;</operator><name>columnCount</name></name></expr>;</condition> <incr><expr><name>column</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>attrDropped</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>column</name></expr>]</index></name><operator>.</operator><name>attisdropped</name></expr></init></decl>;</decl_stmt>
			<for>for <control>(<init><decl><type><name>uint32</name></type> <name>chunk</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>chunk</name> <operator>&lt;</operator> <name><name>skiplist</name><operator>-&gt;</operator><name>chunkCount</name></name></expr>;</condition> <incr><expr><name>chunk</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>skipnode</name> <init>=
					<expr><operator>&amp;</operator><name><name>skiplist</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name><index>[<expr><name>column</name></expr>]</index><index>[<expr><name>chunk</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* ignore zero length chunks for dropped attributes */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>skipnode</name><operator>-&gt;</operator><name>valueLength</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>compressionStats</name><index>[<expr><name><name>skipnode</name><operator>-&gt;</operator><name>valueCompressionType</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>chunkCount</name><operator>++</operator></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>attrDropped</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>droppedChunksWithData</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We don't compress exists buffer, so its compressed &amp; decompressed
				 * lengths are the same.
				 */</comment>
				<expr_stmt><expr><name>totalDecompressedLength</name> <operator>+=</operator> <name><name>skipnode</name><operator>-&gt;</operator><name>existsLength</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>totalDecompressedLength</name> <operator>+=</operator> <name><name>skipnode</name><operator>-&gt;</operator><name>decompressedValueSize</name></name></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>

		<expr_stmt><expr><name>tupleCount</name> <operator>+=</operator> <name><name>stripe</name><operator>-&gt;</operator><name>rowCount</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalStripeLength</name> <operator>+=</operator> <name><name>stripe</name><operator>-&gt;</operator><name>dataLength</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>uint64</name></type> <name>relPages</name> <init>= <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RelationCloseSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Datum</name></type> <name>storageId</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>columnar_relation_storageid</name></expr></argument>,
										  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>compressionRate</name> <init>= <expr><ternary><condition><expr><name>totalStripeLength</name></expr> ?</condition><then>
							 <expr><operator>(</operator><name>double</name><operator>)</operator> <name>totalDecompressedLength</name> <operator>/</operator> <name>totalStripeLength</name></expr> </then><else>:
							 <expr><literal type="number">1.0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>infoBuf</name></expr></argument>, <argument><expr><literal type="string">"storage id: %ld\n"</literal></expr></argument>, <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>storageId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>infoBuf</name></expr></argument>, <argument><expr><literal type="string">"total file size: %ld, total data size: %ld\n"</literal></expr></argument>,
					 <argument><expr><name>relPages</name> <operator>*</operator> <name>BLCKSZ</name></expr></argument>, <argument><expr><name>totalStripeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>infoBuf</name></expr></argument>, <argument><expr><literal type="string">"compression rate: %.2fx\n"</literal></expr></argument>, <argument><expr><name>compressionRate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>infoBuf</name></expr></argument>,
					 <argument><expr><literal type="string">"total row count: %ld, stripe count: %d, "</literal>
					 <literal type="string">"average rows per stripe: %ld\n"</literal></expr></argument>,
					 <argument><expr><name>tupleCount</name></expr></argument>, <argument><expr><name>stripeCount</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name>stripeCount</name></expr> ?</condition><then> <expr><name>tupleCount</name> <operator>/</operator> <name>stripeCount</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>infoBuf</name></expr></argument>,
					 <argument><expr><literal type="string">"chunk count: %ld"</literal>
					 <literal type="string">", containing data for dropped columns: %ld"</literal></expr></argument>,
					 <argument><expr><name>chunkCount</name></expr></argument>, <argument><expr><name>droppedChunksWithData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>compressionType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>compressionType</name> <operator>&lt;</operator> <name>COMPRESSION_COUNT</name></expr>;</condition> <incr><expr><name>compressionType</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>compressionName</name> <init>= <expr><call><name>CompressionTypeStr</name><argument_list>(<argument><expr><name>compressionType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* skip if this compression algorithm has not been compiled */</comment>
		<if_stmt><if>if <condition>(<expr><name>compressionName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* skip if no chunks use this compression type */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>compressionStats</name><index>[<expr><name>compressionType</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>infoBuf</name></expr></argument>,
						 <argument><expr><literal type="string">", %s compressed: %d"</literal></expr></argument>,
						 <argument><expr><name>compressionName</name></expr></argument>,
						 <argument><expr><name><name>compressionStats</name><index>[<expr><name>compressionType</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>infoBuf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statistics for \"%s\":\n%s"</literal></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>infoBuf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * TruncateColumnar truncates the unused space at the end of main fork for
 * a columnar table. This unused space can be created by aborted transactions.
 *
 * This implementation is based on heap_vacuum_rel in vacuumlazy.c with some
 * changes so it suits columnar store relations.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TruncateColumnar</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGRUsage</name></type> <name>ru0</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Report that we are now truncating */</comment>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_VACUUM_PHASE</name></expr></argument>,
								 <argument><expr><name>PROGRESS_VACUUM_PHASE_TRUNCATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * We need access exclusive lock on the relation in order to do
	 * truncation. If we can't get it, give up rather than waiting --- we
	 * don't want to block other backends, and we don't want to deadlock
	 * (which is quite possible considering we already hold a lower-grade
	 * lock).
	 *
	 * The decisions for AccessExclusiveLock and conditional lock with
	 * a timeout is based on lazy_truncate_heap in vacuumlazy.c.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockRelationWithTimeout</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>,
											<argument><expr><name>VACUUM_TRUNCATE_LOCK_TIMEOUT</name></expr></argument>,
											<argument><expr><name>VACUUM_TRUNCATE_LOCK_WAIT_INTERVAL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We failed to establish the lock in the specified number of
		 * retries. This means we give up truncating.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": stopping truncate due to conflicting lock request"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Due to the AccessExclusive lock there's no danger that
	 * new stripes be added beyond highestPhysicalAddress while
	 * we're truncating.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>newDataReservation</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><call><name>GetHighestUsedAddress</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									<argument><expr><name>ColumnarFirstLogicalOffset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>old_rel_pages</name> <init>= <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ColumnarStorageTruncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>newDataReservation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>new_rel_pages</name> <init>= <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We can release the exclusive lock as soon as we have truncated.
	 * Other backends can't safely access the relation until they have
	 * processed the smgr invalidation that smgrtruncate sent out ... but
	 * that should happen as part of standard invalidation processing once
	 * they acquire lock on the relation.
	 */</comment>
	<expr_stmt><expr><call><name>UnlockRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\": truncated %u to %u pages"</literal></expr></argument>,
					<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><name>old_rel_pages</name></expr></argument>, <argument><expr><name>new_rel_pages</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ConditionalLockRelationWithTimeout tries to acquire a relation lock until
 * it either succeeds or timesout. It doesn't enter wait queue and instead it
 * sleeps between lock tries.
 *
 * This is based on the lock loop in lazy_truncate_heap().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ConditionalLockRelationWithTimeout</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockMode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>retryInterval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>lock_retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ConditionalLockRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>lockMode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check for interrupts while trying to (re-)acquire the lock
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>++</operator><name>lock_retry</name> <operator>&gt;</operator> <operator>(</operator><name>timeout</name> <operator>/</operator> <name>retryInterval</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>retryInterval</name> <operator>*</operator> <literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>columnar_scan_analyze_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>,
								 <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Our access method is not pages based, i.e. tuples are not confined
	 * to pages boundaries. So not much to do here. We return true anyway
	 * so acquire_sample_rows() in analyze.c would call our
	 * columnar_scan_analyze_next_tuple() callback.
	 */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>columnar_scan_analyze_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl></parameter>,
								 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>liverows</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>deadrows</name></decl></parameter>,
								 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Currently we don't do anything smart to reduce number of rows returned
	 * for ANALYZE. The TableAM API's ANALYZE functions are designed for page
	 * based access methods where it chooses random pages, and then reads
	 * tuples from those pages.
	 *
	 * We could do something like that here by choosing sample stripes or chunks,
	 * but getting that correct might need quite some work. Since columnar_fdw's
	 * ANALYZE scanned all rows, as a starter we do the same here and scan all
	 * rows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>columnar_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>liverows</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>double</name></type>
<name>columnar_index_build_range_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>columnarRelation</name></decl></parameter>,
								<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
								<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>allow_sync</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>anyvisible</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>,
								<parameter><decl><type><name>BlockNumber</name></type> <name>start_blockno</name></decl></parameter>,
								<parameter><decl><type><name>BlockNumber</name></type> <name>numblocks</name></decl></parameter>,
								<parameter><decl><type><name>IndexBuildCallback</name></type> <name>callback</name></decl></parameter>,
								<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>,
								<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>start_blockno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>numblocks</name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Columnar utility hook already errors out for BRIN indexes on columnar
		 * tables, but be on the safe side.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"BRIN indexes on columnar tables are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>scan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Parallel scans on columnar tables are already discardad by
		 * ColumnarGetRelationInfoHook but be on the safe side.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel scans on columnar are not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In a normal index build, we use SnapshotAny to retrieve all tuples. In
	 * a concurrent build or during bootstrap, we take a regular MVCC snapshot
	 * and index whatever's live according to that.
	 */</comment>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>OldestXmin</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ignore lazy VACUUM's */</comment>
		<expr_stmt><expr><name>OldestXmin</name> <operator>=</operator> <call><name>GetOldestNonRemovableTransactionId_compat</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>,
															   <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>snapshotRegisteredByUs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For serial index build, we begin our own scan. We may also need to
	 * register a snapshot whose lifetime is under our direct control.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snapshotRegisteredByUs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name>SnapshotAny</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>nkeys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scanKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>allowAccessStrategy</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_strat</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>,
								 <argument><expr><name>allowAccessStrategy</name></expr></argument>, <argument><expr><name>allow_sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ColumnarReportTotalVirtualBlocks</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
										 <argument><expr><name>PROGRESS_SCAN_BLOCKS_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Set up execution state for predicate, if any.
	 * Note that this is only useful for partial indexes.
	 */</comment>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>predicate</name> <init>= <expr><call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>reltuples</name> <init>= <expr><call><name>ColumnarReadRowsIntoIndex</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
												 <argument><expr><name>progress</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>callback_state</name></expr></argument>,
												 <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>predicate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>progress</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* report the last "virtual" block as "done" */</comment>
		<expr_stmt><expr><call><name>ColumnarReportTotalVirtualBlocks</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
										 <argument><expr><name>PROGRESS_SCAN_BLOCKS_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>snapshotRegisteredByUs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>reltuples</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarReportTotalVirtualBlocks reports progress for index build based on
 * number of "virtual" blocks that given relation has.
 * "progressArrIndex" argument determines which entry in st_progress_param
 * array should be updated. In this case, we only expect PROGRESS_SCAN_BLOCKS_TOTAL
 * or PROGRESS_SCAN_BLOCKS_DONE to specify whether we want to report calculated
 * number of blocks as "done" or as "total" number of "virtual" blocks to scan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarReportTotalVirtualBlocks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>progressArrIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Indeed, columnar tables might have gaps between row numbers, e.g
	 * due to aborted transactions etc. Also, ItemPointer BlockNumber's
	 * for columnar tables don't actually correspond to actual disk blocks
	 * as in heapAM. For this reason, we call them as "virtual" blocks. At
	 * the moment, we believe it is better to report our progress based on
	 * this "virtual" block concept instead of doing nothing.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>progressArrIndex</name> <operator>==</operator> <name>PROGRESS_SCAN_BLOCKS_TOTAL</name> <operator>||</operator>
		   <name>progressArrIndex</name> <operator>==</operator> <name>PROGRESS_SCAN_BLOCKS_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nvirtualBlocks</name> <init>=
		<expr><call><name>ColumnarGetNumberOfVirtualBlocks</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>progressArrIndex</name></expr></argument>, <argument><expr><name>nvirtualBlocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarGetNumberOfVirtualBlocks returns total number of "virtual" blocks
 * that given columnar table has based on based on ItemPointer BlockNumber's.
 */</comment>
<function><type><specifier>static</specifier> <name>BlockNumber</name></type>
<name>ColumnarGetNumberOfVirtualBlocks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>highestItemPointer</name> <init>=
		<expr><call><name>ColumnarGetHighestItemPointer</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>highestItemPointer</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* table is empty according to our snapshot */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since BlockNumber is 0-based, increment it by 1 to find the total
	 * number of "virtual" blocks.
	 */</comment>
	<return>return <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>highestItemPointer</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarGetHighestItemPointer returns ItemPointerData for the tuple with
 * highest tid for given relation.
 * If given relation is empty, then returns invalid item pointer.
 */</comment>
<function><type><specifier>static</specifier> <name>ItemPointerData</name></type>
<name>ColumnarGetHighestItemPointer</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeWithHighestRowNumber</name> <init>=
		<expr><call><name>FindStripeWithHighestRowNumber</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>stripeWithHighestRowNumber</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<call><name>StripeGetHighestRowNumber</name><argument_list>(<argument><expr><name>stripeWithHighestRowNumber</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* table is empty according to our snapshot */</comment>
		<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>invalidItemPtr</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>invalidItemPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>invalidItemPtr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>highestRowNumber</name> <init>= <expr><call><name>StripeGetHighestRowNumber</name><argument_list>(<argument><expr><name>stripeWithHighestRowNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>row_number_to_tid</name><argument_list>(<argument><expr><name>highestRowNumber</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarReadRowsIntoIndex builds indexRelation tuples by reading the
 * actual relation based on given "scan" and returns number of tuples
 * scanned to build the indexRelation.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>ColumnarReadRowsIntoIndex</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						  <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>progress</name></decl></parameter>,
						  <parameter><decl><type><name>IndexBuildCallback</name></type> <name>indexCallback</name></decl></parameter>,
						  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>indexCallbackState</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
						  <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>reltuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lastReportedBlockNumber</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>columnar_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>currentBlockNumber</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&amp;&amp;</operator> <name>lastReportedBlockNumber</name> <operator>!=</operator> <name>currentBlockNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * columnar_getnextslot guarantees that returned tuple will
			 * always have a greater ItemPointer than the ones we fetched
			 * before, so we directly use BlockNumber to report our progress.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lastReportedBlockNumber</name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator>
				   <name>currentBlockNumber</name> <operator>&gt;=</operator> <name>lastReportedBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_SCAN_BLOCKS_DONE</name></expr></argument>,
										 <argument><expr><name>currentBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastReportedBlockNumber</name> <operator>=</operator> <name>currentBlockNumber</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* for partial indexes, discard tuples that don't satisfy the predicate */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name><name>indexValues</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>indexNulls</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>indexValues</name></expr></argument>, <argument><expr><name>indexNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>itemPointerData</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* currently, columnar tables can't have dead tuples */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>tupleIsAlive</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>indexCallback</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>itemPointerData</name></expr></argument>, <argument><expr><name>indexValues</name></expr></argument>, <argument><expr><name>indexNulls</name></expr></argument>,
					  <argument><expr><name>tupleIsAlive</name></expr></argument>, <argument><expr><name>indexCallbackState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>reltuples</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>reltuples</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_index_validate_scan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>columnarRelation</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
							 <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
							 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
							 <parameter><decl><type><name>ValidateIndexState</name> <modifier>*</modifier></type>
							 <name>validateIndexState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ColumnarReportTotalVirtualBlocks</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
									 <argument><expr><name>PROGRESS_SCAN_BLOCKS_TOTAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up execution state for predicate, if any.
	 * Note that this is only useful for partial indexes.
	 */</comment>
	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>predicate</name> <init>= <expr><call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>nkeys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name> <modifier>*</modifier></type><name>scanKey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>allowAccessStrategy</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>allowSyncScan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name> <init>= <expr><call><name>table_beginscan_strat</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>scanKey</name></expr></argument>,
											   <argument><expr><name>allowAccessStrategy</name></expr></argument>, <argument><expr><name>allowSyncScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ColumnarReadMissingRowsIntoIndex</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
									 <argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>validateIndexState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* report the last "virtual" block as "done" */</comment>
	<expr_stmt><expr><call><name>ColumnarReportTotalVirtualBlocks</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>,
									 <argument><expr><name>PROGRESS_SCAN_BLOCKS_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarReadMissingRowsIntoIndex inserts the tuples that are not in
 * the index yet by reading the actual relation based on given "scan".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarReadMissingRowsIntoIndex</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
								 <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
								 <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>predicate</name></decl></parameter>,
								 <parameter><decl><type><name>ValidateIndexState</name> <modifier>*</modifier></type><name>validateIndexState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>lastReportedBlockNumber</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>indexTupleSortEmpty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>indexedItemPointerData</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexedItemPointerData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><call><name>columnar_getnextslot</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>columnarItemPointer</name> <init>= <expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>currentBlockNumber</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>columnarItemPointer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>lastReportedBlockNumber</name> <operator>!=</operator> <name>currentBlockNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * columnar_getnextslot guarantees that returned tuple will
			 * always have a greater ItemPointer than the ones we fetched
			 * before, so we directly use BlockNumber to report our progress.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lastReportedBlockNumber</name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator>
				   <name>currentBlockNumber</name> <operator>&gt;=</operator> <name>lastReportedBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_progress_update_param</name><argument_list>(<argument><expr><name>PROGRESS_SCAN_BLOCKS_DONE</name></expr></argument>,
										 <argument><expr><name>currentBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastReportedBlockNumber</name> <operator>=</operator> <name>currentBlockNumber</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>validateIndexState</name><operator>-&gt;</operator><name>htups</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>indexTupleSortEmpty</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>!</operator><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexedItemPointerData</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>ItemPointerCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexedItemPointerData</name></expr></argument>, <argument><expr><name>columnarItemPointer</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Skip indexed item pointers until we find or pass the current
			 * columnar relation item pointer.
			 */</comment>
			<expr_stmt><expr><name>indexedItemPointerData</name> <operator>=</operator>
				<call><name>TupleSortSkipSmallerItemPointers</name><argument_list>(<argument><expr><name><name>validateIndexState</name><operator>-&gt;</operator><name>tuplesort</name></name></expr></argument>,
												 <argument><expr><name>columnarItemPointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indexTupleSortEmpty</name> <operator>=</operator> <operator>!</operator><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexedItemPointerData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>indexTupleSortEmpty</name> <operator>&amp;&amp;</operator>
			<call><name>ItemPointerCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexedItemPointerData</name></expr></argument>, <argument><expr><name>columnarItemPointer</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* tuple is already covered by the index, skip */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indexTupleSortEmpty</name> <operator>||</operator>
			   <call><name>ItemPointerCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexedItemPointerData</name></expr></argument>, <argument><expr><name>columnarItemPointer</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* for partial indexes, discard tuples that don't satisfy the predicate */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name><name>indexValues</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>indexNulls</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>indexValues</name></expr></argument>, <argument><expr><name>indexNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Relation</name></type> <name>columnarRelation</name> <init>= <expr><name><name>scan</name><operator>-&gt;</operator><name>rs_rd</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexUniqueCheck</name></type> <name>indexUniqueCheck</name> <init>=
			<expr><ternary><condition><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr> ?</condition><then> <expr><name>UNIQUE_CHECK_YES</name></expr> </then><else>: <expr><name>UNIQUE_CHECK_NO</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>index_insert_compat</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>indexValues</name></expr></argument>, <argument><expr><name>indexNulls</name></expr></argument>, <argument><expr><name>columnarItemPointer</name></expr></argument>,
							<argument><expr><name>columnarRelation</name></expr></argument>, <argument><expr><name>indexUniqueCheck</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>validateIndexState</name><operator>-&gt;</operator><name>tups_inserted</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * TupleSortSkipSmallerItemPointers iterates given tupleSort until finding an
 * ItemPointer that is greater than or equal to given targetItemPointer and
 * returns that ItemPointer.
 * If such an ItemPointer does not exist, then returns invalid ItemPointer.
 *
 * Note that this function assumes given tupleSort doesn't have any NULL
 * Datum's.
 */</comment>
<function><type><specifier>static</specifier> <name>ItemPointerData</name></type>
<name>TupleSortSkipSmallerItemPointers</name><parameter_list>(<parameter><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>tupleSort</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>targetItemPointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tsItemPointerData</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsItemPointerData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>ItemPointerIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsItemPointerData</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>ItemPointerCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsItemPointerData</name></expr></argument>, <argument><expr><name>targetItemPointer</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>forwardDirection</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>abbrev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>tsDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>tsDatumIsNull</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name>tupleSort</name></expr></argument>, <argument><expr><name>forwardDirection</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsDatum</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>tsDatumIsNull</name></expr></argument>, <argument><expr><name>abbrev</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ItemPointerSetInvalid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsItemPointerData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>tsDatumIsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>itemptr_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsItemPointerData</name></expr></argument>, <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>tsDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_FLOAT8_BYVAL</name></cpp:ifndef>

		<comment type="block">/*
		 * If int8 is pass-by-ref, we need to free Datum memory.
		 * See tuplesort_getdatum function's comment.
		 */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>tsDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></while>

	<return>return <expr><name>tsItemPointerData</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>columnar_relation_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forkNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>nblocks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* InvalidForkNumber indicates returning the size for all forks */</comment>
	<if_stmt><if>if <condition>(<expr><name>forkNumber</name> <operator>==</operator> <name>InvalidForkNumber</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_FORKNUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>nblocks</name> <operator>+=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nblocks</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>forkNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>nblocks</name> <operator>*</operator> <name>BLCKSZ</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>columnar_relation_needs_toast_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>columnar_estimate_rel_size</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>attr_widths</name></decl></parameter>,
						   <parameter><decl><type><name>BlockNumber</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>tuples</name></decl></parameter>,
						   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>allvisfrac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>pages</name> <operator>=</operator> <call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>tuples</name> <operator>=</operator> <call><name>ColumnarTableRowCount</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Append-only, so everything is visible except in-progress or rolled-back
	 * transactions.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>allvisfrac</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>get_rel_data_width</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attr_widths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>columnar_scan_sample_next_block</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>SampleScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_scan_sample_next_block not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>columnar_scan_sample_next_tuple</name><parameter_list>(<parameter><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl></parameter>, <parameter><decl><type><name>SampleScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl></parameter>,
								<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"columnar_scan_sample_next_tuple not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarXactCallback</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>XACT_EVENT_COMMIT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PARALLEL_COMMIT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PREPARE</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XACT_EVENT_ABORT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PARALLEL_ABORT</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DiscardWriteStateForAllRels</name><argument_list>(<argument><expr><call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>XACT_EVENT_PRE_COMMIT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PARALLEL_PRE_COMMIT</name></expr>:</case>
		<case>case <expr><name>XACT_EVENT_PRE_PREPARE</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FlushWriteStateForAllRels</name><argument_list>(<argument><expr><call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarSubXactCallback</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
						<parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SUBXACT_EVENT_START_SUB</name></expr>:</case>
		<case>case <expr><name>SUBXACT_EVENT_COMMIT_SUB</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>SUBXACT_EVENT_ABORT_SUB</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DiscardWriteStateForAllRels</name><argument_list>(<argument><expr><name>mySubid</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>SUBXACT_EVENT_PRE_COMMIT_SUB</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FlushWriteStateForAllRels</name><argument_list>(<argument><expr><name>mySubid</name></expr></argument>, <argument><expr><name>parentSubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>columnar_tableam_init</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RegisterXactCallback</name><argument_list>(<argument><expr><name>ColumnarXactCallback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RegisterSubXactCallback</name><argument_list>(<argument><expr><name>ColumnarSubXactCallback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>PrevObjectAccessHook</name> <operator>=</operator> <name>object_access_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>object_access_hook</name> <operator>=</operator> <name>ColumnarTableAMObjectAccessHook</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>PrevProcessUtilityHook</name> <operator>=</operator> <ternary><condition><expr><name>ProcessUtility_hook</name></expr> ?</condition><then>
							 <expr><name>ProcessUtility_hook</name></expr> </then><else>:
							 <expr><name>standard_ProcessUtility</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>ProcessUtility_hook</name> <operator>=</operator> <name>ColumnarProcessUtility</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>columnar_customscan_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>TTSOpsColumnar</name> <operator>=</operator> <name>TTSOpsVirtual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>TTSOpsColumnar</name><operator>.</operator><name>copy_heap_tuple</name></name> <operator>=</operator> <name>ColumnarSlotCopyHeapTuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DefineCustomBoolVariable</name><argument_list>(
		<argument><expr><literal type="string">"columnar.enable_version_checks"</literal></expr></argument>,
		<argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables Version Check for Columnar"</literal></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>EnableVersionChecksColumnar</name></expr></argument>,
		<argument><expr><name>true</name></expr></argument>,
		<argument><expr><name>PGC_USERSET</name></expr></argument>,
		<argument><expr><name>GUC_NO_SHOW_ALL</name></expr></argument>,
		<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Get the number of chunks filtered out during the given scan.
 */</comment>
<function><type><name>int64</name></type>
<name>ColumnarScanChunkGroupsFiltered</name><parameter_list>(<parameter><decl><type><name>ColumnarScanDesc</name></type> <name>columnarScanDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name> <init>= <expr><name><name>columnarScanDesc</name><operator>-&gt;</operator><name>cs_readState</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* readState is initialized lazily */</comment>
	<if_stmt><if>if <condition>(<expr><name>readState</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>ColumnarReadChunkGroupsFiltered</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Implementation of TupleTableSlotOps.copy_heap_tuple for TTSOpsColumnar.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>ColumnarSlotCopyHeapTuple</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>TTS_EMPTY</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name> <init>= <expr><call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
									  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>,
									  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* slot-&gt;tts_tid is filled in columnar_getnextslot */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_tid</name></name></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarTableDropHook
 *
 * Clean-up resources for columnar tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarTableDropHook</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Lock relation to prevent it from being dropped and to avoid
	 * race conditions in the next if block.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsColumnarTableAmTable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Drop metadata. No need to drop storage here since for
		 * tableam tables storage is managed by postgres.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelFileNode</name></type> <name>relfilenode</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>DeleteMetadataRows</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DeleteColumnarTableOptions</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MarkRelfilenodeDropped</name><argument_list>(<argument><expr><name><name>relfilenode</name><operator>.</operator><name>relNode</name></name></expr></argument>, <argument><expr><call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* keep the lock since we did physical changes to the relation */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Reject AFTER ... FOR EACH ROW triggers on columnar tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarTriggerCreateHook</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tgid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Fetch the pg_trigger tuple by the Oid of the trigger
	 */</comment>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>tgrel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_trigger_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tgid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>tgscan</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>TriggerOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											<argument><expr><name>SnapshotSelf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tgtup</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tgtup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Form_pg_trigger</name></type> <name>tgrec</name> <init>= <expr><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tgtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>tgrelid</name> <init>= <expr><name><name>tgrec</name><operator>-&gt;</operator><name>tgrelid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>tgtype</name> <init>= <expr><name><name>tgrec</name><operator>-&gt;</operator><name>tgtype</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>tgscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tgrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_ROW</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TRIGGER_FOR_AFTER</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsColumnarTableAmTable</name><argument_list>(<argument><expr><name>tgrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"Foreign keys and AFTER ROW triggers are not supported for columnar tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider an AFTER STATEMENT trigger instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Capture create/drop events and dispatch to the proper action.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarTableAMObjectAccessHook</name><parameter_list>(<parameter><decl><type><name>ObjectAccessType</name></type> <name>access</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>subId</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>PrevObjectAccessHook</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PrevObjectAccessHook</name><argument_list>(<argument><expr><name>access</name></expr></argument>, <argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><name>subId</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* dispatch to the proper action */</comment>
	<if_stmt><if>if <condition>(<expr><name>access</name> <operator>==</operator> <name>OAT_DROP</name> <operator>&amp;&amp;</operator> <name>classId</name> <operator>==</operator> <name>RelationRelationId</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>subId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ColumnarTableDropHook</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>access</name> <operator>==</operator> <name>OAT_POST_CREATE</name> <operator>&amp;&amp;</operator> <name>classId</name> <operator>==</operator> <name>TriggerRelationId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ColumnarTriggerCreateHook</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarProcessAlterTable - if modifying a columnar table, extract columnar
 * options and return the table's RangeVar.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeVar</name> <modifier>*</modifier></type>
<name>ColumnarProcessAlterTable</name><parameter_list>(<parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStmt</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnarOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>columnarRangeVar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_openrv_extended</name><argument_list>(<argument><expr><name><name>alterTableStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>,
											<argument><expr><name><name>alterTableStmt</name><operator>-&gt;</operator><name>missing_ok</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* track separately in case of ALTER TABLE ... SET ACCESS METHOD */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>srcIsColumnar</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_tableam</name></name> <operator>==</operator> <call><name>GetColumnarTableAmRoutine</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>destIsColumnar</name> <init>= <expr><name>srcIsColumnar</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>alterTableStmt-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>alterTableCmd</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>alterTableCmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_SetRelOptions</name> <operator>||</operator>
			<name><name>alterTableCmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_ResetRelOptions</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>alterTableCmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>alterTableCmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>ExtractColumnarRelOptions</name><argument_list>(
				<argument><expr><name>options</name></expr></argument>, <argument><expr><name>columnarOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>destIsColumnar</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>columnarRangeVar</name> <operator>=</operator> <name><name>alterTableStmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
		<if type="elseif">else if <condition>(<expr><name><name>alterTableCmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>==</operator> <name>AT_SetAccessMethod</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>columnarRangeVar</name> <operator>||</operator> <operator>*</operator><name>columnarOptions</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(
									<argument><expr><literal type="string">"ALTER TABLE cannot alter the access method after altering storage parameters"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errhint</name><argument_list>(
									<argument><expr><literal type="string">"Specify SET ACCESS METHOD before storage parameters, or use separate ALTER TABLE commands."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>destIsColumnar</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>alterTableCmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>COLUMNAR_AM_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>srcIsColumnar</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>destIsColumnar</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DeleteColumnarTableOptions</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PG_VERSION_15 */</comment>
	</block_content>}</block>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>columnarRangeVar</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Utility hook for columnar tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarProcessUtility</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
					   <parameter><decl><type><name>bool</name></type> <name>readOnlyTree</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					   <parameter><decl><type><name>ProcessUtilityContext</name></type> <name>context</name></decl></parameter>,
					   <parameter><decl><type><name>ParamListInfo</name></type> <name>params</name></decl></parameter>,
					   <parameter><decl><type><name><name>struct</name> <name>QueryEnvironment</name></name> <modifier>*</modifier></type><name>queryEnv</name></decl></parameter>,
					   <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
					   <parameter><decl><type><name>QueryCompletion</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>readOnlyTree</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name> <init>= <expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>columnarRangeVar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>columnarOptions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>indexStmt</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_openrv</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>concurrent</name></name></expr> ?</condition><then>
										   <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>:
										   <expr><name>ShareLock</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_tableam</name></name> <operator>==</operator> <call><name>GetColumnarTableAmRoutine</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CheckCitusColumnarVersion</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ColumnarSupportsIndexAM</name><argument_list>(<argument><expr><name><name>indexStmt</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported access method for the "</literal>
										   <literal type="string">"index on columnar table %s"</literal></expr></argument>,
										   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>createStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>no_op</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>createStmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>existing_relid</name></decl>;</decl_stmt>

				<comment type="block">/* use same check as transformCreateStmt */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(
					<argument><expr><name><name>createStmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>existing_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>no_op</name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>existing_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>no_op</name> <operator>&amp;&amp;</operator> <name><name>createStmt</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>createStmt</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>, <argument><expr><name>COLUMNAR_AM_NAME</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>columnarRangeVar</name> <operator>=</operator> <name><name>createStmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>createStmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>ExtractColumnarRelOptions</name><argument_list>(<argument><expr><name><name>createStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
																<argument><expr><operator>&amp;</operator><name>columnarOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>createTableAsStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateTableAsStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IntoClause</name> <modifier>*</modifier></type><name>into</name> <init>= <expr><name><name>createTableAsStmt</name><operator>-&gt;</operator><name>into</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>no_op</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>createTableAsStmt</name><operator>-&gt;</operator><name>if_not_exists</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type> <name>existing_relid</name></decl>;</decl_stmt>

				<comment type="block">/* use same check as transformCreateStmt */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(
					<argument><expr><name><name>into</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>existing_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>no_op</name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>existing_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>no_op</name> <operator>&amp;&amp;</operator> <name><name>into</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>, <argument><expr><name>COLUMNAR_AM_NAME</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>columnarRangeVar</name> <operator>=</operator> <name><name>into</name><operator>-&gt;</operator><name>rel</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>into</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>ExtractColumnarRelOptions</name><argument_list>(<argument><expr><name><name>into</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>columnarOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterTableStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>columnarRangeVar</name> <operator>=</operator> <call><name>ColumnarProcessAlterTable</name><argument_list>(<argument><expr><name>alterTableStmt</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>columnarOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>

			<comment type="block">/* FALL THROUGH */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>columnarOptions</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>columnarRangeVar</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar storage parameters specified on non-columnar table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>CreateExtensionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CheckCitusColumnarCreateExtensionStmt</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>AlterExtensionStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CheckCitusColumnarAlterExtensionStmt</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PrevProcessUtilityHook_compat</name><argument_list>(<argument><expr><name>pstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
								  <argument><expr><name>params</name></expr></argument>, <argument><expr><name>queryEnv</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>completionTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>columnarOptions</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetColumnarRelOptions</name><argument_list>(<argument><expr><name>columnarRangeVar</name></expr></argument>, <argument><expr><name>columnarOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarSupportsIndexAM returns true if indexAM with given name is
 * supported by columnar tables.
 */</comment>
<function><type><name>bool</name></type>
<name>ColumnarSupportsIndexAM</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>indexAMName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>indexAMName</name></expr></argument>, <argument><expr><literal type="string">"btree"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		   <call><name>strncmp</name><argument_list>(<argument><expr><name>indexAMName</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsColumnarTableAmTable returns true if relation has columnar_tableam
 * access method. This can be called before extension creation.
 */</comment>
<function><type><name>bool</name></type>
<name>IsColumnarTableAmTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Lock relation to prevent it from being dropped &amp;
	 * avoid race conditions.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_tableam</name></name> <operator>==</operator> <call><name>GetColumnarTableAmRoutine</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckCitusColumnarCreateExtensionStmt determines whether can install
 * citus_columnar per given CREATE extension statment
 */</comment>
<function><type><name>void</name></type>
<name>CheckCitusColumnarCreateExtensionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>createExtensionStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CreateExtensionStmt</name></expr></argument>,
														<argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>newVersionValue</name> <init>= <expr><call><name>GetExtensionOption</name><argument_list>(
				<argument><expr><name><name>createExtensionStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
				<argument><expr><literal type="string">"new_version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*we are not allowed to install citus_columnar as version 11.1-0 by cx*/</comment>
			<if_stmt><if>if <condition>(<expr><name>newVersionValue</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newVersion</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>newVersionValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>newVersion</name></expr></argument>, <argument><expr><name>CITUS_COLUMNAR_INTERNAL_VERSION</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
									<call><name>errmsg</name><argument_list>(
										<argument><expr><literal type="string">"unsupported citus_columnar version 11.1-0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CheckCitusColumnarAlterExtensionStmt determines whether can alter
 * citus_columnar per given ALTER extension statment
 */</comment>
<function><type><name>void</name></type>
<name>CheckCitusColumnarAlterExtensionStmt</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AlterExtensionStmt</name> <modifier>*</modifier></type><name>alterExtensionStmt</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>AlterExtensionStmt</name></expr></argument>, <argument><expr><name>parseTree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>alterExtensionStmt</name><operator>-&gt;</operator><name>extname</name></name></expr></argument>, <argument><expr><literal type="string">"citus_columnar"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>newVersionValue</name> <init>= <expr><call><name>GetExtensionOption</name><argument_list>(<argument><expr><name><name>alterExtensionStmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>,
													  <argument><expr><literal type="string">"new_version"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*we are not allowed cx to downgrade citus_columnar to 11.1-0*/</comment>
		<if_stmt><if>if <condition>(<expr><name>newVersionValue</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newVersion</name> <init>= <expr><call><name>defGetString</name><argument_list>(<argument><expr><name>newVersionValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>newVersion</name></expr></argument>, <argument><expr><name>CITUS_COLUMNAR_INTERNAL_VERSION</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported citus_columnar version 11.1-0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TableAmRoutine</name></type> <name>columnar_am_methods</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>T_TableAmRoutine</name></expr>,

	<expr><operator>.</operator><name>slot_callbacks</name> <operator>=</operator> <name>columnar_slot_callbacks</name></expr>,

	<expr><operator>.</operator><name>scan_begin</name> <operator>=</operator> <name>columnar_beginscan</name></expr>,
	<expr><operator>.</operator><name>scan_end</name> <operator>=</operator> <name>columnar_endscan</name></expr>,
	<expr><operator>.</operator><name>scan_rescan</name> <operator>=</operator> <name>columnar_rescan</name></expr>,
	<expr><operator>.</operator><name>scan_getnextslot</name> <operator>=</operator> <name>columnar_getnextslot</name></expr>,

	<expr><operator>.</operator><name>parallelscan_estimate</name> <operator>=</operator> <name>columnar_parallelscan_estimate</name></expr>,
	<expr><operator>.</operator><name>parallelscan_initialize</name> <operator>=</operator> <name>columnar_parallelscan_initialize</name></expr>,
	<expr><operator>.</operator><name>parallelscan_reinitialize</name> <operator>=</operator> <name>columnar_parallelscan_reinitialize</name></expr>,

	<expr><operator>.</operator><name>index_fetch_begin</name> <operator>=</operator> <name>columnar_index_fetch_begin</name></expr>,
	<expr><operator>.</operator><name>index_fetch_reset</name> <operator>=</operator> <name>columnar_index_fetch_reset</name></expr>,
	<expr><operator>.</operator><name>index_fetch_end</name> <operator>=</operator> <name>columnar_index_fetch_end</name></expr>,
	<expr><operator>.</operator><name>index_fetch_tuple</name> <operator>=</operator> <name>columnar_index_fetch_tuple</name></expr>,

	<expr><operator>.</operator><name>tuple_fetch_row_version</name> <operator>=</operator> <name>columnar_fetch_row_version</name></expr>,
	<expr><operator>.</operator><name>tuple_get_latest_tid</name> <operator>=</operator> <name>columnar_get_latest_tid</name></expr>,
	<expr><operator>.</operator><name>tuple_tid_valid</name> <operator>=</operator> <name>columnar_tuple_tid_valid</name></expr>,
	<expr><operator>.</operator><name>tuple_satisfies_snapshot</name> <operator>=</operator> <name>columnar_tuple_satisfies_snapshot</name></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_14</name></expr></cpp:if>
	<expr><operator>.</operator><name>index_delete_tuples</name> <operator>=</operator> <name>columnar_index_delete_tuples</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr><operator>.</operator><name>compute_xid_horizon_for_tuples</name> <operator>=</operator> <name>columnar_compute_xid_horizon_for_tuples</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><operator>.</operator><name>tuple_insert</name> <operator>=</operator> <name>columnar_tuple_insert</name></expr>,
	<expr><operator>.</operator><name>tuple_insert_speculative</name> <operator>=</operator> <name>columnar_tuple_insert_speculative</name></expr>,
	<expr><operator>.</operator><name>tuple_complete_speculative</name> <operator>=</operator> <name>columnar_tuple_complete_speculative</name></expr>,
	<expr><operator>.</operator><name>multi_insert</name> <operator>=</operator> <name>columnar_multi_insert</name></expr>,
	<expr><operator>.</operator><name>tuple_delete</name> <operator>=</operator> <name>columnar_tuple_delete</name></expr>,
	<expr><operator>.</operator><name>tuple_update</name> <operator>=</operator> <name>columnar_tuple_update</name></expr>,
	<expr><operator>.</operator><name>tuple_lock</name> <operator>=</operator> <name>columnar_tuple_lock</name></expr>,
	<expr><operator>.</operator><name>finish_bulk_insert</name> <operator>=</operator> <name>columnar_finish_bulk_insert</name></expr>,

	<expr><operator>.</operator><name>relation_set_new_filenode</name> <operator>=</operator> <name>columnar_relation_set_new_filenode</name></expr>,
	<expr><operator>.</operator><name>relation_nontransactional_truncate</name> <operator>=</operator> <name>columnar_relation_nontransactional_truncate</name></expr>,
	<expr><operator>.</operator><name>relation_copy_data</name> <operator>=</operator> <name>columnar_relation_copy_data</name></expr>,
	<expr><operator>.</operator><name>relation_copy_for_cluster</name> <operator>=</operator> <name>columnar_relation_copy_for_cluster</name></expr>,
	<expr><operator>.</operator><name>relation_vacuum</name> <operator>=</operator> <name>columnar_vacuum_rel</name></expr>,
	<expr><operator>.</operator><name>scan_analyze_next_block</name> <operator>=</operator> <name>columnar_scan_analyze_next_block</name></expr>,
	<expr><operator>.</operator><name>scan_analyze_next_tuple</name> <operator>=</operator> <name>columnar_scan_analyze_next_tuple</name></expr>,
	<expr><operator>.</operator><name>index_build_range_scan</name> <operator>=</operator> <name>columnar_index_build_range_scan</name></expr>,
	<expr><operator>.</operator><name>index_validate_scan</name> <operator>=</operator> <name>columnar_index_validate_scan</name></expr>,

	<expr><operator>.</operator><name>relation_size</name> <operator>=</operator> <name>columnar_relation_size</name></expr>,
	<expr><operator>.</operator><name>relation_needs_toast_table</name> <operator>=</operator> <name>columnar_relation_needs_toast_table</name></expr>,

	<expr><operator>.</operator><name>relation_estimate_size</name> <operator>=</operator> <name>columnar_estimate_rel_size</name></expr>,

	<expr><operator>.</operator><name>scan_bitmap_next_block</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>scan_bitmap_next_tuple</name> <operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>scan_sample_next_block</name> <operator>=</operator> <name>columnar_scan_sample_next_block</name></expr>,
	<expr><operator>.</operator><name>scan_sample_next_tuple</name> <operator>=</operator> <name>columnar_scan_sample_next_tuple</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>const</specifier> <name>TableAmRoutine</name> <modifier>*</modifier></type>
<name>GetColumnarTableAmRoutine</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>columnar_am_methods</name></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>columnar_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>columnar_handler</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><operator>&amp;</operator><name>columnar_am_methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * detoast_values
 *
 * Detoast and decompress all values. If there's no work to do, return
 * original pointer; otherwise return a newly-allocated values array. Should
 * be called in per-tuple context.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name> <modifier>*</modifier></type>
<name>detoast_values</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>orig_values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* copy on write to optimize for case where nothing is toasted */</comment>
	<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name> <init>= <expr><name>orig_values</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<call><name>VARATT_IS_EXTENDED</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* make a copy */</comment>
			<if_stmt><if>if <condition>(<expr><name>values</name> <operator>==</operator> <name>orig_values</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We use IGNORE-BANNED here since we don't want to limit
				 * size of the buffer that holds the datum array to RSIZE_MAX
				 * unnecessarily.
				 */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>orig_values</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IGNORE-BANNED */</comment>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* will be freed when per-tuple context is reset */</comment>
			<decl_stmt><decl><type><name><name>struct</name> <name>varlena</name></name> <modifier>*</modifier></type><name>new_value</name> <init>= <expr><operator>(</operator>struct <name>varlena</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>detoast_attr</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>values</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarCheckLogicalReplication throws an error if the relation is
 * part of any publication. This should be called before any write to
 * a columnar table, because columnar changes are not replicated with
 * logical replication (similar to a row table without a replica
 * identity).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarCheckLogicalReplication</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>pubActionInsert</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_publishable_relation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <name>PG_VERSION_15</name></expr></cpp:if>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PublicationDesc</name></type> <name>pubdesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RelationBuildPublicationDesc</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pubdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pubActionInsert</name> <operator>=</operator> <name><name>pubdesc</name><operator>.</operator><name>pubactions</name><operator>.</operator><name>pubinsert</name></name></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pubactions</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GetRelationPublicationActions</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_pubactions</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>pubActionInsert</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_pubactions</name><operator>-&gt;</operator><name>pubinsert</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>pubActionInsert</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"cannot insert into columnar table that is a part of a publication"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * alter_columnar_table_set()
 *
 * Deprecated in 11.1-1: should issue ALTER TABLE ... SET instead. Function
 * still available, but implemented in PL/pgSQL instead of C.
 *
 * C code is removed -- the symbol may still be required in some
 * upgrade/downgrade paths, but it should not be called.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>alter_columnar_table_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>alter_columnar_table_set</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"alter_columnar_table_set is deprecated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * alter_columnar_table_reset()
 *
 * Deprecated in 11.1-1: should issue ALTER TABLE ... RESET instead. Function
 * still available, but implemented in PL/pgSQL instead of C.
 *
 * C code is removed -- the symbol may still be required in some
 * upgrade/downgrade paths, but it should not be called.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>alter_columnar_table_reset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>alter_columnar_table_reset</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"alter_columnar_table_reset is deprecated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * upgrade_columnar_storage - upgrade columnar storage to the current
 * version.
 *
 * DDL:
 *   CREATE OR REPLACE FUNCTION upgrade_columnar_storage(rel regclass)
 *     RETURNS VOID
 *     STRICT
 *     LANGUAGE c AS 'MODULE_PATHNAME', 'upgrade_columnar_storage';
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>upgrade_columnar_storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>upgrade_columnar_storage</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * ACCESS EXCLUSIVE LOCK is not required by the low-level routines, so we
	 * can take only an ACCESS SHARE LOCK. But all access to non-current
	 * columnar tables will fail anyway, so it's better to take ACCESS
	 * EXCLUSIVE LOCK now.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsColumnarTableAmTable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table %s is not a columnar table"</literal></expr></argument>,
							   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ColumnarStorageUpdateIfNeeded</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * downgrade_columnar_storage - downgrade columnar storage to the
 * current version.
 *
 * DDL:
 *   CREATE OR REPLACE FUNCTION downgrade_columnar_storage(rel regclass)
 *     RETURNS VOID
 *     STRICT
 *     LANGUAGE c AS 'MODULE_PATHNAME', 'downgrade_columnar_storage';
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>downgrade_columnar_storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type>
<name>downgrade_columnar_storage</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * ACCESS EXCLUSIVE LOCK is not required by the low-level routines, so we
	 * can take only an ACCESS SHARE LOCK. But all access to non-current
	 * columnar tables will fail anyway, so it's better to take ACCESS
	 * EXCLUSIVE LOCK now.
	 */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsColumnarTableAmTable</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table %s is not a columnar table"</literal></expr></argument>,
							   <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ColumnarStorageUpdateIfNeeded</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Code to check the Citus Version, helps remove dependency from Citus
 */</comment>

<comment type="block">/*
 * CitusColumnarHasBeenLoaded returns true if the citus extension has been created
 * in the current database and the extension script has been executed. Otherwise,
 * it returns false. The result is cached as this is called very frequently.
 */</comment>
<function><type><name>bool</name></type>
<name>CitusColumnarHasBeenLoaded</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extensionLoadedColumnar</name> <operator>||</operator> <name>creating_extension</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Refresh if we have not determined whether the extension has been
		 * loaded yet, or in case of ALTER EXTENSION since we want to treat
		 * Citus as "not loaded" during ALTER EXTENSION citus.
		 */</comment>
		<decl_stmt><decl><type><name>bool</name></type> <name>extensionLoaded</name> <init>= <expr><call><name>CitusColumnarHasBeenLoadedInternal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>extensionLoadedColumnar</name> <operator>=</operator> <name>extensionLoaded</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>extensionLoadedColumnar</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CitusColumnarHasBeenLoadedInternal returns true if the citus extension has been created
 * in the current database and the extension script has been executed. Otherwise,
 * it returns false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CitusColumnarHasBeenLoadedInternal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* never use Citus logic during pg_upgrade */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>citusExtensionOid</name> <init>= <expr><call><name>get_extension_oid</name><argument_list>(<argument><expr><literal type="string">"citus"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>citusExtensionOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Citus extension does not exist yet */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>creating_extension</name> <operator>&amp;&amp;</operator> <name>CurrentExtensionObject</name> <operator>==</operator> <name>citusExtensionOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We do not use Citus hooks during CREATE/ALTER EXTENSION citus
		 * since the objects used by the C code might be not be there yet.
		 */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* citus extension exists and has been created */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckCitusColumnarVersion checks whether there is a version mismatch between the
 * available version and the loaded version or between the installed version
 * and the loaded version. Returns true if compatible, false otherwise.
 *
 * As a side effect, this function also sets citusVersionKnownCompatible_Columnar global
 * variable to true which reduces version check cost of next calls.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckCitusColumnarVersion</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>citusVersionKnownCompatibleColumnar</name> <operator>||</operator>
		<operator>!</operator><call><name>CitusColumnarHasBeenLoaded</name><argument_list>()</argument_list></call> <operator>||</operator>
		<operator>!</operator><name>EnableVersionChecksColumnar</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CheckAvailableVersionColumnar</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CheckInstalledVersionColumnar</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>citusVersionKnownCompatibleColumnar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CheckAvailableVersion compares CITUS_EXTENSIONVERSION and the currently
 * available version from the citus.control file. If they are not compatible,
 * this function logs an error with the specified elevel and returns false,
 * otherwise it returns true.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckAvailableVersionColumnar</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EnableVersionChecksColumnar</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>availableVersion</name> <init>= <expr><call><name>AvailableExtensionVersionColumnar</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MajorVersionsCompatibleColumnar</name><argument_list>(<argument><expr><name>availableVersion</name></expr></argument>, <argument><expr><name>CITUS_EXTENSIONVERSION</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"loaded Citus library version differs from latest "</literal>
								<literal type="string">"available extension version"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Loaded library requires %s, but the latest control "</literal>
								   <literal type="string">"file specifies %s."</literal></expr></argument>, <argument><expr><name>CITUS_MAJORVERSION</name></expr></argument>,
								   <argument><expr><name>availableVersion</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Restart the database to load the latest Citus "</literal>
								 <literal type="string">"library."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>availableVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>availableVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CheckInstalledVersion compares CITUS_EXTENSIONVERSION and the
 * extension's current version from the pg_extension catalog table. If they
 * are not compatible, this function logs an error with the specified elevel,
 * otherwise it returns true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CheckInstalledVersionColumnar</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CitusColumnarHasBeenLoaded</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>EnableVersionChecksColumnar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>installedVersion</name> <init>= <expr><call><name>InstalledExtensionVersionColumnar</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MajorVersionsCompatibleColumnar</name><argument_list>(<argument><expr><name>installedVersion</name></expr></argument>, <argument><expr><name>CITUS_EXTENSIONVERSION</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"loaded Citus library version differs from installed "</literal>
								<literal type="string">"extension version"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Loaded library requires %s, but the installed "</literal>
								   <literal type="string">"extension version is %s."</literal></expr></argument>, <argument><expr><name>CITUS_MAJORVERSION</name></expr></argument>,
								   <argument><expr><name>installedVersion</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Run ALTER EXTENSION citus UPDATE and try again."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>installedVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>installedVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MajorVersionsCompatible checks whether both versions are compatible. They
 * are if major and minor version numbers match, the schema version is
 * ignored.  Returns true if compatible, false otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>MajorVersionsCompatibleColumnar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>leftVersion</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rightVersion</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>schemaVersionSeparator</name> <init>= <expr><literal type="char">'-'</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>leftSeperatorPosition</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>leftVersion</name></expr></argument>, <argument><expr><name>schemaVersionSeparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rightSeperatorPosition</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>rightVersion</name></expr></argument>, <argument><expr><name>schemaVersionSeparator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>leftComparisionLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rightComparisionLimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>leftSeperatorPosition</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>leftComparisionLimit</name> <operator>=</operator> <name>leftSeperatorPosition</name> <operator>-</operator> <name>leftVersion</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>leftComparisionLimit</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>leftVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rightSeperatorPosition</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rightComparisionLimit</name> <operator>=</operator> <name>rightSeperatorPosition</name> <operator>-</operator> <name>rightVersion</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rightComparisionLimit</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>leftVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* we can error out early if hypens are not in the same position */</comment>
	<if_stmt><if>if <condition>(<expr><name>leftComparisionLimit</name> <operator>!=</operator> <name>rightComparisionLimit</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>leftVersion</name></expr></argument>, <argument><expr><name>rightVersion</name></expr></argument>, <argument><expr><name>leftComparisionLimit</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AvailableExtensionVersion returns the Citus version from citus.control file. It also
 * saves the result, thus consecutive calls to CitusExtensionAvailableVersion will
 * not read the citus.control file again.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AvailableExtensionVersionColumnar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LOCAL_FCINFO</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type> <name>flinfo</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>goForward</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>doCopy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>availableExtensionVersion</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>extensionsResultSet</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>extensionsResultSet</name><operator>-&gt;</operator><name>econtext</name></name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>extensionsResultSet</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>F_PG_AVAILABLE_EXTENSIONS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>extensionsResultSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pg_available_extensions returns result set containing all available extensions */</comment>
	<expr_stmt><expr><call>(<modifier>*</modifier><name>pg_available_extensions</name>)<argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleTableSlot</name> <init>= <expr><call><name>MakeSingleTupleTableSlot</name><argument_list>(
		<argument><expr><name><name>extensionsResultSet</name><operator>-&gt;</operator><name>setDesc</name></name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>TTSOpsMinimalTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>hasTuple</name> <init>= <expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>extensionsResultSet</name><operator>-&gt;</operator><name>setResult</name></name></expr></argument>, <argument><expr><name>goForward</name></expr></argument>,
											<argument><expr><name>doCopy</name></expr></argument>,
											<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>hasTuple</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>extensionNameDatum</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>extensionName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><name>extensionNameDatum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>extensionName</name></expr></argument>, <argument><expr><literal type="string">"citus"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type> <name>availableVersion</name> <init>= <expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


			<expr_stmt><expr><name>availableExtensionVersion</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>availableVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


			<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>availableExtensionVersion</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasTuple</name> <operator>=</operator> <call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>extensionsResultSet</name><operator>-&gt;</operator><name>setResult</name></name></expr></argument>, <argument><expr><name>goForward</name></expr></argument>,
										   <argument><expr><name>doCopy</name></expr></argument>, <argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupleTableSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus extension is not found"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InstalledExtensionVersion returns the Citus version in PostgreSQL pg_extension table.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>InstalledExtensionVersionColumnar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>entry</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>installedExtensionVersion</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ExtensionRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_extension_extname</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><literal type="string">"citus"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scandesc</name> <init>= <expr><call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>ExtensionNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>extensionTuple</name> <init>= <expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We assume that there can be at most one matching tuple */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>extensionTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>extensionIndex</name> <init>= <expr><name>Anum_pg_extension_extversion</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name>installedVersion</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>extensionTuple</name></expr></argument>, <argument><expr><name>extensionIndex</name></expr></argument>,
											  <argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus extension version is null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>


		<expr_stmt><expr><name>installedExtensionVersion</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>installedVersion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"citus extension is not loaded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scandesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>installedExtensionVersion</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetExtensionOption returns DefElem * node with "defname" from "options" list
 */</comment>
<function><type><name>DefElem</name> <modifier>*</modifier></type>
<name>GetExtensionOption</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>extensionOptions</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>defname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DefElem</name> <modifier>*</modifier></type><name>defElement</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach_ptr</name><argument_list>(<argument>defElement</argument>, <argument>extensionOptions</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>defElement</name></expr></argument>, <argument><expr><name>DefElem</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><name><name>defElement</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><name>defname</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>defElement</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
