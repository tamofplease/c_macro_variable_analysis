<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/citus/src/backend/columnar/columnar_storage.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * columnar_storage.c
 *
 * Copyright (c) Citus Data, Inc.
 *
 * Low-level storage layer for columnar.
 *   - Translates columnar read/write operations on logical offsets into operations on pages/blocks.
 *   - Emits WAL.
 *   - Reads/writes the columnar metapage.
 *   - Reserves data offsets, stripe numbers, and row offsets.
 *   - Truncation.
 *
 * Higher-level columnar operations deal with logical offsets and large
 * contiguous buffers of data that need to be stored. But the buffer manager
 * and WAL depend on formatted pages with headers, so these large buffers need
 * to be written across many pages. This module translates the contiguous
 * buffers into individual block reads/writes, and performs WAL when
 * necessary.
 *
 * Storage layout: a metapage in block 0, followed by an empty page in block
 * 1, followed by logical data starting at the first byte after the page
 * header in block 2 (having logical offset ColumnarFirstLogicalOffset). (XXX:
 * Block 1 is left empty for no particular reason. Reconsider?). A columnar
 * table should always have at least 2 blocks.
 *
 * Reservation is done with a relation extension lock, and designed for
 * concurrency, so the callers only need an ordinary lock on the
 * relation. Initializing the metapage or truncating the relation require that
 * the caller holds an AccessExclusiveLock. (XXX: New reservations of data are
 * aligned onto a new page for no particular reason. Reconsider?).
 *
 *-------------------------------------------------------------------------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_lib.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/generic_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pg_version_compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_storage.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Content of the first page in main fork, which stores metadata at file
 * level.
 */</comment>
<typedef>typedef <type><struct>struct <name>ColumnarMetapage</name>
<block>{
	<comment type="block">/*
	 * Store version of file format used, so we can detect files from
	 * previous versions if we change file format.
	 */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>versionMajor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>versionMinor</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Each of the metadata table rows are identified by a storageId.
	 * We store it also in the main fork so we can link metadata rows
	 * with data files.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>storageId</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>reservedStripeId</name></decl>;</decl_stmt> <comment type="block">/* first unused stripe id */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>reservedRowNumber</name></decl>;</decl_stmt> <comment type="block">/* first unused row number */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>reservedOffset</name></decl>;</decl_stmt> <comment type="block">/* first unused byte offset */</comment>

	<comment type="block">/*
	 * Flag set to true in the init fork. After an unlogged table reset (due
	 * to a crash), the init fork will be copied over the main fork. When
	 * trying to read an unlogged table, if this flag is set to true, we must
	 * clear the metadata for the table (because the actual data is gone,
	 * too), and clear the flag. We can cross-check that the table is
	 * UNLOGGED, and that the main fork is at the minimum size (no actual
	 * data).
	 *
	 * XXX: Not used yet; reserved field for later support for UNLOGGED.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>unloggedReset</name></decl>;</decl_stmt>
}</block></struct></type> <name>ColumnarMetapage</name>;</typedef>


<comment type="block">/* represents a "physical" block+offset address */</comment>
<typedef>typedef <type><struct>struct <name>PhysicalAddr</name>
<block>{
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>offset</name></decl>;</decl_stmt>
}</block></struct></type> <name>PhysicalAddr</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLUMNAR_METAPAGE_BLOCKNO</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLUMNAR_EMPTY_BLOCKNO</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLUMNAR_INVALID_STRIPE_ID</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLUMNAR_FIRST_STRIPE_ID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OLD_METAPAGE_VERSION_HINT</name></cpp:macro> <cpp:value>"Use \"VACUUM\" to upgrade the columnar table format " \
								  "version or run \"ALTER EXTENSION citus UPDATE\"."</cpp:value></cpp:define>


<comment type="block">/* only for testing purposes */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>test_columnar_storage_write_new_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
 * Map logical offsets to a physical page and offset where the data is kept.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>PhysicalAddr</name></type>
<name>LogicalToPhysical</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>logicalOffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PhysicalAddr</name></type> <name>addr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>addr</name><operator>.</operator><name>blockno</name></name> <operator>=</operator> <name>logicalOffset</name> <operator>/</operator> <name>COLUMNAR_BYTES_PER_PAGE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>addr</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>SizeOfPageHeaderData</name> <operator>+</operator> <operator>(</operator><name>logicalOffset</name> <operator>%</operator> <name>COLUMNAR_BYTES_PER_PAGE</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>addr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Map a physical page and offset address to a logical address.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64</name></type>
<name>PhysicalToLogical</name><parameter_list>(<parameter><decl><type><name>PhysicalAddr</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>COLUMNAR_BYTES_PER_PAGE</name> <operator>*</operator> <name><name>addr</name><operator>.</operator><name>blockno</name></name> <operator>+</operator> <name><name>addr</name><operator>.</operator><name>offset</name></name> <operator>-</operator> <name>SizeOfPageHeaderData</name></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarOverwriteMetapage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
									  <parameter><decl><type><name>ColumnarMetapage</name></type> <name>columnarMetapage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ColumnarMetapage</name></type> <name>ColumnarMetapageRead</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReadFromBlock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>,
						  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WriteToBlock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>clear</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>AlignReservation</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>prevReservation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ColumnarMetapageIsCurrent</name><parameter_list>(<parameter><decl><type><name>ColumnarMetapage</name> <modifier>*</modifier></type><name>metapage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ColumnarMetapageIsOlder</name><parameter_list>(<parameter><decl><type><name>ColumnarMetapage</name> <modifier>*</modifier></type><name>metapage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ColumnarMetapageIsNewer</name><parameter_list>(<parameter><decl><type><name>ColumnarMetapage</name> <modifier>*</modifier></type><name>metapage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ColumnarMetapageCheckVersion</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ColumnarMetapage</name> <modifier>*</modifier></type><name>metapage</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ColumnarStorageInit - initialize a new metapage in an empty relation
 * with the given storageId.
 *
 * Caller must hold AccessExclusiveLock on the relation.
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarStorageInit</name><parameter_list>(<parameter><decl><type><name>SMgrRelation</name></type> <name>srel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>storageId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name> <init>= <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><name>srel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"attempted to initialize metapage, but %d pages already exist"</literal></expr></argument>,
			 <argument><expr><name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* create two pages */</comment>
	<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>block</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Page</name></type> <name>page</name> <init>= <expr><name><name>block</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* write metapage */</comment>
	<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>PageHeader</name></type> <name>phdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>storageId</name></name> <operator>=</operator> <name>storageId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>versionMajor</name></name> <operator>=</operator> <name>COLUMNAR_VERSION_MAJOR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>versionMinor</name></name> <operator>=</operator> <name>COLUMNAR_VERSION_MINOR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedStripeId</name></name> <operator>=</operator> <name>COLUMNAR_FIRST_STRIPE_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedRowNumber</name></name> <operator>=</operator> <name>COLUMNAR_FIRST_ROW_NUMBER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedOffset</name></name> <operator>=</operator> <name>ColumnarFirstLogicalOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>unloggedReset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>-</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>metapage</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnarMetapage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnarMetapage</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>srel</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
				<argument><expr><name>COLUMNAR_METAPAGE_BLOCKNO</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>COLUMNAR_METAPAGE_BLOCKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name>srel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>COLUMNAR_METAPAGE_BLOCKNO</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* write empty page */</comment>
	<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>log_newpage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>srel</name><operator>-&gt;</operator><name>smgr_rnode</name><operator>.</operator><name>node</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>,
				<argument><expr><name>COLUMNAR_EMPTY_BLOCKNO</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PageSetChecksumInplace</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>COLUMNAR_EMPTY_BLOCKNO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>smgrextend</name><argument_list>(<argument><expr><name>srel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>COLUMNAR_EMPTY_BLOCKNO</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * An immediate sync is required even if we xlog'd the page, because the
	 * write did not go through shared_buffers and therefore a concurrent
	 * checkpoint may have moved the redo pointer past our xlog record.
	 */</comment>
	<expr_stmt><expr><call><name>smgrimmedsync</name><argument_list>(<argument><expr><name>srel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageUpdateCurrent - update the metapage to the current
 * version. No effect if the version already matches. If 'upgrade' is true,
 * throw an error if metapage version is newer; if 'upgrade' is false, it's a
 * downgrade, so throw an error if the metapage version is older.
 *
 * NB: caller must ensure that metapage already exists, which might not be the
 * case on 10.0.
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarStorageUpdateCurrent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>upgrade</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>reservedStripeId</name></decl></parameter>,
							 <parameter><decl><type><name>uint64</name></type> <name>reservedRowNumber</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>reservedOffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ColumnarMetapageIsCurrent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metapage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>upgrade</name> <operator>&amp;&amp;</operator> <call><name>ColumnarMetapageIsNewer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metapage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found newer columnar metapage while upgrading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>upgrade</name> <operator>&amp;&amp;</operator> <call><name>ColumnarMetapageIsOlder</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metapage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found older columnar metapage while downgrading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>versionMajor</name></name> <operator>=</operator> <name>COLUMNAR_VERSION_MAJOR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>versionMinor</name></name> <operator>=</operator> <name>COLUMNAR_VERSION_MINOR</name></expr>;</expr_stmt>

	<comment type="block">/* storageId remains the same */</comment>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedStripeId</name></name> <operator>=</operator> <name>reservedStripeId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedRowNumber</name></name> <operator>=</operator> <name>reservedRowNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedOffset</name></name> <operator>=</operator> <name>reservedOffset</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ColumnarOverwriteMetapage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageGetVersionMajor - return major version from the metapage.
 *
 * Throw an error if the metapage is not the current version, unless
 * 'force' is true.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarStorageGetVersionMajor</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>metapage</name><operator>.</operator><name>versionMajor</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageGetVersionMinor - return minor version from the metapage.
 *
 * Throw an error if the metapage is not the current version, unless
 * 'force' is true.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarStorageGetVersionMinor</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>metapage</name><operator>.</operator><name>versionMinor</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageGetStorageId - return storage ID from the metapage.
 *
 * Throw an error if the metapage is not the current version, unless
 * 'force' is true.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarStorageGetStorageId</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>metapage</name><operator>.</operator><name>storageId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageGetReservedStripeId - return reserved stripe ID from the
 * metapage.
 *
 * Throw an error if the metapage is not the current version, unless
 * 'force' is true.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarStorageGetReservedStripeId</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>metapage</name><operator>.</operator><name>reservedStripeId</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageGetReservedRowNumber - return reserved row number from the
 * metapage.
 *
 * Throw an error if the metapage is not the current version, unless
 * 'force' is true.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarStorageGetReservedRowNumber</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>metapage</name><operator>.</operator><name>reservedRowNumber</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageGetReservedOffset - return reserved offset from the metapage.
 *
 * Throw an error if the metapage is not the current version, unless
 * 'force' is true.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarStorageGetReservedOffset</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>metapage</name><operator>.</operator><name>reservedOffset</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageIsCurrent - return true if metapage exists and is not
 * the current version.
 */</comment>
<function><type><name>bool</name></type>
<name>ColumnarStorageIsCurrent</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name> <init>= <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><call><name>ColumnarMetapageIsCurrent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>metapage</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageReserveRowNumber returns reservedRowNumber and advances
 * it for next row number reservation.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarStorageReserveRowNumber</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>nrows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>firstRowNumber</name> <init>= <expr><name><name>metapage</name><operator>.</operator><name>reservedRowNumber</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedRowNumber</name></name> <operator>+=</operator> <name>nrows</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ColumnarOverwriteMetapage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>firstRowNumber</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageReserveStripeId returns stripeId and advances it for next
 * stripeId reservation.
 * Note that this function doesn't handle row number reservation.
 * See ColumnarStorageReserveRowNumber function.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarStorageReserveStripeId</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>stripeId</name> <init>= <expr><name><name>metapage</name><operator>.</operator><name>reservedStripeId</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedStripeId</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ColumnarOverwriteMetapage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stripeId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageReserveData - reserve logical data offsets for writing.
 */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarStorageReserveData</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>amount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>ColumnarInvalidLogicalOffset</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>alignedReservation</name> <init>= <expr><call><name>AlignReservation</name><argument_list>(<argument><expr><name><name>metapage</name><operator>.</operator><name>reservedOffset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>nextReservation</name> <init>= <expr><name>alignedReservation</name> <operator>+</operator> <name>amount</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedOffset</name></name> <operator>=</operator> <name>nextReservation</name></expr>;</expr_stmt>

	<comment type="block">/* write new reservation */</comment>
	<expr_stmt><expr><call><name>ColumnarOverwriteMetapage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* last used PhysicalAddr of new reservation */</comment>
	<decl_stmt><decl><type><name>PhysicalAddr</name></type> <name>final</name> <init>= <expr><call><name>LogicalToPhysical</name><argument_list>(<argument><expr><name>nextReservation</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* extend with new pages */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name> <init>= <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>nblocks</name> <operator>&lt;=</operator> <name><name>final</name><operator>.</operator><name>blockno</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Buffer</name></type> <name>newBuffer</name> <init>= <expr><call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>P_NEW</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>BufferGetBlockNumber</name><argument_list>(<argument><expr><name>newBuffer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>newBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nblocks</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>alignedReservation</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageRead - map the logical offset to a block and offset, then
 * read the buffer from multiple blocks if necessary.
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarStorageRead</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>logicalOffset</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>amount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if there's no work to do, succeed even with invalid offset */</comment>
	<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ColumnarLogicalOffsetIsValid</name><argument_list>(<argument><expr><name>logicalOffset</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"attempted columnar read on relation %d from invalid logical offset: "</literal>
			 <name>UINT64_FORMAT</name></expr></argument>,
			 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>logicalOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>read</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>read</name> <operator>&lt;</operator> <name>amount</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PhysicalAddr</name></type> <name>addr</name> <init>= <expr><call><name>LogicalToPhysical</name><argument_list>(<argument><expr><name>logicalOffset</name> <operator>+</operator> <name>read</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>uint32</name></type> <name>to_read</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>amount</name> <operator>-</operator> <name>read</name></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>-</operator> <name><name>addr</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ReadFromBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>blockno</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>read</name></expr></argument>, <argument><expr><name>to_read</name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>read</name> <operator>+=</operator> <name>to_read</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageWrite - map the logical offset to a block and offset, then
 * write the buffer across multiple blocks if necessary.
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarStorageWrite</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>logicalOffset</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>amount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if there's no work to do, succeed even with invalid offset */</comment>
	<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ColumnarLogicalOffsetIsValid</name><argument_list>(<argument><expr><name>logicalOffset</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"attempted columnar write on relation %d to invalid logical offset: "</literal>
			 <name>UINT64_FORMAT</name></expr></argument>,
			 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>logicalOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>written</name> <operator>&lt;</operator> <name>amount</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PhysicalAddr</name></type> <name>addr</name> <init>= <expr><call><name>LogicalToPhysical</name><argument_list>(<argument><expr><name>logicalOffset</name> <operator>+</operator> <name>written</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>uint64</name></type> <name>to_write</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>amount</name> <operator>-</operator> <name>written</name></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>-</operator> <name><name>addr</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>WriteToBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>blockno</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>written</name></expr></argument>, <argument><expr><name>to_write</name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>written</name> <operator>+=</operator> <name>to_write</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarStorageTruncate - truncate the columnar storage such that
 * newDataReservation will be the first unused logical offset available. Free
 * pages at the end of the relation.
 *
 * Caller must hold AccessExclusiveLock on the relation.
 *
 * Returns true if pages were truncated; false otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>ColumnarStorageTruncate</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>newDataReservation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ColumnarLogicalOffsetIsValid</name><argument_list>(<argument><expr><name>newDataReservation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"attempted to truncate relation %d to invalid logical offset: "</literal> <name>UINT64_FORMAT</name></expr></argument>,
			 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>newDataReservation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>old_rel_pages</name> <init>= <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>old_rel_pages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>metapage</name><operator>.</operator><name>reservedOffset</name></name> <operator>&lt;</operator> <name>newDataReservation</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"attempted to truncate relation %d to offset "</literal> <name>UINT64_FORMAT</name> \
			 <literal type="string">" which is higher than existing offset "</literal> <name>UINT64_FORMAT</name></expr></argument>,
			 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>newDataReservation</name></expr></argument>, <argument><expr><name><name>metapage</name><operator>.</operator><name>reservedOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>metapage</name><operator>.</operator><name>reservedOffset</name></name> <operator>==</operator> <name>newDataReservation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
		<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedOffset</name></name> <operator>=</operator> <name>newDataReservation</name></expr>;</expr_stmt>

	<comment type="block">/* write new reservation */</comment>
	<expr_stmt><expr><call><name>ColumnarOverwriteMetapage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockRelationForExtension</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PhysicalAddr</name></type> <name>final</name> <init>= <expr><call><name>LogicalToPhysical</name><argument_list>(<argument><expr><name>newDataReservation</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>new_rel_pages</name> <init>= <expr><name><name>final</name><operator>.</operator><name>blockno</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>new_rel_pages</name> <operator>&lt;=</operator> <name>old_rel_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Truncate the storage. Note that RelationTruncate() takes care of
	 * Write Ahead Logging.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_rel_pages</name> <operator>&lt;</operator> <name>old_rel_pages</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationTruncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>new_rel_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarOverwriteMetapage writes given columnarMetapage back to metapage
 * for given relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarOverwriteMetapage</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ColumnarMetapage</name></type> <name>columnarMetapage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* clear metapage because we are overwriting */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>clear</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WriteToBlock</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>COLUMNAR_METAPAGE_BLOCKNO</name></expr></argument>, <argument><expr><name>SizeOfPageHeaderData</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>columnarMetapage</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnarMetapage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>clear</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarMetapageRead - read the current contents of the metapage. Error if
 * it does not exist. Throw an error if the metapage is not the current
 * version, unless 'force' is true.
 *
 * NB: it's safe to read a different version of a metapage because we
 * guarantee that fields will only be added and existing fields will never be
 * changed. However, it's important that we don't depend on new fields being
 * set properly when we read an old metapage; an old metapage should only be
 * read for the purposes of upgrading or error checking.
 */</comment>
<function><type><specifier>static</specifier> <name>ColumnarMetapage</name></type>
<name>ColumnarMetapageRead</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>nblocks</name> <init>= <expr><call><name>smgrnblocks</name><argument_list>(<argument><expr><call><name>RelationGetSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>nblocks</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We only expect this to happen when upgrading citus.so. This is because,
		 * in current version of columnar, we immediately create the metapage
		 * for columnar tables, i.e right after creating the table.
		 * However in older versions, we were creating metapages lazily, i.e
		 * when ingesting data to columnar table.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"columnar metapage for relation \"%s\" does not exist"</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><name>OLD_METAPAGE_VERSION_HINT</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Regardless of "force" parameter, always force read metapage block.
	 * We will check metapage version in ColumnarMetapageCheckVersion
	 * depending on "force".
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>forceReadBlock</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReadFromBlock</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>COLUMNAR_METAPAGE_BLOCKNO</name></expr></argument>, <argument><expr><name>SizeOfPageHeaderData</name></expr></argument>,
				  <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>metapage</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnarMetapage</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>forceReadBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ColumnarMetapageCheckVersion</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>metapage</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReadFromBlock - read bytes from a page at the given offset. If 'force' is
 * true, don't check pd_lower; useful when reading a metapage of unknown
 * version.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadFromBlock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			  <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>buffer</name> <init>= <expr><call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Page</name></type> <name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PageHeader</name></type> <name>phdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>BLCKSZ</name> <operator>&lt;</operator> <name>offset</name> <operator>+</operator> <name>len</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&lt;</operator> <name>offset</name> <operator>+</operator> <name>len</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"attempt to read columnar data of length %d from offset %d of block %d of relation %d"</literal></expr></argument>,
			 <argument><expr><name>len</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>page</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * WriteToBlock - append data to a block, initializing if necessary, and emit
 * WAL. If 'clear' is true, always clear the data on the page and reinitialize
 * it first, and offset must be SizeOfPageHeaderData. Otherwise, offset must
 * be equal to pd_lower and pd_lower will be set to the end of the written
 * data.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WriteToBlock</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>blockno</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			 <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>clear</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Buffer</name></type> <name>buffer</name> <init>= <expr><call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GenericXLogState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>GenericXLogStart</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Page</name></type> <name>page</name> <init>= <expr><call><name>GenericXLogRegisterBuffer</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>GENERIC_XLOG_FULL_IMAGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PageHeader</name></type> <name>phdr</name> <init>= <expr><operator>(</operator><name>PageHeader</name><operator>)</operator> <name>page</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PageIsNew</name><argument_list>(<argument><expr><name>page</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>clear</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PageInit</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&lt;</operator> <name>offset</name> <operator>||</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>-</operator> <name>offset</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"attempt to write columnar data of length %d to offset %d of block %d of relation %d"</literal></expr></argument>,
			 <argument><expr><name>len</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>blockno</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * After a transaction has been rolled-back, we might be
	 * over-writing the rolledback write, so phdr-&gt;pd_lower can be
	 * different from addr.offset.
	 *
	 * We reset pd_lower to reset the rolledback write.
	 *
	 * Given that we always align page reservation to the next page as of
	 * 10.2, having such a disk page is only possible if write operaion
	 * failed in an older version of columnar, but now user attempts writing
	 * to that table in version &gt;= 10.2.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>&gt;</operator> <name>offset</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"overwriting page %u"</literal></expr></argument>, <argument><expr><name>blockno</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This can happen after a roll-back."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy_s</name><argument_list>(<argument><expr><name>page</name> <operator>+</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_upper</name></name> <operator>-</operator> <name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>phdr</name><operator>-&gt;</operator><name>pd_lower</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GenericXLogFinish</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AlignReservation - given an unused logical byte offset, align it so that it
 * falls at the start of a page.
 *
 * XXX: Reconsider whether we want/need to do this at all.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>AlignReservation</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>prevReservation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PhysicalAddr</name></type> <name>prevAddr</name> <init>= <expr><call><name>LogicalToPhysical</name><argument_list>(<argument><expr><name>prevReservation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>alignedReservation</name> <init>= <expr><name>prevReservation</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>prevAddr</name><operator>.</operator><name>offset</name></name> <operator>!=</operator> <name>SizeOfPageHeaderData</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not aligned; align on beginning of next page */</comment>
		<decl_stmt><decl><type><name>PhysicalAddr</name></type> <name>initial</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>initial</name><operator>.</operator><name>blockno</name></name> <operator>=</operator> <name><name>prevAddr</name><operator>.</operator><name>blockno</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>initial</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>SizeOfPageHeaderData</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>alignedReservation</name> <operator>=</operator> <call><name>PhysicalToLogical</name><argument_list>(<argument><expr><name>initial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>alignedReservation</name> <operator>&gt;=</operator> <name>prevReservation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>alignedReservation</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarMetapageIsCurrent - is the metapage at the latest version?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ColumnarMetapageIsCurrent</name><parameter_list>(<parameter><decl><type><name>ColumnarMetapage</name> <modifier>*</modifier></type><name>metapage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>metapage</name><operator>-&gt;</operator><name>versionMajor</name></name> <operator>==</operator> <name>COLUMNAR_VERSION_MAJOR</name> <operator>&amp;&amp;</operator>
			<name><name>metapage</name><operator>-&gt;</operator><name>versionMinor</name></name> <operator>==</operator> <name>COLUMNAR_VERSION_MINOR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarMetapageIsOlder - is the metapage older than the current version?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ColumnarMetapageIsOlder</name><parameter_list>(<parameter><decl><type><name>ColumnarMetapage</name> <modifier>*</modifier></type><name>metapage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>metapage</name><operator>-&gt;</operator><name>versionMajor</name></name> <operator>&lt;</operator> <name>COLUMNAR_VERSION_MAJOR</name> <operator>||</operator>
			<operator>(</operator><name><name>metapage</name><operator>-&gt;</operator><name>versionMajor</name></name> <operator>==</operator> <name>COLUMNAR_VERSION_MAJOR</name> <operator>&amp;&amp;</operator>
			 <operator>(</operator><name>int</name><operator>)</operator> <name><name>metapage</name><operator>-&gt;</operator><name>versionMinor</name></name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>COLUMNAR_VERSION_MINOR</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarMetapageIsNewer - is the metapage newer than the current version?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ColumnarMetapageIsNewer</name><parameter_list>(<parameter><decl><type><name>ColumnarMetapage</name> <modifier>*</modifier></type><name>metapage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>metapage</name><operator>-&gt;</operator><name>versionMajor</name></name> <operator>&gt;</operator> <name>COLUMNAR_VERSION_MAJOR</name> <operator>||</operator>
			<operator>(</operator><name><name>metapage</name><operator>-&gt;</operator><name>versionMajor</name></name> <operator>==</operator> <name>COLUMNAR_VERSION_MAJOR</name> <operator>&amp;&amp;</operator>
			 <name><name>metapage</name><operator>-&gt;</operator><name>versionMinor</name></name> <operator>&gt;</operator> <name>COLUMNAR_VERSION_MINOR</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarMetapageCheckVersion - throw an error if accessing old
 * version of metapage.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ColumnarMetapageCheckVersion</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>ColumnarMetapage</name> <modifier>*</modifier></type><name>metapage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ColumnarMetapageIsCurrent</name><argument_list>(<argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(
							<argument><expr><literal type="string">"attempted to access relation \"%s\", which uses an older columnar format"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(
							<argument><expr><literal type="string">"Columnar format version %d.%d is required, \"%s\" has version %d.%d."</literal></expr></argument>,
							<argument><expr><name>COLUMNAR_VERSION_MAJOR</name></expr></argument>, <argument><expr><name>COLUMNAR_VERSION_MINOR</name></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>metapage</name><operator>-&gt;</operator><name>versionMajor</name></name></expr></argument>, <argument><expr><name><name>metapage</name><operator>-&gt;</operator><name>versionMinor</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><name>OLD_METAPAGE_VERSION_HINT</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * test_columnar_storage_write_new_page is a UDF only used for testing
 * purposes. It could make more sense to define this in columnar_debug.c,
 * but the storage layer doesn't expose ColumnarMetapage to any other files,
 * so we define it here.
 */</comment>
<function><type><name>Datum</name></type>
<name>test_columnar_storage_write_new_page</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>relationId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate a new page, write some data to there, and set reserved offset
	 * to the start of that page. That way, for a subsequent write operation,
	 * storage layer would try to overwrite the page that we allocated here.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>newPageOffset</name> <init>= <expr><call><name>ColumnarStorageGetReservedOffset</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ColumnarStorageReserveData</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ColumnarStorageWrite</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>newPageOffset</name></expr></argument>, <argument><expr><literal type="string">"foo_bar"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ColumnarMetapage</name></type> <name>metapage</name> <init>= <expr><call><name>ColumnarMetapageRead</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>metapage</name><operator>.</operator><name>reservedOffset</name></name> <operator>=</operator> <name>newPageOffset</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ColumnarOverwriteMetapage</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>metapage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
