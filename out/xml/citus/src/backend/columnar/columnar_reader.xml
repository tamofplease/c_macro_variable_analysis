<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/citus/src/backend/columnar/columnar_reader.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * columnar_reader.c
 *
 * This file contains function definitions for reading columnar tables. This
 * includes the logic for reading file level metadata, reading row stripes,
 * and skipping unrelated row chunks and columns.
 *
 * Copyright (c) 2016, Citus Data, Inc.
 *
 * $Id$
 *
 *-------------------------------------------------------------------------
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"safe_lib.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"distributed/listutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"columnar/columnar_version_compat.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNEXPECTED_STRIPE_READ_ERR_MSG</name></cpp:macro> \
	<cpp:value>"attempted to read an unexpected stripe while reading columnar " \
	"table %s, stripe with id=" UINT64_FORMAT " is not flushed"</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>ChunkGroupReadState</name>
<block>{
	<decl_stmt><decl><type><name>int64</name></type> <name>currentRow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>rowCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>columnCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl>;</decl_stmt>  <comment type="block">/* borrowed reference */</comment>
	<decl_stmt><decl><type><name>ChunkData</name> <modifier>*</modifier></type><name>chunkGroupData</name></decl>;</decl_stmt>
}</block></struct></type> <name>ChunkGroupReadState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>StripeReadState</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>columnCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>rowCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>currentRow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>chunkGroupIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>chunkGroupsFiltered</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stripeReadContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name></decl>;</decl_stmt>   <comment type="block">/* allocated in stripeReadContext */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl>;</decl_stmt>      <comment type="block">/* borrowed reference */</comment>
	<decl_stmt><decl><type><name>ChunkGroupReadState</name> <modifier>*</modifier></type><name>chunkGroupReadState</name></decl>;</decl_stmt> <comment type="block">/* owned */</comment>
}</block></struct></type> <name>StripeReadState</name>;</typedef>

<struct>struct <name>ColumnarReadState</name>
<block>{
	<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relation</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>currentStripeMetadata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeReadState</name> <modifier>*</modifier></type><name>stripeReadState</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Integer list of attribute numbers (1-indexed) for columns needed by the
	 * query.
	 */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseVars</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stripeReadContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>chunkGroupsFiltered</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Memory context guaranteed to be not freed during scan so we can
	 * safely use for any memory allocations regarding ColumnarReadState
	 * itself.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>scanContext</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>snapshotRegisteredByUs</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* static function declarations */</comment>
<function_decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>CreateStripeReadMemoryContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ColumnarReadIsCurrentStripe</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>,
										<parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StripeMetadata</name> <modifier>*</modifier></type> <name>ColumnarReadGetCurrentStripe</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReadStripeRowByRowNumber</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>,
									 <parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>StripeReadIsCurrentChunkGroup</name><parameter_list>(<parameter><decl><type><name>StripeReadState</name> <modifier>*</modifier></type><name>stripeReadState</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>chunkGroupIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReadChunkGroupRowByRowOffset</name><parameter_list>(<parameter><decl><type><name>ChunkGroupReadState</name> <modifier>*</modifier></type><name>chunkGroupReadState</name></decl></parameter>,
										 <parameter><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name></decl></parameter>,
										 <parameter><decl><type><name>uint64</name></type> <name>stripeRowOffset</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
										 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>StripeReadInProgress</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasUnreadStripe</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StripeReadState</name> <modifier>*</modifier></type> <name>BeginStripeRead</name><parameter_list>(<parameter><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
										 <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>,
										 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseVars</name></decl></parameter>,
										 <parameter><decl><type><name>MemoryContext</name></type> <name>stripeReadContext</name></decl></parameter>,
										 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AdvanceStripeRead</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SnapshotMightSeeUnflushedStripes</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReadStripeNextRow</name><parameter_list>(<parameter><decl><type><name>StripeReadState</name> <modifier>*</modifier></type><name>stripeReadState</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ChunkGroupReadState</name> <modifier>*</modifier></type> <name>BeginChunkGroupRead</name><parameter_list>(<parameter><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name></decl></parameter>, <parameter><decl><type><name>int</name></type>
												 <name>chunkIndex</name></decl></parameter>,
												 <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>,
												 <parameter><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EndChunkGroupRead</name><parameter_list>(<parameter><decl><type><name>ChunkGroupReadState</name> <modifier>*</modifier></type><name>chunkGroupReadState</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReadChunkGroupNextRow</name><parameter_list>(<parameter><decl><type><name>ChunkGroupReadState</name> <modifier>*</modifier></type><name>chunkGroupReadState</name></decl></parameter>,
								  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StripeBuffers</name> <modifier>*</modifier></type> <name>LoadFilteredStripeBuffers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
												 <parameter><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name></decl></parameter>,
												 <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>,
												 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseVars</name></decl></parameter>,
												 <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>chunkGroupsFiltered</name></decl></parameter>,
												 <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ColumnBuffers</name> <modifier>*</modifier></type> <name>LoadColumnBuffers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
										 <parameter><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNodeArray</name></decl></parameter>,
										 <parameter><decl><type><name>uint32</name></type> <name>chunkCount</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripeOffset</name></decl></parameter>,
										 <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name> <modifier>*</modifier></type> <name>SelectedChunkMask</name><parameter_list>(<parameter><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseVars</name></decl></parameter>,
								<parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>chunkGroupsFiltered</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>BuildBaseConstraint</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>GetClauseVars</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>OpExpr</name> <modifier>*</modifier></type> <name>MakeOpExpression</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>strategyNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>GetOperatorByType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>strategyNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateConstraint</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>baseConstraint</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>minValue</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>maxValue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>StripeSkipList</name> <modifier>*</modifier></type> <name>SelectedChunkSkipList</name><parameter_list>(<parameter><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>projectedColumnMask</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>selectedChunkMask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>StripeSkipListRowCount</name><parameter_list>(<parameter><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name> <modifier>*</modifier></type> <name>ProjectedColumnMask</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DeserializeBoolArray</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>boolArrayBuffer</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>boolArray</name></decl></parameter>,
								 <parameter><decl><type><name>uint32</name></type> <name>boolArrayLength</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DeserializeDatumArray</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>datumBuffer</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>existsArray</name></decl></parameter>,
								  <parameter><decl><type><name>uint32</name></type> <name>datumCount</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>datumTypeByValue</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>datumTypeLength</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>datumTypeAlign</name></decl></parameter>,
								  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datumArray</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ChunkData</name> <modifier>*</modifier></type> <name>DeserializeChunkData</name><parameter_list>(<parameter><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>chunkIndex</name></decl></parameter>,
										<parameter><decl><type><name>uint32</name></type> <name>rowCount</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
										<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ColumnDefaultValue</name><parameter_list>(<parameter><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>tupleConstraints</name></decl></parameter>,
								<parameter><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * ColumnarBeginRead initializes a columnar read operation. This function returns a
 * read handle that's used during reading rows and finishing the read operation.
 *
 * projectedColumnList is an integer list of attribute numbers (1-indexed).
 */</comment>
<function><type><name>ColumnarReadState</name> <modifier>*</modifier></type>
<name>ColumnarBeginRead</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>,
				  <parameter><decl><type><name>MemoryContext</name></type> <name>scanContext</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We allocate all stripe specific data in the stripeReadContext, and reset
	 * this memory context before loading a new stripe. This is to avoid memory
	 * leaks.
	 */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stripeReadContext</name> <init>= <expr><call><name>CreateStripeReadMemoryContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnarReadState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>projectedColumnList</name></name> <operator>=</operator> <name>projectedColumnList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>whereClauseList</name></name> <operator>=</operator> <name>whereClauseList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>whereClauseVars</name></name> <operator>=</operator> <call><name>GetClauseVars</name><argument_list>(<argument><expr><name>whereClauseList</name></expr></argument>, <argument><expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>chunkGroupsFiltered</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>tupleDescriptor</name></name> <operator>=</operator> <name>tupleDescriptor</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadContext</name></name> <operator>=</operator> <name>stripeReadContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>scanContext</name></name> <operator>=</operator> <name>scanContext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that ColumnarReadFlushPendingWrites might update those two by
	 * registering a new snapshot.
	 */</comment>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshotRegisteredByUs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>randomAccess</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * When doing random access (i.e.: index scan), we don't need to flush
		 * pending writes until we need to read them.
		 * columnar_index_fetch_tuple would do so when needed.
		 */</comment>
		<expr_stmt><expr><call><name>ColumnarReadFlushPendingWrites</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * AdvanceStripeRead sets currentStripeMetadata for the first stripe
		 * to read if not doing random access. Otherwise, reader (i.e.:
		 * ColumnarReadRowByRowNumber) would already decide the stripe to read
		 * on-the-fly.
		 *
		 * Moreover, Since we don't flush pending writes for random access,
		 * AdvanceStripeRead might encounter with stripe metadata entries due
		 * to current transaction's pending writes even when using an MVCC
		 * snapshot, but AdvanceStripeRead would throw an error for that.
		 * Note that this is not the case with for plain table scan methods
		 * (i.e.: SeqScan and Columnar CustomScan).
		 *
		 * For those reasons, we don't call AdvanceStripeRead if we will do
		 * random access.
		 */</comment>
		<expr_stmt><expr><call><name>AdvanceStripeRead</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>readState</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarReadFlushPendingWrites flushes pending writes for read operation
 * and sets a new (registered) snapshot if necessary.
 *
 * If it sets a new snapshot, then sets snapshotRegisteredByUs to true to
 * indicate that caller should unregister the snapshot after finishing read
 * operation.
 *
 * Note that this function assumes that readState's relation and snapshot
 * fields are already set.
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarReadFlushPendingWrites</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>readState</name><operator>-&gt;</operator><name>snapshotRegisteredByUs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>relfilenode</name> <init>= <expr><name><name>readState</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>FlushWriteStateForRelfilenode</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>, <argument><expr><call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>==</operator> <name>InvalidSnapshot</name> <operator>||</operator> <operator>!</operator><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we flushed any pending writes, then we should guarantee that
	 * those writes are visible to us too. For this reason, if given
	 * snapshot is an MVCC snapshot, then we set its curcid to current
	 * command id.
	 *
	 * For simplicity, we do that even if we didn't flush any writes
	 * since we don't see any problem with that.
	 *
	 * XXX: We should either not update cid if we are executing a FETCH
	 * (from cursor) command, or we should have a better way to deal with
	 * pending writes, see the discussion in
	 * https://github.com/citusdata/citus/issues/5231.
	 */</comment>
	<expr_stmt><expr><call><name>PushCopiedSnapshot</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now our snapshot is the active one */</comment>
	<expr_stmt><expr><call><name>UpdateActiveSnapshotCommandId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type> <name>newSnapshot</name> <init>= <expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>newSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To be able to use UpdateActiveSnapshotCommandId, we pushed the
	 * copied snapshot to the stack. However, we don't need to keep it
	 * there since we will anyway rely on ColumnarReadState-&gt;snapshot
	 * during read operation.
	 *
	 * Note that since we registered the snapshot already, we guarantee
	 * that PopActiveSnapshot won't free it.
	 */</comment>
	<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>newSnapshot</name></expr>;</expr_stmt>

	<comment type="block">/* not forget to unregister it when finishing read operation */</comment>
	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshotRegisteredByUs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CreateStripeReadMemoryContext creates a memory context to be used when
 * reading a stripe.
 */</comment>
<function><type><specifier>static</specifier> <name>MemoryContext</name></type>
<name>CreateStripeReadMemoryContext</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"Stripe Read Memory Context"</literal></expr></argument>,
								 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarReadNextRow tries to read a row from the columnar table. On success, it sets
 * column values, column nulls and rowNumber (if passed to be non-NULL), and returns true.
 * If there are no more rows to read, the function returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>ColumnarReadNextRow</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>,
					<parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>rowNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>StripeReadInProgress</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HasUnreadStripe</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadState</name></name> <operator>=</operator> <call><name>BeginStripeRead</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name></expr></argument>,
														 <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
														 <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>tupleDescriptor</name></name></expr></argument>,
														 <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>projectedColumnList</name></name></expr></argument>,
														 <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>whereClauseList</name></name></expr></argument>,
														 <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>whereClauseVars</name></name></expr></argument>,
														 <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadContext</name></name></expr></argument>,
														 <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadStripeNextRow</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadState</name></name></expr></argument>, <argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AdvanceStripeRead</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rowNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>rowNumber</name> <operator>=</operator> <name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name><operator>-&gt;</operator><name>firstRowNumber</name></name> <operator>+</operator>
						 <name><name>readState</name><operator>-&gt;</operator><name>stripeReadState</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></while>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarReadRowByRowNumberOrError is a wrapper around
 * ColumnarReadRowByRowNumber that throws an error if tuple
 * with rowNumber does not exist.
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarReadRowByRowNumberOrError</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>,
								  <parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ColumnarReadRowByRowNumber</name><argument_list>(<argument><expr><name>readState</name></expr></argument>, <argument><expr><name>rowNumber</name></expr></argument>,
									<argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot read from columnar table %s, tuple with "</literal>
							   <literal type="string">"row number "</literal> <name>UINT64_FORMAT</name> <literal type="string">" does not exist"</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>rowNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarReadRowByRowNumber reads row with rowNumber from given relation
 * into columnValues and columnNulls, and returns true. If no such row
 * exists, then returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>ColumnarReadRowByRowNumber</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>,
						   <parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ColumnarReadIsCurrentStripe</name><argument_list>(<argument><expr><name>readState</name></expr></argument>, <argument><expr><name>rowNumber</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>columnarRelation</name> <init>= <expr><name><name>readState</name><operator>-&gt;</operator><name>relation</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name> <init>= <expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>= <expr><call><name>FindStripeByRowNumber</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>,
															   <argument><expr><name>rowNumber</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>stripeMetadata</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no such row exists */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>StripeWriteState</name><argument_list>(<argument><expr><name>stripeMetadata</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STRIPE_WRITE_FLUSHED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Callers are expected to skip stripes that are not flushed to
			 * disk yet or should wait for the writer xact to commit or abort,
			 * but let's be on the safe side.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><name>UNEXPECTED_STRIPE_READ_ERR_MSG</name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* do the cleanup before reading a new stripe */</comment>
		<expr_stmt><expr><call><name>ColumnarResetRead</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>relationTupleDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>columnarRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseVars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>stripeReadContext</name> <init>= <expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadContext</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadState</name></name> <operator>=</operator> <call><name>BeginStripeRead</name><argument_list>(<argument><expr><name>stripeMetadata</name></expr></argument>,
													 <argument><expr><name>columnarRelation</name></expr></argument>,
													 <argument><expr><name>relationTupleDesc</name></expr></argument>,
													 <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>projectedColumnList</name></name></expr></argument>,
													 <argument><expr><name>whereClauseList</name></expr></argument>,
													 <argument><expr><name>whereClauseVars</name></expr></argument>,
													 <argument><expr><name>stripeReadContext</name></expr></argument>,
													 <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name> <operator>=</operator> <name>stripeMetadata</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReadStripeRowByRowNumber</name><argument_list>(<argument><expr><name>readState</name></expr></argument>, <argument><expr><name>rowNumber</name></expr></argument>, <argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarReadIsCurrentStripe returns true if stripe being read contains
 * row with given rowNumber.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ColumnarReadIsCurrentStripe</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>StripeReadInProgress</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>currentStripeMetadata</name> <init>= <expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>rowNumber</name> <operator>&gt;=</operator> <name><name>currentStripeMetadata</name><operator>-&gt;</operator><name>firstRowNumber</name></name> <operator>&amp;&amp;</operator>
		<name>rowNumber</name> <operator>&lt;=</operator> <call><name>StripeGetHighestRowNumber</name><argument_list>(<argument><expr><name>currentStripeMetadata</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarReadGetCurrentStripe returns StripeMetadata for the stripe that is
 * being read.
 */</comment>
<function><type><specifier>static</specifier> <name>StripeMetadata</name> <modifier>*</modifier></type>
<name>ColumnarReadGetCurrentStripe</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReadStripeRowByRowNumber reads row with rowNumber from given
 * stripeReadState into columnValues and columnNulls.
 * Errors out if no such row exists in the stripe being read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadStripeRowByRowNumber</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>,
						 <parameter><decl><type><name>uint64</name></type> <name>rowNumber</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>= <expr><call><name>ColumnarReadGetCurrentStripe</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StripeReadState</name> <modifier>*</modifier></type><name>stripeReadState</name> <init>= <expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadState</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rowNumber</name> <operator>&lt;</operator> <name><name>stripeMetadata</name><operator>-&gt;</operator><name>firstRowNumber</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not expected but be on the safe side */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row offset cannot be negative"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* find the exact chunk group to be read */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>stripeRowOffset</name> <init>= <expr><name>rowNumber</name> <operator>-</operator> <name><name>stripeMetadata</name><operator>-&gt;</operator><name>firstRowNumber</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>chunkGroupIndex</name> <init>= <expr><name>stripeRowOffset</name> <operator>/</operator> <name><name>stripeMetadata</name><operator>-&gt;</operator><name>chunkGroupRowCount</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>StripeReadIsCurrentChunkGroup</name><argument_list>(<argument><expr><name>stripeReadState</name></expr></argument>, <argument><expr><name>chunkGroupIndex</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EndChunkGroupRead</name><argument_list>(<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupIndex</name></name> <operator>=</operator> <name>chunkGroupIndex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name> <operator>=</operator> <call><name>BeginChunkGroupRead</name><argument_list>(
			<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>stripeBuffers</name></name></expr></argument>,
			<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupIndex</name></name></expr></argument>,
			<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>tupleDescriptor</name></name></expr></argument>,
			<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>projectedColumnList</name></name></expr></argument>,
			<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>stripeReadContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReadChunkGroupRowByRowOffset</name><argument_list>(<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name></expr></argument>,
								 <argument><expr><name>stripeMetadata</name></expr></argument>, <argument><expr><name>stripeRowOffset</name></expr></argument>,
								 <argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StripeReadIsCurrentChunkGroup returns true if chunk group being read is
 * the has given chunkGroupIndex in its stripe.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>StripeReadIsCurrentChunkGroup</name><parameter_list>(<parameter><decl><type><name>StripeReadState</name> <modifier>*</modifier></type><name>stripeReadState</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chunkGroupIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupIndex</name></name> <operator>==</operator> <name>chunkGroupIndex</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ReadChunkGroupRowByRowOffset reads row with stripeRowOffset from given
 * chunkGroupReadState into columnValues and columnNulls.
 * Errors out if no such row exists in the chunk group being read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadChunkGroupRowByRowOffset</name><parameter_list>(<parameter><decl><type><name>ChunkGroupReadState</name> <modifier>*</modifier></type><name>chunkGroupReadState</name></decl></parameter>,
							 <parameter><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name></decl></parameter>,
							 <parameter><decl><type><name>uint64</name></type> <name>stripeRowOffset</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* set the exact row number to be read from given chunk roup */</comment>
	<expr_stmt><expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>stripeRowOffset</name> <operator>%</operator>
									  <name><name>stripeMetadata</name><operator>-&gt;</operator><name>chunkGroupRowCount</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadChunkGroupNextRow</name><argument_list>(<argument><expr><name>chunkGroupReadState</name></expr></argument>, <argument><expr><name>columnValues</name></expr></argument>, <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not expected but be on the safe side */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find the row in stripe"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * StripeReadInProgress returns true if we already started reading a stripe.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>StripeReadInProgress</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadState</name></name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * HasUnreadStripe returns true if we still have stripes to read during current
 * read operation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HasUnreadStripe</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarRescan clears the position where we were scanning so that the next read starts at
 * the beginning again
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarRescan</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scanQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>scanContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ColumnarResetRead</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set currentStripeMetadata for the first stripe to read */</comment>
	<expr_stmt><expr><call><name>AdvanceStripeRead</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>chunkGroupsFiltered</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>whereClauseList</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>scanQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Finishes a columnar read operation.
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarEndRead</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>readState</name><operator>-&gt;</operator><name>snapshotRegisteredByUs</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * init_columnar_read_state created a new snapshot and registered it,
		 * so now forget it.
		 */</comment>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarResetRead resets the stripe and the chunk group that is
 * being read currently (if any).
 */</comment>
<function><type><name>void</name></type>
<name>ColumnarResetRead</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>StripeReadInProgress</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * BeginStripeRead allocates state for reading a stripe.
 */</comment>
<function><type><specifier>static</specifier> <name>StripeReadState</name> <modifier>*</modifier></type>
<name>BeginStripeRead</name><parameter_list>(<parameter><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseVars</name></decl></parameter>,
				<parameter><decl><type><name>MemoryContext</name></type> <name>stripeReadContext</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>stripeReadContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StripeReadState</name> <modifier>*</modifier></type><name>stripeReadState</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StripeReadState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>tupleDescriptor</name></name> <operator>=</operator> <name>tupleDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>columnCount</name></name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>projectedColumnList</name></name> <operator>=</operator> <name>projectedColumnList</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>stripeReadContext</name></name> <operator>=</operator> <name>stripeReadContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>stripeBuffers</name></name> <operator>=</operator> <call><name>LoadFilteredStripeBuffers</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
															   <argument><expr><name>stripeMetadata</name></expr></argument>,
															   <argument><expr><name>tupleDesc</name></expr></argument>,
															   <argument><expr><name>projectedColumnList</name></expr></argument>,
															   <argument><expr><name>whereClauseList</name></expr></argument>,
															   <argument><expr><name>whereClauseVars</name></expr></argument>,
															   <argument><expr><operator>&amp;</operator><name><name>stripeReadState</name><operator>-&gt;</operator>
															   <name>chunkGroupsFiltered</name></name></expr></argument>,
															   <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <name><name>stripeReadState</name><operator>-&gt;</operator><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<return>return <expr><name>stripeReadState</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AdvanceStripeRead updates chunkGroupsFiltered and sets
 * currentStripeMetadata for next stripe read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdvanceStripeRead</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>readState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>scanContext</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* if not read any stripes yet, start from the first one .. */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>lastReadRowNumber</name> <init>= <expr><name>COLUMNAR_INVALID_ROW_NUMBER</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>StripeReadInProgress</name><argument_list>(<argument><expr><name>readState</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* .. otherwise, continue with the next stripe */</comment>
		<expr_stmt><expr><name>lastReadRowNumber</name> <operator>=</operator> <call><name>StripeGetHighestRowNumber</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>chunkGroupsFiltered</name></name> <operator>+=</operator>
			<name><name>readState</name><operator>-&gt;</operator><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupsFiltered</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name> <operator>=</operator> <call><name>FindNextStripeByRowNumber</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
																 <argument><expr><name>lastReadRowNumber</name></expr></argument>,
																 <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name> <operator>&amp;&amp;</operator>
		<call><name>StripeWriteState</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STRIPE_WRITE_FLUSHED</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>SnapshotMightSeeUnflushedStripes</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * To be on the safe side, error out if we don't expect to encounter
		 * with an un-flushed stripe. Otherwise, we will skip such stripes
		 * until finding a flushed one.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><name>UNEXPECTED_STRIPE_READ_ERR_MSG</name></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name> <operator>&amp;&amp;</operator>
		   <call><name>StripeWriteState</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STRIPE_WRITE_FLUSHED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name></name> <operator>=</operator>
			<call><name>FindNextStripeByRowNumber</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
									  <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>currentStripeMetadata</name><operator>-&gt;</operator><name>firstRowNumber</name></name></expr></argument>,
									  <argument><expr><name><name>readState</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>readState</name><operator>-&gt;</operator><name>stripeReadContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SnapshotMightSeeUnflushedStripes returns true if given snapshot is
 * expected to see un-flushed stripes either because of other backends'
 * pending writes or aborted transactions.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SnapshotMightSeeUnflushedStripes</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>InvalidSnapshot</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>snapshot_type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SNAPSHOT_ANY</name></expr>:</case>
		<case>case <expr><name>SNAPSHOT_DIRTY</name></expr>:</case>
		<case>case <expr><name>SNAPSHOT_NON_VACUUMABLE</name></expr>:</case>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block>

		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * ReadStripeNextRow: If more rows can be read from the current stripe, fill
 * in non-NULL columnValues and return true. Otherwise, return false.
 *
 * On entry, all entries in columnNulls should be true; this function only
 * sets non-NULL entries.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReadStripeNextRow</name><parameter_list>(<parameter><decl><type><name>StripeReadState</name> <modifier>*</modifier></type><name>stripeReadState</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>&gt;=</operator> <name><name>stripeReadState</name><operator>-&gt;</operator><name>rowCount</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>==</operator> <name><name>stripeReadState</name><operator>-&gt;</operator><name>rowCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name> <operator>=</operator> <call><name>BeginChunkGroupRead</name><argument_list>(
				<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>stripeBuffers</name></name></expr></argument>,
				<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator>
				<name>chunkGroupIndex</name></name></expr></argument>,
				<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator>
				<name>tupleDescriptor</name></name></expr></argument>,
				<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator>
				<name>projectedColumnList</name></name></expr></argument>,
				<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator>
				<name>stripeReadContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ReadChunkGroupNextRow</name><argument_list>(<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name></expr></argument>, <argument><expr><name>columnValues</name></expr></argument>,
								   <argument><expr><name>columnNulls</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if this chunk group is exhausted, fetch the next one and loop */</comment>
			<expr_stmt><expr><call><name>EndChunkGroupRead</name><argument_list>(<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupReadState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>chunkGroupIndex</name></name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>currentRow</name></name><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stripeReadState</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>==</operator> <name><name>stripeReadState</name><operator>-&gt;</operator><name>rowCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BeginChunkGroupRead allocates state for reading a chunk.
 */</comment>
<function><type><specifier>static</specifier> <name>ChunkGroupReadState</name> <modifier>*</modifier></type>
<name>BeginChunkGroupRead</name><parameter_list>(<parameter><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chunkIndex</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkGroupRowCount</name> <init>=
		<expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>selectedChunkGroupRowCounts</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ChunkGroupReadState</name> <modifier>*</modifier></type><name>chunkGroupReadState</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkGroupReadState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <name>chunkGroupRowCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>columnCount</name></name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>projectedColumnList</name></name> <operator>=</operator> <name>projectedColumnList</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>chunkGroupData</name></name> <operator>=</operator> <call><name>DeserializeChunkData</name><argument_list>(<argument><expr><name>stripeBuffers</name></expr></argument>, <argument><expr><name>chunkIndex</name></expr></argument>,
															   <argument><expr><name>chunkGroupRowCount</name></expr></argument>,
															   <argument><expr><name>tupleDesc</name></expr></argument>,
															   <argument><expr><name>projectedColumnList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunkGroupReadState</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * EndChunkRead finishes a chunk read.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>EndChunkGroupRead</name><parameter_list>(<parameter><decl><type><name>ChunkGroupReadState</name> <modifier>*</modifier></type><name>chunkGroupReadState</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>FreeChunkData</name><argument_list>(<argument><expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>chunkGroupData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>chunkGroupReadState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ReadChunkGroupNextRow: if more rows can be read from the current chunk
 * group, fill in non-NULL columnValues and return true. Otherwise, return
 * false.
 *
 * On entry, all entries in columnNulls should be true; this function only
 * sets non-NULL entries.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReadChunkGroupNextRow</name><parameter_list>(<parameter><decl><type><name>ChunkGroupReadState</name> <modifier>*</modifier></type><name>chunkGroupReadState</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>columnValues</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnNulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>&gt;=</operator> <name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>rowCount</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>==</operator> <name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>rowCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize to all-NULL. Only non-NULL projected attributes will be set.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>columnNulls</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>columnCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>attno</name></decl>;</decl_stmt>
	<macro><name>foreach_int</name><argument_list>(<argument>attno</argument>, <argument>chunkGroupReadState-&gt;projectedColumnList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>ChunkData</name> <modifier>*</modifier></type><name>chunkGroupData</name> <init>= <expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>chunkGroupData</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>rowIndex</name> <init>= <expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>currentRow</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* attno is 1-indexed; existsArray is 0-indexed */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>uint32</name></type> <name>columnIndex</name> <init>= <expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>chunkGroupData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>rowIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>columnValues</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name><name>chunkGroupData</name><operator>-&gt;</operator><name>valueArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>rowIndex</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>columnNulls</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>chunkGroupReadState</name><operator>-&gt;</operator><name>currentRow</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnarReadChunkGroupsFiltered
 *
 * Return the number of chunk groups filtered during this read operation.
 */</comment>
<function><type><name>int64</name></type>
<name>ColumnarReadChunkGroupsFiltered</name><parameter_list>(<parameter><decl><type><name>ColumnarReadState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>chunkGroupsFiltered</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateEmptyChunkDataArray creates data buffers to keep deserialized exist and
 * value arrays for requested columns in columnMask.
 */</comment>
<function><type><name>ChunkData</name> <modifier>*</modifier></type>
<name>CreateEmptyChunkData</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnMask</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>chunkGroupRowCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ChunkData</name> <modifier>*</modifier></type><name>chunkData</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueArray</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueBufferArray</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StringInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>columnCount</name></name> <operator>=</operator> <name>columnCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <name>chunkGroupRowCount</name></expr>;</expr_stmt>

	<comment type="block">/* allocate chunk memory for deserialized data */</comment>
	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>columnMask</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>chunkGroupRowCount</name> <operator>*</operator>
														  <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>chunkGroupRowCount</name> <operator>*</operator>
														 <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueBufferArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>chunkData</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FreeChunkData deallocates data buffers to keep deserialized exist and
 * value arrays for requested columns in columnMask.
 * ColumnChunkData-&gt;serializedValueBuffer lives in memory read/write context
 * so it is deallocated automatically when the context is deleted.
 */</comment>
<function><type><name>void</name></type>
<name>FreeChunkData</name><parameter_list>(<parameter><decl><type><name>ChunkData</name> <modifier>*</modifier></type><name>chunkData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>chunkData</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name><name>chunkData</name><operator>-&gt;</operator><name>columnCount</name></name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>chunkData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ColumnarTableRowCount returns the exact row count of a table using skiplists */</comment>
<function><type><name>uint64</name></type>
<name>ColumnarTableRowCount</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>stripeMetadataCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>totalRowCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stripeList</name> <init>= <expr><call><name>StripesForRelfilenode</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>stripeMetadataCell</argument>, <argument>stripeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name> <init>= <expr><operator>(</operator><name>StripeMetadata</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>stripeMetadataCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>totalRowCount</name> <operator>+=</operator> <name><name>stripeMetadata</name><operator>-&gt;</operator><name>rowCount</name></name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>totalRowCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LoadFilteredStripeBuffers reads serialized stripe data from the given file.
 * The function skips over chunks whose rows are refuted by restriction qualifiers,
 * and only loads columns that are projected in the query.
 */</comment>
<function><type><specifier>static</specifier> <name>StripeBuffers</name> <modifier>*</modifier></type>
<name>LoadFilteredStripeBuffers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>StripeMetadata</name> <modifier>*</modifier></type><name>stripeMetadata</name></decl></parameter>,
						  <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseVars</name></decl></parameter>,
						  <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>chunkGroupsFiltered</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>projectedColumnMask</name> <init>= <expr><call><name>ProjectedColumnMask</name><argument_list>(<argument><expr><name>columnCount</name></expr></argument>, <argument><expr><name>projectedColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name> <init>= <expr><call><name>ReadStripeSkipList</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>,
														<argument><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
														<argument><expr><name>tupleDescriptor</name></expr></argument>,
														<argument><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>chunkCount</name></name></expr></argument>,
														<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>selectedChunkMask</name> <init>= <expr><call><name>SelectedChunkMask</name><argument_list>(<argument><expr><name>stripeSkipList</name></expr></argument>, <argument><expr><name>whereClauseList</name></expr></argument>,
												<argument><expr><name>whereClauseVars</name></expr></argument>, <argument><expr><name>chunkGroupsFiltered</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>selectedChunkSkipList</name> <init>=
		<expr><call><name>SelectedChunkSkipList</name><argument_list>(<argument><expr><name>stripeSkipList</name></expr></argument>, <argument><expr><name>projectedColumnMask</name></expr></argument>,
							  <argument><expr><name>selectedChunkMask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* load column data for projected columns */</comment>
	<decl_stmt><decl><type><name>ColumnBuffers</name> <modifier>*</modifier><modifier>*</modifier></type><name>columnBuffersArray</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnBuffers</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name><name>stripeMetadata</name><operator>-&gt;</operator><name>columnCount</name></name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>projectedColumnMask</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNode</name> <init>=
				<expr><name><name>selectedChunkSkipList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32</name></type> <name>chunkCount</name> <init>= <expr><name><name>selectedChunkSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>ColumnBuffers</name> <modifier>*</modifier></type><name>columnBuffers</name> <init>= <expr><call><name>LoadColumnBuffers</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>chunkSkipNode</name></expr></argument>,
															 <argument><expr><name>chunkCount</name></expr></argument>,
															 <argument><expr><name><name>stripeMetadata</name><operator>-&gt;</operator><name>fileOffset</name></name></expr></argument>,
															 <argument><expr><name>attributeForm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>columnBuffersArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>columnBuffers</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StripeBuffers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnCount</name></name> <operator>=</operator> <name>columnCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>rowCount</name></name> <operator>=</operator> <call><name>StripeSkipListRowCount</name><argument_list>(<argument><expr><name>selectedChunkSkipList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnBuffersArray</name></name> <operator>=</operator> <name>columnBuffersArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>selectedChunkGroupRowCounts</name></name> <operator>=</operator>
		<name><name>selectedChunkSkipList</name><operator>-&gt;</operator><name>chunkGroupRowCounts</name></name></expr>;</expr_stmt>

	<return>return <expr><name>stripeBuffers</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * LoadColumnBuffers reads serialized column data from the given file. These
 * column data are laid out as sequential chunks in the file; and chunk positions
 * and lengths are retrieved from the column chunk skip node array.
 */</comment>
<function><type><specifier>static</specifier> <name>ColumnBuffers</name> <modifier>*</modifier></type>
<name>LoadColumnBuffers</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNodeArray</name></decl></parameter>,
				  <parameter><decl><type><name>uint32</name></type> <name>chunkCount</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>stripeOffset</name></decl></parameter>,
				  <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ColumnChunkBuffers</name> <modifier>*</modifier><modifier>*</modifier></type><name>chunkBuffersArray</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><name>chunkCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnChunkBuffers</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name>chunkCount</name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnChunkBuffers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We first read the "exists" chunks. We don't read "values" array here,
	 * because "exists" chunks are stored sequentially on disk, and we want to
	 * minimize disk seeks.
	 */</comment>
	<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name>chunkCount</name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNode</name> <init>= <expr><operator>&amp;</operator><name><name>chunkSkipNodeArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>existsOffset</name> <init>= <expr><name>stripeOffset</name> <operator>+</operator> <name><name>chunkSkipNode</name><operator>-&gt;</operator><name>existsChunkOffset</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>rawExistsBuffer</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>rawExistsBuffer</name></expr></argument>, <argument><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>existsLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawExistsBuffer</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>chunkSkipNode</name><operator>-&gt;</operator><name>existsLength</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ColumnarStorageRead</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>existsOffset</name></expr></argument>, <argument><expr><name><name>rawExistsBuffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							<argument><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>existsLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name><operator>-&gt;</operator><name>existsBuffer</name> <operator>=</operator> <name>rawExistsBuffer</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* then read "values" chunks, which are also stored sequentially on disk */</comment>
	<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name>chunkCount</name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNode</name> <init>= <expr><operator>&amp;</operator><name><name>chunkSkipNodeArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CompressionType</name></type> <name>compressionType</name> <init>= <expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>valueCompressionType</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>valueOffset</name> <init>= <expr><name>stripeOffset</name> <operator>+</operator> <name><name>chunkSkipNode</name><operator>-&gt;</operator><name>valueChunkOffset</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>rawValueBuffer</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>rawValueBuffer</name></expr></argument>, <argument><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>valueLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rawValueBuffer</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>chunkSkipNode</name><operator>-&gt;</operator><name>valueLength</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ColumnarStorageRead</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>valueOffset</name></expr></argument>, <argument><expr><name><name>rawValueBuffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,
							<argument><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>valueLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name><operator>-&gt;</operator><name>valueBuffer</name> <operator>=</operator> <name>rawValueBuffer</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name><operator>-&gt;</operator><name>valueCompressionType</name> <operator>=</operator> <name>compressionType</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name><operator>-&gt;</operator><name>decompressedValueSize</name> <operator>=</operator>
			<name><name>chunkSkipNode</name><operator>-&gt;</operator><name>decompressedValueSize</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>ColumnBuffers</name> <modifier>*</modifier></type><name>columnBuffers</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ColumnBuffers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>columnBuffers</name><operator>-&gt;</operator><name>chunkBuffersArray</name></name> <operator>=</operator> <name>chunkBuffersArray</name></expr>;</expr_stmt>

	<return>return <expr><name>columnBuffers</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SelectedChunkMask walks over each column's chunks and checks if a chunk can
 * be filtered without reading its data. The filtering happens when all rows in
 * the chunk can be refuted by the given qualifier conditions.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name> <modifier>*</modifier></type>
<name>SelectedChunkMask</name><parameter_list>(<parameter><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseVars</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>chunkGroupsFiltered</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>columnCell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>selectedChunkMask</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>selectedChunkMask</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>columnCell</argument>, <argument>whereClauseVars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>column</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>columnCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><name><name>column</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* if this column's data type doesn't have a comparator, skip it */</comment>
		<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>comparisonFunction</name> <init>= <expr><call><name>GetFunctionInfoOrNull</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
															 <argument><expr><name>BTREE_AM_OID</name></expr></argument>,
															 <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>comparisonFunction</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>baseConstraint</name> <init>= <expr><call><name>BuildBaseConstraint</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNodeArray</name> <init>=
				<expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier></type><name>chunkSkipNode</name> <init>= <expr><operator>&amp;</operator><name><name>chunkSkipNodeArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * A column chunk with comparable data type can miss min/max values
			 * if all values in the chunk are NULL.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>hasMinMax</name></name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>UpdateConstraint</name><argument_list>(<argument><expr><name>baseConstraint</name></expr></argument>, <argument><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>minimumValue</name></name></expr></argument>,
							 <argument><expr><name><name>chunkSkipNode</name><operator>-&gt;</operator><name>maximumValue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>constraintList</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>baseConstraint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>predicateRefuted</name> <init>=
				<expr><call><name>predicate_refuted_by</name><argument_list>(<argument><expr><name>constraintList</name></expr></argument>, <argument><expr><name>whereClauseList</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>predicateRefuted</name> <operator>&amp;&amp;</operator> <name><name>selectedChunkMask</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>selectedChunkMask</name><index>[<expr><name>chunkIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>chunkGroupsFiltered</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<return>return <expr><name>selectedChunkMask</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetFunctionInfoOrNull first resolves the operator for the given data type,
 * access method, and support procedure. The function then uses the resolved
 * operator's identifier to fill in a function manager object, and returns
 * this object. This function is based on a similar function from CitusDB's code.
 */</comment>
<function><type><name>FmgrInfo</name> <modifier>*</modifier></type>
<name>GetFunctionInfoOrNull</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>procedureId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>functionInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* get default operator class from pg_opclass for datum type */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorClassId</name> <init>= <expr><call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>operatorClassId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorFamilyId</name> <init>= <expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name>operatorClassId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>operatorFamilyId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorId</name> <init>= <expr><call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name>operatorFamilyId</name></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>procedureId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>operatorId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>functionInfo</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* fill in the FmgrInfo struct using the operatorId */</comment>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>operatorId</name></expr></argument>, <argument><expr><name>functionInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>functionInfo</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * BuildBaseConstraint builds and returns a base constraint. This constraint
 * implements an expression in the form of (var &lt;= max &amp;&amp; var &gt;= min), where
 * min and max values represent a chunk's min and max values. These chunk
 * values are filled in after the constraint is built. This function is based
 * on a similar function from CitusDB's shard pruning logic.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>BuildBaseConstraint</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>lessThanExpr</name> <init>= <expr><call><name>MakeOpExpression</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>greaterThanExpr</name> <init>= <expr><call><name>MakeOpExpression</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>baseConstraint</name> <init>= <expr><call><name>make_and_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>lessThanExpr</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>greaterThanExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>baseConstraint</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetClauseVars extracts the Vars from the given clauses for the purpose of
 * building constraints that can be refuted by predicate_refuted_by(). It also
 * deduplicates and sorts them.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>GetClauseVars</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseList</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>natts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We don't recurse into or include aggregates, window functions, or
	 * PHVs. We don't expect any PHVs during execution; and Vars found inside
	 * an aggregate or window function aren't going to be useful in forming
	 * constraints that can be refuted.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>whereClauseList</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier><modifier>*</modifier></type><name>deduplicate</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Var</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>deduplicate</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if they have the same varattno, the rest should be identical */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>equal</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>deduplicate</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>deduplicate</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>var</name></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>whereClauseVars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>deduplicate</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>whereClauseVars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>whereClauseVars</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>deduplicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>whereClauseVars</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * MakeOpExpression builds an operator expression node. This operator expression
 * implements the operator clause as defined by the variable and the strategy
 * number. The function is copied from CitusDB's shard pruning logic.
 */</comment>
<function><type><specifier>static</specifier> <name>OpExpr</name> <modifier>*</modifier></type>
<name>MakeOpExpression</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>strategyNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeId</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>vartype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>typeModId</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>vartypmod</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>collationId</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>varcollid</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>accessMethodId</name> <init>= <expr><name>BTREE_AM_OID</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Load the operator from system catalogs */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorId</name> <init>= <expr><call><name>GetOperatorByType</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>, <argument><expr><name>strategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>constantValue</name> <init>= <expr><call><name>makeNullConst</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>typeModId</name></expr></argument>, <argument><expr><name>collationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Now make the expression with the given variable and a null constant */</comment>
	<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expression</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>operatorId</name></expr></argument>,
												  <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* no result type yet */</comment>
												  <argument><expr><name>false</name></expr></argument>, <comment type="block">/* no return set */</comment>
												  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>variable</name></expr></argument>,
												  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>constantValue</name></expr></argument>,
												  <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>collationId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set implementing function id and result type */</comment>
	<expr_stmt><expr><name><name>expression</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>operatorId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>expression</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <call><name>get_func_rettype</name><argument_list>(<argument><expr><name><name>expression</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>expression</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetOperatorByType returns operator Oid for the given type, access method,
 * and strategy number. Note that this function incorrectly errors out when
 * the given type doesn't have its own operator but can use another compatible
 * type's default operator. The function is copied from CitusDB's shard pruning
 * logic.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>GetOperatorByType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>accessMethodId</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>strategyNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Get default operator class from pg_opclass */</comment>
	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorClassId</name> <init>= <expr><call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>accessMethodId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorFamily</name> <init>= <expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name>operatorClassId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type> <name>operatorId</name> <init>= <expr><call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>operatorFamily</name></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>typeId</name></expr></argument>, <argument><expr><name>strategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>operatorId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * UpdateConstraint updates the base constraint with the given min/max values.
 * The function is copied from CitusDB's shard pruning logic.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateConstraint</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>baseConstraint</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>minValue</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>maxValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>andExpr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>baseConstraint</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>lessThanExpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>andExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>greaterThanExpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>andExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>minNode</name> <init>= <expr><call><name>get_rightop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>greaterThanExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>maxNode</name> <init>= <expr><call><name>get_rightop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lessThanExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>minNode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>maxNode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>minConstant</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>minNode</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>maxConstant</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>maxNode</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>minConstant</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <name>minValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>maxConstant</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <name>maxValue</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>minConstant</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>maxConstant</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>minConstant</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>maxConstant</name><operator>-&gt;</operator><name>constbyval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SelectedChunkSkipList constructs a new StripeSkipList in which the
 * non-selected chunks are removed from the given stripeSkipList.
 */</comment>
<function><type><specifier>static</specifier> <name>StripeSkipList</name> <modifier>*</modifier></type>
<name>SelectedChunkSkipList</name><parameter_list>(<parameter><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>projectedColumnMask</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>selectedChunkMask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>selectedChunkCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>columnCount</name> <init>= <expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>columnCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>selectedChunkIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>selectedChunkMask</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>selectedChunkCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>ColumnChunkSkipNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>selectedChunkSkipNodeArray</name> <init>=
		<expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnChunkSkipNode</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name>columnCount</name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>firstColumn</name> <init>= <expr><name>columnIndex</name> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>selectedChunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* first column's chunk skip node is always read */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>projectedColumnMask</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>firstColumn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>selectedChunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>selectedChunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>selectedChunkCount</name> <operator>*</operator>
														  <sizeof>sizeof<argument_list>(<argument><expr><name>ColumnChunkSkipNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>selectedChunkMask</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>selectedChunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>selectedChunkIndex</name></expr>]</index></name> <operator>=</operator>
					<name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>selectedChunkIndex</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><name>selectedChunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32</name> <modifier>*</modifier></type><name>chunkGroupRowCounts</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>selectedChunkCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>selectedChunkMask</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunkGroupRowCounts</name><index>[<expr><name>selectedChunkIndex</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkGroupRowCounts</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<decl_stmt><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>selectedChunkSkipList</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StripeSkipList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>selectedChunkSkipList</name><operator>-&gt;</operator><name>chunkSkipNodeArray</name></name> <operator>=</operator> <name>selectedChunkSkipNodeArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>selectedChunkSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name> <operator>=</operator> <name>selectedChunkCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>selectedChunkSkipList</name><operator>-&gt;</operator><name>columnCount</name></name> <operator>=</operator> <name><name>stripeSkipList</name><operator>-&gt;</operator><name>columnCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>selectedChunkSkipList</name><operator>-&gt;</operator><name>chunkGroupRowCounts</name></name> <operator>=</operator> <name>chunkGroupRowCounts</name></expr>;</expr_stmt>

	<return>return <expr><name>selectedChunkSkipList</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * StripeSkipListRowCount counts the number of rows in the given stripeSkipList.
 * To do this, the function finds the first column, and sums up row counts across
 * all chunks for that column.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>StripeSkipListRowCount</name><parameter_list>(<parameter><decl><type><name>StripeSkipList</name> <modifier>*</modifier></type><name>stripeSkipList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>stripeSkipListRowCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>chunkIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name> <modifier>*</modifier></type><name>chunkGroupRowCounts</name> <init>= <expr><name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkGroupRowCounts</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>chunkIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>chunkIndex</name> <operator>&lt;</operator> <name><name>stripeSkipList</name><operator>-&gt;</operator><name>chunkCount</name></name></expr>;</condition> <incr><expr><name>chunkIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>chunkGroupRowCount</name> <init>= <expr><name><name>chunkGroupRowCounts</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>stripeSkipListRowCount</name> <operator>+=</operator> <name>chunkGroupRowCount</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>stripeSkipListRowCount</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ProjectedColumnMask returns a boolean array in which the projected columns
 * from the projected column list are marked as true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name> <modifier>*</modifier></type>
<name>ProjectedColumnMask</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>columnCount</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>projectedColumnMask</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>columnCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>attno</name></decl>;</decl_stmt>

	<macro><name>foreach_int</name><argument_list>(<argument>attno</argument>, <argument>projectedColumnList</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/* attno is 1-indexed; projectedColumnMask is 0-indexed */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>projectedColumnMask</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>projectedColumnMask</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeserializeBoolArray reads an array of bits from the given buffer and stores
 * it in provided bool array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DeserializeBoolArray</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>boolArrayBuffer</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>boolArray</name></decl></parameter>,
					 <parameter><decl><type><name>uint32</name></type> <name>boolArrayLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>boolArrayIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>maximumBoolCount</name> <init>= <expr><name><name>boolArrayBuffer</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>boolArrayLength</name> <operator>&gt;</operator> <name>maximumBoolCount</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient data for reading boolean array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>boolArrayIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>boolArrayIndex</name> <operator>&lt;</operator> <name>boolArrayLength</name></expr>;</condition> <incr><expr><name>boolArrayIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type> <name>byteIndex</name> <init>= <expr><name>boolArrayIndex</name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type> <name>bitIndex</name> <init>= <expr><name>boolArrayIndex</name> <operator>%</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type> <name>bitmask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitIndex</name><operator>)</operator></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>uint8</name></type> <name>shiftedBit</name> <init>= <expr><operator>(</operator><name><name>boolArrayBuffer</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>byteIndex</name></expr>]</index></name> <operator>&amp;</operator> <name>bitmask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>shiftedBit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>boolArray</name><index>[<expr><name>boolArrayIndex</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>boolArray</name><index>[<expr><name>boolArrayIndex</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * DeserializeDatumArray reads an array of datums from the given buffer and stores
 * them in provided datumArray. If a value is marked as false in the exists array,
 * the function assumes that the datum isn't in the buffer, and simply skips it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DeserializeDatumArray</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>datumBuffer</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>existsArray</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>datumCount</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>datumTypeByValue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>datumTypeLength</name></decl></parameter>,
					  <parameter><decl><type><name>char</name></type> <name>datumTypeAlign</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>datumArray</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>datumIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>currentDatumDataOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>datumIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>datumIndex</name> <operator>&lt;</operator> <name>datumCount</name></expr>;</condition> <incr><expr><name>datumIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>existsArray</name><index>[<expr><name>datumIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>currentDatumDataPointer</name> <init>= <expr><name><name>datumBuffer</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>currentDatumDataOffset</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>datumArray</name><index>[<expr><name>datumIndex</name></expr>]</index></name> <operator>=</operator> <call><name>fetch_att</name><argument_list>(<argument><expr><name>currentDatumDataPointer</name></expr></argument>, <argument><expr><name>datumTypeByValue</name></expr></argument>,
										   <argument><expr><name>datumTypeLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>currentDatumDataOffset</name> <operator>=</operator> <call><name>att_addlength_datum</name><argument_list>(<argument><expr><name>currentDatumDataOffset</name></expr></argument>,
													 <argument><expr><name>datumTypeLength</name></expr></argument>,
													 <argument><expr><name>currentDatumDataPointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>currentDatumDataOffset</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>currentDatumDataOffset</name></expr></argument>,
												   <argument><expr><name>datumTypeAlign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>currentDatumDataOffset</name> <operator>&gt;</operator> <name><name>datumBuffer</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient data left in datum buffer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * DeserializeChunkGroupData deserializes requested data chunk for all columns and
 * stores in chunkDataArray. It uncompresses serialized data if necessary. The
 * function also deallocates data buffers used for previous chunk, and compressed
 * data buffers for the current chunk which will not be needed again. If a column
 * data is not present serialized buffer, then default value (or null) is used
 * to fill value array.
 */</comment>
<function><type><specifier>static</specifier> <name>ChunkData</name> <modifier>*</modifier></type>
<name>DeserializeChunkData</name><parameter_list>(<parameter><decl><type><name>StripeBuffers</name> <modifier>*</modifier></type><name>stripeBuffers</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>chunkIndex</name></decl></parameter>,
					 <parameter><decl><type><name>uint32</name></type> <name>rowCount</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>projectedColumnList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>columnIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>columnMask</name> <init>= <expr><call><name>ProjectedColumnMask</name><argument_list>(<argument><expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name>projectedColumnList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkData</name> <modifier>*</modifier></type><name>chunkData</name> <init>= <expr><call><name>CreateEmptyChunkData</name><argument_list>(<argument><expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name>columnMask</name></expr></argument>,
												<argument><expr><name>rowCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>columnIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>columnIndex</name> <operator>&lt;</operator> <name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnCount</name></name></expr>;</condition> <incr><expr><name>columnIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>columnIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnBuffers</name> <modifier>*</modifier></type><name>columnBuffers</name> <init>= <expr><name><name>stripeBuffers</name><operator>-&gt;</operator><name>columnBuffersArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>columnAdded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>columnBuffers</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>columnMask</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>columnAdded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>columnBuffers</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ColumnChunkBuffers</name> <modifier>*</modifier></type><name>chunkBuffers</name> <init>=
				<expr><name><name>columnBuffers</name><operator>-&gt;</operator><name>chunkBuffersArray</name><index>[<expr><name>chunkIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* decompress and deserialize current chunk's data */</comment>
			<decl_stmt><decl><type><name>StringInfo</name></type> <name>valueBuffer</name> <init>=
				<expr><call><name>DecompressBuffer</name><argument_list>(<argument><expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>valueBuffer</name></name></expr></argument>,
								 <argument><expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>valueCompressionType</name></name></expr></argument>,
								 <argument><expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>decompressedValueSize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>DeserializeBoolArray</name><argument_list>(<argument><expr><name><name>chunkBuffers</name><operator>-&gt;</operator><name>existsBuffer</name></name></expr></argument>,
								 <argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>,
								 <argument><expr><name>rowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DeserializeDatumArray</name><argument_list>(<argument><expr><name>valueBuffer</name></expr></argument>, <argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name>rowCount</name></expr></argument>, <argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>,
								  <argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>, <argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>,
								  <argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* store current chunk's data buffer to be freed at next chunk read */</comment>
			<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueBufferArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name> <operator>=</operator> <name>valueBuffer</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>columnAdded</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This is a column that was added after creation of this stripe.
			 * So we use either the default value or NULL.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>attributeForm</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>rowIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<decl_stmt><decl><type><name>Datum</name></type> <name>defaultValue</name> <init>= <expr><call><name>ColumnDefaultValue</name><argument_list>(<argument><expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>constr</name></name></expr></argument>,
														<argument><expr><name>attributeForm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>rowIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rowIndex</name> <operator>&lt;</operator> <name>rowCount</name></expr>;</condition> <incr><expr><name>rowIndex</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>rowIndex</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>chunkData</name><operator>-&gt;</operator><name>valueArray</name><index>[<expr><name>columnIndex</name></expr>]</index><index>[<expr><name>rowIndex</name></expr>]</index></name> <operator>=</operator> <name>defaultValue</name></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>chunkData</name><operator>-&gt;</operator><name>existsArray</name><index>[<expr><name>columnIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					   <argument><expr><name>rowCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>chunkData</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ColumnDefaultValue returns default value for given column. Only const values
 * are supported. The function errors on any other default value expressions.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ColumnDefaultValue</name><parameter_list>(<parameter><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>tupleConstraints</name></decl></parameter>, <parameter><decl><type><name>Form_pg_attribute</name></type> <name>attributeForm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>defaultValueNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>defValIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>defValIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>defValIndex</name> <operator>&lt;</operator> <name><name>tupleConstraints</name><operator>-&gt;</operator><name>num_defval</name></name></expr>;</condition> <incr><expr><name>defValIndex</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrDefault</name></type> <name>attrDefault</name> <init>= <expr><name><name>tupleConstraints</name><operator>-&gt;</operator><name>defval</name><index>[<expr><name>defValIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>attrDefault</name><operator>.</operator><name>adnum</name></name> <operator>==</operator> <name><name>attributeForm</name><operator>-&gt;</operator><name>attnum</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>defaultValueNode</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>attrDefault</name><operator>.</operator><name>adbin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultValueNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* try reducing the default value node to a const node */</comment>
	<expr_stmt><expr><name>defaultValueNode</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>defaultValueNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>defaultValueNode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>constNode</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>defaultValueNode</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><name><name>constNode</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>columnName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attributeForm</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported default value for column \"%s\""</literal></expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Expression is either mutable or "</literal>
								<literal type="string">"does not evaluate to constant value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
