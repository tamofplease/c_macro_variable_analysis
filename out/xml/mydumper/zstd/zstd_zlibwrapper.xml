<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/mydumper/zstd/zstd_zlibwrapper.c"><comment type="block">/*
 * Copyright (c) 2016-2021, Przemyslaw Skibinski, Yann Collet, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 */</comment>


<comment type="block">/* ===   Tuning parameters   === */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZWRAP_USE_ZSTD</name></cpp:ifndef>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZWRAP_USE_ZSTD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* ===   Dependencies   === */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>                 <comment type="block">/* vsprintf */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>                <comment type="block">/* va_list, for z_gzprintf */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_DUMMY_DECL</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZLIB_CONST</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>                  <comment type="block">/* without #define Z_PREFIX */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd_zlibwrapper.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_STATIC_LINKING_ONLY</name></cpp:macro></cpp:define>   <comment type="block">/* ZSTD_isFrame, ZSTD_MAGICNUMBER, ZSTD_customMem */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zstd.h"</cpp:file></cpp:include>


<comment type="block">/* ===   Constants   === */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_INFLATE_SYNC</name></cpp:macro>              <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZLIB_HEADERSIZE</name></cpp:macro>             <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_HEADERSIZE</name></cpp:macro>             <cpp:value>ZSTD_FRAMEHEADERSIZE_MIN(ZSTD_f_zstd1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZWRAP_DEFAULT_CLEVEL</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>   <comment type="block">/* Z_DEFAULT_COMPRESSION is translated to ZWRAP_DEFAULT_CLEVEL for zstd */</comment>


<comment type="block">/* ===   Debug   === */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_WRAPPERC</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>  <comment type="block">/* fprintf(stderr, __VA_ARGS__) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_WRAPPERD</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>  <comment type="block">/* fprintf(stderr, __VA_ARGS__) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FINISH_WITH_GZ_ERR</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ (void)msg; return Z_STREAM_ERROR; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FINISH_WITH_NULL_ERR</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ (void)msg; return NULL; }</cpp:value></cpp:define>

<comment type="block">/* ===   Utility   === */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; (y) ? (x) : (y))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>ZWRAP_isLittleEndian</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <union><specifier>const</specifier> union <block>{ <decl_stmt><decl><type><name>unsigned</name></type> <name>u</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> }</block> <decl><name>one</name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</union>   <comment type="block">/* don't use static : performance detrimental  */</comment>
    <return>return <expr><name><name>one</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__has_builtin</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>__has_builtin</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>ZWRAP_swap32</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>in</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>     <comment type="block">/* Visual Studio */</comment>
    <return>return <expr><call><name>_byteswap_ulong</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name> <argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC__</name> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <name>__GNUC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">403</literal><operator>)</operator><operator>)</operator> \
  <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>__has_builtin</name><argument_list>(<argument><expr><name>__builtin_bswap32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>
    <return>return <expr><call><name>__builtin_bswap32</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return  <expr><operator>(</operator><operator>(</operator><name>in</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff000000</literal> <operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>in</name> <operator>&lt;&lt;</operator>  <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x00ff0000</literal> <operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>in</name> <operator>&gt;&gt;</operator>  <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0000ff00</literal> <operator>)</operator> <operator>|</operator>
            <operator>(</operator><operator>(</operator><name>in</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x000000ff</literal> <operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>ZWRAP_readLE32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>value</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ZWRAP_isLittleEndian</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>value</name></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>ZWRAP_swap32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* ===   Wrapper   === */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>g_ZWRAP_useZSTDcompression</name> <init>= <expr><name>ZWRAP_USE_ZSTD</name></expr></init></decl>;</decl_stmt> <comment type="block">/* 0 = don't use ZSTD */</comment>

<function><type><name>void</name></type> <name>ZWRAP_useZSTDcompression</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>turn_on</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>g_ZWRAP_useZSTDcompression</name> <operator>=</operator> <name>turn_on</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>int</name></type> <name>ZWRAP_isUsingZSTDcompression</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>g_ZWRAP_useZSTDcompression</name></expr>;</return> </block_content>}</block></function>



<decl_stmt><decl><type><specifier>static</specifier> <name>ZWRAP_decompress_type</name></type> <name>g_ZWRAPdecompressionType</name> <init>= <expr><name>ZWRAP_AUTO</name></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>ZWRAP_setDecompressionType</name><parameter_list>(<parameter><decl><type><name>ZWRAP_decompress_type</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>g_ZWRAPdecompressionType</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>ZWRAP_decompress_type</name></type> <name>ZWRAP_getDecompressionType</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>g_ZWRAPdecompressionType</name></expr>;</return> </block_content>}</block></function>



<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>zstdVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>ZSTD_VERSION_STRING</name></expr>;</return> </block_content>}</block></function>

<decl_stmt><decl><type><name>ZEXTERN</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <name>ZEXPORT</name> <name>z_zlibVersion</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator></expr></argument>)</argument_list> <block>{<block_content> <return>return <expr><call><name>zlibVersion</name><argument_list>()</argument_list></call></expr>;</return>  </block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>ZWRAP_allocFunction</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name> <init>= <expr><operator>(</operator><name>z_streamp</name><operator>)</operator> <name>opaque</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>address</name> <init>= <expr><call><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>opaque</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>uInt</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* LOG_WRAPPERC("ZWRAP alloc %p, %d \n", address, (int)size); */</comment>
    <return>return <expr><name>address</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZWRAP_freeFunction</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>opaque</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name> <init>= <expr><operator>(</operator><name>z_streamp</name><operator>)</operator> <name>opaque</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>opaque</name></name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <comment type="block">/* if (address) LOG_WRAPPERC("ZWRAP free %p \n", address); */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>ZWRAP_customMalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name><argument_list>(<argument><expr><name><name>customMem</name><operator>.</operator><name>opaque</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>ZWRAP_customCalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* calloc implemented as malloc+memset;
         * not as efficient as calloc, but next best guess for custom malloc */</comment>
        <decl_stmt><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier></type> <name>ptr</name> <init>= <expr><call><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name><argument_list>(<argument><expr><name><name>customMem</name><operator>.</operator><name>opaque</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ptr</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ZWRAP_customFree</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ptr</name><operator>!=</operator><name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>customMem</name><operator>.</operator><name>customFree</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name><name>customMem</name><operator>.</operator><name>customFree</name></name><argument_list>(<argument><expr><name><name>customMem</name><operator>.</operator><name>opaque</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<comment type="block">/* ===   Compression   === */</comment>
<typedef>typedef <type><enum>enum <block>{ <decl><name>ZWRAP_useInit</name></decl>, <decl><name>ZWRAP_useReset</name></decl>, <decl><name>ZWRAP_streamEnd</name></decl> }</block></enum></type> <name>ZWRAP_state_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zbc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>compressionLevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>streamEnd</name></decl>;</decl_stmt> <comment type="block">/* a flag to signal the end of a stream */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>totalInBytes</name></decl>;</decl_stmt> <comment type="block">/* we need it as strm-&gt;total_in can be reset by user */</comment>
    <decl_stmt><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_stream</name></type> <name>allocFunc</name></decl>;</decl_stmt> <comment type="block">/* copy of zalloc, zfree, opaque */</comment>
    <decl_stmt><decl><type><name>ZSTD_inBuffer</name></type> <name>inBuffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_outBuffer</name></type> <name>outBuffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZWRAP_state_t</name></type> <name>comprState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pledgedSrcSize</name></decl>;</decl_stmt>
}</block></struct></type> <name>ZWRAP_CCtx</name>;</typedef>

<comment type="block">/* typedef ZWRAP_CCtx internal_state; */</comment>



<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZWRAP_freeCCtx</name><parameter_list>(<parameter><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>zwc</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* support free on NULL */</comment>
    <expr_stmt><expr><call><name>ZSTD_freeCStream</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZWRAP_customFree</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>ZWRAP_createCCtx</name><parameter_list>(<parameter><decl><type><name>z_streamp</name></type> <name>strm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name> <operator>=</operator> <name>ZWRAP_allocFunction</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>customMem</name><operator>.</operator><name>customFree</name></name> <operator>=</operator> <name>ZWRAP_freeFunction</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>customMem</name><operator>.</operator><name>opaque</name></name> <operator>=</operator> <name>strm</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>zwc</name> <operator>=</operator> <operator>(</operator><name>ZWRAP_CCtx</name><operator>*</operator><operator>)</operator><call><name>ZWRAP_customCalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZWRAP_CCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>zwc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>allocFunc</name></name> <operator>=</operator> <operator>*</operator><name>strm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>customMem</name><operator>.</operator><name>opaque</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>zwc</name><operator>-&gt;</operator><name>allocFunc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>customMem</name></name> <operator>=</operator> <name>customMem</name></expr>;</expr_stmt>

    <return>return <expr><name>zwc</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>ZWRAP_initializeCStream</name><parameter_list>(<parameter><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>dict</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dictSize</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- ZWRAP_initializeCStream=%p\n"</literal></expr></argument>, <argument><expr><name>zwc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>zwc</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pledgedSrcSize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pledgedSrcSize</name> <operator>=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>pledgedSrcSize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>unsigned</name></type> <name>initErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_parameters</name> <specifier>const</specifier></type> <name>params</name> <init>= <expr><call><name>ZSTD_getParams</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZSTD_CCtx_params</name><modifier>*</modifier></type> <name>cctxParams</name> <init>= <expr><call><name>ZSTD_createCCtxParams</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cctxParams</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"pledgedSrcSize=%d windowLog=%d chainLog=%d hashLog=%d searchLog=%d minMatch=%d strategy=%d\n"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>pledgedSrcSize</name></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>windowLog</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>chainLog</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>hashLog</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>searchLog</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>minMatch</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>.</operator><name>cParams</name><operator>.</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>initErr</name> <operator>|=</operator> <call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>initErr</name> <operator>|=</operator> <call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_CCtxParams_init_advanced</name><argument_list>(<argument><expr><name>cctxParams</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>initErr</name> <operator>|=</operator> <call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_CCtx_setParametersUsingCCtxParams</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name></expr></argument>, <argument><expr><name>cctxParams</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>initErr</name> <operator>|=</operator> <call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_CCtx_setPledgedSrcSize</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name></expr></argument>, <argument><expr><name>pledgedSrcSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>initErr</name> <operator>|=</operator> <call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_CCtx_loadDictionary</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name></expr></argument>, <argument><expr><name>dict</name></expr></argument>, <argument><expr><name>dictSize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ZSTD_freeCCtxParams</name><argument_list>(<argument><expr><name>cctxParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>initErr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>ZWRAPC_finishWithError</name><parameter_list>(<parameter><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name></decl></parameter>, <parameter><decl><type><name>z_streamp</name></type> <name>strm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- ZWRAPC_finishWithError=%d\n"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>zwc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZWRAP_freeCCtx</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>strm</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>error</name><operator>)</operator></expr> ?</condition><then> <expr><name>error</name></expr> </then><else>: <expr><name>Z_STREAM_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>ZWRAPC_finishWithErrorMsg</name><parameter_list>(<parameter><decl><type><name>z_streamp</name></type> <name>strm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name> <init>= <expr><operator>(</operator><name>ZWRAP_CCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>message</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>zwc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>ZWRAP_setPledgedSrcSize</name><parameter_list>(<parameter><decl><type><name>z_streamp</name></type> <name>strm</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>pledgedSrcSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name> <init>= <expr><operator>(</operator><name>ZWRAP_CCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>zwc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>pledgedSrcSize</name></name> <operator>=</operator> <name>pledgedSrcSize</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>comprState</name></name> <operator>=</operator> <name>ZWRAP_useInit</name></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>internal_state</name></name><modifier>*</modifier></type> <name>convert_into_sis</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator>struct <name>internal_state</name><operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflateInit_</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator> <name>int</name> <name>level</name><operator>,</operator>
                                     <specifier>const</specifier> <name>char</name> <operator>*</operator><name>version</name><operator>,</operator> <name>int</name> <name>stream_size</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- deflateInit level=%d\n"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>deflateInit_</name><argument_list>(<argument><expr><operator>(</operator><name>strm</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>level</name><operator>)</operator></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>zwc</name> <operator>=</operator> <call><name>ZWRAP_createCCtx</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>zwc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_MEM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>level</name> <operator>=</operator> <name>ZWRAP_DEFAULT_CLEVEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>streamEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>compressionLevel</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <call><name>convert_into_sis</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* use state which in not used by user */</comment>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflateInit2_</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator> <name>int</name> <name>level</name><operator>,</operator> <name>int</name> <name>method</name><operator>,</operator>
                                      <name>int</name> <name>windowBits</name><operator>,</operator> <name>int</name> <name>memLevel</name><operator>,</operator>
                                      <name>int</name> <name>strategy</name><operator>,</operator> <specifier>const</specifier> <name>char</name> <operator>*</operator><name>version</name><operator>,</operator>
                                      <name>int</name> <name>stream_size</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>deflateInit2_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name>windowBits</name></expr></argument>, <argument><expr><name>memLevel</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>z_deflateInit_</name> <argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><name>int</name></type> <name>ZWRAP_deflateReset_keepDict</name><parameter_list>(<parameter><decl><type><name>z_streamp</name></type> <name>strm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- ZWRAP_deflateReset_keepDict\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>deflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content> <decl_stmt><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name> <init>= <expr><operator>(</operator><name>ZWRAP_CCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>zwc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>streamEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflateReset</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- deflateReset\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>deflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>ZWRAP_deflateReset_keepDict</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <block>{<block_content> <decl_stmt><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name> <init>= <expr><operator>(</operator><name>ZWRAP_CCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>zwc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>comprState</name></name> <operator>=</operator> <name>ZWRAP_useInit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflateSetDictionary</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                             <specifier>const</specifier> <name>Bytef</name> <operator>*</operator><name>dictionary</name><operator>,</operator>
                                             <name>uInt</name>  <name>dictLength</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- deflateSetDictionary\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>deflateSetDictionary</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name> <init>= <expr><operator>(</operator><name>ZWRAP_CCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- deflateSetDictionary level=%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwc</name><operator>-&gt;</operator><name>compressionLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zwc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name> <operator>=</operator> <call><name>ZSTD_createCStream_advanced</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <block>{<block_content> <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>ZWRAP_initializeCStream</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>, <argument><expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> </block_content>}</block>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>comprState</name></name> <operator>=</operator> <name>ZWRAP_useReset</name></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflate</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- deflate1 flush=%d avail_in=%d avail_out=%d total_in=%d total_out=%d\n"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>flush</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>deflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>zwc</name> <operator>=</operator> <operator>(</operator><name>ZWRAP_CCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>zwc</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"zwc == NULL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return> </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name> <operator>=</operator> <call><name>ZSTD_createCStream_advanced</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <block>{<block_content> <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>initErr</name> <init>= <expr><call><name>ZWRAP_initializeCStream</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>flush</name> <operator>==</operator> <name>Z_FINISH</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr> </then><else>: <expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>initErr</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>!=</operator> <name>Z_FINISH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>comprState</name></name> <operator>=</operator> <name>ZWRAP_useReset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>zwc</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>zwc</name><operator>-&gt;</operator><name>comprState</name></name> <operator>==</operator> <name>ZWRAP_useReset</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name></type> <name>resetErr</name> <init>= <expr><call><name>ZSTD_CCtx_reset</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>resetErr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"ERROR: ZSTD_CCtx_reset errorCode=%s\n"</literal></expr></argument>,
                                <argument><expr><call><name>ZSTD_getErrorName</name><argument_list>(<argument><expr><name>resetErr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>resetErr</name> <operator>=</operator> <call><name>ZSTD_CCtx_setPledgedSrcSize</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>flush</name> <operator>==</operator> <name>Z_FINISH</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr> </then><else>: <expr><name><name>zwc</name><operator>-&gt;</operator><name>pledgedSrcSize</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>resetErr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"ERROR: ZSTD_CCtx_setPledgedSrcSize errorCode=%s\n"</literal></expr></argument>,
                                <argument><expr><call><name>ZSTD_getErrorName</name><argument_list>(<argument><expr><name>resetErr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>res</name> <init>= <expr><call><name>ZWRAP_initializeCStream</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>flush</name> <operator>==</operator> <name>Z_FINISH</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr> </then><else>: <expr><name>ZSTD_CONTENTSIZE_UNKNOWN</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>!=</operator> <name>Z_FINISH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>comprState</name></name> <operator>=</operator> <name>ZWRAP_useReset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>  <comment type="block">/* (zwc-&gt;totalInBytes == 0) */</comment>
    </block_content>}</block></else></if_stmt>  <comment type="block">/* ! (zwc-&gt;zbc == NULL) */</comment>

    <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- deflate2 flush=%d avail_in=%d avail_out=%d total_in=%d total_out=%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>flush</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>src</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <block>{<block_content> <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cErr</name> <init>= <expr><call><name>ZSTD_compressStream</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zwc</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"deflate ZSTD_compressStream srcSize=%d dstCapacity=%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwc</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cErr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>+=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>-=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>+=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>+=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>+=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>-=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FULL_FLUSH</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZLIB_VERNUM</name> <operator>&gt;=</operator> <literal type="number">0x1240</literal></expr></cpp:if>
        <operator>||</operator> <name>flush</name> <operator>==</operator> <name>Z_TREES</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <operator>||</operator> <name>flush</name> <operator>==</operator> <name>Z_BLOCK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>ZWRAPC_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"Z_FULL_FLUSH, Z_BLOCK and Z_TREES are not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>bytesLeft</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>zwc</name><operator>-&gt;</operator><name>streamEnd</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_END</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>bytesLeft</name> <operator>=</operator> <call><name>ZSTD_endStream</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"deflate ZSTD_endStream dstCapacity=%d bytesLeft=%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>bytesLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>bytesLeft</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>+=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>-=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bytesLeft</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>streamEnd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"Z_STREAM_END2 strm-&gt;total_in=%d strm-&gt;avail_out=%d strm-&gt;total_out=%d\n"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>Z_STREAM_END</name></expr>;</return>
    </block_content>}</block></if></if_stmt>   </block_content>}</block></if>
    <if type="elseif">else
    if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_SYNC_FLUSH</name> <operator>||</operator> <name>flush</name> <operator>==</operator> <name>Z_PARTIAL_FLUSH</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>bytesLeft</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>bytesLeft</name> <operator>=</operator> <call><name>ZSTD_flushStream</name><argument_list>(<argument><expr><name><name>zwc</name><operator>-&gt;</operator><name>zbc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"deflate ZSTD_flushStream dstCapacity=%d bytesLeft=%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>bytesLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>bytesLeft</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPC_finishWithError</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>+=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>-=</operator> <name><name>zwc</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- deflate3 flush=%d avail_in=%d avail_out=%d total_in=%d total_out=%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>flush</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflateEnd</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- deflateEnd\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>deflateEnd</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- deflateEnd total_in=%d total_out=%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>errorCode</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ZWRAP_CCtx</name><modifier>*</modifier></type> <name>zwc</name> <init>= <expr><operator>(</operator><name>ZWRAP_CCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>zwc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_OK</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* structures are already freed */</comment>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>errorCode</name> <operator>=</operator> <call><name>ZWRAP_freeCCtx</name><argument_list>(<argument><expr><name>zwc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>errorCode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>z_deflateBound</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                       <name>uLong</name> <name>sourceLen</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>deflateBound</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>ZSTD_compressBound</name><argument_list>(<argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflateParams</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                      <name>int</name> <name>level</name><operator>,</operator>
                                      <name>int</name> <name>strategy</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LOG_WRAPPERC</name><argument_list>(<argument><expr><literal type="string">"- deflateParams level=%d strategy=%d\n"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>deflateParams</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<comment type="block">/* ===   Decompression   === */</comment>

<typedef>typedef <type><enum>enum <block>{ <decl><name>ZWRAP_ZLIB_STREAM</name></decl>, <decl><name>ZWRAP_ZSTD_STREAM</name></decl>, <decl><name>ZWRAP_UNKNOWN_STREAM</name></decl> }</block></enum></type> <name>ZWRAP_stream_type</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>zbd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>headerBuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* must be &gt;= ZSTD_frameHeaderSize_min */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>errorCount</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>totalInBytes</name></decl>;</decl_stmt> <comment type="block">/* we need it as strm-&gt;total_in can be reset by user */</comment>
    <decl_stmt><decl><type><name>ZWRAP_state_t</name></type> <name>decompState</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_inBuffer</name></type> <name>inBuffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_outBuffer</name></type> <name>outBuffer</name></decl>;</decl_stmt>

    <comment type="block">/* zlib params */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>stream_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>windowBits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_stream</name></type> <name>allocFunc</name></decl>;</decl_stmt> <comment type="block">/* just to copy zalloc, zfree, opaque */</comment>
}</block></struct></type> <name>ZWRAP_DCtx</name>;</typedef>


<function><type><specifier>static</specifier> <name>void</name></type> <name>ZWRAP_initDCtx</name><parameter_list>(<parameter><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier></type> <name>zwd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>errorCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ZWRAP_DCtx</name><modifier>*</modifier></type> <name>ZWRAP_createDCtx</name><parameter_list>(<parameter><decl><type><name>z_streamp</name></type> <name>strm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier></type> <name>zwd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ZSTD_customMem</name></type> <name>customMem</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>zfree</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>customMem</name><operator>.</operator><name>customAlloc</name></name> <operator>=</operator> <name>ZWRAP_allocFunction</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>customMem</name><operator>.</operator><name>customFree</name></name> <operator>=</operator> <name>ZWRAP_freeFunction</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>customMem</name><operator>.</operator><name>opaque</name></name> <operator>=</operator> <name>strm</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>zwd</name> <operator>=</operator> <operator>(</operator><name>ZWRAP_DCtx</name><operator>*</operator><operator>)</operator><call><name>ZWRAP_customCalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ZWRAP_DCtx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>customMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>zwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>allocFunc</name></name> <operator>=</operator> <operator>*</operator><name>strm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>customMem</name><operator>.</operator><name>opaque</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>zwd</name><operator>-&gt;</operator><name>allocFunc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>customMem</name></name> <operator>=</operator> <name>customMem</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZWRAP_initDCtx</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>zwd</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>ZWRAP_freeDCtx</name><parameter_list>(<parameter><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier></type> <name>zwd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>zwd</name><operator>==</operator><name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* support free on null */</comment>
    <expr_stmt><expr><call><name>ZSTD_freeDStream</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZWRAP_customFree</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZWRAP_customFree</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>ZWRAP_isUsingZSTDdecompression</name><parameter_list>(<parameter><decl><type><name>z_streamp</name></type> <name>strm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>strm</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name> <operator>==</operator> <name>ZWRAP_ZSTD_STREAM</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>ZWRAPD_finishWithError</name><parameter_list>(<parameter><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier></type> <name>zwd</name></decl></parameter>, <parameter><decl><type><name>z_streamp</name></type> <name>strm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- ZWRAPD_finishWithError=%d\n"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZWRAP_freeDCtx</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>error</name><operator>)</operator></expr> ?</condition><then> <expr><name>error</name></expr> </then><else>: <expr><name>Z_STREAM_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ZWRAPD_finishWithErrorMsg</name><parameter_list>(<parameter><decl><type><name>z_streamp</name></type> <name>strm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>zwd</name> <init>= <expr><operator>(</operator><name>ZWRAP_DCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>message</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>zwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>ZWRAPD_finishWithError</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateInit_</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                     <specifier>const</specifier> <name>char</name><operator>*</operator> <name>version</name><operator>,</operator> <name>int</name> <name>stream_size</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <name>ZWRAP_ZLIB_STREAM</name></expr>;</expr_stmt>
        <return>return <expr><call><name>inflateInit</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>zwd</name> <init>= <expr><call><name>ZWRAP_createDCtx</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- inflateInit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>zwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPD_finishWithError</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>ZWRAP_customMalloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>version</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPD_finishWithError</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>stream_size</name></name> <operator>=</operator> <name>stream_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <call><name>convert_into_sis</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <name>ZWRAP_UNKNOWN_STREAM</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>adler</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateInit2_</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator> <name>int</name>  <name>windowBits</name><operator>,</operator>
                                      <specifier>const</specifier> <name>char</name> <operator>*</operator><name>version</name><operator>,</operator> <name>int</name> <name>stream_size</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>inflateInit2_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>windowBits</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>z_inflateInit_</name> <argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- inflateInit2 windowBits=%d\n"</literal></expr></argument>, <argument><expr><name>windowBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Z_OK</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>zwd</name> <init>= <expr><operator>(</operator><name>ZWRAP_DCtx</name><operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>zwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>windowBits</name></name> <operator>=</operator> <name>windowBits</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>ret</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></decl></decl_stmt>

<function><type><name>int</name></type> <name>ZWRAP_inflateReset_keepDict</name><parameter_list>(<parameter><decl><type><name>z_streamp</name></type> <name>strm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- ZWRAP_inflateReset_keepDict\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>zwd</name> <init>= <expr><operator>(</operator><name>ZWRAP_DCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>zwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ZWRAP_initDCtx</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>decompState</name></name> <operator>=</operator> <name>ZWRAP_useReset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateReset</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- inflateReset\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content> <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>ZWRAP_inflateReset_keepDict</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt> </block_content>}</block>

    <block>{<block_content> <decl_stmt><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>zwd</name> <init>= <expr><operator>(</operator><name>ZWRAP_DCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>zwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>decompState</name></name> <operator>=</operator> <name>ZWRAP_useInit</name></expr>;</expr_stmt> </block_content>}</block>

    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZLIB_VERNUM</name> <operator>&gt;=</operator> <literal type="number">0x1240</literal></expr></cpp:if>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateReset2</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                      <name>int</name> <name>windowBits</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateReset2</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>windowBits</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>ret</name> <init>= <expr><call><name>z_inflateReset</name> <argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Z_OK</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>zwd</name> <init>= <expr><operator>(</operator><name>ZWRAP_DCtx</name><operator>*</operator><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>zwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>windowBits</name></name> <operator>=</operator> <name>windowBits</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>ret</name></expr>;</return>
    </block_content>}</block>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateSetDictionary</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                             <specifier>const</specifier> <name>Bytef</name> <operator>*</operator><name>dictionary</name><operator>,</operator>
                                             <name>uInt</name>  <name>dictLength</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- inflateSetDictionary\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateSetDictionary</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>zwd</name> <init>= <expr><operator>(</operator><name>ZWRAP_DCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>zwd</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
        <block>{<block_content> <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>initErr</name> <init>= <expr><call><name>ZSTD_initDStream_usingDict</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPD_finishWithError</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> </block_content>}</block>
        <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>decompState</name></name> <operator>=</operator> <name>ZWRAP_useReset</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>==</operator> <name>ZSTD_HEADERSIZE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>src</name></name> <operator>=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>headerBuf</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>errorCode</name> <init>= <expr><call><name>ZSTD_decompressStream</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"inflateSetDictionary ZSTD_decompressStream errorCode=%d srcSize=%d dstCapacity=%d\n"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>errorCode</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name> <operator>||</operator> <call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>errorCode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"ERROR: ZSTD_decompressStream %s\n"</literal></expr></argument>,
                                 <argument><expr><call><name>ZSTD_getErrorName</name><argument_list>(<argument><expr><name>errorCode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>ZWRAPD_finishWithError</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>   </block_content>}</block>   </block_content>}</block></if></if_stmt>   </block_content>}</block>

    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflate</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator> <name>int</name> <name>flush</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier></type> <name>zwd</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>result</name> <init>= <expr><call><name>inflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- inflate2 flush=%d avail_in=%d avail_out=%d total_in=%d total_out=%d res=%d\n"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>flush</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_OK</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>zwd</name> <operator>=</operator> <operator>(</operator><name>ZWRAP_DCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- inflate1 flush=%d avail_in=%d avail_out=%d total_in=%d total_out=%d\n"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>flush</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>zwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>decompState</name></name> <operator>==</operator> <name>ZWRAP_streamEnd</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_END</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>&lt;</operator> <name>ZLIB_HEADERSIZE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>&gt;=</operator> <name>ZLIB_HEADERSIZE</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>ZWRAP_readLE32</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ZSTD_MAGICNUMBER</name></expr>)</condition> <block>{<block_content>
                <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>initErr</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>zwd</name><operator>-&gt;</operator><name>windowBits</name></name><operator>)</operator></expr> ?</condition><then>
                                <expr><call><name>inflateInit2_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>windowBits</name></name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>stream_size</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
                                <expr><call><name>inflateInit_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>stream_size</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"ZLIB inflateInit errorCode=%d\n"</literal></expr></argument>, <argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>initErr</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPD_finishWithError</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <name>ZWRAP_ZLIB_STREAM</name></expr>;</expr_stmt>
                <block>{<block_content> <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>freeErr</name> <init>= <expr><call><name>ZWRAP_freeDCtx</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>freeErr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt> </block_content>}</block>

                <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>result</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flush</name> <operator>==</operator> <name>Z_INFLATE_SYNC</name><operator>)</operator></expr> ?</condition><then>
                                        <expr><call><name>inflateSync</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                        <expr><call><name>inflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- inflate3 flush=%d avail_in=%d avail_out=%d total_in=%d total_out=%d res=%d\n"</literal></expr></argument>,
                                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>flush</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>result</name></expr>;</return>
            </block_content>}</block>   </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* ! (zwd-&gt;totalInBytes == 0 &amp;&amp; strm-&gt;avail_in &gt;= ZLIB_HEADERSIZE) */</comment>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>srcSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><name>ZLIB_HEADERSIZE</name> <operator>-</operator> <name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>headerBuf</name></name><operator>+</operator><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>+=</operator> <name>srcSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>+=</operator> <name>srcSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>+=</operator> <name>srcSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>-=</operator> <name>srcSize</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>&lt;</operator> <name>ZLIB_HEADERSIZE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_OK</name></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>ZWRAP_readLE32</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>headerBuf</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ZSTD_MAGICNUMBER</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>z_stream</name></type> <name>strm2</name></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>strm2</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm2</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm2</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm2</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>;</expr_stmt>

                <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>initErr</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>zwd</name><operator>-&gt;</operator><name>windowBits</name></name><operator>)</operator></expr> ?</condition><then>
                                <expr><call><name>inflateInit2_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>windowBits</name></name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>stream_size</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
                                <expr><call><name>inflateInit_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>version</name></name></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>stream_size</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"ZLIB inflateInit errorCode=%d\n"</literal></expr></argument>, <argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>initErr</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ZWRAPD_finishWithError</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>

                <comment type="block">/* inflate header */</comment>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>zwd</name><operator>-&gt;</operator><name>headerBuf</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <name>ZLIB_HEADERSIZE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>dErr</name> <init>= <expr><call><name>inflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"ZLIB inflate errorCode=%d strm-&gt;avail_in=%d\n"</literal></expr></argument>,
                                  <argument><expr><name>dErr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>dErr</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><call><name>ZWRAPD_finishWithError</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><name>dErr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>
                <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <name><name>strm2</name><operator>.</operator><name>next_in</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <name><name>strm2</name><operator>.</operator><name>avail_in</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>=</operator> <name><name>strm2</name><operator>.</operator><name>next_out</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>=</operator> <name><name>strm2</name><operator>.</operator><name>avail_out</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <name>ZWRAP_ZLIB_STREAM</name></expr>;</expr_stmt> <comment type="block">/* mark as zlib stream */</comment>
                <block>{<block_content> <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>freeErr</name> <init>= <expr><call><name>ZWRAP_freeDCtx</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>freeErr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt> </block_content>}</block>

                <block>{<block_content>   <decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>result</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flush</name> <operator>==</operator> <name>Z_INFLATE_SYNC</name><operator>)</operator></expr> ?</condition><then>
                                       <expr><call><name>inflateSync</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                       <expr><call><name>inflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- inflate2 flush=%d avail_in=%d avail_out=%d total_in=%d total_out=%d res=%d\n"</literal></expr></argument>,
                                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>flush</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block>   </block_content>}</block></if></if_stmt>   </block_content>}</block></else></if_stmt>  <comment type="block">/* if ! (zwd-&gt;totalInBytes == 0 &amp;&amp; strm-&gt;avail_in &gt;= ZLIB_HEADERSIZE) */</comment>
    </block_content>}</block></if></if_stmt>  <comment type="block">/* (zwd-&gt;totalInBytes &lt; ZLIB_HEADERSIZE) */</comment>

    <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name> <operator>=</operator> <name>ZWRAP_ZSTD_STREAM</name></expr>;</expr_stmt> <comment type="block">/* mark as zstd steam */</comment>

    <if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_INFLATE_SYNC</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <literal type="string">"inflateSync is not supported!"</literal></expr>;</expr_stmt> <goto>goto <name>error</name>;</goto> </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name> <operator>=</operator> <call><name>ZSTD_createDStream_advanced</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>customMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"ERROR: ZSTD_createDStream_advanced\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <goto>goto <name>error</name>;</goto> </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>decompState</name></name> <operator>=</operator> <name>ZWRAP_useInit</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>&lt;</operator> <name>ZSTD_HEADERSIZE</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>&gt;=</operator> <name>ZSTD_HEADERSIZE</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>decompState</name></name> <operator>==</operator> <name>ZWRAP_useInit</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>initErr</name> <init>= <expr><call><name>ZSTD_initDStream</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"ERROR: ZSTD_initDStream errorCode=%s\n"</literal></expr></argument>,
                                 <argument><expr><call><name>ZSTD_getErrorName</name><argument_list>(<argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>error</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>resetErr</name> <init>= <expr><call><name>ZSTD_DCtx_reset</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>resetErr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>srcSize</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><name>ZSTD_HEADERSIZE</name> <operator>-</operator> <name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>headerBuf</name></name><operator>+</operator><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>, <argument><expr><name>srcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>+=</operator> <name>srcSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>+=</operator> <name>srcSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>+=</operator> <name>srcSize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>-=</operator> <name>srcSize</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>&lt;</operator> <name>ZSTD_HEADERSIZE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_OK</name></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>decompState</name></name> <operator>==</operator> <name>ZWRAP_useInit</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>initErr</name> <init>= <expr><call><name>ZSTD_initDStream</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"ERROR: ZSTD_initDStream errorCode=%s\n"</literal></expr></argument>,
                                <argument><expr><call><name>ZSTD_getErrorName</name><argument_list>(<argument><expr><name>initErr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>error</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>resetErr</name> <init>= <expr><call><name>ZSTD_DCtx_reset</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name></expr></argument>, <argument><expr><name>ZSTD_reset_session_only</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>resetErr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>src</name></name> <operator>=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>headerBuf</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>ZSTD_HEADERSIZE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dErr</name> <init>= <expr><call><name>ZSTD_decompressStream</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"inflate ZSTD_decompressStream1 errorCode=%d srcSize=%d dstCapacity=%d\n"</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>dErr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>dErr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"ERROR: ZSTD_decompressStream1 %s\n"</literal></expr></argument>, <argument><expr><call><name>ZSTD_getErrorName</name><argument_list>(<argument><expr><name>dErr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>error</name>;</goto>
            </block_content>}</block></if></if_stmt>   </block_content>}</block>
            <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name> <operator>!=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt> <comment type="block">/* not consumed */</comment>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>   <comment type="block">/* (zwd-&gt;totalInBytes &lt; ZSTD_HEADERSIZE) */</comment>

    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>src</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dErr</name> <init>= <expr><call><name>ZSTD_decompressStream</name><argument_list>(<argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>zbd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"inflate ZSTD_decompressStream2 errorCode=%d srcSize=%d dstCapacity=%d\n"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>dErr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>dErr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>errorCount</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"ERROR: ZSTD_decompressStream2 %s zwd-&gt;errorCount=%d\n"</literal></expr></argument>,
                        <argument><expr><call><name>ZSTD_getErrorName</name><argument_list>(<argument><expr><name>dErr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>zwd</name><operator>-&gt;</operator><name>errorCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>zwd</name><operator>-&gt;</operator><name>errorCount</name></name><operator>&lt;=</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_NEED_DICT</name></expr>;</return></block_content></block></if> <else>else<block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"inflate inBuffer.pos=%d inBuffer.size=%d outBuffer.pos=%d outBuffer.size=%d o\n"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>+=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name> <operator>+=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>-=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>outBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name> <operator>+=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>totalInBytes</name></name> <operator>+=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>+=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>-=</operator> <name><name>zwd</name><operator>-&gt;</operator><name>inBuffer</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dErr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"inflate Z_STREAM_END1 avail_in=%d avail_out=%d total_in=%d total_out=%d\n"</literal></expr></argument>,
                        <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zwd</name><operator>-&gt;</operator><name>decompState</name></name> <operator>=</operator> <name>ZWRAP_streamEnd</name></expr>;</expr_stmt>
            <return>return <expr><name>Z_STREAM_END</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>  <comment type="block">/* dErr lifetime */</comment>

    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- inflate2 flush=%d avail_in=%d avail_out=%d total_in=%d total_out=%d res=%d\n"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>flush</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name></expr></argument>, <argument><expr><name>Z_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>Z_OK</name></expr>;</return>

<label><name>error</name>:</label>
    <return>return <expr><call><name>ZWRAPD_finishWithError</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>, <argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateEnd</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateEnd</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"- inflateEnd total_in=%d total_out=%d\n"</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_in</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>total_out</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>   <decl_stmt><decl><type><name>ZWRAP_DCtx</name><modifier>*</modifier> <specifier>const</specifier></type> <name>zwd</name> <init>= <expr><operator>(</operator><name>ZWRAP_DCtx</name><operator>*</operator><operator>)</operator> <name><name>strm</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>zwd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_OK</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* structures are already freed */</comment>
        <block>{<block_content> <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>freeErr</name> <init>= <expr><call><name>ZWRAP_freeDCtx</name><argument_list>(<argument><expr><name>zwd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>freeErr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt> </block_content>}</block>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateSync</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>inflateSync</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>z_inflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_INFLATE_SYNC</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<comment type="block">/* Advanced compression functions */</comment>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflateCopy</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>dest</name><operator>,</operator>
                                    <name>z_streamp</name> <name>source</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>deflateCopy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPC_finishWithErrorMsg</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="string">"deflateCopy is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflateTune</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                    <name>int</name> <name>good_length</name><operator>,</operator>
                                    <name>int</name> <name>max_lazy</name><operator>,</operator>
                                    <name>int</name> <name>nice_length</name><operator>,</operator>
                                    <name>int</name> <name>max_chain</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>deflateTune</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>good_length</name></expr></argument>, <argument><expr><name>max_lazy</name></expr></argument>, <argument><expr><name>nice_length</name></expr></argument>, <argument><expr><name>max_chain</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPC_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"deflateTune is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZLIB_VERNUM</name> <operator>&gt;=</operator> <literal type="number">0x1260</literal></expr></cpp:if>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflatePending</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                       <name>unsigned</name> <operator>*</operator><name>pending</name><operator>,</operator>
                                       <name>int</name> <operator>*</operator><name>bits</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>deflatePending</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>pending</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPC_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"deflatePending is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflatePrime</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                     <name>int</name> <name>bits</name><operator>,</operator>
                                     <name>int</name> <name>value</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>deflatePrime</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPC_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"deflatePrime is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_deflateSetHeader</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                         <name>gz_headerp</name> <name>head</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>deflateSetHeader</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPC_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"deflateSetHeader is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<comment type="block">/* Advanced decompression functions */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZLIB_VERNUM</name> <operator>&gt;=</operator> <literal type="number">0x1280</literal></expr></cpp:if>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateGetDictionary</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                             <name>Bytef</name> <operator>*</operator><name>dictionary</name><operator>,</operator>
                                             <name>uInt</name>  <operator>*</operator><name>dictLength</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateGetDictionary</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>dictionary</name></expr></argument>, <argument><expr><name>dictLength</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPD_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"inflateGetDictionary is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateCopy</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>dest</name><operator>,</operator>
                                    <name>z_streamp</name> <name>source</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>source</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateCopy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPD_finishWithErrorMsg</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="string">"inflateCopy is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZLIB_VERNUM</name> <operator>&gt;=</operator> <literal type="number">0x1240</literal></expr></cpp:if>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>long</name> <name>ZEXPORT</name> <name>z_inflateMark</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateMark</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPD_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"inflateMark is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflatePrime</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                     <name>int</name> <name>bits</name><operator>,</operator>
                                     <name>int</name> <name>value</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflatePrime</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPD_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"inflatePrime is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateGetHeader</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                         <name>gz_headerp</name> <name>head</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateGetHeader</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPD_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"inflateGetHeader is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateBackInit_</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator> <name>int</name> <name>windowBits</name><operator>,</operator>
                                         <name>unsigned</name> <name>char</name> <name>FAR</name> <operator>*</operator><name>window</name><operator>,</operator>
                                         <specifier>const</specifier> <name>char</name> <operator>*</operator><name>version</name><operator>,</operator>
                                         <name>int</name> <name>stream_size</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateBackInit_</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>windowBits</name></expr></argument>, <argument><expr><name>window</name></expr></argument>, <argument><expr><name>version</name></expr></argument>, <argument><expr><name>stream_size</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPD_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"inflateBackInit is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateBack</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>,</operator>
                                    <name>in_func</name> <name>in</name><operator>,</operator> <name>void</name> <name>FAR</name> <operator>*</operator><name>in_desc</name><operator>,</operator>
                                    <name>out_func</name> <name>out</name><operator>,</operator> <name>void</name> <name>FAR</name> <operator>*</operator><name>out_desc</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateBack</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>in_desc</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>out_desc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPD_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"inflateBack is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_inflateBackEnd</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>z_streamp</name> <name>strm</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_ZWRAPdecompressionType</name> <operator>==</operator> <name>ZWRAP_FORCE_ZLIB</name> <operator>||</operator> <operator>!</operator><name><name>strm</name><operator>-&gt;</operator><name>reserved</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>inflateBackEnd</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>ZWRAPD_finishWithErrorMsg</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><literal type="string">"inflateBackEnd is not supported!"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>z_zlibCompileFlags</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator></expr></argument>)</argument_list> <block>{<block_content> <return>return <expr><call><name>zlibCompileFlags</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></decl></decl_stmt>



                    <comment type="block">/* ===   utility functions  === */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Z_SOLO</name></cpp:ifndef>

<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_compress</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>Bytef</name> <operator>*</operator><name>dest</name><operator>,</operator>   <name>uLongf</name> <operator>*</operator><name>destLen</name><operator>,</operator>
                                 <specifier>const</specifier> <name>Bytef</name> <operator>*</operator><name>source</name><operator>,</operator> <name>uLong</name> <name>sourceLen</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>compress</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>destLen</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content>   <decl_stmt><decl><type><name>size_t</name></type> <name>dstCapacity</name> <init>= <expr><operator>*</operator><name>destLen</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_compress</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>,
                                           <argument><expr><name>source</name></expr></argument>, <argument><expr><name>sourceLen</name></expr></argument>,
                                           <argument><expr><name>ZWRAP_DEFAULT_CLEVEL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LOG_WRAPPERD</name><argument_list>(<argument><expr><literal type="string">"z_compress sourceLen=%d dstCapacity=%d\n"</literal></expr></argument>,
                    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sourceLen</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>dstCapacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>destLen</name> <operator>=</operator> <name>cSize</name></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_compress2</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>Bytef</name> <operator>*</operator><name>dest</name><operator>,</operator>   <name>uLongf</name> <operator>*</operator><name>destLen</name><operator>,</operator>
                                  <specifier>const</specifier> <name>Bytef</name> <operator>*</operator><name>source</name><operator>,</operator> <name>uLong</name> <name>sourceLen</name><operator>,</operator>
                                  <name>int</name> <name>level</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>compress2</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>destLen</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>sourceLen</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content> <decl_stmt><decl><type><name>size_t</name></type> <name>dstCapacity</name> <init>= <expr><operator>*</operator><name>destLen</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>cSize</name> <init>= <expr><call><name>ZSTD_compress</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>sourceLen</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>cSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>destLen</name> <operator>=</operator> <name>cSize</name></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>z_compressBound</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>uLong</name> <name>sourceLen</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_ZWRAP_useZSTDcompression</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>compressBound</name><argument_list>(<argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>ZSTD_compressBound</name><argument_list>(<argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>z_uncompress</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>Bytef</name> <operator>*</operator><name>dest</name><operator>,</operator>   <name>uLongf</name> <operator>*</operator><name>destLen</name><operator>,</operator>
                                   <specifier>const</specifier> <name>Bytef</name> <operator>*</operator><name>source</name><operator>,</operator> <name>uLong</name> <name>sourceLen</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ZSTD_isFrame</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>uncompress</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>destLen</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <block>{<block_content> <decl_stmt><decl><type><name>size_t</name></type> <name>dstCapacity</name> <init>= <expr><operator>*</operator><name>destLen</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name> <specifier>const</specifier></type> <name>dSize</name> <init>= <expr><call><name>ZSTD_decompress</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dstCapacity</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>dSize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>destLen</name> <operator>=</operator> <name>dSize</name></expr>;</expr_stmt>
     </block_content>}</block>
    <return>return <expr><name>Z_OK</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !Z_SOLO */</comment>


                        <comment type="block">/* checksum functions */</comment>

<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>z_adler32</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>uLong</name> <name>adler</name><operator>,</operator> <specifier>const</specifier> <name>Bytef</name> <operator>*</operator><name>buf</name><operator>,</operator> <name>uInt</name> <name>len</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <return>return <expr><call><name>adler32</name><argument_list>(<argument><expr><name>adler</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>z_crc32</name></type>   <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>uLong</name> <name>crc</name><operator>,</operator> <specifier>const</specifier> <name>Bytef</name> <operator>*</operator><name>buf</name><operator>,</operator> <name>uInt</name> <name>len</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <return>return <expr><call><name>crc32</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZLIB_VERNUM</name> <operator>&gt;=</operator> <literal type="number">0x12B0</literal></expr></cpp:if>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>z_adler32_z</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>uLong</name> <name>adler</name><operator>,</operator> <specifier>const</specifier> <name>Bytef</name> <operator>*</operator><name>buf</name><operator>,</operator> <name>z_size_t</name> <name>len</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <return>return <expr><call><name>adler32_z</name><argument_list>(<argument><expr><name>adler</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>z_crc32_z</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>uLong</name> <name>crc</name><operator>,</operator> <specifier>const</specifier> <name>Bytef</name> <operator>*</operator><name>buf</name><operator>,</operator> <name>z_size_t</name> <name>len</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <return>return <expr><call><name>crc32_z</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZLIB_VERNUM</name> <operator>&gt;=</operator> <literal type="number">0x1270</literal></expr></cpp:if>
<decl_stmt><decl><type><name>ZEXTERN</name> <specifier>const</specifier> <name>z_crc_t</name> <name>FAR</name> <modifier>*</modifier> <name>ZEXPORT</name> <name>z_get_crc_table</name></type>    <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>)</operator></expr></argument>)</argument_list>
<block>{<block_content>
    <return>return <expr><call><name>get_crc_table</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
