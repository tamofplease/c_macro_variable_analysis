<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/mydumper/zstd/gzread.c"><comment type="block">/* gzread.c contains minimal changes required to be compiled with zlibWrapper:
 * - gz_statep was converted to union to work with -Wstrict-aliasing=1      */</comment>

 <comment type="block">/* gzread.c -- zlib functions for reading gzip files
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013, 2016 Mark Adler
 * For conditions of distribution and use, see http://www.zlib.net/zlib_license.html
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gzguts.h"</cpp:file></cpp:include>

<comment type="block">/* fix for Visual Studio, which doesn't support ssize_t type.
 * see https://github.com/facebook/zstd/issues/1800#issuecomment-545945050 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ssize_t</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;BaseTsd.h&gt;</cpp:file></cpp:include>
   <typedef>typedef <type><name>SSIZE_T</name></type> <name>ssize_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Local functions */</comment>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>gz_load</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>gz_statep</name><operator>,</operator> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>,</operator> <name>unsigned</name><operator>,</operator> <name>unsigned</name> <operator>*</operator><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>gz_avail</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>gz_statep</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>gz_look</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>gz_statep</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>gz_decomp</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>gz_statep</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>gz_fetch</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>gz_statep</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>int</name> <name>gz_skip</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>gz_statep</name><operator>,</operator> <name>z_off64_t</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>z_size_t</name> <name>gz_read</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>gz_statep</name><operator>,</operator> <name>voidp</name><operator>,</operator> <name>z_size_t</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<comment type="block">/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
   state.state-&gt;fd, and update state.state-&gt;eof, state.state-&gt;err, and state.state-&gt;msg as appropriate.
   This function needs to loop on read(), since read() is not guaranteed to
   read the number of bytes requested, depending on the type of descriptor. */</comment>
<function><type><name>local</name> <name>int</name></type> <name>gz_load</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>, <parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>len</name></type></decl></parameter>, <parameter><decl><type><name>have</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>have</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>get</name></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>-</operator><literal type="number">1</literal> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>have</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <do>do <block>{<block_content>
        <expr_stmt><expr><name>get</name> <operator>=</operator> <name>len</name> <operator>-</operator> <operator>*</operator><name>have</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>get</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>get</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <operator>*</operator><name>have</name></expr></argument>, <argument><expr><name>get</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>have</name> <operator>+=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>ret</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><operator>*</operator><name>have</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>;</do>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_ERRNO</name></expr></argument>, <argument><expr><call><name>zstrerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Load up input buffer and set eof flag if last data loaded -- return -1 on
   error, 0 otherwise.  Note that the eof flag is set when the end of the input
   file is reached, even though there may be unused data in the buffer.  Once
   that data has been used, no more attempts will be made to read the file.
   If strm-&gt;avail_in != 0, then the current data is moved to the beginning of
   the input buffer, and then the remainder of the buffer is loaded with the
   available data from the input file. */</comment>
<function><type><name>local</name> <name>int</name></type> <name>gz_avail</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>got</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_BUF_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>eof</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>)</condition> <block>{<block_content>       <comment type="block">/* copy what's there to the start */</comment>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>in</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></init></decl>;</decl_stmt>
            <do>do <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>q</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><operator>--</operator><name>n</name></expr>)</condition>;</do>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>gz_load</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>in</name></name> <operator>+</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>,
                    <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>got</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>+=</operator> <name>got</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>in</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Look for gzip header, set up for inflate or copy.  state.state-&gt;x.have must be 0.
   If this is the first time in, allocate required memory.  state.state-&gt;how will be
   left unchanged if there is no more input data available, will be set to COPY
   if there is no gzip header and direct copying will be performed, or it will
   be set to GZIP for decompression.  If direct copying, then leftover input
   data from the input buffer will be copied to the output buffer.  In that
   case, all further file reads will be directly to either the output buffer or
   a user buffer.  If decompressing, the inflate state will be initialized.
   gz_look() will return 0 on success or -1 on failure. */</comment>
<function><type><name>local</name> <name>int</name></type> <name>gz_look</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* allocate read buffers and inflate memory */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* allocate buffers */</comment>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>in</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>want</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>want</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>in</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_MEM_ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>want</name></name></expr>;</expr_stmt>

        <comment type="block">/* allocate inflate memory */</comment>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>zalloc</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>zfree</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>opaque</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>inflateInit2</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">15</literal> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition> <block>{<block_content>    <comment type="block">/* gunzip */</comment>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_MEM_ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get at least the magic bytes in the input buffer */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>gz_avail</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* look for gzip magic bytes -- if there, do gzip decoding (note: there is
       a logical dilemma here when considering the case of a partially written
       gzip file, to wit, if a single 31 byte is written, then we cannot tell
       whether this is a single-byte file, or just a partially written gzip
       file -- for here we assume that if a gzip file is being written, then
       the header will be written in a single operation, so that reading a
       single byte is sufficient indication that it is not a gzip file) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>next_in</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">31</literal> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_in</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">139</literal><operator>)</operator> <comment type="block">/* gz header */</comment>
            <operator>||</operator> <operator>(</operator><name><name>strm</name><operator>-&gt;</operator><name>next_in</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">40</literal> <operator>&amp;&amp;</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_in</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">181</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content> <comment type="block">/* zstd header */</comment>
        <expr_stmt><expr><call><name>inflateReset</name><argument_list>(<argument><expr><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>how</name></name> <operator>=</operator> <name>GZIP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>direct</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* no gzip header -- if we were decoding gzip before, then this is trailing
       garbage.  Ignore the trailing garbage and finish. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>direct</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* doing raw i/o, copy any leftover input to output -- this assumes that
       the output buffer is larger than the input buffer, which also assures
       space for gzungetc() */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>, <argument><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>how</name></name> <operator>=</operator> <name>COPY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>direct</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decompress from input to the provided next_out and avail_out in the state.
   On return, state.state-&gt;x.have and state.state-&gt;x.next point to the just decompressed
   data.  If the gzip stream completes, state.state-&gt;how is reset to LOOK to look for
   the next gzip stream or raw data, once state.state-&gt;x.have is depleted.  Returns 0
   on success, -1 on failure. */</comment>
<function><type><name>local</name> <name>int</name></type> <name>gz_decomp</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>Z_OK</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>had</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* fill output buffer up to end of deflate stream */</comment>
    <expr_stmt><expr><name>had</name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>;</expr_stmt>
    <do>do <block>{<block_content>
        <comment type="block">/* get more input for inflate() */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>gz_avail</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_BUF_ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* decompress and handle errors */</comment>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><name>strm</name></expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Z_STREAM_ERROR</name> <operator>||</operator> <name>ret</name> <operator>==</operator> <name>Z_NEED_DICT</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_STREAM_ERROR</name></expr></argument>,
                     <argument><expr><literal type="string">"internal error: inflate stream corrupt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Z_MEM_ERROR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_MEM_ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Z_DATA_ERROR</name></expr>)</condition> <block>{<block_content>              <comment type="block">/* deflate stream invalid */</comment>
            <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_DATA_ERROR</name></expr></argument>,
                     <argument><expr><ternary><condition><expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">"compressed data error"</literal></expr> </then><else>: <expr><name><name>strm</name><operator>-&gt;</operator><name>msg</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block> while <condition>(<expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>&amp;&amp;</operator> <name>ret</name> <operator>!=</operator> <name>Z_STREAM_END</name></expr>)</condition>;</do>

    <comment type="block">/* update available output */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>=</operator> <name>had</name> <operator>-</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>-</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr>;</expr_stmt>

    <comment type="block">/* if the gzip stream completed successfully, look for another */</comment>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Z_STREAM_END</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>how</name></name> <operator>=</operator> <name>LOOK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* good decompression */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Fetch data and put it in the output buffer.  Assumes state.state-&gt;x.have is 0.
   Data is either copied from the input file or decompressed from the input
   file depending on state.state-&gt;how.  If state.state-&gt;how is LOOK, then a gzip header is
   looked for to determine whether to copy or decompress.  Returns -1 on error,
   otherwise 0.  gz_fetch() will leave state.state-&gt;how as COPY or GZIP unless the
   end of the input file has been reached and all data has been processed.  */</comment>
<function><type><name>local</name> <name>int</name></type> <name>gz_fetch</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>z_streamp</name></type> <name>strm</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <do>do <block>{<block_content>
        <switch>switch<condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>how</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>LOOK</name></expr>:</case>      <comment type="block">/* -&gt; LOOK, COPY (only if never GZIP), or GZIP */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>gz_look</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>how</name></name> <operator>==</operator> <name>LOOK</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>COPY</name></expr>:</case>      <comment type="block">/* -&gt; COPY */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>gz_load</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name><operator>)</operator></expr></argument>)</argument_list></call>
                    <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>GZIP</name></expr>:</case>      <comment type="block">/* -&gt; GZIP or LOOK (if end of gzip stream) */</comment>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>strm</name><operator>-&gt;</operator><name>next_out</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>gz_decomp</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></switch>
    </block_content>}</block> while <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>eof</name></name> <operator>||</operator> <name><name>strm</name><operator>-&gt;</operator><name>avail_in</name></name><operator>)</operator></expr>)</condition>;</do>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */</comment>
<function><type><name>local</name> <name>int</name></type> <name>gz_skip</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>, <parameter><decl><type><name>len</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_off64_t</name></type> <name>len</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>

    <comment type="block">/* skip over len bytes or reach end-of-file, whichever comes first */</comment>
    <while>while <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* skip over whatever is in output buffer */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><call><name>GT_OFF</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>z_off64_t</name><operator>)</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>&gt;</operator> <name>len</name></expr> ?</condition><then>
                <expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>len</name></expr> </then><else>: <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
        </block_content>}</block></if>

        <comment type="block">/* output buffer empty -- return if we're at the end of the input */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>eof</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if>

        <comment type="block">/* need more data to skip -- load up output buffer */</comment>
        <else>else <block>{<block_content>
            <comment type="block">/* get more output, looking for header if required */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>gz_fetch</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt></block_content></block></while>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read len bytes into buf from file, or less than len up to the end of the
   input.  Return the number of bytes read.  If zero is returned, either the
   end of file was reached, or there was an error.  state.state-&gt;err must be
   consulted in that case to determine which. */</comment>
<function><type><name>local</name> <name>z_size_t</name></type> <name>gz_read</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>, <parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>len</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>voidp</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_size_t</name></type> <name>len</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>z_size_t</name></type> <name>got</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>

    <comment type="block">/* if len is zero, avoid unnecessary operations */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* process a skip request */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>gz_skip</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>skip</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get len bytes to buf, or less than len if at the end */</comment>
    <expr_stmt><expr><name>got</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <do>do <block>{<block_content>
        <comment type="block">/* set n to the maximum amount of len that fits in an unsigned int */</comment>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* first just try copying data from the output buffer */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>&lt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
        </block_content>}</block></if>

        <comment type="block">/* output buffer empty -- return if we're at the end of the input */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>eof</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>past</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <comment type="block">/* tried to read past end */</comment>
            <break>break;</break>
        </block_content>}</block></if>

        <comment type="block">/* need output data -- for small len or new stream load up our output
           buffer */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>how</name></name> <operator>==</operator> <name>LOOK</name> <operator>||</operator> <name>n</name> <operator>&lt;</operator> <operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
            <comment type="block">/* get more output, looking for header if required */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>gz_fetch</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <continue>continue;</continue>       <comment type="block">/* no progress yet -- go back to copy above */</comment>
            <comment type="block">/* the copy above assures that we will leave with space in the
               output buffer, allowing at least one gzungetc() to succeed */</comment>
        </block_content>}</block></if>

        <comment type="block">/* large len -- read directly into user buffer */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>how</name></name> <operator>==</operator> <name>COPY</name></expr>)</condition> <block>{<block_content>      <comment type="block">/* read directly */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>gz_load</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if>

        <comment type="block">/* large len -- decompress directly into user buffer */</comment>
        <else>else <block>{<block_content>  <comment type="block">/* state.state-&gt;how == GZIP */</comment>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>gz_decomp</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* update progress */</comment>
        <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>got</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>len</name></expr>)</condition>;</do>

    <comment type="block">/* return number of bytes read into user buffer */</comment>
    <return>return <expr><name>got</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzread</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>, <parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>len</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>voidp</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

    <comment type="block">/* check that we're reading and that there's no (serious) error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>||</operator>
            <operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_BUF_ERROR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* since an int is returned, make sure len fits in one, otherwise return
       with an error (this avoids a flaw in the interface) */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_STREAM_ERROR</name></expr></argument>, <argument><expr><literal type="string">"request does not fit in an int"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* read len or fewer bytes to buf */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>gz_read</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for an error */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_BUF_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* return the number of bytes read (this is assured to fit in an int) */</comment>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>z_size_t</name> <name>ZEXPORT</name></type> <name>gzfread</name><parameter_list>(<parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>size</name></type></decl></parameter>, <parameter><decl><type><name>nitems</name></type></decl></parameter>, <parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>voidp</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_size_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_size_t</name></type> <name>nitems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>z_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

    <comment type="block">/* check that we're reading and that there's no (serious) error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>||</operator>
            <operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_BUF_ERROR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* compute bytes to read -- error on overflow */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name>nitems</name> <operator>*</operator> <name>size</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>/</operator> <name>size</name> <operator>!=</operator> <name>nitems</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_STREAM_ERROR</name></expr></argument>, <argument><expr><literal type="string">"request does not fit in a size_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* read len or fewer bytes to buf, return the number of full items read */</comment>
    <return>return <expr><ternary><condition><expr><name>len</name></expr> ?</condition><then> <expr><call><name>gz_read</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>size</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZLIB_VERNUM</name> <operator>&gt;=</operator> <literal type="number">0x1261</literal></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_PREFIX_SET</name></cpp:ifdef>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>z_gzgetc</name></cpp:undef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>gzgetc</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZLIB_VERNUM</name> <operator>==</operator> <literal type="number">0x1260</literal></expr></cpp:if>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>gzgetc</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ZLIB_VERNUM</name> <operator>&lt;=</operator> <literal type="number">0x1250</literal></expr></cpp:if>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzgetc</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>gzFile</name> <name>file</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzgetc_</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>gzFile</name> <name>file</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzgetc</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

    <comment type="block">/* check that we're reading and that there's no (serious) error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>||</operator>
        <operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_BUF_ERROR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* try output buffer (no need to check for skip request) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return <expr><operator>*</operator><operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name><operator>)</operator><operator>++</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* nothing there -- try gz_read() */</comment>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>gz_read</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>ret</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzgetc_</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
<decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <return>return <expr><call><name>gzgetc</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzungetc</name><parameter_list>(<parameter><decl><type><name>c</name></type></decl></parameter>, <parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

    <comment type="block">/* check that we're reading and that there's no (serious) error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>||</operator>
        <operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_BUF_ERROR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* process a skip request */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>gz_skip</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>skip</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* can't push EOF */</comment>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* if output buffer empty, put byte at end (allows more pushing) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name> <operator>+</operator> <operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>past</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>c</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if no room, give up (must have already done a gzungetc()) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>==</operator> <operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_DATA_ERROR</name></expr></argument>, <argument><expr><literal type="string">"out of room to push characters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* slide output data if needed and insert byte before existing data */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name> <operator>==</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name> <operator>+</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name> <operator>+</operator> <operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>src</name> <operator>&gt;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><operator>--</operator><name>dest</name> <operator>=</operator> <operator>*</operator><operator>--</operator><name>src</name></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>past</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>char</name> <modifier>*</modifier> <name>ZEXPORT</name></type> <name>gzgets</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>, <parameter><decl><type><name>buf</name></type></decl></parameter>, <parameter><decl><type><name>len</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eol</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* check parameters and get internal structure */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>buf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

    <comment type="block">/* check that we're reading and that there's no (serious) error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>||</operator>
        <operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_BUF_ERROR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* process a skip request */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>gz_skip</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>skip</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* copy output bytes up to new line or len - 1, whichever comes first --
       append a terminating zero to the string (we don't check for a zero in
       the contents, let the user worry about that) */</comment>
    <expr_stmt><expr><name>str</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>left</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>left</name></expr>)</condition><block type="pseudo"><block_content> <do>do <block>{<block_content>
        <comment type="block">/* assure that something is in the output buffer */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>gz_fetch</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>                <comment type="block">/* error */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>       <comment type="block">/* end of file */</comment>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>past</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>            <comment type="block">/* read past end */</comment>
            <break>break;</break>                      <comment type="block">/* return what we have */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* look for end-of-line in current output buffer */</comment>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>&gt;</operator> <name>left</name></expr> ?</condition><then> <expr><name>left</name></expr> </then><else>: <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>eol</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>memchr</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>eol</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>eol</name> <operator>-</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* copy through end-of-line, or remainder if not found */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>left</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>left</name> <operator>&amp;&amp;</operator> <name>eol</name> <operator>==</operator> <name>NULL</name></expr>)</condition>;</do></block_content></block></if></if_stmt>

    <comment type="block">/* return terminated string, or if nothing, end of file */</comment>
    <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>str</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzdirect</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

    <comment type="block">/* if the state is not known, but we can find out, then do so (this is
       mainly for right after a gzopen() or gzdopen()) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_READ</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>how</name></name> <operator>==</operator> <name>LOOK</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>gz_look</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* return 1 if transparent, 0 if processing a gzip stream */</comment>
    <return>return <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>direct</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzclose_r</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

    <comment type="block">/* check that we're reading */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>Z_STREAM_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* free memory and close file */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>err</name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>==</operator> <name>Z_BUF_ERROR</name></expr> ?</condition><then> <expr><name>Z_BUF_ERROR</name></expr> </then><else>: <expr><name>Z_OK</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>close</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>ret</name></expr> ?</condition><then> <expr><name>Z_ERRNO</name></expr> </then><else>: <expr><name>err</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
</unit>
