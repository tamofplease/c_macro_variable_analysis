<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/mydumper/zstd/gzlib.c"><comment type="block">/* gzlib.c contains minimal changes required to be compiled with zlibWrapper:
 * - gz_statep was converted to union to work with -Wstrict-aliasing=1      */</comment>

<comment type="block">/* gzlib.c -- zlib functions common to reading and writing gzip files
 * Copyright (C) 2004-2017 Mark Adler
 * For conditions of distribution and use, see http://www.zlib.net/zlib_license.html
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gzguts.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LSEEK</name></cpp:macro> <cpp:value>_lseeki64</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_LARGEFILE64_SOURCE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_LFS64_LARGEFILE</name><operator>-</operator><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LSEEK</name></cpp:macro> <cpp:value>lseek64</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>LSEEK</name></cpp:macro> <cpp:value>lseek</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Local functions */</comment>
<decl_stmt><decl><type><name>local</name> <name>void</name> <name>gz_reset</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><name>gz_statep</name><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>local</name> <name>gzFile</name> <name>gz_open</name></type> <name>OF</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>,</operator> <name>int</name><operator>,</operator> <specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>UNDER_CE</name></expr></cpp:if>

<comment type="block">/* Map the Windows error number in ERROR to a locale-dependent error message
   string and return a pointer to it.  Typically, the values for ERROR come
   from GetLastError.

   The string pointed to shall not be modified by the application, but may be
   overwritten by a subsequent call to gz_strwinerror

   The gz_strwinerror function does not change the current setting of
   GetLastError. */</comment>
<function><type><name>char</name> <name>ZLIB_INTERNAL</name> <modifier>*</modifier></type><name>gz_strwinerror</name> <parameter_list>(<parameter><decl><type><name>error</name></type></decl></parameter>)</parameter_list>
     <decl_stmt><decl><type><name>DWORD</name></type> <name>error</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>msgbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>lasterr</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>chars</name> <init>= <expr><call><name>FormatMessage</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_FROM_SYSTEM</name>
        <operator>|</operator> <name>FORMAT_MESSAGE_ALLOCATE_BUFFER</name></expr></argument>,
        <argument><expr><name>NULL</name></expr></argument>,
        <argument><expr><name>error</name></expr></argument>,
        <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* Default language */</comment>
        <argument><expr><operator>(</operator><name>LPVOID</name><operator>)</operator><operator>&amp;</operator><name>msgbuf</name></expr></argument>,
        <argument><expr><literal type="number">0</literal></expr></argument>,
        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>chars</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If there is an \r\n appended, zap it.  */</comment>
        <if_stmt><if>if <condition>(<expr><name>chars</name> <operator>&gt;=</operator> <literal type="number">2</literal>
            <operator>&amp;&amp;</operator> <name><name>msgbuf</name><index>[<expr><name>chars</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name><name>msgbuf</name><index>[<expr><name>chars</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>chars</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>msgbuf</name><index>[<expr><name>chars</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>chars</name> <operator>&gt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>chars</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>msgbuf</name><index>[<expr><name>chars</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>wcstombs</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><name>chars</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"unknown win32 error (%ld)"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>SetLastError</name><argument_list>(<argument><expr><name>lasterr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* UNDER_CE */</comment>

<comment type="block">/* Reset gzip file state */</comment>
<function><type><name>local</name> <name>void</name></type> <name>gz_reset</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>
<block>{<block_content>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>              <comment type="block">/* no output data available */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_READ</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* for reading ... */</comment>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>             <comment type="block">/* not at end of file */</comment>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>past</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* have not read past end yet */</comment>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>how</name></name> <operator>=</operator> <name>LOOK</name></expr>;</expr_stmt>          <comment type="block">/* look for gzip header */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                <comment type="block">/* no seek request pending */</comment>
    <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* clear error */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>               <comment type="block">/* no uncompressed data yet */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>       <comment type="block">/* no input data yet */</comment>
</block_content>}</block></function>

<comment type="block">/* Open a gzip file either by name or file descriptor. */</comment>
<function><type><name>local</name> <name>gzFile</name></type> <name>gz_open</name><parameter_list>(<parameter><decl><type><name>path</name></type></decl></parameter>, <parameter><decl><type><name>fd</name></type></decl></parameter>, <parameter><decl><type><name>mode</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>oflag</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_CLOEXEC</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>cloexec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_EXCL</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>exclusive</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* check input */</comment>
    <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* allocate gzFile structure to return */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <operator>(</operator><name>gz_state</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>gz_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>            <comment type="block">/* no buffers allocated yet */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>want</name></name> <operator>=</operator> <name>GZBUFSIZE</name></expr>;</expr_stmt>    <comment type="block">/* requested buffer size */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>          <comment type="block">/* no error message yet */</comment>

    <comment type="block">/* interpret mode */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>GZ_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>Z_DEFAULT_STRATEGY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>direct</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>mode</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>mode</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>mode</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <operator>*</operator><name>mode</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <switch>switch <condition>(<expr><operator>*</operator><name>mode</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><literal type="char">'r'</literal></expr>:</case>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>GZ_READ</name></expr>;</expr_stmt>
                <break>break;</break>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_GZCOMPRESS</name></cpp:ifndef>
            <case>case <expr><literal type="char">'w'</literal></expr>:</case>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>GZ_WRITE</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'a'</literal></expr>:</case>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>GZ_APPEND</name></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <case>case <expr><literal type="char">'+'</literal></expr>:</case>       <comment type="block">/* can't read and write at the same time */</comment>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            <case>case <expr><literal type="char">'b'</literal></expr>:</case>       <comment type="block">/* ignore -- will request binary anyway */</comment>
                <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_CLOEXEC</name></cpp:ifdef>
            <case>case <expr><literal type="char">'e'</literal></expr>:</case>
                <expr_stmt><expr><name>cloexec</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_EXCL</name></cpp:ifdef>
            <case>case <expr><literal type="char">'x'</literal></expr>:</case>
                <expr_stmt><expr><name>exclusive</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <case>case <expr><literal type="char">'f'</literal></expr>:</case>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>Z_FILTERED</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'h'</literal></expr>:</case>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>Z_HUFFMAN_ONLY</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'R'</literal></expr>:</case>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>Z_RLE</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'F'</literal></expr>:</case>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>Z_FIXED</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'T'</literal></expr>:</case>
                <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>direct</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>        <comment type="block">/* could consider as an error, but just ignore */</comment>
                <empty_stmt>;</empty_stmt>
            </block_content>}</block></switch></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>mode</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* must provide an "r", "w", or "a" */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_NONE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* can't force transparent read */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_READ</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>direct</name></name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>direct</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>      <comment type="block">/* for empty file */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* save the path name for error messages */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIDECHAR</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>wcstombs</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>(</operator><name>z_size_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIDECHAR</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>wcstombs</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_snprintf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_vsnprintf</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* compute the flags for open() */</comment>
    <expr_stmt><expr><name>oflag</name> <operator>=</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_LARGEFILE</name></cpp:ifdef>
        <name>O_LARGEFILE</name> <operator>|</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_BINARY</name></cpp:ifdef>
        <name>O_BINARY</name> <operator>|</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_CLOEXEC</name></cpp:ifdef>
        <operator>(</operator><ternary><condition><expr><name>cloexec</name></expr> ?</condition><then> <expr><name>O_CLOEXEC</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <operator>(</operator><ternary><condition><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_READ</name></expr> ?</condition><then>
         <expr><name>O_RDONLY</name></expr> </then><else>:
         <expr><operator>(</operator><name>O_WRONLY</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>O_EXCL</name></cpp:ifdef>
          <operator>(</operator><ternary><condition><expr><name>exclusive</name></expr> ?</condition><then> <expr><name>O_EXCL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <operator>(</operator><ternary><condition><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_WRITE</name></expr> ?</condition><then>
           <expr><name>O_TRUNC</name></expr> </then><else>:
           <expr><name>O_APPEND</name></expr></else></ternary><operator>)</operator><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* open the file with the appropriate flags (or just use fd) */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <ternary><condition><expr><name>fd</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>fd</name></expr> </then><else>: <expr><operator>(</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIDECHAR</name></cpp:ifdef>
        <ternary><condition><expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><call><name>_wopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>oflag</name></expr></argument>, <argument><expr><literal type="number">0666</literal></expr></argument>)</argument_list></call></expr> </then><else>:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr><call><name>open</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr></argument>, <argument><expr><name>oflag</name></expr></argument>, <argument><expr><literal type="number">0666</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>fd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_APPEND</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>LSEEK</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* so gzoffset() is correct */</comment>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>GZ_WRITE</name></expr>;</expr_stmt>         <comment type="block">/* simplify later checks */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* save the current position for rewinding (only if reading) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_READ</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <call><name>LSEEK</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>start</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* initialize stream */</comment>
    <expr_stmt><expr><call><name>gz_reset</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return stream */</comment>
    <return>return <expr><name><name>state</name><operator>.</operator><name>file</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>gzFile</name> <name>ZEXPORT</name></type> <name>gzopen</name><parameter_list>(<parameter><decl><type><name>path</name></type></decl></parameter>, <parameter><decl><type><name>mode</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
<block>{<block_content>
    <return>return <expr><call><name>gz_open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>gzFile</name> <name>ZEXPORT</name></type> <name>gzopen64</name><parameter_list>(<parameter><decl><type><name>path</name></type></decl></parameter>, <parameter><decl><type><name>mode</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
<block>{<block_content>
    <return>return <expr><call><name>gz_open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>gzFile</name> <name>ZEXPORT</name></type> <name>gzdopen</name><parameter_list>(<parameter><decl><type><name>fd</name></type></decl></parameter>, <parameter><decl><type><name>mode</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>         <comment type="block">/* identifier for error messages */</comment>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>gz</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>path</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_snprintf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_vsnprintf</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">7</literal> <operator>+</operator> <literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;fd:%d&gt;"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"&lt;fd:%d&gt;"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* for debugging */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>gz</name> <operator>=</operator> <call><name>gz_open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>gz</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIDECHAR</name></cpp:ifdef>
<function><type><name>gzFile</name> <name>ZEXPORT</name></type> <name>gzopen_w</name><parameter_list>(<parameter><decl><type><name>path</name></type></decl></parameter>, <parameter><decl><type><name>mode</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
<block>{<block_content>
    <return>return <expr><call><name>gz_open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzbuffer</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>, <parameter><decl><type><name>size</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>size</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure and check integrity */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* make sure we haven't already allocated memory */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* check and set requested size */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>              <comment type="block">/* need to be able to double it */</comment>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>               <comment type="block">/* need two bytes to check magic header */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>want</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzrewind</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

    <comment type="block">/* check that we're reading and that there's no error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>||</operator>
            <operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_BUF_ERROR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* back up and start over */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>LSEEK</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>gz_reset</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>z_off64_t</name> <name>ZEXPORT</name></type> <name>gzseek64</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>, <parameter><decl><type><name>offset</name></type></decl></parameter>, <parameter><decl><type><name>whence</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_off64_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>whence</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_off64_t</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure and check integrity */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* check that there's no error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_BUF_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* can only seek from start or relative to current position */</comment>
    <if_stmt><if>if <condition>(<expr><name>whence</name> <operator>!=</operator> <name>SEEK_SET</name> <operator>&amp;&amp;</operator> <name>whence</name> <operator>!=</operator> <name>SEEK_CUR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* normalize offset to a SEEK_CUR specification */</comment>
    <if_stmt><if>if <condition>(<expr><name>whence</name> <operator>==</operator> <name>SEEK_SET</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>offset</name> <operator>-=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>skip</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* if within raw area while reading, just go there */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_READ</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>how</name></name> <operator>==</operator> <name>COPY</name> <operator>&amp;&amp;</operator>
            <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name> <operator>+</operator> <name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>LSEEK</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>offset</name> <operator>-</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>past</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>
        <return>return <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* calculate skip amount, rewinding if needed for back seek when reading */</comment>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name></expr>)</condition><block type="pseudo"><block_content>         <comment type="block">/* writing -- can't go backwards */</comment>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>                     <comment type="block">/* before start of file! */</comment>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>gzrewind</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>           <comment type="block">/* rewind, then skip to offset */</comment>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if reading, skip what's in output buffer (one less gzgetc() check) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_READ</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><call><name>GT_OFF</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>z_off64_t</name><operator>)</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>&gt;</operator> <name>offset</name></expr> ?</condition><then>
            <expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>offset</name></expr> </then><else>: <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>next</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* request skip (if not zero) */</comment>
    <if_stmt><if>if <condition>(<expr><name>offset</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>skip</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name> <operator>+</operator> <name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>z_off_t</name> <name>ZEXPORT</name></type> <name>gzseek</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>, <parameter><decl><type><name>offset</name></type></decl></parameter>, <parameter><decl><type><name>whence</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>z_off_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>whence</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>z_off64_t</name></type> <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>gzseek64</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>z_off64_t</name><operator>)</operator><name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>ret</name> <operator>==</operator> <operator>(</operator><name>z_off_t</name><operator>)</operator><name>ret</name></expr> ?</condition><then> <expr><operator>(</operator><name>z_off_t</name><operator>)</operator><name>ret</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>z_off64_t</name> <name>ZEXPORT</name></type> <name>gztell64</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure and check integrity */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* return position */</comment>
    <return>return <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pos</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>seek</name></name></expr> ?</condition><then> <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>skip</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>z_off_t</name> <name>ZEXPORT</name></type> <name>gztell</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>z_off64_t</name></type> <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>gztell64</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>ret</name> <operator>==</operator> <operator>(</operator><name>z_off_t</name><operator>)</operator><name>ret</name></expr> ?</condition><then> <expr><operator>(</operator><name>z_off_t</name><operator>)</operator><name>ret</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>z_off64_t</name> <name>ZEXPORT</name></type> <name>gzoffset64</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>z_off64_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure and check integrity */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* compute and return effective offset in file */</comment>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>LSEEK</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_READ</name></expr>)</condition><block type="pseudo"><block_content>             <comment type="block">/* reading */</comment>
        <expr_stmt><expr><name>offset</name> <operator>-=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>strm</name><operator>.</operator><name>avail_in</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>     <comment type="block">/* don't count buffered input */</comment>
    <return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>z_off_t</name> <name>ZEXPORT</name></type> <name>gzoffset</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>z_off64_t</name></type> <name>ret</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>gzoffset64</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name>ret</name> <operator>==</operator> <operator>(</operator><name>z_off_t</name><operator>)</operator><name>ret</name></expr> ?</condition><then> <expr><operator>(</operator><name>z_off_t</name><operator>)</operator><name>ret</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>int</name> <name>ZEXPORT</name></type> <name>gzeof</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure and check integrity */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* return end-of-file state */</comment>
    <return>return <expr><ternary><condition><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_READ</name></expr> ?</condition><then> <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>past</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <name>ZEXPORT</name></type> <name>gzerror</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>, <parameter><decl><type><name>errnum</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>errnum</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure and check integrity */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* return error information */</comment>
    <if_stmt><if>if <condition>(<expr><name>errnum</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>errnum</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>==</operator> <name>Z_MEM_ERROR</name></expr> ?</condition><then> <expr><literal type="string">"out of memory"</literal></expr> </then><else>:
                                       <expr><operator>(</operator><ternary><condition><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -- see zlib.h -- */</comment>
<function><type><name>void</name> <name>ZEXPORT</name></type> <name>gzclearerr</name><parameter_list>(<parameter><decl><type><name>file</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gzFile</name></type> <name>file</name></decl>;</decl_stmt>
<block>{<block_content>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>

    <comment type="block">/* get internal structure and check integrity */</comment>
    <if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_READ</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>GZ_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* clear error and end-of-file */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>GZ_READ</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>past</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>gz_error</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Z_OK</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create an error message in allocated memory and set state.state-&gt;err and
   state.state-&gt;msg accordingly.  Free any previous error message already there.  Do
   not try to free or allocate space if the error is Z_MEM_ERROR (out of
   memory).  Simply save the error message as a static string.  If there is an
   allocation failure constructing the error message, then convert the error to
   out of memory. */</comment>
<function><type><name>void</name> <name>ZLIB_INTERNAL</name></type> <name>gz_error</name><parameter_list>(<parameter><decl><type><name>state</name></type></decl></parameter>, <parameter><decl><type><name>err</name></type></decl></parameter>, <parameter><decl><type><name>msg</name></type></decl></parameter>)</parameter_list>
    <decl_stmt><decl><type><name>gz_statep</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
<block>{<block_content>
    <comment type="block">/* free previously allocated message and clear */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>Z_MEM_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if fatal, set state.state-&gt;x.have to 0 so that the gzgetc() macro fails */</comment>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name>err</name> <operator>!=</operator> <name>Z_BUF_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>have</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* set error code, and if no message, then done */</comment>
    <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>msg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* for an out of memory error, return literal string when requested */</comment>
    <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>Z_MEM_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* construct error message with path */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator>
            <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>Z_MEM_ERROR</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_snprintf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_vsnprintf</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr></argument>,
                   <argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INT_MAX</name></cpp:ifndef>
<comment type="block">/* portably return maximum value for an int (when limits.h presumed not
   available) -- we need to do this to cover cases where 2's complement not
   used, since C standard permits 1's complement and sign-bit representations,
   otherwise we could just use ((unsigned)-1) &gt;&gt; 1 */</comment>
<function><type><name>unsigned</name> <name>ZLIB_INTERNAL</name></type> <name>gz_intmax</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>p</name></decl>, <decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <do>do <block>{<block_content>
        <expr_stmt><expr><name>q</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>q</name></expr>)</condition>;</do>
    <return>return <expr><name>q</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
