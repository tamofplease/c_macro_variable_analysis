<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/wcdb/fts/mm_tokenizer.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making
 * WCDB available.
 *
 * Copyright (C) 2017 THL A29 Limited, a Tencent company.
 * All rights reserved.
 *
 * Licensed under the BSD 3-Clause License (the "License"); you may not use
 * this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *       https://opensource.org/licenses/BSD-3-Clause
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts3_tokenizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mm_fts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;icucompat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unicode/ubrk.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unicode/unorm.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unicode/utf16.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unicode/utf8.h&gt;</cpp:file></cpp:include>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROUND4</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((n) + 3) &amp; ~3)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>mm_tokenizer_t</name> <block>{
    <decl_stmt><decl><type><name>sqlite3_tokenizer</name></type> <name>base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>locale</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>mm_tokenizer_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>mm_cursor_t</name> <block>{
    <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name></type> <name>base</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>UBreakIterator</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>   <comment type="line">// UBreakIterator for the text.</comment>
    <decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>in_buffer</name></decl>;</decl_stmt>       <comment type="line">// whole input text buffer, in UTF-16, </comment>
                            <comment type="line">// allocated altogather with mm_cursor_t.</comment>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>in_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>in_length</name></decl>;</decl_stmt>          <comment type="line">// input text length.</comment>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out_buffer</name></decl>;</decl_stmt>       <comment type="line">// output token buffer, int UTF-8, </comment>
                            <comment type="line">// allocated in mmtok_next.</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>out_length</name></decl>;</decl_stmt>         <comment type="line">// output token buffer length.</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>token_count</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int32_t</name></type> <name>ideo_start</name></decl>;</decl_stmt> <comment type="line">// ideographic unary/binary tokenizing cursor.</comment>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>ideo_end</name></decl>;</decl_stmt>   <comment type="line">// ideographic unary/binary tokenizing end point.</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ideo_state</name></decl>;</decl_stmt>     <comment type="line">// 0 for unary output, -1 for invalid status.</comment>
}</block></struct></type> <name>mm_cursor_t</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINIMAL_OUT_BUFFER_LENGTH</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>generate_token_printable_code</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>length</name> <operator>*</operator> <literal type="number">5</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><name>out</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"%04hX "</literal></expr></argument>, <argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>output_token</name><parameter_list>(<parameter><decl><type><name>mm_cursor_t</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,
                        <parameter><decl><type><name>int32_t</name></type> <name>start</name></decl></parameter>,
                        <parameter><decl><type><name>int32_t</name></type> <name>end</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppToken</name></decl></parameter>,
                        <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnBytes</name></decl></parameter>,
                        <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piStartOffset</name></decl></parameter>,
                        <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piEndOffset</name></decl></parameter>,
                        <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPosition</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>UChar</name></type> <name><name>buf1</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UChar</name></type> <name><name>buf2</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UErrorCode</name></type> <name>status</name> <init>= <expr><name>U_ZERO_ERROR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>length</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>length</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>unorm_normalize</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>in_buffer</name></name> <operator>+</operator> <name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>UNORM_NFKD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                             <argument><expr><name>buf1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf1</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UChar</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// currently, only try fixed length buffer, failed if overflowed.</comment>
    <if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>result</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf1</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UChar</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seq</name> <init>=
            <expr><call><name>generate_token_printable_code</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>in_buffer</name></name> <operator>+</operator> <name>start</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_mm_set_last_error</name><argument_list>(
            <argument><expr><literal type="string">"Normalize token failed. ICU status: %d, input: %s"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>length</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>u_strFoldCase</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf2</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UChar</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
                           <argument><expr><name>U_FOLD_CASE_DEFAULT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// currently, only try fixed length buffer, failed if overflowed.</comment>
    <if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>result</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf2</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UChar</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seq</name> <init>= <expr><call><name>generate_token_printable_code</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_mm_set_last_error</name><argument_list>(
            <argument><expr><literal type="string">"FoldCase token failed. ICU status: %d, input: %s"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name> <operator>=</operator>
            <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>MINIMAL_OUT_BUFFER_LENGTH</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>out_length</name></name> <operator>=</operator> <name>MINIMAL_OUT_BUFFER_LENGTH</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>length</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>u_strToUTF8</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>out_length</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;</operator> <name><name>cur</name><operator>-&gt;</operator><name>out_length</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name> <init>=
            <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name></expr></argument>, <argument><expr><name>result</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>out_length</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>u_strToUTF8</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>out_length</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>length</name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>result</name> <operator>&gt;</operator> <name><name>cur</name><operator>-&gt;</operator><name>out_length</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>seq</name> <init>= <expr><call><name>generate_token_printable_code</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>sqlite3_mm_set_last_error</name><argument_list>(
            <argument><expr><literal type="string">"Transform token to UTF-8 failed. ICU status: %d, input: %s"</literal></expr></argument>,
            <argument><expr><name>status</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>ppToken</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnBytes</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piStartOffset</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>in_offset</name><index>[<expr><name>start</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piEndOffset</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>in_offset</name><index>[<expr><name>end</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piPosition</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>token_count</name></name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_splited_ideo_token</name><parameter_list>(<parameter><decl><type><name>mm_cursor_t</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UChar32</name></type> <name>c</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>ideo_state</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>ideo_start</name></name> <operator>==</operator> <name><name>cur</name><operator>-&gt;</operator><name>ideo_end</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>ideo_state</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// check UTF-16 surrogates, output 2 UChars if it's a lead surrogates, otherwise 1.</comment>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>ideo_start</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>in_buffer</name><index>[<expr><name>s</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>U16_IS_LEAD</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cur</name><operator>-&gt;</operator><name>ideo_end</name></name> <operator>-</operator> <name>s</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>e</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>ideo_start</name></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>mmtok_create</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppTokenizer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mm_tokenizer_t</name> <modifier>*</modifier></type><name>tok</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mm_tokenizer_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tok</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>tok</name><operator>-&gt;</operator><name>locale</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>locale</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>tok</name><operator>-&gt;</operator><name>locale</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>ppTokenizer</name> <operator>=</operator> <operator>(</operator><name>sqlite3_tokenizer</name> <operator>*</operator><operator>)</operator> <name>tok</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mmtok_destroy</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mm_tokenizer_t</name> <modifier>*</modifier></type><name>tok</name> <init>= <expr><operator>(</operator><name>mm_tokenizer_t</name> <operator>*</operator><operator>)</operator> <name>pTokenizer</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mmtok_open</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>nInput</name></decl></parameter>,
                      <parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mm_tokenizer_t</name> <modifier>*</modifier></type><name>tok</name> <init>= <expr><operator>(</operator><name>mm_tokenizer_t</name> <operator>*</operator><operator>)</operator> <name>pTokenizer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>mm_cursor_t</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i_input</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i_output</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>UErrorCode</name></type> <name>status</name> <init>= <expr><name>U_ZERO_ERROR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>dst_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UChar32</name></type> <name>c</name></decl>;</decl_stmt>

    <comment type="line">//__android_log_print(ANDROID_LOG_VERBOSE, "TOKENIZER", "Begin: %s", zInput);</comment>

    <if_stmt><if>if <condition>(<expr><name>nInput</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nInput</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>dst_len</name> <operator>=</operator> <call><name>ROUND4</name><argument_list>(<argument><expr><name>nInput</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cur</name> <operator>=</operator> <operator>(</operator><name>mm_cursor_t</name> <operator>*</operator><operator>)</operator> <call><name>sqlite3_malloc</name><argument_list>(
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mm_cursor_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>dst_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UChar</name></expr></argument>)</argument_list></sizeof> <comment type="line">// in_buffer</comment>
        <operator>+</operator> <operator>(</operator><name>dst_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>                 <comment type="line">// in_offset</comment>
        )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cur</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mm_cursor_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>in_buffer</name></name> <operator>=</operator> <operator>(</operator><name>UChar</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>cur</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>in_offset</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>in_buffer</name><index>[<expr><name>dst_len</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>out_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>token_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>ideo_start</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>ideo_end</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>ideo_state</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>i_input</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i_output</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>in_offset</name><index>[<expr><name>i_output</name></expr>]</index></name> <operator>=</operator> <name>i_input</name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i_input</name> <operator>&gt;=</operator> <name>nInput</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>U8_NEXT</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>i_input</name></expr></argument>, <argument><expr><name>nInput</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>is_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>U16_APPEND</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>in_buffer</name></name></expr></argument>, <argument><expr><name>i_output</name></expr></argument>, <argument><expr><name>dst_len</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>is_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_error</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_mm_set_last_error</name><argument_list>(
                <argument><expr><literal type="string">"Writing UTF-16 character failed. Code point: 0x%x"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>in_offset</name><index>[<expr><name>i_output</name></expr>]</index></name> <operator>=</operator> <name>i_input</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator>
        <call><name>ubrk_open</name><argument_list>(<argument><expr><name>UBRK_WORD</name></expr></argument>, <argument><expr><name><name>tok</name><operator>-&gt;</operator><name>locale</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>in_buffer</name></name></expr></argument>, <argument><expr><name>i_output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_mm_set_last_error</name><argument_list>(
            <argument><expr><literal type="string">"Open UBreakIterator failed. ICU error code: %d"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>in_length</name></name> <operator>=</operator> <name>i_output</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ubrk_first</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>(</operator><name>sqlite3_tokenizer_cursor</name> <operator>*</operator><operator>)</operator> <name>cur</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mmtok_close</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mm_cursor_t</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><operator>(</operator><name>mm_cursor_t</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ubrk_close</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>out_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>mmtok_next</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, <comment type="line">// Cursor returned by simpleOpen</comment>
           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppToken</name></decl></parameter>,              <comment type="line">// OUT: *ppToken is the token text</comment>
           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnBytes</name></decl></parameter>,                      <comment type="line">// OUT: Number of bytes in token</comment>
           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piStartOffset</name></decl></parameter>,                <comment type="line">// OUT: Starting offset of token</comment>
           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piEndOffset</name></decl></parameter>,                  <comment type="line">// OUT: Ending offset of token</comment>
           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piPosition</name></decl></parameter>                    <comment type="line">// OUT: Position integer of token</comment>
           )</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>mm_cursor_t</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><operator>(</operator><name>mm_cursor_t</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>token_type</name></decl>;</decl_stmt>

    <comment type="line">// process pending ideographic token.</comment>
    <if_stmt><if>if <condition>(<expr><call><name>find_splited_ideo_token</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>output_token</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>ppToken</name></expr></argument>, <argument><expr><name>pnBytes</name></expr></argument>, <argument><expr><name>piStartOffset</name></expr></argument>,
                            <argument><expr><name>piEndOffset</name></expr></argument>, <argument><expr><name>piPosition</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>ubrk_current</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// find first non-NONE token.</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>ubrk_next</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>UBRK_DONE</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_mm_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SQLITE_DONE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>token_type</name> <operator>=</operator> <call><name>ubrk_getRuleStatus</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>token_type</name> <operator>&gt;=</operator> <name>UBRK_WORD_NONE</name> <operator>&amp;&amp;</operator> <name>token_type</name> <operator>&lt;</operator> <name>UBRK_WORD_NONE_LIMIT</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// look at the first character, if it's a space or ZWSP, ignore this token.</comment>
            <comment type="line">// also ignore '*' because sqlite parser uses it as prefix operator.</comment>
            <decl_stmt><decl><type><name>UChar32</name></type> <name>c</name> <init>= <expr><name><name>cur</name><operator>-&gt;</operator><name>in_buffer</name><index>[<expr><name>start</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="number">0x200b</literal> <operator>||</operator> <call><name>u_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <break>break;</break>
    </block_content>}</block></for>

    <comment type="line">// for non-IDEO tokens, just return.</comment>
    <if_stmt><if>if <condition>(<expr><name>token_type</name> <operator>&lt;</operator> <name>UBRK_WORD_IDEO</name> <operator>||</operator> <name>token_type</name> <operator>&gt;=</operator> <name>UBRK_WORD_IDEO_LIMIT</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>output_token</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>ppToken</name></expr></argument>, <argument><expr><name>pnBytes</name></expr></argument>, <argument><expr><name>piStartOffset</name></expr></argument>,
                            <argument><expr><name>piEndOffset</name></expr></argument>, <argument><expr><name>piPosition</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// for IDEO tokens, find all suffix ideo tokens.</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>e</name> <init>= <expr><call><name>ubrk_next</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>UBRK_DONE</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>token_type</name> <operator>=</operator> <call><name>ubrk_getRuleStatus</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>token_type</name> <operator>&lt;</operator> <name>UBRK_WORD_IDEO</name> <operator>||</operator> <name>token_type</name> <operator>&gt;=</operator> <name>UBRK_WORD_IDEO_LIMIT</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>ubrk_isBoundary</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>ideo_start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>ideo_end</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>ideo_state</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>find_splited_ideo_token</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>output_token</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>ppToken</name></expr></argument>, <argument><expr><name>pnBytes</name></expr></argument>, <argument><expr><name>piStartOffset</name></expr></argument>,
                            <argument><expr><name>piEndOffset</name></expr></argument>, <argument><expr><name>piPosition</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_mm_set_last_error</name><argument_list>(<argument><expr><literal type="string">"IDEO token found but can't output token."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_tokenizer_module</name></type> <name>mm_tokenizer_module</name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>, <expr><name>mmtok_create</name></expr>, <expr><name>mmtok_destroy</name></expr>, <expr><name>mmtok_open</name></expr>, <expr><name>mmtok_close</name></expr>, <expr><name>mmtok_next</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>sqlite3_register_mm_tokenizer</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>module</name> <init>= <expr><operator>&amp;</operator><name>mm_tokenizer_module</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator>
        <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"SELECT fts3_tokenizer(?, ?)"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"mmicu"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>module</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_tokenizer_module</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
                      <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
