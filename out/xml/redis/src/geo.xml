<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/geo.c"><comment type="block">/*
 * Copyright (c) 2014, Matt Stancliff &lt;matt@genges.com&gt;.
 * Copyright (c) 2015-2016, Salvatore Sanfilippo &lt;antirez@gmail.com&gt;.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"geo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"geohash_helper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debugmacro.h"</cpp:file></cpp:include>

<comment type="block">/* Things exported from t_zset.c only for geo.c, since it is the only other
 * part of Redis that requires close zset introspection. */</comment>
<function_decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlFirstInRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>zslValueLteMax</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ====================================================================
 * This file implements the following commands:
 *
 *   - geoadd - add coordinates for value to geoset
 *   - georadius - search radius by coordinates in geoset
 *   - georadiusbymember - search radius based on geoset member position
 * ==================================================================== */</comment>

<comment type="block">/* ====================================================================
 * geoArray implementation
 * ==================================================================== */</comment>

<comment type="block">/* Create a new array of geoPoints. */</comment>
<function><type><name>geoArray</name> <modifier>*</modifier></type><name>geoArrayCreate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>geoArray</name> <modifier>*</modifier></type><name>ga</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ga</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* It gets allocated on first geoArrayAppend() call. */</comment>
    <expr_stmt><expr><name><name>ga</name><operator>-&gt;</operator><name>array</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ga</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ga</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>ga</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a new entry and return its pointer so that the caller can populate
 * it with data. */</comment>
<function><type><name>geoPoint</name> <modifier>*</modifier></type><name>geoArrayAppend</name><parameter_list>(<parameter><decl><type><name>geoArray</name> <modifier>*</modifier></type><name>ga</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ga</name><operator>-&gt;</operator><name>used</name></name> <operator>==</operator> <name><name>ga</name><operator>-&gt;</operator><name>buckets</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>ga</name><operator>-&gt;</operator><name>buckets</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>ga</name><operator>-&gt;</operator><name>buckets</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><name><name>ga</name><operator>-&gt;</operator><name>buckets</name></name><operator>*</operator><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ga</name><operator>-&gt;</operator><name>array</name></name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name><name>ga</name><operator>-&gt;</operator><name>array</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>geoPoint</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>ga</name><operator>-&gt;</operator><name>buckets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>geoPoint</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><name><name>ga</name><operator>-&gt;</operator><name>array</name></name><operator>+</operator><name><name>ga</name><operator>-&gt;</operator><name>used</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ga</name><operator>-&gt;</operator><name>used</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>gp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Destroy a geoArray created with geoArrayCreate(). */</comment>
<function><type><name>void</name></type> <name>geoArrayFree</name><parameter_list>(<parameter><decl><type><name>geoArray</name> <modifier>*</modifier></type><name>ga</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ga</name><operator>-&gt;</operator><name>used</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>ga</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>member</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>ga</name><operator>-&gt;</operator><name>array</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ====================================================================
 * Helpers
 * ==================================================================== */</comment>
<function><type><name>int</name></type> <name>decodeGeohash</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>bits</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>xy</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>GeoHashBits</name></type> <name>hash</name> <init>= <expr><block>{ <expr><operator>.</operator><name>bits</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>bits</name></expr>, <expr><operator>.</operator><name>step</name> <operator>=</operator> <name>GEO_STEP_MAX</name></expr> }</block></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>geohashDecodeToLongLatWGS84</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>xy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Input Argument Helper */</comment>
<comment type="block">/* Take a pointer to the latitude arg then use the next arg for longitude.
 * On parse error C_ERR is returned, otherwise C_OK. */</comment>
<function><type><name>int</name></type> <name>extractLongLatOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>xy</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>getDoubleFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>xy</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator>
            <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>C_ERR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name><name>xy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name>GEO_LONG_MIN</name> <operator>||</operator> <name><name>xy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name>GEO_LONG_MAX</name> <operator>||</operator>
        <name><name>xy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>GEO_LAT_MIN</name>  <operator>||</operator> <name><name>xy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name>GEO_LAT_MAX</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>sdscatprintf</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><literal type="string">"-ERR invalid longitude,latitude pair %f,%f\r\n"</literal></expr></argument>,<argument><expr><name><name>xy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>xy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Input Argument Helper */</comment>
<comment type="block">/* Decode lat/long from a zset member's score.
 * Returns C_OK on successful decoding, otherwise C_ERR is returned. */</comment>
<function><type><name>int</name></type> <name>longLatFromMember</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>member</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>xy</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>zsetScore</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>decodeGeohash</name><argument_list>(<argument><expr><name>score</name></expr></argument>, <argument><expr><name>xy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check that the unit argument matches one of the known units, and returns
 * the conversion factor to meters (you need to divide meters by the conversion
 * factor to convert to the right unit).
 *
 * If the unit is not valid, an error is reported to the client, and a value
 * less than zero is returned. */</comment>
<function><type><name>double</name></type> <name>extractUnitOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>unit</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>u</name> <init>= <expr><name><name>unit</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><literal type="string">"m"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><literal type="string">"km"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1000</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><literal type="string">"ft"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0.3048</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><literal type="string">"mi"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">1609.34</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
            <argument><expr><literal type="string">"unsupported unit provided. please use m, km, ft, mi"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Input Argument Helper.
 * Extract the dinstance from the specified two arguments starting at 'argv'
 * that shouldbe in the form: &lt;number&gt; &lt;unit&gt; and return the dinstance in the
 * specified unit on success. *conversions is populated with the coefficient
 * to use in order to convert meters to the unit.
 *
 * On error a value less than zero is returned. */</comment>
<function><type><name>double</name></type> <name>extractDistanceOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
                                     <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>conversion</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>distance</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>getDoubleFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>distance</name></expr></argument>,
                                   <argument><expr><literal type="string">"need numeric radius"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>distance</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"radius cannot be negative"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>double</name></type> <name>to_meters</name> <init>= <expr><call><name>extractUnitOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>to_meters</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>conversion</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>conversion</name> <operator>=</operator> <name>to_meters</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>distance</name> <operator>*</operator> <name>to_meters</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The default addReplyDouble has too much accuracy.  We use this
 * for returning location distances. "5.2145 meters away" is nicer
 * than "5.2144992818115 meters away." We provide 4 digits after the dot
 * so that the returned value is decently accurate even when the unit is
 * the kilometer. */</comment>
<function><type><name>void</name></type> <name>addReplyDoubleDistance</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>dbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dlen</name> <init>= <expr><call><name>snprintf</name><argument_list>(<argument><expr><name>dbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dbuf</name></expr></argument>, <argument><expr><name>dlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Helper function for geoGetPointsInRange(): given a sorted set score
 * representing a point, and another point (the center of our search) and
 * a radius, appends this entry as a geoPoint into the specified geoArray
 * only if the point is within the search area.
 *
 * returns C_OK if the point is included, or REIDS_ERR if it is outside. */</comment>
<function><type><name>int</name></type> <name>geoAppendIfWithinRadius</name><parameter_list>(<parameter><decl><type><name>geoArray</name> <modifier>*</modifier></type><name>ga</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lon</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lat</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>radius</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>member</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>distance</name></decl>, <decl><type ref="prev"/><name><name>xy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>decodeGeohash</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>xy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Can't decode. */</comment>
    <comment type="block">/* Note that geohashGetDistanceIfInRadiusWGS84() takes arguments in
     * reverse order: longitude first, latitude later. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>geohashGetDistanceIfInRadiusWGS84</name><argument_list>(<argument><expr><name>lon</name></expr></argument>,<argument><expr><name>lat</name></expr></argument>, <argument><expr><name><name>xy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>xy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                           <argument><expr><name>radius</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>distance</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>C_ERR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Append the new element. */</comment>
    <decl_stmt><decl><type><name>geoPoint</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><call><name>geoArrayAppend</name><argument_list>(<argument><expr><name>ga</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>longitude</name></name> <operator>=</operator> <name><name>xy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>latitude</name></name> <operator>=</operator> <name><name>xy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>dist</name></name> <operator>=</operator> <name>distance</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>member</name></name> <operator>=</operator> <name>member</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Query a Redis sorted set to extract all the elements between 'min' and
 * 'max', appending them into the array of geoPoint structures 'gparray'.
 * The command returns the number of elements added to the array.
 *
 * Elements which are farest than 'radius' from the specified 'x' and 'y'
 * coordinates are not included.
 *
 * The ability of this function to append to an existing set of points is
 * important for good performances because querying by radius is performed
 * using multiple queries to the sorted set, that we later need to sort
 * via qsort. Similarly we need to be able to reject points outside the search
 * radius area ASAP in order to allocate and process more points than needed. */</comment>
<function><type><name>int</name></type> <name>geoGetPointsInRange</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lon</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lat</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>radius</name></decl></parameter>, <parameter><decl><type><name>geoArray</name> <modifier>*</modifier></type><name>ga</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* minex 0 = include min in range; maxex 1 = exclude max in range */</comment>
    <comment type="block">/* That's: min &lt;= val &lt; max */</comment>
    <decl_stmt><decl><type><name>zrangespec</name></type> <name>range</name> <init>= <expr><block>{ <expr><operator>.</operator><name>min</name> <operator>=</operator> <name>min</name></expr>, <expr><operator>.</operator><name>max</name> <operator>=</operator> <name>max</name></expr>, <expr><operator>.</operator><name>minex</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>maxex</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>origincount</name> <init>= <expr><name><name>ga</name><operator>-&gt;</operator><name>used</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>member</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_ZIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>vlong</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Nothing exists starting at our min.  No results. */</comment>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>eptr</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If we fell out of range, break. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <comment type="block">/* We know the element exists. ziplistGet should always succeed */</comment>
            <expr_stmt><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>member</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>vstr</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr> </then><else>:
                                      <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>geoAppendIfWithinRadius</name><argument_list>(<argument><expr><name>ga</name></expr></argument>,<argument><expr><name>lon</name></expr></argument>,<argument><expr><name>lat</name></expr></argument>,<argument><expr><name>radius</name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>member</name></expr></argument>)</argument_list></call>
                <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>member</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ln</name> <operator>=</operator> <call><name>zslFirstInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Nothing exists starting at our min.  No results. */</comment>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <while>while <condition>(<expr><name>ln</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Abort when the node is no longer in range. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>geoAppendIfWithinRadius</name><argument_list>(<argument><expr><name>ga</name></expr></argument>,<argument><expr><name>lon</name></expr></argument>,<argument><expr><name>lat</name></expr></argument>,<argument><expr><name>radius</name></expr></argument>,<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call>
                <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>ga</name><operator>-&gt;</operator><name>used</name></name> <operator>-</operator> <name>origincount</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compute the sorted set scores min (inclusive), max (exclusive) we should
 * query in order to retrieve all the elements inside the specified area
 * 'hash'. The two scores are returned by reference in *min and *max. */</comment>
<function><type><name>void</name></type> <name>scoresOfGeoHashBox</name><parameter_list>(<parameter><decl><type><name>GeoHashBits</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>GeoHashFix52Bits</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>GeoHashFix52Bits</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* We want to compute the sorted set scores that will include all the
     * elements inside the specified Geohash 'hash', which has as many
     * bits as specified by hash.step * 2.
     *
     * So if step is, for example, 3, and the hash value in binary
     * is 101010, since our score is 52 bits we want every element which
     * is in binary: 101010?????????????????????????????????????????????
     * Where ? can be 0 or 1.
     *
     * To get the min score we just use the initial hash value left
     * shifted enough to get the 52 bit value. Later we increment the
     * 6 bit prefis (see the hash.bits++ statement), and get the new
     * prefix: 101011, which we align again to 52 bits to get the maximum
     * value (which is excluded from the search). So we get everything
     * between the two following scores (represented in binary):
     *
     * 1010100000000000000000000000000000000000000000000000 (included)
     * and
     * 1010110000000000000000000000000000000000000000000000 (excluded).
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <call><name>geohashAlign52Bits</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash</name><operator>.</operator><name>bits</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <call><name>geohashAlign52Bits</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Obtain all members between the min/max of this geohash bounding box.
 * Populate a geoArray of GeoPoints by calling geoGetPointsInRange().
 * Return the number of points added to the array. */</comment>
<function><type><name>int</name></type> <name>membersOfGeoHashBox</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>GeoHashBits</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>geoArray</name> <modifier>*</modifier></type><name>ga</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lon</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lat</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>radius</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>GeoHashFix52Bits</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>scoresOfGeoHashBox</name><argument_list>(<argument><expr><name>hash</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>min</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>geoGetPointsInRange</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>lon</name></expr></argument>, <argument><expr><name>lat</name></expr></argument>, <argument><expr><name>radius</name></expr></argument>, <argument><expr><name>ga</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Search all eight neighbors + self geohash box */</comment>
<function><type><name>int</name></type> <name>membersOfAllNeighbors</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>GeoHashRadius</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lon</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>lat</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>radius</name></decl></parameter>, <parameter><decl><type><name>geoArray</name> <modifier>*</modifier></type><name>ga</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>GeoHashBits</name></type> <name><name>neighbors</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>last_processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>debugmsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>neighbors</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>n</name><operator>.</operator><name>hash</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neighbors</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>n</name><operator>.</operator><name>neighbors</name><operator>.</operator><name>north</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neighbors</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>n</name><operator>.</operator><name>neighbors</name><operator>.</operator><name>south</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neighbors</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>n</name><operator>.</operator><name>neighbors</name><operator>.</operator><name>east</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neighbors</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>n</name><operator>.</operator><name>neighbors</name><operator>.</operator><name>west</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neighbors</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>n</name><operator>.</operator><name>neighbors</name><operator>.</operator><name>north_east</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neighbors</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>n</name><operator>.</operator><name>neighbors</name><operator>.</operator><name>north_west</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neighbors</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>n</name><operator>.</operator><name>neighbors</name><operator>.</operator><name>south_east</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neighbors</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name><name>n</name><operator>.</operator><name>neighbors</name><operator>.</operator><name>south_west</name></name></expr>;</expr_stmt>

    <comment type="block">/* For each neighbor (*and* our own hashbox), get all the matching
     * members and add them to the potential result list. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>neighbors</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>neighbors</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>HASHISZERO</name><argument_list>(<argument><expr><name><name>neighbors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>debugmsg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"neighbors[%d] is zero"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Debugging info. */</comment>
        <if_stmt><if>if <condition>(<expr><name>debugmsg</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>GeoHashRange</name></type> <name>long_range</name></decl>, <decl><type ref="prev"/><name>lat_range</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>geohashGetCoordRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>long_range</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lat_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>GeoHashArea</name></type> <name>myarea</name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>geohashDecode</name><argument_list>(<argument><expr><name>long_range</name></expr></argument>, <argument><expr><name>lat_range</name></expr></argument>, <argument><expr><name><name>neighbors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>myarea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Dump center square. */</comment>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"neighbors[%d]:\n"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"area.longitude.min: %f\n"</literal></expr></argument>, <argument><expr><name><name>myarea</name><operator>.</operator><name>longitude</name><operator>.</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"area.longitude.max: %f\n"</literal></expr></argument>, <argument><expr><name><name>myarea</name><operator>.</operator><name>longitude</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"area.latitude.min: %f\n"</literal></expr></argument>, <argument><expr><name><name>myarea</name><operator>.</operator><name>latitude</name><operator>.</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"area.latitude.max: %f\n"</literal></expr></argument>, <argument><expr><name><name>myarea</name><operator>.</operator><name>latitude</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* When a huge Radius (in the 5000 km range or more) is used,
         * adjacent neighbors can be the same, leading to duplicated
         * elements. Skip every range which is the same as the one
         * processed previously. */</comment>
        <if_stmt><if>if <condition>(<expr><name>last_processed</name> <operator>&amp;&amp;</operator>
            <name><name>neighbors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>bits</name> <operator>==</operator> <name><name>neighbors</name><index>[<expr><name>last_processed</name></expr>]</index></name><operator>.</operator><name>bits</name> <operator>&amp;&amp;</operator>
            <name><name>neighbors</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>step</name> <operator>==</operator> <name><name>neighbors</name><index>[<expr><name>last_processed</name></expr>]</index></name><operator>.</operator><name>step</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>debugmsg</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Skipping processing of %d, same as previous\n"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>count</name> <operator>+=</operator> <call><name>membersOfGeoHashBox</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name><name>neighbors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ga</name></expr></argument>, <argument><expr><name>lon</name></expr></argument>, <argument><expr><name>lat</name></expr></argument>, <argument><expr><name>radius</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_processed</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Sort comparators for qsort() */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sort_gp_asc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>geoPoint</name></name> <modifier>*</modifier></type><name>gpa</name> <init>= <expr><name>a</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>gpb</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* We can't do adist - bdist because they are doubles and
     * the comparator returns an int. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>gpa</name><operator>-&gt;</operator><name>dist</name></name> <operator>&gt;</operator> <name><name>gpb</name><operator>-&gt;</operator><name>dist</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>gpa</name><operator>-&gt;</operator><name>dist</name></name> <operator>==</operator> <name><name>gpb</name><operator>-&gt;</operator><name>dist</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sort_gp_desc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><operator>-</operator><call><name>sort_gp_asc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ====================================================================
 * Commands
 * ==================================================================== */</comment>

<comment type="block">/* GEOADD key long lat name [long2 lat2 name2 ... longN latN nameN] */</comment>
<function><type><name>void</name></type> <name>geoaddCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Check arguments number for sanity. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>%</operator> <literal type="number">3</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Need an odd number of arguments if we got this far... */</comment>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"syntax error. Try GEOADD key [x1] [y1] [name1] "</literal>
                         <literal type="string">"[x2] [y2] [name2] ... "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>elements</name> <init>= <expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">2</literal><operator>+</operator><name>elements</name><operator>*</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* ZADD key score ele ... */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>zcalloc</name><argument_list>(<argument><expr><name>argc</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>robj</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>createRawStringObject</name><argument_list>(<argument><expr><literal type="string">"zadd"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <comment type="block">/* key */</comment>
    <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create the argument vector to call ZADD in order to add all
     * the score,value pairs to the requested zset, where score is actually
     * an encoded version of lat,long. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>elements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name><name>xy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>extractLongLatOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">2</literal><operator>)</operator><operator>+</operator><operator>(</operator><name>i</name><operator>*</operator><literal type="number">3</literal><operator>)</operator></expr></argument>,<argument><expr><name>xy</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
            <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Turn the coordinates into the score of the element. */</comment>
        <decl_stmt><decl><type><name>GeoHashBits</name></type> <name>hash</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>geohashEncodeWGS84</name><argument_list>(<argument><expr><name><name>xy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>xy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>GEO_STEP_MAX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>GeoHashFix52Bits</name></type> <name>bits</name> <init>= <expr><call><name>geohashAlign52Bits</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>score</name> <init>= <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>, <argument><expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>i</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal><operator>+</operator><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal><operator>+</operator><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Finally call ZADD that will do the work for us. */</comment>
    <expr_stmt><expr><call><name>replaceClientCommandVector</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>argc</name></expr></argument>,<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zaddCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SORT_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SORT_ASC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SORT_DESC</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_COORDS</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>    <comment type="block">/* Search around coordinates. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_MEMBER</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>    <comment type="block">/* Search around member. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RADIUS_NOSTORE</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>   <comment type="block">/* Do not acceot STORE/STOREDIST option. */</comment>

<comment type="block">/* GEORADIUS key x y radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC]
 *                               [COUNT count] [STORE key] [STOREDIST key]
 * GEORADIUSBYMEMBER key member radius unit ... options ... */</comment>
<function><type><name>void</name></type> <name>georadiusGeneric</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>storekey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>storedist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 0 for STORE, 1 for STOREDIST. */</comment>

    <comment type="block">/* Look up the requested zset */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Find long/lat to use for radius search based on inquiry type */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>base_args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name><name>xy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>RADIUS_COORDS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>base_args</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>extractLongLatOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>xy</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>RADIUS_MEMBER</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>base_args</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>member</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>longLatFromMember</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>member</name></expr></argument>, <argument><expr><name>xy</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"could not decode requested zset member"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"Unknown georadius search type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Extract radius and units from arguments */</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>radius_meters</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>conversion</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>radius_meters</name> <operator>=</operator> <call><name>extractDistanceOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>+</operator> <name>base_args</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>conversion</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Discover and populate all optional parameters. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>withdist</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>withhash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>withcoords</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sort</name> <init>= <expr><name>SORT_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <name>base_args</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>remaining</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <name>base_args</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>remaining</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>base_args</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"withdist"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>withdist</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"withhash"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>withhash</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"withcoord"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>withcoords</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"asc"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>sort</name> <operator>=</operator> <name>SORT_ASC</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"desc"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>sort</name> <operator>=</operator> <name>SORT_DESC</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>remaining</name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>base_args</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"COUNT must be &gt; 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"store"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                       <operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>remaining</name> <operator>&amp;&amp;</operator>
                       <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RADIUS_NOSTORE</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>storekey</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>base_args</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>storedist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"storedist"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                       <operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>remaining</name> <operator>&amp;&amp;</operator>
                       <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RADIUS_NOSTORE</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>storekey</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>base_args</name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>storedist</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Trap options not compatible with STORE and STOREDIST. */</comment>
    <if_stmt><if>if <condition>(<expr><name>storekey</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>withdist</name> <operator>||</operator> <name>withhash</name> <operator>||</operator> <name>withcoords</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
            <argument><expr><literal type="string">"STORE option in GEORADIUS is not compatible with "</literal>
            <literal type="string">"WITHDIST, WITHHASH and WITHCOORDS options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* COUNT without ordering does not make much sense, force ASC
     * ordering if COUNT was specified but no sorting was requested. */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sort</name> <operator>==</operator> <name>SORT_NONE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>sort</name> <operator>=</operator> <name>SORT_ASC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get all neighbor geohash boxes for our radius search */</comment>
    <decl_stmt><decl><type><name>GeoHashRadius</name></type> <name>georadius</name> <init>=
        <expr><call><name>geohashGetAreasByRadiusWGS84</name><argument_list>(<argument><expr><name><name>xy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>xy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>radius_meters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Search the zset for all matching points */</comment>
    <decl_stmt><decl><type><name>geoArray</name> <modifier>*</modifier></type><name>ga</name> <init>= <expr><call><name>geoArrayCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>membersOfAllNeighbors</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>georadius</name></expr></argument>, <argument><expr><name><name>xy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>xy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>radius_meters</name></expr></argument>, <argument><expr><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If no matching results, the user gets an empty reply. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ga</name><operator>-&gt;</operator><name>used</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>storekey</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>geoArrayFree</name><argument_list>(<argument><expr><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>result_length</name> <init>= <expr><name><name>ga</name><operator>-&gt;</operator><name>used</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>returned_items</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>result_length</name> <operator>&lt;</operator> <name>count</name><operator>)</operator></expr> ?</condition><then>
                          <expr><name>result_length</name></expr> </then><else>: <expr><name>count</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONG</name></type> <name>option_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Process [optional] requested sorting */</comment>
    <if_stmt><if>if <condition>(<expr><name>sort</name> <operator>==</operator> <name>SORT_ASC</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>ga</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name>result_length</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>geoPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sort_gp_asc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>sort</name> <operator>==</operator> <name>SORT_DESC</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>ga</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name>result_length</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>geoPoint</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sort_gp_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>storekey</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* No target key, return results to user. */</comment>

        <comment type="block">/* Our options are self-contained nested multibulk replies, so we
         * only need to track how many of those nested replies we return. */</comment>
        <if_stmt><if>if <condition>(<expr><name>withdist</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>option_length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>withcoords</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>option_length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>withhash</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>option_length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* The multibulk len we send is exactly result_length. The result is
         * either all strings of just zset members  *or* a nested multi-bulk
         * reply containing the zset member string _and_ all the additional
         * options the user enabled for this request. */</comment>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>returned_items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Finally send results back to the caller */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>returned_items</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>geoPoint</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><name><name>ga</name><operator>-&gt;</operator><name>array</name></name><operator>+</operator><name>i</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>dist</name></name> <operator>/=</operator> <name>conversion</name></expr>;</expr_stmt> <comment type="block">/* Fix according to unit. */</comment>

            <comment type="block">/* If we have options in option_length, return each sub-result
             * as a nested multi-bulk.  Add 1 to account for result value
             * itself. */</comment>
            <if_stmt><if>if <condition>(<expr><name>option_length</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>option_length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>addReplyBulkSds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>gp</name><operator>-&gt;</operator><name>member</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>member</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>withdist</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addReplyDoubleDistance</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>gp</name><operator>-&gt;</operator><name>dist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>withhash</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>gp</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>withcoords</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReplyHumanLongDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>gp</name><operator>-&gt;</operator><name>longitude</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReplyHumanLongDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>gp</name><operator>-&gt;</operator><name>latitude</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Target key, create a sorted set with the results. */</comment>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>maxelelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>returned_items</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>createZsetObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zs</name> <operator>=</operator> <name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>returned_items</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>znode</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>geoPoint</name> <modifier>*</modifier></type><name>gp</name> <init>= <expr><name><name>ga</name><operator>-&gt;</operator><name>array</name></name><operator>+</operator><name>i</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>dist</name></name> <operator>/=</operator> <name>conversion</name></expr>;</expr_stmt> <comment type="block">/* Fix according to unit. */</comment>
            <decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><ternary><condition><expr><name>storedist</name></expr> ?</condition><then> <expr><name><name>gp</name><operator>-&gt;</operator><name>dist</name></name></expr> </then><else>: <expr><name><name>gp</name><operator>-&gt;</operator><name>score</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>elelen</name> <init>= <expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>gp</name><operator>-&gt;</operator><name>member</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>maxelelen</name> <operator>&lt;</operator> <name>elelen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxelelen</name> <operator>=</operator> <name>elelen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name><name>gp</name><operator>-&gt;</operator><name>member</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>gp</name><operator>-&gt;</operator><name>member</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>gp</name><operator>-&gt;</operator><name>member</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>returned_items</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>zsetConvertToZiplistIfNeeded</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>maxelelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>storekey</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,<argument><expr><literal type="string">"georadiusstore"</literal></expr></argument>,<argument><expr><name>storekey</name></expr></argument>,
                                <argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>returned_items</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>storekey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>storekey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>storekey</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>returned_items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>geoArrayFree</name><argument_list>(<argument><expr><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* GEORADIUS wrapper function. */</comment>
<function><type><name>void</name></type> <name>georadiusCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>georadiusGeneric</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RADIUS_COORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* GEORADIUSBYMEMBER wrapper function. */</comment>
<function><type><name>void</name></type> <name>georadiusbymemberCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>georadiusGeneric</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RADIUS_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* GEORADIUS_RO wrapper function. */</comment>
<function><type><name>void</name></type> <name>georadiusroCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>georadiusGeneric</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RADIUS_COORDS</name><operator>|</operator><name>RADIUS_NOSTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* GEORADIUSBYMEMBER_RO wrapper function. */</comment>
<function><type><name>void</name></type> <name>georadiusbymemberroCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>georadiusGeneric</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>RADIUS_MEMBER</name><operator>|</operator><name>RADIUS_NOSTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* GEOHASH key ele1 ele2 ... eleN
 *
 * Returns an array with an 11 characters geohash representation of the
 * position of the specified elements. */</comment>
<function><type><name>void</name></type> <name>geohashCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>geoalphabet</name><init>= <expr><literal type="string">"0123456789bcdefghjkmnpqrstuvwxyz"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Look up the requested zset */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>zobj</name> <operator>&amp;&amp;</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Geohash elements one after the other, using a null bulk reply for
     * missing elements. */</comment>
    <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zobj</name> <operator>||</operator> <call><name>zsetScore</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* The internal format we use for geocoding is a bit different
             * than the standard, since we use as initial latitude range
             * -85,85, while the normal geohashing algorithm uses -90,90.
             * So we have to decode our position and re-encode using the
             * standard ranges in order to output a valid geohash string. */</comment>

            <comment type="block">/* Decode... */</comment>
            <decl_stmt><decl><type><name>double</name></type> <name><name>xy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>decodeGeohash</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>xy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Re-encode */</comment>
            <decl_stmt><decl><type><name>GeoHashRange</name></type> <name><name>r</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>GeoHashBits</name></type> <name>hash</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>min</name> <operator>=</operator> <operator>-</operator><literal type="number">180</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>max</name> <operator>=</operator> <literal type="number">180</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>min</name> <operator>=</operator> <operator>-</operator><literal type="number">90</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>max</name> <operator>=</operator> <literal type="number">90</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>geohashEncode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>xy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>xy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">26</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">11</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><operator>(</operator><name><name>hash</name><operator>.</operator><name>bits</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">52</literal><operator>-</operator><operator>(</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><literal type="number">5</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1f</literal></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>geoalphabet</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* GEOPOS key ele1 ele2 ... eleN
 *
 * Returns an array of two-items arrays representing the x,y position of each
 * element specified in the arguments. For missing elements NULL is returned. */</comment>
<function><type><name>void</name></type> <name>geoposCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Look up the requested zset */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>zobj</name> <operator>&amp;&amp;</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Report elements one after the other, using a null bulk reply for
     * missing elements. */</comment>
    <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zobj</name> <operator>||</operator> <call><name>zsetScore</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullmultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Decode... */</comment>
            <decl_stmt><decl><type><name>double</name></type> <name><name>xy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>decodeGeohash</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>xy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullmultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyHumanLongDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>xy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyHumanLongDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>xy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* GEODIST key ele1 ele2 [unit]
 *
 * Return the distance, in meters by default, otherwise accordig to "unit",
 * between points ele1 and ele2. If one or more elements are missing NULL
 * is returned. */</comment>
<function><type><name>void</name></type> <name>geodistCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>to_meter</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check if there is the unit to extract, otherwise assume meters. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>to_meter</name> <operator>=</operator> <call><name>extractUnitOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>to_meter</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Look up the requested zset */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call><operator>)</operator>
        <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Get the scores. We need both otherwise NULL is returned. */</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>score1</name></decl>, <decl><type ref="prev"/><name>score2</name></decl>, <decl><type ref="prev"/><name><name>xyxy</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>zsetScore</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>score1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name> <operator>||</operator>
        <call><name>zsetScore</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>score2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Decode &amp; compute the distance. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>decodeGeohash</name><argument_list>(<argument><expr><name>score1</name></expr></argument>,<argument><expr><name>xyxy</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>decodeGeohash</name><argument_list>(<argument><expr><name>score2</name></expr></argument>,<argument><expr><name>xyxy</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>addReplyDoubleDistance</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
            <argument><expr><call><name>geohashGetDistance</name><argument_list>(<argument><expr><name><name>xyxy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>xyxy</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>xyxy</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>xyxy</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>/</operator> <name>to_meter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
