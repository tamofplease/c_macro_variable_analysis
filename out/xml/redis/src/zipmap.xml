<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/zipmap.c"><comment type="block">/* String -&gt; String Map data structure optimized for size.
 * This file implements a data structure mapping strings to other strings
 * implementing an O(n) lookup data structure designed to be very memory
 * efficient.
 *
 * The Redis Hash type uses this data structure for hashes composed of a small
 * number of elements, to switch to a hash table once a given number of
 * elements is reached.
 *
 * Given that many times Redis Hashes are used to represent objects composed
 * of few fields, this is a very big win in terms of used memory.
 *
 * --------------------------------------------------------------------------
 *
 * Copyright (c) 2009-2010, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<comment type="block">/* Memory layout of a zipmap, for the map "foo" =&gt; "bar", "hello" =&gt; "world":
 *
 * &lt;zmlen&gt;&lt;len&gt;"foo"&lt;len&gt;&lt;free&gt;"bar"&lt;len&gt;"hello"&lt;len&gt;&lt;free&gt;"world"
 *
 * &lt;zmlen&gt; is 1 byte length that holds the current size of the zipmap.
 * When the zipmap length is greater than or equal to 254, this value
 * is not used and the zipmap needs to be traversed to find out the length.
 *
 * &lt;len&gt; is the length of the following string (key or value).
 * &lt;len&gt; lengths are encoded in a single value or in a 5 bytes value.
 * If the first byte value (as an unsigned 8 bit value) is between 0 and
 * 253, it's a single-byte length. If it is 254 then a four bytes unsigned
 * integer follows (in the host byte ordering). A value of 255 is used to
 * signal the end of the hash.
 *
 * &lt;free&gt; is the number of free unused bytes after the string, resulting
 * from modification of values associated to a key. For instance if "foo"
 * is set to "bar", and later "foo" will be set to "hi", it will have a
 * free byte to use if the value will enlarge again later, or even in
 * order to add a key/value pair if it fits.
 *
 * &lt;free&gt; is always an unsigned 8 bit number, because if after an
 * update operation there are more than a few free bytes, the zipmap will be
 * reallocated to make sure it is as small as possible.
 *
 * The most compact representation of the above two elements hash is actually:
 *
 * "\x02\x03foo\x03\x00bar\x05hello\x05\x00world\xff"
 *
 * Note that because keys and values are prefixed length "objects",
 * the lookup will take O(N) where N is the number of elements
 * in the zipmap and *not* the number of bytes needed to represent the zipmap.
 * This lowers the constant times considerably.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"endianconv.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_Portability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Win32_Interop/Win32_FDAPI.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPMAP_BIGLEN</name></cpp:macro> <cpp:value>254</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPMAP_END</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>

<comment type="block">/* The following defines the max value for the &lt;free&gt; field described in the
 * comments above, that is, the max number of trailing bytes in a value. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPMAP_VALUE_MAX_FREE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/* The following macro returns the number of bytes needed to encode the length
 * for the integer value _l, that is, 1 byte for lengths &lt; ZIPMAP_BIGLEN and
 * 5 bytes for all the other lengths. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPMAP_LEN_BYTES</name><parameter_list>(<parameter><type><name>_l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((_l) &lt; ZIPMAP_BIGLEN) ? 1 : sizeof(unsigned int)+1)</cpp:value></cpp:define>

<comment type="block">/* Create a new empty zipmap. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zipmapNew</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>zm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Length */</comment>
    <expr_stmt><expr><name><name>zm</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ZIPMAP_END</name></expr>;</expr_stmt>
    <return>return <expr><name>zm</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decode the encoded length pointed by 'p' */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>zipmapDecodeLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name> <init>= <expr><operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>ZIPMAP_BIGLEN</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memrev32ifbe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Encode the length 'l' writing it in 'p'. If p is NULL it just returns
 * the amount of bytes required to encode such a length. */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>zipmapEncodeLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>ZIPMAP_LEN_BYTES</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>ZIPMAP_BIGLEN</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ZIPMAP_BIGLEN</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memrev32ifbe</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="number">1</literal><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Search for a matching key, returning a pointer to the entry inside the
 * zipmap. Returns NULL if the key is not found.
 *
 * If NULL is returned, and totlen is not NULL, it is set to the entire
 * size of the zimap, so that the calling function will be able to
 * reallocate the original zipmap to make room for more entries. */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zipmapLookupRaw</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>totlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>zm</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>k</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>l</name></decl>,<decl><type ref="prev"/><name>llen</name></decl>;</decl_stmt>

    <while>while<condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>ZIPMAP_END</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>free</name></decl>;</decl_stmt>

        <comment type="block">/* Match or skip the key */</comment>
        <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>zipmapDecodeLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>llen</name> <operator>=</operator> <call><name>zipmapEncodeLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>l</name> <operator>==</operator> <name>klen</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>llen</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Only return when the user doesn't care
             * for the total length of the zipmap. */</comment>
            <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>k</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><name>p</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>llen</name><operator>+</operator><name>l</name></expr>;</expr_stmt>
        <comment type="block">/* Skip the value as well */</comment>
        <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>zipmapDecodeLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipmapEncodeLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>free</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>free</name></expr>;</expr_stmt> <comment type="block">/* +1 to skip the free byte */</comment>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>totlen</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>zm</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>k</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PORT_ULONG</name></type> <name>zipmapRequiredLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl></parameter>)</parameter_list> <block>{<block_content> <decl_stmt><decl><type><name>WIN_PORT_FIX</name> <comment type="block">/* PORT_ULONG -&gt; unsigned int */</comment>
    <name>PORT_ULONG</name></type> <name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>l</name> <operator>=</operator> <name>klen</name><operator>+</operator><name>vlen</name><operator>+</operator><literal type="number">3</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>klen</name> <operator>&gt;=</operator> <name>ZIPMAP_BIGLEN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>l</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&gt;=</operator> <name>ZIPMAP_BIGLEN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>l</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>l</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the total amount used by a key (encoded length + payload) */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>zipmapRawKeyLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>l</name> <init>= <expr><call><name>zipmapDecodeLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>zipmapEncodeLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>l</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the total amount used by a value
 * (encoded length + single byte free count + payload) */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>zipmapRawValueLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>l</name> <init>= <expr><call><name>zipmapDecodeLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>used</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>used</name> <operator>=</operator> <call><name>zipmapEncodeLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>used</name> <operator>+=</operator> <name><name>p</name><index>[<expr><name>used</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>l</name></expr>;</expr_stmt>
    <return>return <expr><name>used</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If 'p' points to a key, this function returns the total amount of
 * bytes used to store this entry (entry = key + associated value + trailing
 * free space if any). */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>zipmapRawEntryLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>l</name> <init>= <expr><call><name>zipmapRawKeyLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>l</name> <operator>+</operator> <call><name>zipmapRawValueLength</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zipmapResize</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>zm</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zm</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ZIPMAP_END</name></expr>;</expr_stmt>
    <return>return <expr><name>zm</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set key to value, creating the key if it does not already exist.
 * If 'update' is not NULL, *update is set to 1 if the key was
 * already preset, otherwise to 0. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zipmapSet</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>update</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>zmlen</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>freelen</name></decl>, <decl><type ref="prev"/><name>reqlen</name> <init>= <expr><call><name>zipmapRequiredLength</name><argument_list>(<argument><expr><name>klen</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>empty</name></decl>, <decl><type ref="prev"/><name>vempty</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>freelen</name> <operator>=</operator> <name>reqlen</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>update</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>update</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>zipmapLookupRaw</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>klen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zmlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Key not found: enlarge */</comment>
        <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapResize</name><argument_list>(<argument><expr><name>zm</name></expr></argument>, <argument><expr><name>zmlen</name><operator>+</operator><name>reqlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>zm</name><operator>+</operator><name>zmlen</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>zmlen</name> <operator>=</operator> <name>zmlen</name><operator>+</operator><name>reqlen</name></expr>;</expr_stmt>

        <comment type="block">/* Increase zipmap length (this is an insert) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>zm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name>ZIPMAP_BIGLEN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* Key found. Is there enough space for the new value? */</comment>
        <comment type="block">/* Compute the total length: */</comment>
        <if_stmt><if>if <condition>(<expr><name>update</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>update</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>freelen</name> <operator>=</operator> <call><name>zipmapRawEntryLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>freelen</name> <operator>&lt;</operator> <name>reqlen</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Store the offset of this key within the current zipmap, so
             * it can be resized. Then, move the tail backwards so this
             * pair fits at the current position. */</comment>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>zm</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapResize</name><argument_list>(<argument><expr><name>zm</name></expr></argument>, <argument><expr><name>zmlen</name><operator>-</operator><name>freelen</name><operator>+</operator><name>reqlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <name>zm</name><operator>+</operator><name>offset</name></expr>;</expr_stmt>

            <comment type="block">/* The +1 in the number of bytes to be moved is caused by the
             * end-of-zipmap byte. Note: the *original* zmlen is used. */</comment>
            <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>reqlen</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>freelen</name></expr></argument>, <argument><expr><name>zmlen</name><operator>-</operator><operator>(</operator><name>offset</name><operator>+</operator><name>freelen</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>zmlen</name> <operator>=</operator> <name>zmlen</name><operator>-</operator><name>freelen</name><operator>+</operator><name>reqlen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>freelen</name> <operator>=</operator> <name>reqlen</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* We now have a suitable block where the key/value entry can
     * be written. If there is too much free space, move the tail
     * of the zipmap a few bytes to the front and shrink the zipmap,
     * as we want zipmaps to be very space efficient. */</comment>
    <expr_stmt><expr><name>empty</name> <operator>=</operator> <name>freelen</name><operator>-</operator><name>reqlen</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>empty</name> <operator>&gt;=</operator> <name>ZIPMAP_VALUE_MAX_FREE</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* First, move the tail &lt;empty&gt; bytes to the front, then resize
         * the zipmap to be &lt;empty&gt; bytes smaller. */</comment>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>zm</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>reqlen</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>freelen</name></expr></argument>, <argument><expr><name>zmlen</name><operator>-</operator><operator>(</operator><name>offset</name><operator>+</operator><name>freelen</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zmlen</name> <operator>-=</operator> <name>empty</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapResize</name><argument_list>(<argument><expr><name>zm</name></expr></argument>, <argument><expr><name>zmlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>zm</name><operator>+</operator><name>offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>vempty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>vempty</name> <operator>=</operator> <name>empty</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Just write the key + value and we are done. */</comment>
    <comment type="block">/* Key: */</comment>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipmapEncodeLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>klen</name></expr>;</expr_stmt>
    <comment type="block">/* Value: */</comment>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipmapEncodeLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>vempty</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>val</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>zm</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Remove the specified key. If 'deleted' is not NULL the pointed integer is
 * set to 0 if the key was not found, to 1 if it was found and deleted. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zipmapDel</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>deleted</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>zmlen</name></decl>, <decl><type ref="prev"/><name>freelen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>zipmapLookupRaw</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>klen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zmlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>freelen</name> <operator>=</operator> <call><name>zipmapRawEntryLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>freelen</name></expr></argument>, <argument><expr><name>zmlen</name><operator>-</operator><operator>(</operator><operator>(</operator><name>p</name><operator>-</operator><name>zm</name><operator>)</operator><operator>+</operator><name>freelen</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapResize</name><argument_list>(<argument><expr><name>zm</name></expr></argument>, <argument><expr><name>zmlen</name><operator>-</operator><name>freelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Decrease zipmap length */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>zm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name>ZIPMAP_BIGLEN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>zm</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Call before iterating through elements via zipmapNext() */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zipmapRewind</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><name>zm</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function is used to iterate through all the zipmap elements.
 * In the first call the first argument is the pointer to the zipmap + 1.
 * In the next calls what zipmapNext returns is used as first argument.
 * Example:
 *
 * unsigned char *i = zipmapRewind(my_zipmap);
 * while((i = zipmapNext(i,&amp;key,&amp;klen,&amp;value,&amp;vlen)) != NULL) {
 *     printf("%d bytes key at $p\n", klen, key);
 *     printf("%d bytes value at $p\n", vlen, value);
 * }
 */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zipmapNext</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>klen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>vlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>zm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIPMAP_END</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>key</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>key</name> <operator>=</operator> <name>zm</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>klen</name> <operator>=</operator> <call><name>zipmapDecodeLength</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>key</name> <operator>+=</operator> <call><name>ZIPMAP_LEN_BYTES</name><argument_list>(<argument><expr><operator>*</operator><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zm</name> <operator>+=</operator> <call><name>zipmapRawKeyLength</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>zm</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>vlen</name> <operator>=</operator> <call><name>zipmapDecodeLength</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>+=</operator> <call><name>ZIPMAP_LEN_BYTES</name><argument_list>(<argument><expr><operator>*</operator><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zm</name> <operator>+=</operator> <call><name>zipmapRawValueLength</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>zm</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Search a key and retrieve the pointer and len of the associated value.
 * If the key is found the function returns 1, otherwise 0. */</comment>
<function><type><name>int</name></type> <name>zipmapGet</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>vlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>zipmapLookupRaw</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>klen</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipmapRawKeyLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>vlen</name> <operator>=</operator> <call><name>zipmapDecodeLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>ZIPMAP_LEN_BYTES</name><argument_list>(<argument><expr><operator>*</operator><name>vlen</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return 1 if the key exists, otherwise 0 is returned. */</comment>
<function><type><name>int</name></type> <name>zipmapExists</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>zipmapLookupRaw</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>klen</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the number of entries inside a zipmap */</comment>
<function><type><name>unsigned</name> <name>int</name></type> <name>zipmapLen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>zm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name>ZIPMAP_BIGLEN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>zm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>zipmapRewind</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>zipmapNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

        <comment type="block">/* Re-store length if small enough */</comment>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>ZIPMAP_BIGLEN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>zm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the raw size in bytes of a zipmap, so that we can serialize
 * the zipmap on disk (or everywhere is needed) just writing the returned
 * amount of bytes of the C array starting at the zipmap pointer. */</comment>
<function><type><name>size_t</name></type> <name>zipmapBlobLen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>totlen</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>zipmapLookupRaw</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>totlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>totlen</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REDIS_TEST</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zipmapRepr</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{status %u}"</literal></expr></argument>,<argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIPMAP_END</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{end}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>e</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>zipmapDecodeLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{key %u}"</literal></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipmapEncodeLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>zipmapDecodeLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{value %u}"</literal></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipmapEncodeLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>l</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name><operator>+</operator><name>e</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while<condition>(<expr><name>e</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
                <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(x)</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>zipmapTest</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zm</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapSet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"name"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"foo"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapSet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"surname"</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"foo"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapSet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"age"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"foo"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipmapRepr</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapSet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"hello"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"world!"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapSet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"foo"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"bar"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapSet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"foo"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"!"</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipmapRepr</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapSet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"foo"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"12345"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipmapRepr</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapSet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"new"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"xx"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapSet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"noval"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">""</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipmapRepr</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapDel</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"new"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zipmapRepr</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nLook up large key:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">512</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>zipmapSet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">512</literal></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"long"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>zipmapGet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">512</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  &lt;long key&gt; is associated to the %d bytes value: %.*s\n"</literal></expr></argument>,
                <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nPerform a direct lookup:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>zipmapGet</name><argument_list>(<argument><expr><name>zm</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <literal type="string">"foo"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  foo is associated to the %d bytes value: %.*s\n"</literal></expr></argument>,
                <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nIterate through elements:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>zipmapRewind</name><argument_list>(<argument><expr><name>zm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name></decl>, <decl><type ref="prev"/><name>vlen</name></decl>;</decl_stmt>

        <while>while<condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>zipmapNext</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>klen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  %d:%.*s =&gt; %d:%.*s\n"</literal></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
