<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/redis/src/t_stream.c"><comment type="block">/*
 * Copyright (c) 2017, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"endianconv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stream.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_BYTES_PER_LISTPACK</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>

<comment type="block">/* Every stream item inside the listpack, has a flags field that is used to
 * mark the entry as deleted, or having the same field as the "master"
 * entry at the start of the listpack&gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_ITEM_FLAG_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>             <comment type="block">/* No special flags. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_ITEM_FLAG_DELETED</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>     <comment type="block">/* Entry is delted. Skip it. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_ITEM_FLAG_SAMEFIELDS</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>  <comment type="block">/* Same fields as master entry. */</comment>

<function_decl><type><name>void</name></type> <name>streamFreeCG</name><parameter_list>(<parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>streamFreeNACK</name><parameter_list>(<parameter><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>na</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>size_t</name></type> <name>streamReplyWithRangeFromConsumerPEL</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* -----------------------------------------------------------------------
 * Low level stream encoding: a radix tree of listpacks.
 * ----------------------------------------------------------------------- */</comment>

<comment type="block">/* Create a new stream data structure. */</comment>
<function><type><name>stream</name> <modifier>*</modifier></type><name>streamNew</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name><operator>.</operator><name>ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Created on demand to save memory when not used. */</comment>
    <return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free a stream, including the listpacks stored inside the radix tree. */</comment>
<function><type><name>void</name></type> <name>freeStream</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>raxFreeWithCallback</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>lpFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>raxFreeWithCallback</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>,<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>streamFreeCG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Set 'id' to be its successor streamID */</comment>
<function><type><name>void</name></type> <name>streamIncrID</name><parameter_list>(<parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>==</operator> <name>UINT64_MAX</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>==</operator> <name>UINT64_MAX</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* Special case where 'id' is the last possible streamID... */</comment>
            <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the length of a stream. */</comment>
<function><type><name>PORT_ULONG</name></type> <name>streamLength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>robj</name> <modifier>*</modifier></type><name>subject</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Generate the next stream item ID given the previous one. If the current
 * milliseconds Unix time is greater than the previous one, just use this
 * as time part and start with sequence part of zero. Otherwise we use the
 * previous time (and never go backward) and increment the sequence. */</comment>
<function><type><name>void</name></type> <name>streamNextID</name><parameter_list>(<parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>last_id</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>new_id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>ms</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ms</name> <operator>&gt;</operator> <name><name>last_id</name><operator>-&gt;</operator><name>ms</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>new_id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>new_id</name> <operator>=</operator> <operator>*</operator><name>last_id</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>streamIncrID</name><argument_list>(<argument><expr><name>new_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This is just a wrapper for lpAppend() to directly use a 64 bit integer
 * instead of a string. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpAppendInteger</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>LONG_STR_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slen</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is just a wrapper for lpReplace() to directly use a 64 bit integer
 * instead of a string to replace the current element. The function returns
 * the new listpack as return value, and also updates the current cursor
 * by updating '*pos'. */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpReplaceInteger</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>LONG_STR_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slen</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>lpInsert</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><operator>*</operator><name>pos</name></expr></argument>, <argument><expr><name>LP_REPLACE</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is a wrapper function for lpGet() to directly get an integer value
 * from the listpack (that may store numbers as a string), converting
 * the string if needed. */</comment>
<function><type><name>int64_t</name></type> <name>lpGetInteger</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>lpGet</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* The following code path should never be used for how listpacks work:
     * they should always be able to store an int64_t value in integer
     * encoded form. However the implementation may change. */</comment>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>ll</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>string2ll</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>e</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>retval</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <name>ll</name></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Debugging function to log the full content of a listpack. Useful
 * for development and debugging. */</comment>
<function><type><name>void</name></type> <name>streamLogListpackContent</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>LP_INTBUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>v</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"- [%d] '%.*s'"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Convert the specified stream entry ID as a 128 bit big endian number, so
 * that the IDs can be sorted lexicographically. */</comment>
<function><type><name>void</name></type> <name>streamEncodeID</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>htonu64</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>htonu64</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This is the reverse of streamEncodeID(): the decoded ID will be stored
 * in the 'id' structure passed by reference. The buffer 'buf' must point
 * to a 128 bit big-endian encoded ID. */</comment>
<function><type><name>void</name></type> <name>streamDecodeID</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <call><name>ntohu64</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <call><name>ntohu64</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Compare two stream IDs. Return -1 if a &lt; b, 0 if a == b, 1 if a &gt; b. */</comment>
<function><type><name>int</name></type> <name>streamCompareID</name><parameter_list>(<parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ms</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ms</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ms</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ms</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <comment type="block">/* The ms part is the same. Check the sequence part. */</comment>
    <if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>seq</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>seq</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>seq</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Everything is the same: IDs are equal. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Adds a new item into the stream 's' having the specified number of
 * field-value pairs as specified in 'numfields' and stored into 'argv'.
 * Returns the new entry ID populating the 'added_id' structure.
 *
 * If 'use_id' is not NULL, the ID is not auto-generated by the function,
 * but instead the passed ID is uesd to add the new entry. In this case
 * adding the entry may fail as specified later in this comment.
 *
 * The function returns C_OK if the item was added, this is always true
 * if the ID was generated by the function. However the function may return
 * C_ERR if an ID was given via 'use_id', but adding it failed since the
 * current top ID is greater or equal. */</comment>
<function><type><name>int</name></type> <name>streamAppendItem</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>numfields</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>added_id</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>use_id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    
    <comment type="block">/* Generate the new entry ID. */</comment>
    <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>use_id</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>id</name> <operator>=</operator> <operator>*</operator><name>use_id</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>streamNextID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Check that the new ID is greater than the last entry ID
     * or return an error. Automatically generated IDs might
     * overflow (and wrap-around) when incrementing the sequence 
       part. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Add the new entry. */</comment>
    <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>lp_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Total bytes in the tail listpack. */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Tail listpack pointer. */</comment>

    <comment type="block">/* Get a reference to the tail node listpack. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>ri</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lp_bytes</name> <operator>=</operator> <call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We have to add the key into the radix tree in lexicographic order,
     * to do so we consider the ID as a single 128 bit number written in
     * big endian, so that the most significant bytes are the first ones. */</comment>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name><name>rax_key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Key in the radix tree containing the listpack.*/</comment>
    <decl_stmt><decl><type><name>streamID</name></type> <name>master_id</name></decl>;</decl_stmt>     <comment type="block">/* ID of the master entry in the listpack. */</comment>

    <comment type="block">/* Create a new listpack and radix tree node if needed. Note that when
     * a new listpack is created, we populate it with a "master entry". This
     * is just a set of fields that is taken as references in order to compress
     * the stream entries that we'll add inside the listpack.
     *
     * Note that while we use the first added entry fields to create
     * the master entry, the first added entry is NOT represented in the master
     * entry, which is a stand alone object. But of course, the first entry
     * will compress well because it's used as reference.
     *
     * The master entry is composed like in the following example:
     *
     * +-------+---------+------------+---------+--/--+---------+---------+-+
     * | count | deleted | num-fields | field_1 | field_2 | ... | field_N |0|
     * +-------+---------+------------+---------+--/--+---------+---------+-+
     *
     * count and deleted just represent respectively the total number of
     * entries inside the listpack that are valid, and marked as deleted
     * (delted flag in the entry flags set). So the total number of items
     * actually inside the listpack (both deleted and not) is count+deleted.
     *
     * The real entries will be encoded with an ID that is just the
     * millisecond and sequence difference compared to the key stored at
     * the radix tree node containing the listpack (delta encoding), and
     * if the fields of the entry are the same as the master enty fields, the
     * entry flags will specify this fact and the entry fields and number
     * of fields will be omitted (see later in the code of this function).
     *
     * The "0" entry at the end is the same as the 'lp-count' entry in the
     * regular stream entries (see below), and marks the fact that there are
     * no more entries, when we scan the stream from right to left. */</comment>

    <comment type="block">/* First of all, check if we can append to the current macro node or
     * if we need to switch to the next one. 'lp' will be set to NULL if
     * the current node is full. */</comment>
    <if_stmt><if>if <condition>(<expr><name>lp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>stream_node_max_bytes</name></name> <operator>&amp;&amp;</operator>
            <name>lp_bytes</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>stream_node_max_bytes</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>lp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>stream_node_max_entries</name></name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>stream_node_max_entries</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>STREAM_ITEM_FLAG_NONE</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>lp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>lp_bytes</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>stream_node_max_bytes</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>master_id</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>rax_key</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Create the listpack having the master entry ID and fields. */</comment>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* One item, the one we are adding. */</comment>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Zero deleted so far. */</comment>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>numfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>sds</name></type> <name>field</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>field</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Master entry zero terminator. */</comment>
        <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rax_key</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rax_key</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The first entry we insert, has obviously the same fields of the
         * master entry. */</comment>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rax_key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>rax_key</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rax_key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Read the master ID from the radix tree key. */</comment>
        <expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name>rax_key</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>master_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp_ele</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Update count and skip the deleted fields. */</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lp_ele</name></expr></argument>,<argument><expr><name>count</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* seek deleted. */</comment>
        <expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* seek master entry num fields. */</comment>

        <comment type="block">/* Check if the entry we are adding, have the same fields
         * as the master entry. */</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>master_fields_count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>numfields</name> <operator>==</operator> <name>master_fields_count</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>master_fields_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>sds</name></type> <name>field</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>e_len</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>LP_INTBUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>lpGet</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e_len</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="block">/* Stop if there is a mismatch. */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>e_len</name> <operator>||</operator>
                    <call><name>memcmp</name><argument_list>(<argument><expr><name>e</name></expr></argument>,<argument><expr><name>field</name></expr></argument>,<argument><expr><name>e_len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <comment type="block">/* All fields are the same! We can compress the field names
             * setting a single bit in the flags. */</comment>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>master_fields_count</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Populate the listpack with the new entry. We use the following
     * encoding:
     *
     * +-----+--------+----------+-------+-------+-/-+-------+-------+--------+
     * |flags|entry-id|num-fields|field-1|value-1|...|field-N|value-N|lp-count|
     * +-----+--------+----------+-------+-------+-/-+-------+-------+--------+
     *
     * However if the SAMEFIELD flag is set, we have just to populate
     * the entry with the values, so it becomes:
     *
     * +-----+--------+-------+-/-+-------+--------+
     * |flags|entry-id|value-1|...|value-N|lp-count|
     * +-----+--------+-------+-/-+-------+--------+
     *
     * The entry-id field is actually two separated fields: the ms
     * and seq difference compared to the master entry.
     *
     * The lp-count field is a number that states the number of listpack pieces
     * that compose the entry, so that it's possible to travel the entry
     * in reverse order: we can just start from the end of the listpack, read
     * the entry, and jump back N times to seek the "flags" field to read
     * the stream full entry. */</comment>
    <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name><name>id</name><operator>.</operator><name>ms</name></name> <operator>-</operator> <name><name>master_id</name><operator>.</operator><name>ms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name><name>id</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <name><name>master_id</name><operator>.</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>numfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>sds</name></type> <name>field</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>field</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>value</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <comment type="block">/* Compute and store the lp-count field. */</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>lp_count</name> <init>= <expr><name>numfields</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>lp_count</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <comment type="block">/* Add the 3 fixed fields flags + ms-diff + seq-diff. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If the item is not compressed, it also has the fields other than
         * the values, and an additional num-fileds field. */</comment>
        <expr_stmt><expr><name>lp_count</name> <operator>+=</operator> <name>numfields</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Insert back into the tree in order to update the listpack pointer. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>.</operator><name>data</name></name> <operator>!=</operator> <name>lp</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rax_key</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rax_key</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>added_id</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>added_id</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Trim the stream 's' to have no more than maxlen elements, and return the
 * number of elements removed from the stream. The 'approx' option, if non-zero,
 * specifies that the trimming must be performed in a approximated way in
 * order to maximize performances. This means that the stream may contain
 * more elements than 'maxlen', and elements are only removed if we can remove
 * a *whole* node of the radix tree. The elements are removed from the head
 * of the stream (older elements).
 *
 * The function may return zero if:
 *
 * 1) The stream is already shorter or equal to the specified max length.
 * 2) The 'approx' option is true and the head node had not enough elements
 *    to be deleted, leaving the stream with a number of elements &gt;= maxlen.
 */</comment>
<function><type><name>int64_t</name></type> <name>streamTrimByLength</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>approx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;=</operator> <name>maxlen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <name>maxlen</name> <operator>&amp;&amp;</operator> <call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>entries</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Check if we can remove the whole node, and still have at
         * least maxlen elements. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>entries</name> <operator>&gt;=</operator> <name>maxlen</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"&gt;="</literal></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name>entries</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>deleted</name> <operator>+=</operator> <name>entries</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* If we cannot remove a whole element, and approx is true,
         * stop here. */</comment>
        <if_stmt><if>if <condition>(<expr><name>approx</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* Otherwise, we have to mark single entries inside the listpack
         * as deleted. We start by updating the entries/deleted counters. */</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>to_delete</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>maxlen</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>to_delete</name> <operator>&lt;</operator> <name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,<argument><expr><name>entries</name><operator>-</operator><name>to_delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Seek deleted field. */</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>marked_deleted</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,<argument><expr><name>marked_deleted</name><operator>+</operator><name>to_delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Seek num-of-fields in the master entry. */</comment>

        <comment type="block">/* Skip all the master fields. */</comment>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>master_fields_count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Seek the first field. */</comment>
        <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>master_fields_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> <comment type="block">/* Skip all master fields. */</comment>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Skip the zero master entry terminator. */</comment>

        <comment type="block">/* 'p' is now pointing to the first entry inside the listpack.
         * We have to run entry after entry, marking entries as deleted
         * if they are already not deleted. */</comment>
        <while>while<condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>to_skip</name></decl>;</decl_stmt>

            <comment type="block">/* Mark the entry as deleted. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_DELETED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_ITEM_FLAG_DELETED</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>deleted</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;=</operator> <name>maxlen</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* Enough entries deleted. */</comment>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Skip ID ms delta. */</comment>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Skip ID seq delta. */</comment>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Seek num-fields or values (if compressed). */</comment>
            <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>to_skip</name> <operator>=</operator> <name>master_fields_count</name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>to_skip</name> <operator>=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>to_skip</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><operator>(</operator><name>to_skip</name><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <while>while<condition>(<expr><name>to_skip</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while> <comment type="block">/* Skip the whole entry. */</comment>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Skip the final lp-count field. */</comment>
        </block_content>}</block></while>

        <comment type="block">/* Here we should perform garbage collection in case at this point
         * there are too many entries deleted inside the listpack. */</comment>
        <expr_stmt><expr><name>entries</name> <operator>-=</operator> <name>to_delete</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>marked_deleted</name> <operator>+=</operator> <name>to_delete</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>entries</name> <operator>+</operator> <name>marked_deleted</name> <operator>&gt;</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <name>marked_deleted</name> <operator>&gt;</operator> <name>entries</name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* TODO: perform a garbage collection. */</comment>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Update the listpack with the new pointer. */</comment>
        <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <break>break;</break> <comment type="block">/* If we are here, there was enough to delete in the current
                  node, so no need to go to the next node. */</comment>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>deleted</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Initialize the stream iterator, so that we can call iterating functions
 * to get the next items. This requires a corresponding streamIteratorStop()
 * at the end. The 'rev' parameter controls the direction. If it's zero the
 * iteration is from the start to the end element (inclusive), otherwise
 * if rev is non-zero, the iteration is reversed.
 *
 * Once the iterator is initialized, we iterate like this:
 *
 *  streamIterator myiterator;
 *  streamIteratorStart(&amp;myiterator,...);
 *  int64_t numfields;
 *  while(streamIteratorGetID(&amp;myiterator,&amp;ID,&amp;numfields)) {
 *      while(numfields--) {
 *          unsigned char *key, *value;
 *          size_t key_len, value_len;
 *          streamIteratorGetField(&amp;myiterator,&amp;key,&amp;value,&amp;key_len,&amp;value_len);
 *
 *          ... do what you want with key and value ...
 *      }
 *  }
 *  streamIteratorStop(&amp;myiterator); */</comment>
<function><type><name>void</name></type> <name>streamIteratorStart</name><parameter_list>(<parameter><decl><type><name>streamIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rev</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* Intialize the iterator and translates the iteration start/stop
     * elements into a 128 big big-endian number. */</comment>
    <if_stmt><if>if <condition>(<expr><name>start</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>,<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>,<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Seek the correct node in the radix tree. */</comment>
    <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rev</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>start</name><operator>-&gt;</operator><name>ms</name></name> <operator>||</operator> <name><name>start</name><operator>-&gt;</operator><name>seq</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;="</literal></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>,
                    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>raxEOF</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>end</name><operator>-&gt;</operator><name>ms</name></name> <operator>||</operator> <name><name>end</name><operator>-&gt;</operator><name>seq</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;="</literal></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>,
                    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>raxEOF</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>stream</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* There is no current listpack right now. */</comment>
    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Current listpack cursor. */</comment>
    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>rev</name></name> <operator>=</operator> <name>rev</name></expr>;</expr_stmt>  <comment type="block">/* Direction, if non-zero reversed, from end to start. */</comment>
</block_content>}</block></function>

<comment type="block">/* Return 1 and store the current item ID at 'id' if there are still
 * elements within the iteration range, otherwise return 0 in order to
 * signal the iteration terminated. */</comment>
<function><type><name>int</name></type> <name>streamIteratorGetID</name><parameter_list>(<parameter><decl><type><name>streamIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>numfields</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* Will stop when element &gt; stop_key or end of radix tree. */</comment>
        <comment type="block">/* If the current listpack is set to NULL, this is the start of the
         * iteration or the previous listpack was completely iterated.
         * Go to the next node. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>si</name><operator>-&gt;</operator><name>rev</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>rev</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>raxPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Get the master ID. */</comment>
            <expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>master_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Get the master fields count. */</comment>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpFirst</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <comment type="block">/* Seek items count */</comment>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Seek deleted count. */</comment>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Seek num fields. */</comment>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_count</name></name> <operator>=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Seek first field. */</comment>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_start</name></name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr>;</expr_stmt>
            <comment type="block">/* We are now pointing to the first field of the master entry.
             * We need to seek either the first or the last entry depending
             * on the direction of the iteration. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If we are iterating in normal order, skip the master fields
                 * to seek the first actual entry. */</comment>
                <for>for <control>(<init><decl><type><name>uint64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>si</name><operator>-&gt;</operator><name>master_fields_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* If we are iterating in reverse direction, just seek the
                 * last part of the last entry in the listpack (that is, the
                 * fields count). */</comment>
                <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpLast</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If we are itereating in the reverse order, and this is not
             * the first entry emitted for this listpack, then we already
             * emitted the current entry, and have to go back to the previous
             * one. */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>lp_count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while<condition>(<expr><name>lp_count</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
            <comment type="block">/* Seek lp-count of prev entry. */</comment>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* For every radix tree node, iterate the corresponding listpack,
         * returning elements when they are within range. */</comment>
        <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* If we are going forward, skip the previous entry
                 * lp-count field (or in case of the master entry, the zero
                 * term field) */</comment>
                <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <comment type="block">/* If we are going backward, read the number of elements this
                 * entry is composed of, and jump backward N times to seek
                 * its start. */</comment>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>lp_count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>lp_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* We reached the master entry. */</comment>
                    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <while>while<condition>(<expr><name>lp_count</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* Get the flags entry. */</comment>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_flags</name></name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Seek ID. */</comment>

            <comment type="block">/* Get the ID: it is encoded as difference between the master
             * ID and this entry ID. */</comment>
            <expr_stmt><expr><operator>*</operator><name>id</name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>master_id</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>+=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>+=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* The number of entries is here or not depending on the
             * flags. */</comment>
            <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>numfields</name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>master_fields_count</name></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>numfields</name> <operator>=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* If current &gt;= start, and the entry is not marked as
             * deleted, emit it. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                    <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_DELETED</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* We are already out of range. */</comment>
                    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_ptr</name></name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>master_fields_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <return>return <expr><literal type="number">1</literal></expr>;</return> <comment type="block">/* Valid item returned. */</comment>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                    <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_DELETED</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* We are already out of range. */</comment>
                    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_ptr</name></name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>master_fields_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <return>return <expr><literal type="number">1</literal></expr>;</return> <comment type="block">/* Valid item returned. */</comment>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* If we do not emit, we have to discard if we are going
             * forward, or seek the previous entry if we are going
             * backward. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>to_discard</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr> ?</condition><then>
                                      <expr><operator>*</operator><name>numfields</name></expr> </then><else>: <expr><operator>*</operator><name>numfields</name><operator>*</operator><literal type="number">2</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>to_discard</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>int64_t</name></type> <name>prev_times</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* flag + id ms + id seq + one more to
                                           go back to the previous entry "count"
                                           field. */</comment>
                <comment type="block">/* If the entry was not flagged SAMEFIELD we also read the
                 * number of fields, so go back one more. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prev_times</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <while>while<condition>(<expr><name>prev_times</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/* End of listpack reached. Try the next/prev radix tree node. */</comment>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Get the field and value of the current item we are iterating. This should
 * be called immediately after streamIteratorGetID(), and for each field
 * according to the number of fields returned by streamIteratorGetID().
 * The function populates the field and value pointers and the corresponding
 * lengths by reference, that are valid until the next iterator call, assuming
 * no one touches the stream meanwhile. */</comment>
<function><type><name>void</name></type> <name>streamIteratorGetField</name><parameter_list>(<parameter><decl><type><name>streamIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fieldptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>valueptr</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>fieldlen</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>valuelen</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>fieldptr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_ptr</name></name></expr></argument>,<argument><expr><name>fieldlen</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>field_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_ptr</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>fieldptr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>,<argument><expr><name>fieldlen</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>field_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>valueptr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>,<argument><expr><name>valuelen</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>value_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Remove the current entry from the stream: can be called after the
 * GetID() API or after any GetField() call, however we need to iterate
 * a valid entry while calling this function. Moreover the function
 * requires the entry ID we are currently iterating, that was previously
 * returned by GetID().
 *
 * Note that after calling this function, next calls to GetField() can't
 * be performed: the entry is now deleted. Instead the iterator will
 * automatically re-seek to the next entry, so the caller should continue
 * with GetID(). */</comment>
<function><type><name>void</name></type> <name>streamIteratorRemoveEntry</name><parameter_list>(<parameter><decl><type><name>streamIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>aux</name></decl>;</decl_stmt>

    <comment type="block">/* We do not really delete the entry here. Instead we mark it as
     * deleted flagging it, and also incrementing the count of the
     * deleted entries in the listpack header.
     *
     * We start flagging: */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_ITEM_FLAG_DELETED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>lp_flags</name></name></expr></argument>,<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Change the valid/deleted entries count in the master entry. */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>aux</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If this is the last element in the listpack, we can remove the whole
         * node. */</comment>
        <expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>stream</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* In the base case we alter the counters of valid/deleted entries. */</comment>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,<argument><expr><name>aux</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Seek deleted field. */</comment>
        <expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,<argument><expr><name>aux</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Update the listpack with the new pointer. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name> <operator>!=</operator> <name>lp</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>stream</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Update the number of entries counter. */</comment>
    <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>stream</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>

    <comment type="block">/* Re-seek the iterator to fix the now messed up state. */</comment>
    <decl_stmt><decl><type><name>streamID</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <operator>*</operator><name>current</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>*</operator><name>current</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><name>si</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* TODO: perform a garbage collection here if the ration between
     * deleted and valid goes over a certain limit. */</comment>
</block_content>}</block></function>

<comment type="block">/* Stop the stream iterator. The only cleanup we need is to free the rax
 * itereator, since the stream iterator itself is supposed to be stack
 * allocated. */</comment>
<function><type><name>void</name></type> <name>streamIteratorStop</name><parameter_list>(<parameter><decl><type><name>streamIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Delete the specified item ID from the stream, returning 1 if the item
 * was deleted 0 otherwise (if it does not exist). */</comment>
<function><type><name>int</name></type> <name>streamDeleteItem</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamIterator</name></type> <name>si</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>streamID</name></type> <name>myid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>numfields</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>streamIteratorGetID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>myid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numfields</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>streamIteratorRemoveEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>myid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>deleted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>deleted</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the last valid (non-tombstone) streamID of 's'. */</comment>
<function><type><name>void</name></type> <name>streamLastValidID</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>maxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>streamIterator</name></type> <name>si</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>numfields</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>streamIteratorGetID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><name>maxid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Emit a reply in the client output buffer by formatting a Stream ID
 * in the standard &lt;ms&gt;-&lt;seq&gt; format, using the simple string protocol
 * of REPL. */</comment>
<function><type><name>void</name></type> <name>addReplyStreamID</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>sds</name></type> <name>replyid</name> <init>= <expr><call><name>sdscatfmt</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"%U-%U"</literal></expr></argument>,<argument><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name></expr></argument>,<argument><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>addReplyBulkSds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>replyid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Similar to the above function, but just creates an object, usually useful
 * for replication purposes to create arguments. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>createObjectFromStreamID</name><parameter_list>(<parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>, <argument><expr><call><name>sdscatfmt</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"%U-%U"</literal></expr></argument>,
                        <argument><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name></expr></argument>,<argument><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* As a result of an explicit XCLAIM or XREADGROUP command, new entries
 * are created in the pending list of the stream and consumers. We need
 * to propagate this changes in the form of XCLAIM commands. */</comment>
<function><type><name>void</name></type> <name>streamPropagateXCLAIM</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>groupname</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="block">/* We need to generate an XCLAIM that will work in a idempotent fashion:
     *
     * XCLAIM &lt;key&gt; &lt;group&gt; &lt;consumer&gt; 0 &lt;id&gt; TIME &lt;milliseconds-unix-time&gt;
     *        RETRYCOUNT &lt;count&gt; FORCE JUSTID LASTID &lt;id&gt;.
     *
     * Note that JUSTID is useful in order to avoid that XCLAIM will do
     * useless work in the slave side, trying to fetch the stream item. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"XCLAIM"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>groupname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"TIME"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"RETRYCOUNT"</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"FORCE"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"JUSTID"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"LASTID"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>createObjectFromStreamID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We use progagate() because this code path is not always called from
     * the command execution context. Moreover this will just alter the
     * consumer group state, and we don't need MULTI/EXEC wrapping because
     * there is no message state cross-message atomicity required. */</comment>
    <expr_stmt><expr><call><name>propagate</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>xclaimCommand</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><literal type="number">14</literal></expr></argument>,<argument><expr><name>PROPAGATE_AOF</name><operator>|</operator><name>PROPAGATE_REPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We need this when we want to propoagate the new last-id of a consumer group
 * that was consumed by XREADGROUP with the NOACK option: in that case we can't
 * propagate the last ID just using the XCLAIM LASTID option, so we emit
 *
 *  XGROUP SETID &lt;key&gt; &lt;groupname&gt; &lt;id&gt;
 */</comment>
<function><type><name>void</name></type> <name>streamPropagateGroupID</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>groupname</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"XGROUP"</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"SETID"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>groupname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>createObjectFromStreamID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We use progagate() because this code path is not always called from
     * the command execution context. Moreover this will just alter the
     * consumer group state, and we don't need MULTI/EXEC wrapping because
     * there is no message state cross-message atomicity required. */</comment>
    <expr_stmt><expr><call><name>propagate</name><argument_list>(<argument><expr><name><name>server</name><operator>.</operator><name>xgroupCommand</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>,<argument><expr><name>PROPAGATE_AOF</name><operator>|</operator><name>PROPAGATE_REPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send the stream items in the specified range to the client 'c'. The range
 * the client will receive is between start and end inclusive, if 'count' is
 * non zero, no more than 'count' elements are sent.
 *
 * The 'end' pointer can be NULL to mean that we want all the elements from
 * 'start' till the end of the stream. If 'rev' is non zero, elements are
 * produced in reversed order from end to start.
 *
 * The function returns the number of entries emitted.
 *
 * If group and consumer are not NULL, the function performs additional work:
 * 1. It updates the last delivered ID in the group in case we are
 *    sending IDs greater than the current last ID.
 * 2. If the requested IDs are already assigned to some other consumer, the
 *    function will not return it to the client.
 * 3. An entry in the pending list will be created for every entry delivered
 *    for the first time to this consumer.
 *
 * The behavior may be modified passing non-zero flags:
 *
 * STREAM_RWR_NOACK: Do not craete PEL entries, that is, the point "3" above
 *                   is not performed.
 * STREAM_RWR_RAWENTRIES: Do not emit array boundaries, but just the entries,
 *                        and return the number of entries emitted as usually.
 *                        This is used when the function is just used in order
 *                        to emit data and there is some higher level logic.
 *
 * The final argument 'spi' (stream propagatino info pointer) is a structure
 * filled with information needed to propagte the command execution to AOF
 * and slaves, in the case a consumer group was passed: we need to generate
 * XCLAIM commands to create the pending list into AOF/slaves in that case.
 *
 * If 'spi' is set to NULL no propagation will happen even if the group was
 * given, but currently such a feature is never used by the code base that
 * will always pass 'spi' and propagate when a group is passed.
 *
 * Note that this function is recursive in certain cases. When it's called
 * with a non NULL group and consumer argument, it may call
 * streamReplyWithRangeFromConsumerPEL() in order to get entries from the
 * consumer pending entries list. However such a function will then call
 * streamReplyWithRange() in order to emit single entries (found in the
 * PEL by ID) to the client. This is the use case for the STREAM_RWR_RAWENTRIES
 * flag.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_RWR_NOACK</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>         <comment type="block">/* Do not create entries in the PEL. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_RWR_RAWENTRIES</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>    <comment type="block">/* Do not emit protocol for array
                                           boundaries, just the entries. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_RWR_HISTORY</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>       <comment type="block">/* Only serve consumer local PEL. */</comment>
<function><type><name>size_t</name></type> <name>streamReplyWithRange</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rev</name></decl></parameter>, <parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>streamPropInfo</name> <modifier>*</modifier></type><name>spi</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamIterator</name></type> <name>si</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>numfields</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>propagate_last_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If the client is asking for some history, we serve it using a
     * different function, so that we return entries *solely* from its
     * own PEL. This ensures each consumer will always and only see
     * the history of messages delivered to it and not yet confirmed
     * as delivered. */</comment>
    <if_stmt><if>if <condition>(<expr><name>group</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_RWR_HISTORY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>streamReplyWithRangeFromConsumerPEL</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>start</name></expr></argument>,<argument><expr><name>end</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,
                                                   <argument><expr><name>consumer</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_RWR_RAWENTRIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>arraylen_ptr</name> <operator>=</operator> <call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>start</name></expr></argument>,<argument><expr><name>end</name></expr></argument>,<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><call><name>streamIteratorGetID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numfields</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Update the group last_id if needed. */</comment>
        <if_stmt><if>if <condition>(<expr><name>group</name> <operator>&amp;&amp;</operator> <call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>propagate_last_id</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Emit a two elements array for each item. The first is
         * the ID, the second is an array of field-value pairs. */</comment>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>numfields</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Emit the field-value pairs. */</comment>
        <while>while<condition>(<expr><name>numfields</name><operator>--</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>key_len</name></decl>, <decl><type ref="prev"/><name>value_len</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>streamIteratorGetField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key_len</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>value</name></expr></argument>,<argument><expr><name>value_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* If a group is passed, we need to create an entry in the
         * PEL (pending entries list) of this group *and* this consumer.
         *
         * Note that we cannot be sure about the fact the message is not
         * already owned by another consumer, because the admin is able
         * to change the consumer group last delivered ID using the
         * XGROUP SETID command. So if we find that there is already
         * a NACK for the entry, we need to associate it to the new
         * consumer. */</comment>
        <if_stmt><if>if <condition>(<expr><name>group</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_RWR_NOACK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Try to add a new NACK. Most of the time this will work and
             * will not require extra lookups. We'll fix the problem later
             * if we find that there is already a entry for this ID. */</comment>
            <decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><call><name>streamCreateNACK</name><argument_list>(<argument><expr><name>consumer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>group_inserted</name> <init>=
                <expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>consumer_inserted</name> <init>=
                <expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Now we can check if the entry was already busy, and
             * in that case reassign the entry to the new consumer,
             * or update it if the consumer is the same as before. */</comment>
            <if_stmt><if>if <condition>(<expr><name>group_inserted</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>streamFreeNACK</name><argument_list>(<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nack</name> <operator>=</operator> <call><name>raxFind</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>nack</name> <operator>!=</operator> <name>raxNotFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Update the consumer and NACK metadata. */</comment>
                <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>=</operator> <name>consumer</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <comment type="block">/* Add the entry in the new consumer local PEL. */</comment>
                <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>group_inserted</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>consumer_inserted</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"NACK half-created. Should not be possible."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Propagate as XCLAIM. */</comment>
            <if_stmt><if>if <condition>(<expr><name>spi</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>idarg</name> <init>= <expr><call><name>createObjectFromStreamID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>streamPropagateXCLAIM</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>spi</name><operator>-&gt;</operator><name>keyname</name></name></expr></argument>,<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>spi</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>,<argument><expr><name>idarg</name></expr></argument>,<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>idarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>propagate_last_id</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>streamPropagateGroupID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>spi</name><operator>-&gt;</operator><name>keyname</name></name></expr></argument>,<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>spi</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>==</operator> <name>arraylen</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>arraylen_ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>arraylen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is an helper function for streamReplyWithRange() when called with
 * group and consumer arguments, but with a range that is referring to already
 * delivered messages. In this case we just emit messages that are already
 * in the history of the consumer, fetching the IDs from its PEL.
 *
 * Note that this function does not have a 'rev' argument because it's not
 * possible to iterate in reverse using a group. Basically this function
 * is only called as a result of the XREADGROUP command.
 *
 * This function is more expensive because it needs to inspect the PEL and then
 * seek into the radix tree of the messages in order to emit the full message
 * to the client. However clients only reach this code path when they are
 * fetching the history of already retrieved messages, which is rare. */</comment>
<function><type><name>size_t</name></type> <name>streamReplyWithRangeFromConsumerPEL</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>startkey</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>endkey</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>,<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>endkey</name></expr></argument>,<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"&gt;="</literal></expr></argument>,<argument><expr><name>startkey</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>count</name> <operator>||</operator> <name>arraylen</name> <operator>&lt;</operator> <name>count</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name>end</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>streamID</name></type> <name>thisid</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>thisid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>thisid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>thisid</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>STREAM_RWR_RAWENTRIES</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Note that we may have a not acknowledged entry in the PEL
             * about a message that's no longer here because was removed
             * by the user by other means. In that case we signal it emitting
             * the ID but then a NULL entry for the fields. */</comment>
            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullmultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>arraylen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------
 * Stream commands implementation
 * ----------------------------------------------------------------------- */</comment>

<comment type="block">/* Look the stream at 'key' and return the corresponding stream object.
 * The function creates a key setting it to an empty stream if needed. */</comment>
<function><type><name>robj</name> <modifier>*</modifier></type><name>streamTypeLookupWriteOrCreate</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createStreamObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_STREAM</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>wrongtypeerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function to convert a string to an unsigned long long value.
 * The function attempts to use the faster string2ll() function inside
 * Redis: if it fails, strtoull() is used instead. The function returns
 * 1 if the conversion happened successfully or 0 if the number is
 * invalid or out of range. */</comment>
<function><type><name>int</name></type> <name>string2ull</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>PORT_ULONGLONG</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>ll</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>string2ll</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>ll</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ll</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Negative values are out of range. */</comment>
        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>ll</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>strtoull</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINVAL</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <operator>!</operator><operator>(</operator><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* strtoull() failed. */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return> <comment type="block">/* Conversion done! */</comment>
</block_content>}</block></function>

<comment type="block">/* Parse a stream ID in the format given by clients to Redis, that is
 * &lt;ms&gt;-&lt;seq&gt;, and converts it into a streamID structure. If
 * the specified ID is invalid C_ERR is returned and an error is reported
 * to the client, otherwise C_OK is returned. The ID may be in incomplete
 * form, just stating the milliseconds time part of the stream. In such a case
 * the missing part is set according to the value of 'missing_seq' parameter.
 *
 * The IDs "-" and "+" specify respectively the minimum and maximum IDs
 * that can be represented. If 'strict' is set to 1, "-" and "+" will be
 * treated as an invalid ID.
 *
 * If 'c' is set to NULL, no reply is sent to the client. */</comment>
<function><type><name>int</name></type> <name>streamGenericParseIDOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>missing_seq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strict</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>strict</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Handle the "-" and "+" special cases. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>C_OK</name></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
        <return>return <expr><name>C_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse &lt;ms&gt;-&lt;seq&gt; form. */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dot</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>dot</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>dot</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>PORT_ULONGLONG</name></type> <name>ms</name></decl>, <decl><type ref="prev"/><name>seq</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>string2ull</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dot</name> <operator>&amp;&amp;</operator> <call><name>string2ull</name><argument_list>(<argument><expr><name>dot</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dot</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>seq</name> <operator>=</operator> <name>missing_seq</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <name>seq</name></expr>;</expr_stmt>
    <return>return <expr><name>C_OK</name></expr>;</return>

<label><name>invalid</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid stream ID specified as stream "</literal>
                           <literal type="string">"command argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Wrapper for streamGenericParseIDOrReply() with 'strict' argument set to
 * 0, to be used when - and + are accetable IDs. */</comment>
<function><type><name>int</name></type> <name>streamParseIDOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>missing_seq</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>streamGenericParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><name>missing_seq</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Wrapper for streamGenericParseIDOrReply() with 'strict' argument set to
 * 1, to be used when we want to return an error if the special IDs + or -
 * are provided. */</comment>
<function><type><name>int</name></type> <name>streamParseStrictIDOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>missing_seq</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>streamGenericParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><name>missing_seq</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* We propagate MAXLEN ~ &lt;count&gt; as MAXLEN = &lt;resulting-len-of-stream&gt;
 * otherwise trimming is no longer determinsitic on replicas / AOF. */</comment>
<function><type><name>void</name></type> <name>streamRewriteApproxMaxlen</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxlen_arg_idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>maxlen_obj</name> <init>= <expr><call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>equal_obj</name> <init>= <expr><call><name>createStringObject</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>rewriteClientCommandArgument</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>maxlen_arg_idx</name></expr></argument>,<argument><expr><name>maxlen_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>rewriteClientCommandArgument</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>maxlen_arg_idx</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>equal_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>equal_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>maxlen_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* XADD key [MAXLEN [~|=] &lt;count&gt;] &lt;ID or *&gt; [field value] [field value] ... */</comment>
<function><type><name>void</name></type> <name>xaddCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>id_given</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Was an ID different than "*" specified? */</comment>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>maxlen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* If left to -1 no trimming is performed. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>approx_maxlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* If 1 only delete whole radix tree nodes, so
                               the maxium length is not applied verbatim. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>maxlen_arg_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Index of the count in MAXLEN, for rewriting. */</comment>

    <comment type="block">/* Parse options. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* This is the first argument position where we could
                  find an option, or the ID. */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>i</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Number of additional arguments. */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>opt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>opt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
            <comment type="block">/* This is just a fast path for the common case of auto-ID
             * creation. */</comment>
            <break>break;</break>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"maxlen"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>approx_maxlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Check for the form MAXLEN ~ &lt;count&gt;. */</comment>
            <if_stmt><if>if <condition>(<expr><name>moreargs</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>approx_maxlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>moreargs</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>maxlen</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>maxlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The MAXLEN argument must be &gt;= 0."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>maxlen_arg_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* If we are here is a syntax error or a valid ID. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>id_given</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>int</name></type> <name>field_pos</name> <init>= <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check arity. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <name>field_pos</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>field_pos</name><operator>)</operator> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"wrong number of arguments for XADD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Return ASAP if minimal ID (0-0) was given so we avoid possibly creating
     * a new stream and have streamAppendItem fail, leaving an empty key in the
     * database. */</comment>
    <if_stmt><if>if <condition>(<expr><name>id_given</name> <operator>&amp;&amp;</operator> <name><name>id</name><operator>.</operator><name>ms</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>id</name><operator>.</operator><name>seq</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The ID specified in XADD must be greater than 0-0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Lookup the stream at key. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>streamTypeLookupWriteOrCreate</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>

    <comment type="block">/* Return ASAP if the stream has reached the last possible ID */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name><operator>.</operator><name>ms</name></name> <operator>==</operator> <name>UINT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>last_id</name><operator>.</operator><name>seq</name></name> <operator>==</operator> <name>UINT64_MAX</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The stream has exhausted the last possible ID, "</literal>
                        <literal type="string">"unable to add more items"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Append using the low level function and return the ID. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>streamAppendItem</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><name>field_pos</name></expr></argument>,<argument><expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>field_pos</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><ternary><condition><expr><name>id_given</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>id</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call>
        <operator>==</operator> <name>C_ERR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The ID specified in XADD is equal or smaller than the "</literal>
                        <literal type="string">"target stream top item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xadd"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>maxlen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Notify xtrim event if needed. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>streamTrimByLength</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>maxlen</name></expr></argument>,<argument><expr><name>approx_maxlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xtrim"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>approx_maxlen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>streamRewriteApproxMaxlen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>maxlen_arg_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Let's rewrite the ID argument with the one actually generated for
     * AOF/replication propagation. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>idarg</name> <init>= <expr><call><name>createObjectFromStreamID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>rewriteClientCommandArgument</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>idarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>idarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We need to signal to blocked clients that there is new data on this
     * stream. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>blocked_clients_by_type</name><index>[<expr><name>BLOCKED_STREAM</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>signalKeyAsReady</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* XRANGE/XREVRANGE actual implementation. */</comment>
<function><type><name>void</name></type> <name>xrangeGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rev</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamID</name></type> <name>startid</name></decl>, <decl><type ref="prev"/><name>endid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>count</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>startarg</name> <init>= <expr><ternary><condition><expr><name>rev</name></expr> ?</condition><then> <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>endarg</name> <init>= <expr><ternary><condition><expr><name>rev</name></expr> ?</condition><then> <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>streamParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>startarg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>streamParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>endarg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>,<argument><expr><name>UINT64_MAX</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Parse the COUNT option if any. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>additional</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>j</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"COUNT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>additional</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                    <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* Consume additional arg. */</comment>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Return the specified range to the user. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptymultibulk</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>
        <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullmultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><name>rev</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* XRANGE key start end [COUNT &lt;n&gt;] */</comment>
<function><type><name>void</name></type> <name>xrangeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>xrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* XREVRANGE key end start [COUNT &lt;n&gt;] */</comment>
<function><type><name>void</name></type> <name>xrevrangeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>xrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* XLEN */</comment>
<function><type><name>void</name></type> <name>xlenCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>
        <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* XREAD [BLOCK &lt;milliseconds&gt;] [COUNT &lt;count&gt;] STREAMS key_1 key_2 ... key_N
 *       ID_1 ID_2 ... ID_N
 *
 * This function also implements the XREAD-GROUP command, which is like XREAD
 * but accepting the [GROUP group-name consumer-name] additional option.
 * This is useful because while XREAD is a read command and can be called
 * on slaves, XREAD-GROUP is not. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XREAD_BLOCKED_DEFAULT_COUNT</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>xreadCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>timeout</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* -1 means, no BLOCK argument given. */</comment>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>streams_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>streams_arg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>noack</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* True if NOACK option was specified. */</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAMID_STATIC_VECTOR_LEN</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>streamID</name></type> <name><name>static_ids</name><index>[<expr><name>STREAMID_STATIC_VECTOR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamID</name> <modifier>*</modifier></type><name>ids</name> <init>= <expr><name>static_ids</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier><modifier>*</modifier></type><name>groups</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>xreadgroup</name> <init>= <expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* XREAD or XREADGROUP? */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>groupname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>consumername</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Parse arguments. */</comment>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"BLOCK"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>getTimeoutFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>,
                <argument><expr><name>UNIT_MILLISECONDS</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"COUNT"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"STREAMS"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>streams_arg</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>streams_count</name> <operator>=</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>streams_arg</name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>streams_count</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unbalanced XREAD list of streams: "</literal>
                                <literal type="string">"for each stream key an ID or '$' must be "</literal>
                                <literal type="string">"specified."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>streams_count</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* We have two arguments for each stream. */</comment>
            <break>break;</break>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"GROUP"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>xreadgroup</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The GROUP option is only supported by "</literal>
                                <literal type="string">"XREADGROUP. You called XREAD instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>groupname</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>consumername</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"NOACK"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>xreadgroup</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The NOACK option is only supported by "</literal>
                                <literal type="string">"XREADGROUP. You called XREAD instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>noack</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* STREAMS option is mandatory. */</comment>
    <if_stmt><if>if <condition>(<expr><name>streams_arg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the user specified XREADGROUP then it must also
     * provide the GROUP option. */</comment>
    <if_stmt><if>if <condition>(<expr><name>xreadgroup</name> <operator>&amp;&amp;</operator> <name>groupname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Missing GROUP option for XREADGROUP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse the IDs and resolve the group name. */</comment>
    <if_stmt><if>if <condition>(<expr><name>streams_count</name> <operator>&gt;</operator> <name>STREAMID_STATIC_VECTOR_LEN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ids</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>streams_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>groupname</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>groups</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamCG</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>streams_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>streams_arg</name> <operator>+</operator> <name>streams_count</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <comment type="block">/* Specifying "$" as last-known-id means that the client wants to be
         * served with just the messages that will arrive into the stream
         * starting from now. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>id_idx</name> <init>= <expr><name>i</name> <operator>-</operator> <name>streams_arg</name> <operator>-</operator> <name>streams_count</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>-</operator><name>streams_count</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&amp;&amp;</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If a group was specified, than we need to be sure that the
         * key and group actually exist. */</comment>
        <if_stmt><if>if <condition>(<expr><name>groupname</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
                <operator>(</operator><name>group</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>groupname</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"-NOGROUP No such key '%s' or consumer "</literal>
                                       <literal type="string">"group '%s' in XREADGROUP with GROUP "</literal>
                                       <literal type="string">"option"</literal></expr></argument>,
                                    <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>groupname</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>groups</name><index>[<expr><name>id_idx</name></expr>]</index></name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>xreadgroup</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The $ ID is meaningless in the context of "</literal>
                                <literal type="string">"XREADGROUP: you want to read the history of "</literal>
                                <literal type="string">"this consumer by specifying a proper ID, or "</literal>
                                <literal type="string">"use the &gt; ID to get new messages. The $ ID would "</literal>
                                <literal type="string">"just return an empty result set."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>ids</name><index>[<expr><name>id_idx</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>ids</name><index>[<expr><name>id_idx</name></expr>]</index></name><operator>.</operator><name>ms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ids</name><index>[<expr><name>id_idx</name></expr>]</index></name><operator>.</operator><name>seq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>xreadgroup</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The &gt; ID can be specified only when calling "</literal>
                                <literal type="string">"XREADGROUP using the GROUP &lt;group&gt; "</literal>
                                <literal type="string">"&lt;consumer&gt; option."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>cleanup</name>;</goto>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* We use just the maximum ID to signal this is a "&gt;" ID, anyway
             * the code handling the blocking clients will have to update the
             * ID later in order to match the changing consumer group last ID. */</comment>
            <expr_stmt><expr><name><name>ids</name><index>[<expr><name>id_idx</name></expr>]</index></name><operator>.</operator><name>ms</name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ids</name><index>[<expr><name>id_idx</name></expr>]</index></name><operator>.</operator><name>seq</name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>ids</name><operator>+</operator><name>id_idx</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Try to serve the client synchronously. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>streams_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>streams_arg</name><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>streamID</name> <modifier>*</modifier></type><name>gt</name> <init>= <expr><name>ids</name><operator>+</operator><name>i</name></expr></init></decl>;</decl_stmt> <comment type="block">/* ID must be greater than this. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>serve_synchronously</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>serve_history</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* True for XREADGROUP with ID != "&gt;". */</comment>

        <comment type="block">/* Check if there are the conditions to serve the client
         * synchronously. */</comment>
        <if_stmt><if>if <condition>(<expr><name>groups</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* If the consumer is blocked on a group, we always serve it
             * synchronously (serving its local history) if the ID specified
             * was not the special "&gt;" ID. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>gt</name><operator>-&gt;</operator><name>ms</name></name> <operator>!=</operator> <name>UINT64_MAX</name> <operator>||</operator>
                <name><name>gt</name><operator>-&gt;</operator><name>seq</name></name> <operator>!=</operator> <name>UINT64_MAX</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>serve_synchronously</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>serve_history</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
                <comment type="block">/* We also want to serve a consumer in a consumer group
                 * synchronously in case the group top item delivered is smaller
                 * than what the stream has inside. */</comment>
                <decl_stmt><decl><type><name>streamID</name></type> <name>maxid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last</name> <init>= <expr><operator>&amp;</operator><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>last_id</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>streamLastValidID</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>serve_synchronously</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>gt</name> <operator>=</operator> <operator>*</operator><name>last</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* For consumers without a group, we serve synchronously if we can
             * actually provide at least one item from the stream. */</comment>
            <decl_stmt><decl><type><name>streamID</name></type> <name>maxid</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>streamLastValidID</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>, <argument><expr><name>gt</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>serve_synchronously</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>serve_synchronously</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>arraylen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>arraylen_ptr</name> <operator>=</operator> <call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* streamReplyWithRange() handles the 'start' ID as inclusive,
             * so start from the next ID, since we want only messages with
             * IDs greater than start. */</comment>
            <decl_stmt><decl><type><name>streamID</name></type> <name>start</name> <init>= <expr><operator>*</operator><name>gt</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>streamIncrID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Emit the two elements sub-array consisting of the name
             * of the stream and the data we extracted from it. */</comment>
            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>streams_arg</name><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>groups</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>consumer</name> <operator>=</operator> <call><name>streamLookupConsumer</name><argument_list>(<argument><expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                                        <argument><expr><name><name>consumername</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,
                                                        <argument><expr><name>SLC_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <decl_stmt><decl><type><name>streamPropInfo</name></type> <name>spi</name> <init>= <expr><block>{<expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><name>streams_arg</name></expr>]</index></name></expr>,<expr><name>groupname</name></expr>}</block></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>noack</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_RWR_NOACK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>serve_history</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_RWR_HISTORY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><ternary><condition><expr><name>groups</name></expr> ?</condition><then> <expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
                                 <argument><expr><name>consumer</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>spi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>groups</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

     <comment type="block">/* We replied synchronously! Set the top array len and return to caller. */</comment>
    <if_stmt><if>if <condition>(<expr><name>arraylen</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Block if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If we are inside a MULTI/EXEC and the list is empty the only thing
         * we can do is treating it as a timeout (even with timeout 0). */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_MULTI</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullmultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>blockForKeys</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BLOCKED_STREAM</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><name>streams_arg</name></expr></argument>, <argument><expr><name>streams_count</name></expr></argument>,
                     <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* If no COUNT is given and we block, set a relatively small count:
         * in case the ID provided is too low, we do not want the server to
         * block just to serve this client a huge stream of messages. */</comment>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_count</name></name> <operator>=</operator> <ternary><condition><expr><name>count</name></expr> ?</condition><then> <expr><name>count</name></expr> </then><else>: <expr><name>XREAD_BLOCKED_DEFAULT_COUNT</name></expr></else></ternary></expr>;</expr_stmt>

        <comment type="block">/* If this is a XREADGROUP + GROUP we need to remember for which
         * group and consumer name we are blocking, so later when one of the
         * keys receive more data, we can call streamReplyWithRange() passing
         * the right arguments. */</comment>
        <if_stmt><if>if <condition>(<expr><name>groupname</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>groupname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>consumername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_group</name></name> <operator>=</operator> <name>groupname</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_consumer</name></name> <operator>=</operator> <name>consumername</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_group_noack</name></name> <operator>=</operator> <name>noack</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_group</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_consumer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <goto>goto <name>cleanup</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No BLOCK option, nor any stream we can serve. Reply as with a
     * timeout happened. */</comment>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullmultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Continue to cleanup... */</comment>

<label><name>cleanup</name>:</label> <comment type="block">/* Cleanup. */</comment>

    <comment type="block">/* The command is propagated (in the READGROUP form) as a side effect
     * of calling lower level APIs. So stop any implicit propagation. */</comment>
    <expr_stmt><expr><call><name>preventCommandPropagation</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ids</name> <operator>!=</operator> <name>static_ids</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------
 * Low level implementation of consumer groups
 * ----------------------------------------------------------------------- */</comment>

<comment type="block">/* Create a NACK entry setting the delivery count to 1 and the delivery
 * time to the current time. The NACK consumer will be set to the one
 * specified as argument of the function. */</comment>
<function><type><name>streamNACK</name> <modifier>*</modifier></type><name>streamCreateNACK</name><parameter_list>(<parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>=</operator> <name>consumer</name></expr>;</expr_stmt>
    <return>return <expr><name>nack</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free a NACK entry. */</comment>
<function><type><name>void</name></type> <name>streamFreeNACK</name><parameter_list>(<parameter><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>na</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>na</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free a consumer and associated data structures. Note that this function
 * will not reassign the pending messages associated with this consumer
 * nor will delete them from the stream, so when this function is called
 * to delete a consumer, and not when the whole stream is destroyed, the caller
 * should do some work before. */</comment>
<function><type><name>void</name></type> <name>streamFreeConsumer</name><parameter_list>(<parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>sc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name><name>sc</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* No value free callback: the PEL entries are shared
                         between the consumer and the main stream PEL. */</comment>
    <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>sc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create a new consumer group in the context of the stream 's', having the
 * specified name and last server ID. If a consumer group with the same name
 * already existed NULL is returned, otherwise the pointer to the consumer
 * group is returned. */</comment>
<function><type><name>streamCG</name> <modifier>*</modifier></type><name>streamCreateCG</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>namelen</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>,<argument><expr><name>namelen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cg</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <operator>*</operator><name>id</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>,<argument><expr><name>namelen</name></expr></argument>,<argument><expr><name>cg</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free a consumer group and all its associated data. */</comment>
<function><type><name>void</name></type> <name>streamFreeCG</name><parameter_list>(<parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>raxFreeWithCallback</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>streamFreeNACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxFreeWithCallback</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>,<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>streamFreeConsumer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Lookup the consumer group in the specified stream and returns its
 * pointer, otherwise if there is no such group, NULL is returned. */</comment>
<function><type><name>streamCG</name> <modifier>*</modifier></type><name>streamLookupCG</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>groupname</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>groupname</name></expr></argument>,
                           <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>groupname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>cg</name> <operator>==</operator> <name>raxNotFound</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>cg</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Lookup the consumer with the specified name in the group 'cg': if the
 * consumer does not exist it is automatically created as a side effect
 * of calling this function, otherwise its last seen time is updated and
 * the existing consumer reference returned. */</comment>
<function><type><name>streamConsumer</name> <modifier>*</modifier></type><name>streamLookupConsumer</name><parameter_list>(<parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>create</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SLC_NOCREAT</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>refresh</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SLC_NOREFRESH</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>,
                               <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>consumer</name> <operator>==</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>create</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>consumer</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>consumer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><name>consumer</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>refresh</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>consumer</name><operator>-&gt;</operator><name>seen_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>consumer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete the consumer specified in the consumer group 'cg'. The consumer
 * may have pending messages: they are removed from the PEL, and the number
 * of pending messages "lost" is returned. */</comment>
<function><type><name>uint64_t</name></type> <name>streamDelConsumer</name><parameter_list>(<parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>=
        <expr><call><name>streamLookupConsumer</name><argument_list>(<argument><expr><name>cg</name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>SLC_NOCREAT</name><operator>|</operator><name>SLC_NOREFRESH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>consumer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>retval</name> <init>= <expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Iterate all the consumer pending messages, deleting every corresponding
     * entry from the global entry. */</comment>
    <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>streamFreeNACK</name><argument_list>(<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Deallocate the consumer. */</comment>
    <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>streamFreeConsumer</name><argument_list>(<argument><expr><name>consumer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* -----------------------------------------------------------------------
 * Consumer groups commands
 * ----------------------------------------------------------------------- */</comment>

<comment type="block">/* XGROUP CREATE &lt;key&gt; &lt;groupname&gt; &lt;id or $&gt; [MKSTREAM]
 * XGROUP SETID &lt;key&gt; &lt;groupname&gt; &lt;id or $&gt;
 * XGROUP DESTROY &lt;key&gt; &lt;groupname&gt;
 * XGROUP DELCONSUMER &lt;key&gt; &lt;groupname&gt; &lt;consumername&gt; */</comment>
<function><type><name>void</name></type> <name>xgroupCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"CREATE      &lt;key&gt; &lt;groupname&gt; &lt;id or $&gt; [opt] -- Create a new consumer group."</literal></expr>,
<expr><literal type="string">"            option MKSTREAM: create the empty stream if it does not exist."</literal></expr>,
<expr><literal type="string">"SETID       &lt;key&gt; &lt;groupname&gt; &lt;id or $&gt;  -- Set the current group ID."</literal></expr>,
<expr><literal type="string">"DESTROY     &lt;key&gt; &lt;groupname&gt;            -- Remove the specified group."</literal></expr>,
<expr><literal type="string">"DELCONSUMER &lt;key&gt; &lt;groupname&gt; &lt;consumer&gt; -- Remove the specified consumer."</literal></expr>,
<expr><literal type="string">"HELP                                     -- Prints this help."</literal></expr>,
<expr><name>NULL</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sds</name></type> <name>grpname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Subcommand name. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>mkstream</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

    <comment type="block">/* CREATE has an MKSTREAM option that creates the stream if it
     * does not exist. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"MKSTREAM"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>mkstream</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>grpname</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Everything but the "HELP" option requires a key and group name. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>grpname</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for missing key/group. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>mkstream</name></expr>)</condition> <block>{<block_content>
        <comment type="block">/* At this point key must exist, or there is an error. */</comment>
        <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                <argument><expr><literal type="string">"The XGROUP subcommand requires the key to exist. "</literal>
                <literal type="string">"Note that for CREATE you may want to use the MKSTREAM "</literal>
                <literal type="string">"option to create an empty stream automatically."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Certain subcommands require the group to exist. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cg</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>grpname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"SETID"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
             <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"DELCONSUMER"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"-NOGROUP No such consumer group '%s' "</literal>
                                   <literal type="string">"for key name '%s'"</literal></expr></argument>,
                                   <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>grpname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Dispatch the different subcommands. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">6</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name><name>id</name><operator>.</operator><name>ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>id</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Handle the MKSTREAM option now that the command can no longer fail. */</comment>
        <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>mkstream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createStreamObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><call><name>streamCreateCG</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>grpname</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>grpname</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>cg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xgroup-create"</literal></expr></argument>,
                                <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReplySds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
                <argument><expr><call><name>sdsnew</name><argument_list>(<argument><expr><literal type="string">"-BUSYGROUP Consumer Group name already exists\r\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"SETID"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>streamParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>cg</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xgroup-setid"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"DESTROY"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cg</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>grpname</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>grpname</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>streamFreeCG</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xgroup-destroy"</literal></expr></argument>,
                                <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"DELCONSUMER"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* Delete the consumer and returns the number of pending messages
         * that were yet associated with such a consumer. */</comment>
        <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>pending</name> <init>= <expr><call><name>streamDelConsumer</name><argument_list>(<argument><expr><name>cg</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xgroup-delconsumer"</literal></expr></argument>,
                            <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"HELP"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyHelp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* XSETID &lt;stream&gt; &lt;groupname&gt; &lt;id&gt;
 *
 * Set the internal "last ID" of a stream. */</comment>
<function><type><name>void</name></type> <name>xsetidCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nokeyerr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If the stream has at least one item, we want to check that the user
     * is setting a last ID that is equal or greater than the current top
     * item, otherwise the fundamental ID monotonicity assumption is violated. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>streamID</name></type> <name>maxid</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>streamLastValidID</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The ID specified in XSETID is smaller than the "</literal>
                            <literal type="string">"target stream top item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xsetid"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* XACK &lt;key&gt; &lt;group&gt; &lt;id&gt; &lt;id&gt; ... &lt;id&gt;
 *
 * Acknowledge a message as processed. In practical terms we just check the
 * pendine entries list (PEL) of the group, and delete the PEL entry both from
 * the group and the consumer (pending messages are referenced in both places).
 *
 * Return value of the command is the number of messages successfully
 * acknowledged, that is, the IDs we were actually able to resolve in the PEL.
 */</comment>
<function><type><name>void</name></type> <name>xackCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Type error. */</comment>
        <expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No key or group? Nothing to ack. */</comment>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>group</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>acknowledged</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Lookup the ID in the group PEL: it will have a reference to the
         * NACK structure that will have a reference to the consumer, so that
         * we are able to remove the entry from both PELs. */</comment>
        <decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nack</name> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>streamFreeNACK</name><argument_list>(<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>acknowledged</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>acknowledged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* XPENDING &lt;key&gt; &lt;group&gt; [&lt;start&gt; &lt;stop&gt; &lt;count&gt; [&lt;consumer&gt;]]
 *
 * If start and stop are omitted, the command just outputs information about
 * the amount of pending messages for the key/group pair, together with
 * the minimum and maxium ID of pending messages.
 *
 * If start and stop are provided instead, the pending messages are returned
 * with informations about the current owner, number of deliveries and last
 * delivery time and so forth. */</comment>
<function><type><name>void</name></type> <name>xpendingCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>justinfo</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Without the range just outputs general
                                    informations about the PEL. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>groupname</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>consumername</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">7</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamID</name></type> <name>startid</name></decl>, <decl><type ref="prev"/><name>endid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* Start and stop, and the consumer, can be omitted. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Parse start/end/count arguments ASAP if needed, in order to report
     * syntax errors before any other error. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>streamParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>streamParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>,<argument><expr><name>UINT64_MAX</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Lookup the key and the group inside the stream. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>&amp;&amp;</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <operator>(</operator><name>group</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>groupname</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"-NOGROUP No such key '%s' or consumer "</literal>
                               <literal type="string">"group '%s'"</literal></expr></argument>,
                               <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>groupname</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* XPENDING &lt;key&gt; &lt;group&gt; variant. */</comment>
    <if_stmt><if>if <condition>(<expr><name>justinfo</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Total number of messages in the PEL. */</comment>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* First and last IDs. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Start. */</comment>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* End. */</comment>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullmultibulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Clients. */</comment>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="block">/* Start. */</comment>
            <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* End. */</comment>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Consumers with pending messages. */</comment>
            <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>group</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* XPENDING &lt;key&gt; &lt;group&gt; &lt;start&gt; &lt;stop&gt; &lt;count&gt; [&lt;consumer&gt;] variant. */</comment>
    <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>consumername</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>consumer</name> <operator>=</operator> <call><name>streamLookupConsumer</name><argument_list>(<argument><expr><name>group</name></expr></argument>,
                                            <argument><expr><name><name>consumername</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,
                                            <argument><expr><name>SLC_NOCREAT</name><operator>|</operator><name>SLC_NOREFRESH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If a consumer name was mentioned but it does not exist, we can
             * just return an empty array. */</comment>
            <if_stmt><if>if <condition>(<expr><name>consumer</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>pel</name> <init>= <expr><ternary><condition><expr><name>consumer</name></expr> ?</condition><then> <expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr> </then><else>: <expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>startkey</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>endkey</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>endkey</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name>pel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"&gt;="</literal></expr></argument>,<argument><expr><name>startkey</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <while>while<condition>(<expr><name>count</name> <operator>&amp;&amp;</operator> <call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name>endkey</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Entry ID. */</comment>
            <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Consumer name. */</comment>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Milliseconds elapsed since last delivery. */</comment>
            <decl_stmt><decl><type><name>mstime_t</name></type> <name>elapsed</name> <init>= <expr><name>now</name> <operator>-</operator> <name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>elapsed</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>elapsed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>elapsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Number of deliveries. */</comment>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* XCLAIM &lt;key&gt; &lt;group&gt; &lt;consumer&gt; &lt;min-idle-time&gt; &lt;ID-1&gt; &lt;ID-2&gt;
 *        [IDLE &lt;milliseconds&gt;] [TIME &lt;mstime&gt;] [RETRYCOUNT &lt;count&gt;]
 *        [FORCE] [JUSTID]
 *
 * Gets ownership of one or multiple messages in the Pending Entries List
 * of a given stream consumer group.
 *
 * If the message ID (among the specified ones) exists, and its idle
 * time greater or equal to &lt;min-idle-time&gt;, then the message new owner
 * becomes the specified &lt;consumer&gt;. If the minimum idle time specified
 * is zero, messages are claimed regardless of their idle time.
 *
 * All the messages that cannot be found inside the pending entries list
 * are ignored, but in case the FORCE option is used. In that case we
 * create the NACK (representing a not yet acknowledged message) entry in
 * the consumer group PEL.
 *
 * This command creates the consumer as side effect if it does not yet
 * exists. Moreover the command reset the idle time of the message to 0,
 * even if by using the IDLE or TIME options, the user can control the
 * new idle time.
 *
 * The options at the end can be used in order to specify more attributes
 * to set in the representation of the pending message:
 *
 * 1. IDLE &lt;ms&gt;:
 *      Set the idle time (last time it was delivered) of the message.
 *      If IDLE is not specified, an IDLE of 0 is assumed, that is,
 *      the time count is reset because the message has now a new
 *      owner trying to process it.
 *
 * 2. TIME &lt;ms-unix-time&gt;:
 *      This is the same as IDLE but instead of a relative amount of
 *      milliseconds, it sets the idle time to a specific unix time
 *      (in milliseconds). This is useful in order to rewrite the AOF
 *      file generating XCLAIM commands.
 *
 * 3. RETRYCOUNT &lt;count&gt;:
 *      Set the retry counter to the specified value. This counter is
 *      incremented every time a message is delivered again. Normally
 *      XCLAIM does not alter this counter, which is just served to clients
 *      when the XPENDING command is called: this way clients can detect
 *      anomalies, like messages that are never processed for some reason
 *      after a big number of delivery attempts.
 *
 * 4. FORCE:
 *      Creates the pending message entry in the PEL even if certain
 *      specified IDs are not already in the PEL assigned to a different
 *      client. However the message must be exist in the stream, otherwise
 *      the IDs of non existing messages are ignored.
 *
 * 5. JUSTID:
 *      Return just an array of IDs of messages successfully claimed,
 *      without returning the actual message.
 *
 * 6. LASTID &lt;id&gt;:
 *      Update the consumer group last ID with the specified ID if the
 *      current last ID is smaller than the provided one.
 *      This is used for replication / AOF, so that when we read from a
 *      consumer group, the XCLAIM that gets propagated to give ownership
 *      to the consumer, is also used in order to update the group current
 *      ID.
 *
 * The command returns an array of messages that the user
 * successfully claimed, so that the caller is able to understand
 * what messages it is now in charge of. */</comment>
<function><type><name>void</name></type> <name>xclaimCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>minidle</name></decl>;</decl_stmt> <comment type="block">/* Minimum idle time argument. */</comment>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>retrycount</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* -1 means RETRYCOUNT option not given. */</comment>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>deliverytime</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* -1 means IDLE/TIME options not given. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>force</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>justid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* Type error. */</comment>
        <expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No key or group? Send an error given that the group creation
     * is mandatory. */</comment>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>group</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"-NOGROUP No such key '%s' or "</literal>
                              <literal type="string">"consumer group '%s'"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>minidle</name></expr></argument>,
        <argument><expr><literal type="string">"Invalid min-idle-time argument for XCLAIM"</literal></expr></argument>)</argument_list></call>
        <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>minidle</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>minidle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Start parsing the IDs, so that we abort ASAP if there is a syntax
     * error: the return value of this command cannot be an error in case
     * the client successfully claimed some message, so it should be
     * executed in a "all or nothing" fashion. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">5</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>int</name></type> <name>last_id_arg</name> <init>= <expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Next time we iterate the IDs we now the range. */</comment>

    <comment type="block">/* If we stopped because some IDs cannot be parsed, perhaps they
     * are trailing options. */</comment>
    <decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>streamID</name></type> <name>last_id</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>propagate_last_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>j</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Number of additional arguments. */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"FORCE"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>force</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"JUSTID"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>justid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"IDLE"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>deliverytime</name></expr></argument>,
                <argument><expr><literal type="string">"Invalid IDLE option argument for XCLAIM"</literal></expr></argument>)</argument_list></call>
                <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>deliverytime</name> <operator>=</operator> <name>now</name> <operator>-</operator> <name>deliverytime</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"TIME"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>deliverytime</name></expr></argument>,
                <argument><expr><literal type="string">"Invalid TIME option argument for XCLAIM"</literal></expr></argument>)</argument_list></call>
                <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"RETRYCOUNT"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>retrycount</name></expr></argument>,
                <argument><expr><literal type="string">"Invalid RETRYCOUNT option argument for XCLAIM"</literal></expr></argument>)</argument_list></call>
                <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"LASTID"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>last_id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unrecognized XCLAIM option '%s'"</literal></expr></argument>,<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name>last_id</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>propagate_last_id</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>deliverytime</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* If a delivery time was passed, either with IDLE or TIME, we
         * do some sanity check on it, and set the deliverytime to now
         * (which is a sane choice usually) if the value is bogus.
         * To raise an error here is not wise because clients may compute
         * the idle time doing some math starting from their local time,
         * and this is not a good excuse to fail in case, for instance,
         * the computer time is a bit in the future from our POV. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>deliverytime</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>deliverytime</name></expr></argument> &gt;</argument_list></name> <name>now</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>deliverytime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* If no IDLE/TIME option was passed, we want the last delivery
         * time to be now, so that the idle time of the message will be
         * zero. */</comment>
        <expr_stmt><expr><name>deliverytime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Do the actual claiming. */</comment>
    <decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylenptr</name> <init>= <expr><call><name>addDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>last_id_arg</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"StreamID invalid after check. Should not be possible."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Lookup the ID in the group PEL. */</comment>
        <decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If FORCE is passed, let's check if at least the entry
         * exists in the Stream. In such case, we'll crate a new
         * entry in the PEL from scratch, so that XCLAIM can also
         * be used to create entries in the PEL. Useful for AOF
         * and replication of consumer groups. */</comment>
        <if_stmt><if>if <condition>(<expr><name>force</name> <operator>&amp;&amp;</operator> <name>nack</name> <operator>==</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>streamIterator</name></type> <name>myiterator</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myiterator</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>numfields</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>streamID</name></type> <name>item_id</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>streamIteratorGetID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myiterator</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>item_id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numfields</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myiterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Item must exist for us to create a NACK for it. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/* Create the NACK. */</comment>
            <expr_stmt><expr><name>nack</name> <operator>=</operator> <call><name>streamCreateNACK</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>nack</name> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
            <comment type="block">/* We need to check if the minimum idle time requested
             * by the caller is satisfied by this entry.
             *
             * Note that the nack could be created by FORCE, in this
             * case there was no pre-existing entry and minidle should
             * be ignored, but in that case nick-&gt;consumer is NULL. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>&amp;&amp;</operator> <name>minidle</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>mstime_t</name></type> <name>this_idle</name> <init>= <expr><name>now</name> <operator>-</operator> <name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>this_idle</name> <operator>&lt;</operator> <name>minidle</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Remove the entry from the old consumer.
             * Note that nack-&gt;consumer is NULL if we created the
             * NACK above because of the FORCE option. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* Update the consumer and idle time. */</comment>
            <if_stmt><if>if <condition>(<expr><name>consumer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>consumer</name> <operator>=</operator> <call><name>streamLookupConsumer</name><argument_list>(<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><name>SLC_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>=</operator> <name>consumer</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name> <operator>=</operator> <name>deliverytime</name></expr>;</expr_stmt>
            <comment type="block">/* Set the delivery attempts counter if given, otherwise
             * autoincrement unless JUSTID option provided */</comment>
            <if_stmt><if>if <condition>(<expr><name>retrycount</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name> <operator>=</operator> <name>retrycount</name></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>justid</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Add the entry in the new consumer local PEL. */</comment>
            <expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Send the reply for this entry. */</comment>
            <if_stmt><if>if <condition>(<expr><name>justid</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name>size_t</name></type> <name>emitted</name> <init>= <expr><call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>STREAM_RWR_RAWENTRIES</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>emitted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/* Propagate this change. */</comment>
            <expr_stmt><expr><call><name>streamPropagateXCLAIM</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>propagate_last_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Will be propagated by XCLAIM itself. */</comment>
            <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>propagate_last_id</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>streamPropagateGroupID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>setDeferredMultiBulkLength</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylenptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>preventCommandPropagation</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* XDEL &lt;key&gt; [&lt;ID1&gt; &lt;ID2&gt; ... &lt;IDN&gt;]
 *
 * Removes the specified entries from the stream. Returns the number
 * of items actually deleted, that may be different from the number
 * of IDs passed in case certain IDs do not exist. */</comment>
<function><type><name>void</name></type> <name>xdelCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>
        <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We need to sanity check the IDs passed to start. Even if not
     * a big issue, it is not great that the command is only partially
     * executed because at some point an invalid ID is parsed. */</comment>
    <decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Actually apply the command. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Retval already checked. */</comment>
        <expr_stmt><expr><name>deleted</name> <operator>+=</operator> <call><name>streamDeleteItem</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Propagate the write if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xdel"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>deleted</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* General form: XTRIM &lt;key&gt; [... options ...]
 *
 * List of options:
 *
 * MAXLEN [~|=] &lt;count&gt;     -- Trim so that the stream will be capped at
 *                             the specified length. Use ~ before the
 *                             count in order to demand approximated trimming
 *                             (like XADD MAXLEN option).
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRIM_STRATEGY_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRIM_STRATEGY_MAXLEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>xtrimCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

    <comment type="block">/* If the key does not exist, we are ok returning zero, that is, the
     * number of elements removed from the stream. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>
        <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Argument parsing. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>trim_strategy</name> <init>= <expr><name>TRIM_STRATEGY_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PORT_LONGLONG</name></type> <name>maxlen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* If left to -1 no trimming is performed. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>approx_maxlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* If 1 only delete whole radix tree nodes, so
                               the maxium length is not applied verbatim. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>maxlen_arg_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Index of the count in MAXLEN, for rewriting. */</comment>

    <comment type="block">/* Parse options. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Start of options. */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>i</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Number of additional arguments. */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"maxlen"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>approx_maxlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>trim_strategy</name> <operator>=</operator> <name>TRIM_STRATEGY_MAXLEN</name></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Check for the form MAXLEN ~ &lt;count&gt;. */</comment>
            <if_stmt><if>if <condition>(<expr><name>moreargs</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>approx_maxlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>moreargs</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>maxlen</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>maxlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The MAXLEN argument must be &gt;= 0."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>maxlen_arg_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Perform the trimming. */</comment>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>trim_strategy</name> <operator>==</operator> <name>TRIM_STRATEGY_MAXLEN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>streamTrimByLength</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>maxlen</name></expr></argument>,<argument><expr><name>approx_maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"XTRIM called without an option to trim the stream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Propagate the write if needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xtrim"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>deleted</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>approx_maxlen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>streamRewriteApproxMaxlen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>maxlen_arg_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* XINFO CONSUMERS &lt;key&gt; &lt;group&gt;
 * XINFO GROUPS &lt;key&gt;
 * XINFO STREAM &lt;key&gt;
 * XINFO HELP. */</comment>
<function><type><name>void</name></type> <name>xinfoCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"CONSUMERS &lt;key&gt; &lt;groupname&gt;  -- Show consumer groups of group &lt;groupname&gt;."</literal></expr>,
<expr><literal type="string">"GROUPS &lt;key&gt;                 -- Show the stream consumer groups."</literal></expr>,
<expr><literal type="string">"STREAM &lt;key&gt;                 -- Show information about the stream."</literal></expr>,
<expr><literal type="string">"HELP                         -- Print this help."</literal></expr>,
<expr><name>NULL</name></expr>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>

    <comment type="block">/* HELP is special. Handle it ASAP. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"HELP"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyHelp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"syntax error, try 'XINFO HELP'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* With the exception of HELP handled before any other sub commands, all
     * the ones are in the form of "&lt;subcommand&gt; &lt;key&gt;". */</comment>
    <expr_stmt><expr><name>opt</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* Lookup the key now, this is common for all the subcommands but HELP. */</comment>
    <decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nokeyerr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>

    <comment type="block">/* Dispatch the different subcommands. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"CONSUMERS"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* XINFO CONSUMERS &lt;key&gt; &lt;group&gt;. */</comment>
        <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><call><name>streamLookupCG</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>cg</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"-NOGROUP No such consumer group '%s' "</literal>
                                   <literal type="string">"for key name '%s'"</literal></expr></argument>,
                                   <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>mstime_t</name></type> <name>idle</name> <init>= <expr><name>now</name> <operator>-</operator> <name><name>consumer</name><operator>-&gt;</operator><name>seen_time</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>idle</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"pending"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"idle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>idle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"GROUPS"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* XINFO GROUPS &lt;key&gt;. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"consumers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"pending"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"last-delivered-id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>cg</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"STREAM"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/* XINFO STREAM &lt;key&gt; (or the alias XINFO &lt;key&gt;). */</comment>
        <expr_stmt><expr><call><name>addReplyMultiBulkLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"radix-tree-keys"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"radix-tree-nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"groups"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr> ?</condition><then> <expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"last-generated-id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* To emit the first/last entry we us the streamReplyWithRange()
         * API. */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>streamID</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>start</name><operator>.</operator><name>ms</name></name> <operator>=</operator> <name><name>start</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>end</name><operator>.</operator><name>ms</name></name> <operator>=</operator> <name><name>end</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"first-entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>STREAM_RWR_RAWENTRIES</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>count</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"last-entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>STREAM_RWR_RAWENTRIES</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>count</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nullbulk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

</unit>
